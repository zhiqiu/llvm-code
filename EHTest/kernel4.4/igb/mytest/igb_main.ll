; ModuleID = '/home/bai/MyProject/EHTestDir/Kern3.17.2/igb/igb_main.c'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.smp_ops = type { void ()*, void (i32)*, void (i32)*, void (i32)*, void (i32)*, i32 (i32, %struct.task_struct*)*, i32 ()*, void (i32)*, void ()*, void (%struct.cpumask*)*, void (i32)* }
%struct.task_struct = type { i64, i8*, %struct.atomic_t, i32, i32, %struct.llist_node, i32, %struct.task_struct*, i64, i64, i32, i32, i32, i32, i32, i32, %struct.sched_class*, %struct.sched_entity, %struct.sched_rt_entity, %struct.task_group*, %struct.sched_dl_entity, %struct.hlist_head, i32, i32, i32, %struct.cpumask, %struct.sched_info, %struct.list_head, %struct.plist_node, %struct.rb_node, %struct.mm_struct*, %struct.mm_struct*, i32, [4 x %struct.vm_area_struct*], %struct.task_rss_stat, i32, i32, i32, i32, i32, i32, i8, i64, i32, i32, %struct.task_struct*, %struct.task_struct*, %struct.list_head, %struct.list_head, %struct.task_struct*, %struct.list_head, %struct.list_head, [3 x %struct.pid_link], %struct.list_head, %struct.list_head, %struct.completion*, i32*, i32*, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, %struct.task_cputime, [3 x %struct.list_head], %struct.cred*, %struct.cred*, [16 x i8], i32, i32, %struct.sysv_sem, %struct.sysv_shm, i64, %struct.thread_struct, %struct.fs_struct*, %struct.files_struct*, %struct.nsproxy*, %struct.signal_struct*, %struct.sighand_struct*, %struct.sigset_t, %struct.sigset_t, %struct.sigset_t, %struct.sigpending, i64, i64, i32 (i8*)*, i8*, %struct.sigset_t*, %struct.callback_head*, %struct.audit_context*, %struct.kuid_t, i32, %struct.seccomp, i32, i32, %struct.spinlock, %struct.raw_spinlock, %struct.rb_root, %struct.rb_node*, %struct.rt_mutex_waiter*, i8*, %struct.bio_list*, %struct.blk_plug*, %struct.reclaim_state*, %struct.backing_dev_info*, %struct.io_context*, i64, %struct.siginfo*, %struct.task_io_accounting, i64, i64, i64, %struct.nodemask_t, %struct.seqcount, i32, i32, %struct.css_set*, %struct.list_head, %struct.robust_list_head*, %struct.compat_robust_list_head*, %struct.list_head, %struct.futex_pi_state*, [2 x %struct.perf_event_context*], %struct.mutex, %struct.list_head, %struct.mempolicy*, i16, i16, %struct.callback_head, %struct.pipe_inode_info*, %struct.page_frag, %struct.task_delay_info*, i32, i32, i64, i32, [32 x %struct.latency_record], i64, i64, i32, %struct.ftrace_ret_stack*, i64, %struct.atomic_t, %struct.atomic_t, i64, i64 }
%struct.atomic_t = type { i32 }
%struct.llist_node = type { %struct.llist_node* }
%struct.sched_class = type opaque
%struct.sched_entity = type { %struct.load_weight, %struct.rb_node, %struct.list_head, i32, i64, i64, i64, i64, i64, %struct.sched_statistics, i32, %struct.sched_entity*, %struct.cfs_rq*, %struct.cfs_rq*, %struct.sched_avg }
%struct.load_weight = type { i64, i32 }
%struct.rb_node = type { i64, %struct.rb_node*, %struct.rb_node* }
%struct.list_head = type { %struct.list_head*, %struct.list_head* }
%struct.sched_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.cfs_rq = type opaque
%struct.sched_avg = type { i32, i32, i64, i64, i64 }
%struct.sched_rt_entity = type { %struct.list_head, i64, i64, i32, %struct.sched_rt_entity*, %struct.sched_rt_entity*, %struct.rt_rq*, %struct.rt_rq* }
%struct.rt_rq = type opaque
%struct.task_group = type opaque
%struct.sched_dl_entity = type { %struct.rb_node, i64, i64, i64, i64, i64, i64, i32, i32, i32, i32, i32, %struct.hrtimer }
%struct.hrtimer = type { %struct.timerqueue_node, %union.ktime, i32 (%struct.hrtimer*)*, %struct.hrtimer_clock_base*, i64, i32, i8*, [16 x i8] }
%struct.timerqueue_node = type { %struct.rb_node, %union.ktime }
%union.ktime = type { i64 }
%struct.hrtimer_clock_base = type { %struct.hrtimer_cpu_base*, i32, i32, %struct.timerqueue_head, %union.ktime, i64 ()*, %union.ktime, %union.ktime }
%struct.hrtimer_cpu_base = type { %struct.raw_spinlock, i32, i32, i32, %union.ktime, i32, i32, i64, i64, i64, %union.ktime, [4 x %struct.hrtimer_clock_base] }
%struct.raw_spinlock = type { %struct.arch_spinlock }
%struct.arch_spinlock = type { %union.anon.4 }
%union.anon.4 = type { i32 }
%struct.timerqueue_head = type { %struct.rb_root, %struct.timerqueue_node* }
%struct.rb_root = type { %struct.rb_node* }
%struct.hlist_head = type { %struct.hlist_node* }
%struct.hlist_node = type { %struct.hlist_node*, %struct.hlist_node** }
%struct.cpumask = type { [4 x i64] }
%struct.sched_info = type { i64, i64, i64, i64 }
%struct.plist_node = type { i32, %struct.list_head, %struct.list_head }
%struct.mm_struct = type { %struct.vm_area_struct*, %struct.rb_root, i32, i64 (%struct.file*, i64, i64, i64, i64)*, i64, i64, i64, i64, %struct.pgd_t*, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i32, %struct.spinlock, %struct.rw_semaphore, %struct.list_head, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, [46 x i64], %struct.mm_rss_stat, %struct.linux_binfmt*, [1 x %struct.cpumask], %struct.mm_context_t, i64, %struct.core_state*, %struct.spinlock, %struct.kioctx_table*, %struct.file*, %struct.mmu_notifier_mm*, i8, %struct.uprobes_state }
%struct.vm_area_struct = type { i64, i64, %struct.vm_area_struct*, %struct.vm_area_struct*, %struct.rb_node, i64, %struct.mm_struct*, %struct.pgprot, i64, %union.anon, %struct.list_head, %struct.anon_vma*, %struct.vm_operations_struct*, i64, %struct.file*, i8*, %struct.mempolicy* }
%struct.pgprot = type { i64 }
%union.anon = type { %struct.anon }
%struct.anon = type { %struct.rb_node, i64 }
%struct.anon_vma = type opaque
%struct.vm_operations_struct = type { void (%struct.vm_area_struct*)*, void (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, void (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, %struct.vm_fault*)*, i32 (%struct.vm_area_struct*, i64, i8*, i32, i32)*, i8* (%struct.vm_area_struct*)*, i32 (%struct.vm_area_struct*, %struct.mempolicy*)*, %struct.mempolicy* (%struct.vm_area_struct*, i64)*, i32 (%struct.vm_area_struct*, %struct.nodemask_t*, %struct.nodemask_t*, i64)*, i32 (%struct.vm_area_struct*, i64, i64, i64)* }
%struct.vm_fault = type { i32, i64, i8*, %struct.page*, i64, %struct.pte_t* }
%struct.page = type { i64, %union.anon.0, %struct.anon.25, %union.anon.31, %union.anon.33, [8 x i8] }
%union.anon.0 = type { %struct.address_space* }
%struct.address_space = type { %struct.inode*, %struct.radix_tree_root, %struct.spinlock, %struct.atomic_t, %struct.rb_root, %struct.list_head, %struct.mutex, i64, i64, i64, %struct.address_space_operations*, i64, %struct.backing_dev_info*, %struct.spinlock, %struct.list_head, i8* }
%struct.inode = type { i16, i16, %struct.kuid_t, %struct.kgid_t, i32, %struct.posix_acl*, %struct.posix_acl*, %struct.inode_operations*, %struct.super_block*, %struct.address_space*, i8*, i64, %union.anon.50, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.spinlock, i16, i32, i64, i64, %struct.mutex, i64, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %union.anon.51, i64, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.file_operations*, %struct.file_lock*, %struct.address_space, [2 x %struct.dquot*], %struct.list_head, %union.anon.52, i32, i32, %struct.hlist_head, i8* }
%struct.kuid_t = type { i32 }
%struct.kgid_t = type { i32 }
%struct.posix_acl = type opaque
%struct.inode_operations = type { %struct.dentry* (%struct.inode*, %struct.dentry*, i32)*, i8* (%struct.dentry*, %struct.nameidata*)*, i32 (%struct.inode*, i32)*, %struct.posix_acl* (%struct.inode*, i32)*, i32 (%struct.dentry*, i8*, i32)*, void (%struct.dentry*, %struct.nameidata*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16, i1)*, i32 (%struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, i16, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*)*, i32 (%struct.inode*, %struct.dentry*, %struct.inode*, %struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.iattr*)*, i32 (%struct.vfsmount*, %struct.dentry*, %struct.kstat*)*, i32 (%struct.dentry*, i8*, i8*, i64, i32)*, i64 (%struct.dentry*, i8*, i8*, i64)*, i64 (%struct.dentry*, i8*, i64)*, i32 (%struct.dentry*, i8*)*, i32 (%struct.inode*, %struct.fiemap_extent_info*, i64, i64)*, i32 (%struct.inode*, %struct.timespec*, i32)*, i32 (%struct.inode*, %struct.dentry*, %struct.file*, i32, i16, i32*)*, i32 (%struct.inode*, %struct.dentry*, i16)*, i32 (%struct.inode*, %struct.posix_acl*, i32)*, [48 x i8] }
%struct.dentry = type { i32, %struct.seqcount, %struct.hlist_bl_node, %struct.dentry*, %struct.qstr, %struct.inode*, [32 x i8], %struct.lockref, %struct.dentry_operations*, %struct.super_block*, i64, i8*, %struct.list_head, %union.anon.14, %struct.list_head, %struct.hlist_node }
%struct.seqcount = type { i32 }
%struct.hlist_bl_node = type { %struct.hlist_bl_node*, %struct.hlist_bl_node** }
%struct.qstr = type { %union.anon.6, i8* }
%union.anon.6 = type { i64 }
%struct.lockref = type { %union.anon.8 }
%union.anon.8 = type { i64 }
%struct.dentry_operations = type { i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, i32)*, i32 (%struct.dentry*, %struct.qstr*)*, i32 (%struct.dentry*, %struct.dentry*, i32, i8*, %struct.qstr*)*, i32 (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*)*, void (%struct.dentry*, %struct.inode*)*, i8* (%struct.dentry*, i8*, i32)*, %struct.vfsmount* (%struct.path*)*, i32 (%struct.dentry*, i1)*, [40 x i8] }
%struct.vfsmount = type opaque
%struct.path = type { %struct.vfsmount*, %struct.dentry* }
%struct.super_block = type { %struct.list_head, i32, i8, i64, i64, %struct.file_system_type*, %struct.super_operations*, %struct.dquot_operations*, %struct.quotactl_ops*, %struct.export_operations*, i64, i64, %struct.dentry*, %struct.rw_semaphore, i32, %struct.atomic_t, i8*, %struct.xattr_handler**, %struct.list_head, %struct.hlist_bl_head, %struct.list_head, %struct.block_device*, %struct.backing_dev_info*, %struct.mtd_info*, %struct.hlist_node, %struct.quota_info, %struct.sb_writers, [32 x i8], [16 x i8], i8*, i32, i32, i32, %struct.mutex, i8*, i8*, %struct.dentry_operations*, i32, %struct.shrinker, %struct.atomic64_t, i32, %struct.workqueue_struct*, %struct.hlist_head, [32 x i8], %struct.list_lru, [48 x i8], %struct.list_lru, %struct.callback_head, [32 x i8] }
%struct.file_system_type = type { i8*, i32, %struct.dentry* (%struct.file_system_type*, i32, i8*, i8*)*, void (%struct.super_block*)*, %struct.module*, %struct.file_system_type*, %struct.hlist_head, %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key, [3 x %struct.lock_class_key], %struct.lock_class_key, %struct.lock_class_key, %struct.lock_class_key }
%struct.module = type { i32, %struct.list_head, [56 x i8], %struct.module_kobject, %struct.module_attribute*, i8*, i8*, %struct.kobject*, %struct.kernel_symbol*, i64*, i32, %struct.kernel_param*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.kernel_symbol*, i64*, %struct.kernel_symbol*, i64*, i32, i32, %struct.exception_table_entry*, i32 ()*, i8*, i8*, i32, i32, i32, i32, i32, i32, %struct.mod_arch_specific, i32, i32, %struct.list_head, %struct.bug_entry*, %struct.elf64_sym*, %struct.elf64_sym*, i32, i32, i8*, i8*, %struct.module_sect_attrs*, %struct.module_notes_attrs*, i8*, i8*, i32, i32, %struct.tracepoint**, i32, i8**, %struct.ftrace_event_call**, i32, i32, i64*, %struct.list_head, %struct.list_head, void ()*, %struct.module_ref* }
%struct.module_kobject = type { %struct.kobject, %struct.module*, %struct.kobject*, %struct.module_param_attrs*, %struct.completion* }
%struct.kobject = type { i8*, %struct.list_head, %struct.kobject*, %struct.kset*, %struct.kobj_type*, %struct.kernfs_node*, %struct.kref, i8 }
%struct.kset = type { %struct.list_head, %struct.spinlock, %struct.kobject, %struct.kset_uevent_ops* }
%struct.spinlock = type { %union.anon.3 }
%union.anon.3 = type { %struct.raw_spinlock }
%struct.kset_uevent_ops = type { i32 (%struct.kset*, %struct.kobject*)*, i8* (%struct.kset*, %struct.kobject*)*, i32 (%struct.kset*, %struct.kobject*, %struct.kobj_uevent_env*)* }
%struct.kobj_uevent_env = type { [3 x i8*], [32 x i8*], i32, [2048 x i8], i32 }
%struct.kobj_type = type { void (%struct.kobject*)*, %struct.sysfs_ops*, %struct.attribute**, %struct.kobj_ns_type_operations* (%struct.kobject*)*, i8* (%struct.kobject*)* }
%struct.sysfs_ops = type { i64 (%struct.kobject*, %struct.attribute*, i8*)*, i64 (%struct.kobject*, %struct.attribute*, i8*, i64)* }
%struct.attribute = type { i8*, i16 }
%struct.kobj_ns_type_operations = type { i32, i1 ()*, i8* ()*, i8* (%struct.sock*)*, i8* ()*, void (i8*)* }
%struct.sock = type { %struct.sock_common, %struct.socket_lock_t, %struct.sk_buff_head, %struct.anon.79, i32, i32, i32, i32, i32, %struct.atomic_t, i32, %struct.sk_filter*, %struct.socket_wq*, [2 x %struct.xfrm_policy*], i64, %struct.dst_entry*, %struct.dst_entry*, %struct.spinlock, %struct.atomic_t, %struct.atomic_t, i32, %struct.sk_buff_head, i8, i8, [2 x i8], i32, i32, i32, i32, i64, i64, i32, i32, i16, i32, i64, %struct.sk_buff_head, %struct.proto*, %struct.rwlock_t, i32, i32, i16, i16, i32, %struct.pid*, %struct.cred*, i64, i64, i8*, %struct.timer_list, %union.ktime, i16, i32, %struct.socket*, i8*, %struct.page_frag, %struct.sk_buff*, i32, i32, i8*, i32, i32, %struct.cg_proto*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)* }
%struct.sock_common = type { %union.anon.71, %union.anon.73, %union.anon.74, i16, i8, i8, i32, %union.anon.76, %struct.proto*, %struct.net*, %struct.in6_addr, %struct.in6_addr, [0 x i32], %union.anon.78, i32, %struct.atomic_t, [0 x i32] }
%union.anon.71 = type { i64 }
%union.anon.73 = type { i32 }
%union.anon.74 = type { i32 }
%union.anon.76 = type { %struct.hlist_node }
%struct.proto = type { void (%struct.sock*, i64)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, i32)*, %struct.sock* (%struct.sock*, i32, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i32, i8*, i32)*, i32 (%struct.sock*, i32, i32, i8*, i32*)*, i32 (%struct.sock*, i32, i64)*, i32 (%struct.kiocb*, %struct.sock*, %struct.msghdr*, i64)*, i32 (%struct.kiocb*, %struct.sock*, %struct.msghdr*, i64, i32, i32, i32*)*, i32 (%struct.sock*, %struct.page*, i32, i64, i32)*, i32 (%struct.sock*, %struct.sockaddr*, i32)*, i32 (%struct.sock*, %struct.sk_buff*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, void (%struct.sock*)*, i32 (%struct.sock*, i16)*, void (%struct.sock*, i32)*, i32, i1 (%struct.sock*)*, void (%struct.sock*)*, %struct.atomic64_t*, %struct.percpu_counter*, i32*, i64*, i32*, i32*, i32, i8, %struct.kmem_cache*, i32, i32, %struct.percpu_counter*, %struct.request_sock_ops*, %struct.timewait_sock_ops*, %union.anon.81, %struct.module*, [32 x i8], %struct.list_head }
%struct.sockaddr = type { i16, [14 x i8] }
%struct.kiocb = type { %struct.file*, %struct.kioctx*, i32 (%struct.kiocb*)*, i8*, %union.anon.69, i64, i64, i64, %struct.list_head, %struct.eventfd_ctx* }
%struct.file = type { %union.anon.5, %struct.path, %struct.inode*, %struct.file_operations*, %struct.spinlock, %struct.atomic64_t, i32, i32, %struct.mutex, i64, %struct.fown_struct, %struct.cred*, %struct.file_ra_state, i64, i8*, i8*, %struct.list_head, %struct.list_head, %struct.address_space* }
%union.anon.5 = type { %struct.callback_head }
%struct.callback_head = type { %struct.callback_head*, void (%struct.callback_head*)* }
%struct.file_operations = type { %struct.module*, i64 (%struct.file*, i64, i32)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.file*, i8*, i64, i64*)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iovec*, i64, i64)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i64 (%struct.kiocb*, %struct.iov_iter*)*, i32 (%struct.file*, %struct.dir_context*)*, i32 (%struct.file*, %struct.poll_table_struct*)*, i64 (%struct.file*, i32, i64)*, i64 (%struct.file*, i32, i64)*, i32 (%struct.file*, %struct.vm_area_struct*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i8*)*, i32 (%struct.inode*, %struct.file*)*, i32 (%struct.file*, i64, i64, i32)*, i32 (%struct.kiocb*, i32)*, i32 (i32, %struct.file*, i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.file*, %struct.page*, i32, i64, i64*, i32)*, i64 (%struct.file*, i64, i64, i64, i64)*, i32 (i32)*, i32 (%struct.file*, i32, %struct.file_lock*)*, i64 (%struct.pipe_inode_info*, %struct.file*, i64*, i64, i32)*, i64 (%struct.file*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.file*, i64, %struct.file_lock**)*, i64 (%struct.file*, i32, i64, i64)*, i32 (%struct.seq_file*, %struct.file*)* }
%struct.iovec = type { i8*, i64 }
%struct.iov_iter = type { i32, i64, i64, %union.anon.15, i64 }
%union.anon.15 = type { %struct.iovec* }
%struct.dir_context = type { i32 (i8*, i8*, i32, i64, i64, i32)*, i64 }
%struct.poll_table_struct = type { void (%struct.file*, %struct.__wait_queue_head*, %struct.poll_table_struct*)*, i64 }
%struct.__wait_queue_head = type { %struct.spinlock, %struct.list_head }
%struct.file_lock = type { %struct.file_lock*, %struct.hlist_node, %struct.list_head, i8*, i32, i8, i32, i32, %struct.pid*, %struct.__wait_queue_head, %struct.file*, i64, i64, %struct.fasync_struct*, i64, i64, %struct.file_lock_operations*, %struct.lock_manager_operations*, %union.anon.16 }
%struct.pid = type { %struct.atomic_t, i32, [3 x %struct.hlist_head], %struct.callback_head, [1 x %struct.upid] }
%struct.upid = type { i32, %struct.pid_namespace*, %struct.hlist_node }
%struct.pid_namespace = type opaque
%struct.fasync_struct = type { %struct.spinlock, i32, i32, %struct.fasync_struct*, %struct.file*, %struct.callback_head }
%struct.file_lock_operations = type { void (%struct.file_lock*, %struct.file_lock*)*, void (%struct.file_lock*)* }
%struct.lock_manager_operations = type { i32 (%struct.file_lock*, %struct.file_lock*)*, i64 (%struct.file_lock*)*, void (%struct.file_lock*)*, i32 (%struct.file_lock*, %struct.file_lock*, i32)*, void (%struct.file_lock*)*, i32 (%struct.file_lock**, i32)* }
%union.anon.16 = type { %struct.nfs_lock_info }
%struct.nfs_lock_info = type { i32, %struct.nlm_lockowner*, %struct.list_head }
%struct.nlm_lockowner = type opaque
%struct.pipe_inode_info = type opaque
%struct.seq_file = type { i8*, i64, i64, i64, i64, i64, i64, i64, %struct.mutex, %struct.seq_operations*, i32, i8* }
%struct.mutex = type { %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.task_struct*, %struct.optimistic_spin_queue }
%struct.optimistic_spin_queue = type { %struct.atomic_t }
%struct.seq_operations = type { i8* (%struct.seq_file*, i64*)*, void (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i8*, i64*)*, i32 (%struct.seq_file*, i8*)* }
%struct.atomic64_t = type { i64 }
%struct.fown_struct = type { %struct.rwlock_t, %struct.pid*, i32, %struct.kuid_t, %struct.kuid_t, i32 }
%struct.rwlock_t = type { %struct.qrwlock }
%struct.qrwlock = type { %struct.atomic_t, %struct.arch_spinlock }
%struct.cred = type { %struct.atomic_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, %struct.kuid_t, %struct.kgid_t, i32, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, %struct.kernel_cap_struct, i8, %struct.key*, %struct.key*, %struct.key*, %struct.key*, i8*, %struct.user_struct*, %struct.user_namespace*, %struct.group_info*, %struct.callback_head }
%struct.kernel_cap_struct = type { [2 x i32] }
%struct.key = type { %struct.atomic_t, i32, %union.anon.18, %struct.rw_semaphore, %struct.key_user*, i8*, %union.anon.19, i64, %struct.kuid_t, %struct.kgid_t, i32, i16, i16, i64, %union.anon.20, %union.anon.22, %union.anon.23 }
%union.anon.18 = type { %struct.rb_node }
%struct.rw_semaphore = type { i64, %struct.list_head, %struct.raw_spinlock, %struct.optimistic_spin_queue, %struct.task_struct* }
%struct.key_user = type opaque
%union.anon.19 = type { i64 }
%union.anon.20 = type { %struct.keyring_index_key }
%struct.keyring_index_key = type { %struct.key_type*, i8*, i64 }
%struct.key_type = type opaque
%union.anon.22 = type { %struct.list_head }
%union.anon.23 = type { %union.anon.24 }
%union.anon.24 = type { [2 x i8*] }
%struct.user_struct = type { %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic_t, %struct.atomic64_t, i64, i64, %struct.key*, %struct.key*, %struct.hlist_node, %struct.kuid_t, %struct.atomic64_t }
%struct.user_namespace = type opaque
%struct.group_info = type { %struct.atomic_t, i32, i32, [32 x %struct.kgid_t], [0 x %struct.kgid_t*] }
%struct.file_ra_state = type { i64, i32, i32, i32, i32, i64 }
%struct.kioctx = type opaque
%union.anon.69 = type { i8* }
%struct.eventfd_ctx = type opaque
%struct.msghdr = type { i8*, i32, %struct.iovec*, i64, i8*, i64, i32 }
%struct.sk_buff = type { %struct.sk_buff*, %struct.sk_buff*, %union.anon.55, %struct.sock*, %struct.net_device*, [48 x i8], i64, %struct.sec_path*, i32, i32, i16, i16, %union.anon.58, i32, i8, i8, i16, {}*, %struct.nf_conntrack*, %struct.nf_bridge_info*, i32, i32, i16, i16, i16, i16, i16, i8, i8, %union.anon.60, i32, %union.anon.61, i16, i16, i16, i16, i16, i16, i16, i32, i32, i8*, i8*, i32, %struct.atomic_t }
%union.anon.55 = type { %union.ktime }
%struct.net_device = type { [16 x i8], %struct.hlist_node, i8*, i64, i64, i64, i32, i64, %struct.list_head, %struct.list_head, %struct.list_head, %struct.list_head, %struct.anon.62, %struct.anon.63, i64, i64, i64, i64, i64, i64, i32, i32, %struct.net_device_stats, %struct.atomic64_t, %struct.atomic64_t, %struct.atomic_t, %struct.iw_handler_def*, %struct.iw_public_data*, %struct.net_device_ops*, %struct.ethtool_ops*, %struct.forwarding_accel_ops*, %struct.header_ops*, i32, i32, i16, i16, i8, i8, i8, i8, i32, i16, i16, i16, i16, [32 x i8], i8, i8, i16, i16, i16, %struct.spinlock, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.netdev_hw_addr_list, %struct.kset*, i8, i8, i32, i32, %struct.vlan_info*, %struct.dsa_switch_tree*, %struct.tipc_bearer*, i8*, %struct.in_device*, %struct.dn_dev*, %struct.inet6_dev*, i8*, %struct.wireless_dev*, i64, i8*, %struct.netdev_rx_queue*, i32, i32, i32 (%struct.sk_buff**)*, i8*, %struct.netdev_queue*, [32 x i8], [48 x i8], %struct.netdev_queue*, i32, i32, %struct.Qdisc*, i64, %struct.spinlock, %struct.xps_dev_maps*, %struct.cpu_rmap*, i64, i32, %struct.timer_list, i32*, %struct.list_head, %struct.hlist_node, %struct.list_head, i8, i8, [2 x i8], void (%struct.net_device*)*, %struct.netpoll_info*, %struct.net*, %union.anon.68, %struct.garp_port*, %struct.mrp_port*, %struct.device, [4 x %struct.attribute_group*], %struct.attribute_group*, %struct.rtnl_link_ops*, i32, i16, %struct.dcbnl_rtnl_ops*, i8, [16 x %struct.netdev_tc_txq], [16 x i8], i32, %struct.phy_device*, %struct.lock_class_key*, i32, %struct.pm_qos_request, [40 x i8] }
%struct.anon.62 = type { %struct.list_head, %struct.list_head }
%struct.anon.63 = type { %struct.list_head, %struct.list_head }
%struct.net_device_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.iw_handler_def = type opaque
%struct.iw_public_data = type opaque
%struct.net_device_ops = type { i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i16 (%struct.net_device*, %struct.sk_buff*, i8*, i16 (%struct.net_device*, %struct.sk_buff*)*)*, void (%struct.net_device*, i32)*, void (%struct.net_device*)*, i32 (%struct.net_device*, i8*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ifreq*, i32)*, i32 (%struct.net_device*, %struct.ifmap*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.neigh_parms*)*, void (%struct.net_device*)*, %struct.rtnl_link_stats64* (%struct.net_device*, %struct.rtnl_link_stats64*)*, %struct.net_device_stats* (%struct.net_device*)*, i32 (%struct.net_device*, i16, i16)*, i32 (%struct.net_device*, i16, i16)*, void (%struct.net_device*)*, i32 (%struct.net_device*, %struct.netpoll_info*)*, void (%struct.net_device*)*, i32 (%struct.napi_struct*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i16, i8)*, i32 (%struct.net_device*, i32, i32, i32)*, i32 (%struct.net_device*, i32, i1)*, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)*, i32 (%struct.net_device*, i32, i32)*, i32 (%struct.net_device*, i32, %struct.nlattr**)*, i32 (%struct.net_device*, i32, %struct.sk_buff*)*, i32 (%struct.net_device*, i8)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i16, %struct.scatterlist*, i32)*, i32 (%struct.net_device*, i16)*, i32 (%struct.net_device*, i16, %struct.scatterlist*, i32)*, i32 (%struct.net_device*, %struct.netdev_fcoe_hbainfo*)*, i32 (%struct.net_device*, i64*, i32)*, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)*, i32 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.net_device*, %struct.net_device*)*, i64 (%struct.net_device*, i64)*, i32 (%struct.net_device*, i64)*, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)*, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*)*, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*)*, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.nlmsghdr*)*, i32 (%struct.net_device*, i1)*, i32 (%struct.net_device*, %struct.netdev_phys_port_id*)*, void (%struct.net_device*, i16, i16)*, void (%struct.net_device*, i16, i16)*, i8* (%struct.net_device*, %struct.net_device*)*, void (%struct.net_device*, i8*)*, i32 (%struct.sk_buff*, %struct.net_device*, i8*)*, i32 (%struct.net_device*)* }
%struct.ifreq = type { %union.anon.64, %union.anon.65 }
%union.anon.64 = type { [16 x i8] }
%union.anon.65 = type { %struct.ifmap }
%struct.ifmap = type { i64, i64, i16, i8, i8, i8 }
%struct.neigh_parms = type { %struct.net*, %struct.net_device*, %struct.neigh_parms*, i32 (%struct.neighbour*)*, void (%struct.neighbour*)*, %struct.neigh_table*, i8*, i32, %struct.atomic_t, %struct.callback_head, i32, [12 x i32], [1 x i64] }
%struct.net = type { %struct.atomic_t, %struct.atomic_t, %struct.spinlock, %struct.list_head, %struct.list_head, %struct.list_head, %struct.user_namespace*, i32, %struct.proc_dir_entry*, %struct.proc_dir_entry*, %struct.ctl_table_set, %struct.sock*, %struct.sock*, %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, i32, i32, i32, %struct.list_head, %struct.net_device*, %struct.netns_core, %struct.netns_mib, %struct.netns_packet, %struct.netns_unix, [48 x i8], %struct.netns_ipv4, %struct.netns_ipv6, %struct.netns_sctp, %struct.netns_dccp, %struct.netns_nf, %struct.netns_xt, %struct.netns_ct, [16 x i8], %struct.netns_nf_frag, %struct.sock*, %struct.sock*, %struct.sk_buff_head, %struct.net_generic*, [16 x i8], %struct.netns_xfrm, %struct.netns_ipvs*, %struct.sock*, %struct.atomic_t, [44 x i8] }
%struct.proc_dir_entry = type opaque
%struct.ctl_table_set = type { i32 (%struct.ctl_table_set*)*, %struct.ctl_dir }
%struct.ctl_dir = type { %struct.ctl_table_header, %struct.rb_root }
%struct.ctl_table_header = type { %union.anon.53, %struct.completion*, %struct.ctl_table*, %struct.ctl_table_root*, %struct.ctl_table_set*, %struct.ctl_dir*, %struct.ctl_node* }
%union.anon.53 = type { %struct.anon.54 }
%struct.anon.54 = type { %struct.ctl_table*, i32, i32, i32 }
%struct.ctl_table = type { i8*, i8*, i32, i16, %struct.ctl_table*, i32 (%struct.ctl_table*, i32, i8*, i64*, i64*)*, %struct.ctl_table_poll*, i8*, i8* }
%struct.ctl_table_poll = type { %struct.atomic_t, %struct.__wait_queue_head }
%struct.completion = type { i32, %struct.__wait_queue_head }
%struct.ctl_table_root = type { %struct.ctl_table_set, %struct.ctl_table_set* (%struct.ctl_table_root*, %struct.nsproxy*)*, i32 (%struct.ctl_table_header*, %struct.ctl_table*)* }
%struct.nsproxy = type { %struct.atomic_t, %struct.uts_namespace*, %struct.ipc_namespace*, %struct.mnt_namespace*, %struct.pid_namespace*, %struct.net* }
%struct.uts_namespace = type opaque
%struct.ipc_namespace = type opaque
%struct.mnt_namespace = type opaque
%struct.ctl_node = type { %struct.rb_node, %struct.ctl_table_header* }
%struct.netns_core = type { %struct.ctl_table_header*, i32, %struct.prot_inuse* }
%struct.prot_inuse = type opaque
%struct.netns_mib = type { %struct.tcp_mib*, %struct.ipstats_mib*, %struct.linux_mib*, %struct.udp_mib*, %struct.udp_mib*, %struct.icmp_mib*, %struct.icmpmsg_mib*, %struct.proc_dir_entry*, %struct.udp_mib*, %struct.udp_mib*, %struct.ipstats_mib*, %struct.icmpv6_mib*, %struct.icmpv6msg_mib* }
%struct.tcp_mib = type { [16 x i64] }
%struct.ipstats_mib = type { [36 x i64], %struct.u64_stats_sync }
%struct.u64_stats_sync = type {}
%struct.linux_mib = type { [103 x i64] }
%struct.udp_mib = type { [8 x i64] }
%struct.icmp_mib = type { [28 x i64] }
%struct.icmpmsg_mib = type { [512 x %struct.atomic64_t] }
%struct.icmpv6_mib = type { [6 x i64] }
%struct.icmpv6msg_mib = type { [512 x %struct.atomic64_t] }
%struct.netns_packet = type { %struct.mutex, %struct.hlist_head }
%struct.netns_unix = type { i32, %struct.ctl_table_header* }
%struct.netns_ipv4 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ipv4_devconf*, %struct.ipv4_devconf*, %struct.fib_rules_ops*, i8, %struct.fib_table*, %struct.fib_table*, %struct.fib_table*, i32, %struct.hlist_head*, %struct.sock*, %struct.sock**, %struct.inet_peer_base*, %struct.tcpm_hash_bucket*, i32, [44 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, i32, i32, i32, i32, i32, i32, %struct.local_ports, i32, i32, i32, i32, i32, %struct.ping_group_range, %struct.atomic_t, i64*, %struct.mr_table*, %struct.atomic_t, [44 x i8] }
%struct.ipv4_devconf = type opaque
%struct.fib_rules_ops = type opaque
%struct.fib_table = type opaque
%struct.inet_peer_base = type { %struct.inet_peer*, %struct.seqlock_t, i32, i32 }
%struct.inet_peer = type { %struct.inet_peer*, %struct.inet_peer*, %struct.inetpeer_addr, i32, [15 x i32], i32, i64, %union.anon.83, %union.anon.84, i32, %struct.atomic_t }
%struct.inetpeer_addr = type { %struct.inetpeer_addr_base, i16 }
%struct.inetpeer_addr_base = type { %union.anon.82 }
%union.anon.82 = type { [4 x i32] }
%union.anon.83 = type { %struct.list_head }
%union.anon.84 = type { %struct.callback_head }
%struct.seqlock_t = type { %struct.seqcount, %struct.spinlock }
%struct.tcpm_hash_bucket = type opaque
%struct.netns_frags = type { %struct.percpu_counter, i32, i32, i32, [12 x i8] }
%struct.percpu_counter = type { %struct.raw_spinlock, i64, %struct.list_head, i32* }
%struct.xt_table = type opaque
%struct.local_ports = type { %struct.seqlock_t, [2 x i32] }
%struct.ping_group_range = type { %struct.seqlock_t, [2 x %struct.kgid_t] }
%struct.mr_table = type opaque
%struct.netns_ipv6 = type { %struct.netns_sysctl_ipv6, %struct.ipv6_devconf*, %struct.ipv6_devconf*, %struct.inet_peer_base*, [8 x i8], %struct.netns_frags, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.xt_table*, %struct.rt6_info*, %struct.rt6_statistics*, %struct.timer_list, %struct.hlist_head*, %struct.fib6_table*, [40 x i8], %struct.dst_ops, i32, i64, %struct.rt6_info*, %struct.rt6_info*, %struct.fib6_table*, %struct.fib_rules_ops*, %struct.sock**, %struct.sock*, %struct.sock*, %struct.sock*, %struct.list_head, %struct.fib_rules_ops*, %struct.atomic_t, %struct.atomic_t, [16 x i8] }
%struct.netns_sysctl_ipv6 = type { %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ipv6_devconf = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i8* }
%struct.rt6_info = type opaque
%struct.rt6_statistics = type opaque
%struct.timer_list = type { %struct.list_head, i64, %struct.tvec_base*, void (i64)*, i64, i32, i32, i8*, [16 x i8] }
%struct.tvec_base = type opaque
%struct.fib6_table = type opaque
%struct.dst_ops = type { i16, i16, i32, i32 (%struct.dst_ops*)*, %struct.dst_entry* (%struct.dst_entry*, i32)*, i32 (%struct.dst_entry*)*, i32 (%struct.dst_entry*)*, i32* (%struct.dst_entry*, i64)*, void (%struct.dst_entry*)*, void (%struct.dst_entry*, %struct.net_device*, i32)*, %struct.dst_entry* (%struct.dst_entry*)*, void (%struct.sk_buff*)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*, i32)*, void (%struct.dst_entry*, %struct.sock*, %struct.sk_buff*)*, i32 (%struct.sk_buff*)*, %struct.neighbour* (%struct.dst_entry*, %struct.sk_buff*, i8*)*, %struct.kmem_cache*, [8 x i8], %struct.percpu_counter, [24 x i8] }
%struct.dst_entry = type { %struct.callback_head, %struct.dst_entry*, %struct.net_device*, %struct.dst_ops*, i64, i64, %struct.dst_entry*, %struct.dst_entry*, %struct.xfrm_state*, i32 (%struct.sk_buff*)*, i32 (%struct.sock*, %struct.sk_buff*)*, i16, i16, i16, i16, i16, i16, i32, [2 x i64], %struct.atomic_t, i32, i64, %union.anon.70 }
%struct.xfrm_state = type opaque
%union.anon.70 = type { %struct.dst_entry* }
%struct.neighbour = type { %struct.neighbour*, %struct.neigh_table*, %struct.neigh_parms*, i64, i64, %struct.rwlock_t, %struct.atomic_t, %struct.sk_buff_head, i32, %struct.timer_list, i64, %struct.atomic_t, i8, i8, i8, i8, %struct.seqlock_t, [32 x i8], %struct.hh_cache, i32 (%struct.neighbour*, %struct.sk_buff*)*, %struct.neigh_ops*, %struct.callback_head, %struct.net_device*, [0 x i8] }
%struct.neigh_table = type { %struct.neigh_table*, i32, i32, i32, i32 (i8*, %struct.net_device*, i32*)*, i32 (%struct.neighbour*)*, i32 (%struct.pneigh_entry*)*, void (%struct.pneigh_entry*)*, void (%struct.sk_buff*)*, i8*, %struct.neigh_parms, i32, i32, i32, i32, i64, %struct.delayed_work, %struct.timer_list, %struct.sk_buff_head, %struct.atomic_t, %struct.rwlock_t, i64, %struct.neigh_statistics*, %struct.neigh_hash_table*, %struct.pneigh_entry** }
%struct.pneigh_entry = type { %struct.pneigh_entry*, %struct.net*, %struct.net_device*, i8, [0 x i8] }
%struct.delayed_work = type { %struct.work_struct, %struct.timer_list, %struct.workqueue_struct*, i32 }
%struct.work_struct = type { %struct.atomic64_t, %struct.list_head, void (%struct.work_struct*)* }
%struct.workqueue_struct = type opaque
%struct.sk_buff_head = type { %struct.sk_buff*, %struct.sk_buff*, i32, %struct.spinlock }
%struct.neigh_statistics = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.neigh_hash_table = type { %struct.neighbour**, i32, [4 x i32], %struct.callback_head }
%struct.hh_cache = type { i16, i16, %struct.seqlock_t, [16 x i64] }
%struct.neigh_ops = type { i32, void (%struct.neighbour*, %struct.sk_buff*)*, void (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.sk_buff*)* }
%struct.kmem_cache = type { %struct.kmem_cache_cpu*, i64, i64, i32, i32, i32, i32, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, %struct.kmem_cache_order_objects, i32, i32, void (i8*)*, i32, i32, i32, i8*, %struct.list_head, %struct.kobject, i32, [64 x %struct.kmem_cache_node*] }
%struct.kmem_cache_cpu = type { i8**, i64, %struct.page*, %struct.page* }
%struct.kmem_cache_order_objects = type { i64 }
%struct.kmem_cache_node = type opaque
%struct.netns_sctp = type { %struct.sctp_mib*, %struct.proc_dir_entry*, %struct.ctl_table_header*, %struct.sock*, %struct.list_head, %struct.list_head, %struct.timer_list, %struct.list_head, %struct.spinlock, %struct.spinlock, i32, i32, i32, i32, i32, i32, i32, i8*, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i64 }
%struct.sctp_mib = type opaque
%struct.netns_dccp = type { %struct.sock*, %struct.sock* }
%struct.netns_nf = type { %struct.proc_dir_entry*, [13 x %struct.nf_logger*], %struct.ctl_table_header* }
%struct.nf_logger = type opaque
%struct.netns_xt = type { [13 x %struct.list_head], i8, %struct.ebt_table*, %struct.ebt_table*, %struct.ebt_table* }
%struct.ebt_table = type opaque
%struct.netns_ct = type { %struct.atomic_t, i32, %struct.delayed_work, i8, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, %struct.ctl_table_header*, i8*, i32, i32, i32, i32, i8, i32, i32, i32, %struct.seqcount, %struct.kmem_cache*, %struct.hlist_nulls_head*, %struct.hlist_head*, %struct.ct_pcpu*, %struct.ip_conntrack_stat*, %struct.nf_ct_event_notifier*, %struct.nf_exp_event_notifier*, %struct.nf_ip_net }
%struct.hlist_nulls_head = type { %struct.hlist_nulls_node* }
%struct.hlist_nulls_node = type { %struct.hlist_nulls_node*, %struct.hlist_nulls_node** }
%struct.ct_pcpu = type { %struct.spinlock, %struct.hlist_nulls_head, %struct.hlist_nulls_head, %struct.hlist_nulls_head }
%struct.ip_conntrack_stat = type opaque
%struct.nf_ct_event_notifier = type opaque
%struct.nf_exp_event_notifier = type opaque
%struct.nf_ip_net = type { %struct.nf_generic_net, %struct.nf_tcp_net, %struct.nf_udp_net, %struct.nf_icmp_net, %struct.nf_icmp_net, %struct.ctl_table_header*, %struct.ctl_table* }
%struct.nf_generic_net = type { %struct.nf_proto_net, i32 }
%struct.nf_proto_net = type { %struct.ctl_table_header*, %struct.ctl_table*, %struct.ctl_table_header*, %struct.ctl_table*, i32 }
%struct.nf_tcp_net = type { %struct.nf_proto_net, [14 x i32], i32, i32, i32 }
%struct.nf_udp_net = type { %struct.nf_proto_net, [2 x i32] }
%struct.nf_icmp_net = type { %struct.nf_proto_net, i32 }
%struct.netns_nf_frag = type { %struct.netns_sysctl_ipv6, [32 x i8], %struct.netns_frags }
%struct.net_generic = type opaque
%struct.netns_xfrm = type { %struct.list_head, %struct.hlist_head*, %struct.hlist_head*, %struct.hlist_head*, i32, i32, %struct.work_struct, %struct.hlist_head, %struct.work_struct, %struct.list_head, %struct.hlist_head*, i32, [6 x %struct.hlist_head], [6 x %struct.xfrm_policy_hash], [6 x i32], %struct.work_struct, %struct.sock*, %struct.sock*, i32, i32, i32, i32, %struct.ctl_table_header*, [56 x i8], %struct.dst_ops, %struct.dst_ops, %struct.spinlock, %struct.rwlock_t, %struct.mutex, %struct.flow_cache, %struct.atomic_t, %struct.list_head, %struct.spinlock, %struct.work_struct, %struct.work_struct, %struct.mutex }
%struct.xfrm_policy_hash = type { %struct.hlist_head*, i32 }
%struct.flow_cache = type { i32, %struct.flow_cache_percpu*, %struct.notifier_block, i32, i32, %struct.timer_list }
%struct.flow_cache_percpu = type { %struct.hlist_head*, i32, i32, i32, %struct.tasklet_struct }
%struct.tasklet_struct = type { %struct.tasklet_struct*, i64, %struct.atomic_t, void (i64)*, i64 }
%struct.notifier_block = type { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32 }
%struct.netns_ipvs = type opaque
%struct.rtnl_link_stats64 = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.netpoll_info = type opaque
%struct.napi_struct = type { %struct.list_head, i64, i32, i32, i32 (%struct.napi_struct*, i32)*, %struct.spinlock, i32, %struct.net_device*, %struct.sk_buff*, %struct.sk_buff*, %struct.list_head, %struct.hlist_node, i32 }
%struct.ifla_vf_info = type { i32, [32 x i8], i32, i32, i32, i32, i32, i32 }
%struct.nlattr = type { i16, i16 }
%struct.scatterlist = type { i64, i32, i32, i64, i32 }
%struct.netdev_fcoe_hbainfo = type { [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [64 x i8], [256 x i8], [256 x i8] }
%struct.ndmsg = type { i8, i8, i16, i32, i16, i8, i8 }
%struct.netlink_callback = type { %struct.sk_buff*, %struct.nlmsghdr*, i32 (%struct.sk_buff*, %struct.netlink_callback*)*, i32 (%struct.netlink_callback*)*, i8*, %struct.module*, i16, i16, i32, i32, [6 x i64] }
%struct.nlmsghdr = type { i32, i16, i16, i32, i32 }
%struct.netdev_phys_port_id = type { [32 x i8], i8 }
%struct.ethtool_ops = type { i32 (%struct.net_device*, %struct.ethtool_cmd*)*, i32 (%struct.net_device*, %struct.ethtool_cmd*)*, void (%struct.net_device*, %struct.ethtool_drvinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, %struct.ethtool_regs*, i8*)*, void (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*, %struct.ethtool_wolinfo*)*, i32 (%struct.net_device*)*, void (%struct.net_device*, i32)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, i32 (%struct.net_device*, %struct.ethtool_coalesce*)*, void (%struct.net_device*, %struct.ethtool_ringparam*)*, i32 (%struct.net_device*, %struct.ethtool_ringparam*)*, void (%struct.net_device*, %struct.ethtool_pauseparam*)*, i32 (%struct.net_device*, %struct.ethtool_pauseparam*)*, void (%struct.net_device*, %struct.ethtool_test*, i64*)*, void (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32)*, void (%struct.net_device*, %struct.ethtool_stats*, i64*)*, i32 (%struct.net_device*)*, void (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, i32)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*, i32*)*, i32 (%struct.net_device*, %struct.ethtool_rxnfc*)*, i32 (%struct.net_device*, %struct.ethtool_flash*)*, i32 (%struct.net_device*, i32*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*)*, i32 (%struct.net_device*, i32*, i8*)*, i32 (%struct.net_device*, i32*, i8*)*, void (%struct.net_device*, %struct.ethtool_channels*)*, i32 (%struct.net_device*, %struct.ethtool_channels*)*, i32 (%struct.net_device*, %struct.ethtool_dump*)*, i32 (%struct.net_device*, %struct.ethtool_dump*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_dump*)*, i32 (%struct.net_device*, %struct.ethtool_ts_info*)*, i32 (%struct.net_device*, %struct.ethtool_modinfo*)*, i32 (%struct.net_device*, %struct.ethtool_eeprom*, i8*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)*, i32 (%struct.net_device*, %struct.ethtool_eee*)* }
%struct.ethtool_cmd = type { i32, i32, i32, i16, i8, i8, i8, i8, i8, i8, i32, i32, i16, i8, i8, i32, [2 x i32] }
%struct.ethtool_drvinfo = type { i32, [32 x i8], [32 x i8], [32 x i8], [32 x i8], [32 x i8], [12 x i8], i32, i32, i32, i32, i32 }
%struct.ethtool_regs = type { i32, i32, i32, [0 x i8] }
%struct.ethtool_wolinfo = type { i32, i32, i32, [6 x i8] }
%struct.ethtool_eeprom = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_coalesce = type { i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_ringparam = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_pauseparam = type { i32, i32, i32, i32 }
%struct.ethtool_test = type { i32, i32, i32, i32, [0 x i64] }
%struct.ethtool_stats = type { i32, i32, [0 x i64] }
%struct.ethtool_rxnfc = type { i32, i32, i64, %struct.ethtool_rx_flow_spec, i32, [0 x i32] }
%struct.ethtool_rx_flow_spec = type { i32, %union.ethtool_flow_union, %struct.ethtool_flow_ext, %union.ethtool_flow_union, %struct.ethtool_flow_ext, i64, i32 }
%union.ethtool_flow_union = type { %struct.ethtool_tcpip4_spec, [36 x i8] }
%struct.ethtool_tcpip4_spec = type { i32, i32, i16, i16, i8 }
%struct.ethtool_flow_ext = type { [2 x i8], [6 x i8], i16, i16, [2 x i32] }
%struct.ethtool_flash = type { i32, i32, [128 x i8] }
%struct.ethtool_channels = type { i32, i32, i32, i32, i32, i32, i32, i32, i32 }
%struct.ethtool_dump = type { i32, i32, i32, i32, [0 x i8] }
%struct.ethtool_ts_info = type { i32, i32, i32, i32, [3 x i32], i32, [3 x i32] }
%struct.ethtool_modinfo = type { i32, i32, i32, [8 x i32] }
%struct.ethtool_eee = type { i32, i32, i32, i32, i32, i32, i32, i32, [2 x i32] }
%struct.forwarding_accel_ops = type opaque
%struct.header_ops = type { i32 (%struct.sk_buff*, %struct.net_device*, i16, i8*, i8*, i32)*, i32 (%struct.sk_buff*, i8*)*, i32 (%struct.sk_buff*)*, i32 (%struct.neighbour*, %struct.hh_cache*, i16)*, void (%struct.hh_cache*, %struct.net_device*, i8*)* }
%struct.netdev_hw_addr_list = type { %struct.list_head, i32 }
%struct.vlan_info = type opaque
%struct.dsa_switch_tree = type { %struct.dsa_platform_data*, %struct.net_device*, i16, i8, i8, i32, %struct.work_struct, %struct.timer_list, [4 x %struct.dsa_switch*] }
%struct.dsa_platform_data = type { %struct.device*, i32, %struct.dsa_chip_data* }
%struct.device = type { %struct.device*, %struct.device_private*, %struct.kobject, i8*, %struct.device_type*, %struct.mutex, %struct.bus_type*, %struct.device_driver*, i8*, i8*, %struct.dev_pm_info, %struct.dev_pm_domain*, i32, i64*, i64, i64, %struct.device_dma_parameters*, %struct.list_head, %struct.dma_coherent_mem*, %struct.dev_archdata, %struct.device_node*, %struct.acpi_dev_node, i32, i32, %struct.spinlock, %struct.list_head, %struct.klist_node, %struct.class*, %struct.attribute_group**, void (%struct.device*)*, %struct.iommu_group*, i8 }
%struct.device_private = type opaque
%struct.device_type = type { i8*, %struct.attribute_group**, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*, %struct.kuid_t*, %struct.kgid_t*)*, void (%struct.device*)*, %struct.dev_pm_ops* }
%struct.attribute_group = type { i8*, i16 (%struct.kobject*, %struct.attribute*, i32)*, %struct.attribute**, %struct.bin_attribute** }
%struct.bin_attribute = type { %struct.attribute, i64, i8*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i64 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, i8*, i64, i64)*, i32 (%struct.file*, %struct.kobject*, %struct.bin_attribute*, %struct.vm_area_struct*)* }
%struct.dev_pm_ops = type { i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)* }
%struct.bus_type = type { i8*, i8*, %struct.device*, %struct.device_attribute*, %struct.attribute_group**, %struct.attribute_group**, %struct.attribute_group**, i32 (%struct.device*, %struct.device_driver*)*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.dev_pm_ops*, %struct.iommu_ops*, %struct.subsys_private*, %struct.lock_class_key }
%struct.device_attribute = type { %struct.attribute, i64 (%struct.device*, %struct.device_attribute*, i8*)*, i64 (%struct.device*, %struct.device_attribute*, i8*, i64)* }
%struct.device_driver = type { i8*, %struct.bus_type*, %struct.module*, i8*, i8, %struct.of_device_id*, %struct.acpi_device_id*, i32 (%struct.device*)*, i32 (%struct.device*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.attribute_group**, %struct.dev_pm_ops*, %struct.driver_private* }
%struct.of_device_id = type { [32 x i8], [32 x i8], [128 x i8], i8* }
%struct.acpi_device_id = type { [9 x i8], i64 }
%struct.driver_private = type opaque
%struct.iommu_ops = type opaque
%struct.subsys_private = type opaque
%struct.lock_class_key = type {}
%struct.dev_pm_info = type { %struct.pm_message, i8, i8, %struct.spinlock, %struct.list_head, %struct.completion, %struct.wakeup_source*, i8, %struct.timer_list, i64, %struct.work_struct, %struct.__wait_queue_head, %struct.atomic_t, %struct.atomic_t, i8, i8, i32, i32, i32, i32, i64, i64, i64, i64, %struct.pm_subsys_data*, void (%struct.device*, i32)*, %struct.dev_pm_qos* }
%struct.pm_message = type { i32 }
%struct.wakeup_source = type { i8*, %struct.list_head, %struct.spinlock, %struct.timer_list, i64, %union.ktime, %union.ktime, %union.ktime, %union.ktime, %union.ktime, i64, i64, i64, i64, i64, i8 }
%struct.pm_subsys_data = type { %struct.spinlock, i32 }
%struct.dev_pm_qos = type { %struct.pm_qos_constraints, %struct.pm_qos_constraints, %struct.pm_qos_flags, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request*, %struct.dev_pm_qos_request* }
%struct.pm_qos_constraints = type { %struct.plist_head, i32, i32, i32, i32, %struct.blocking_notifier_head* }
%struct.plist_head = type { %struct.list_head }
%struct.blocking_notifier_head = type { %struct.rw_semaphore, %struct.notifier_block* }
%struct.pm_qos_flags = type { %struct.list_head, i32 }
%struct.dev_pm_qos_request = type { i32, %union.anon.67, %struct.device* }
%union.anon.67 = type { %struct.plist_node }
%struct.dev_pm_domain = type { %struct.dev_pm_ops }
%struct.device_dma_parameters = type { i32, i64 }
%struct.dma_coherent_mem = type opaque
%struct.dev_archdata = type { %struct.dma_map_ops*, i8* }
%struct.dma_map_ops = type { i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.vm_area_struct*, i8*, i64, i64, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.sg_table*, i8*, i64, i64, %struct.dma_attrs*)*, i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)*, i32 (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, %struct.scatterlist*, i32, i32, %struct.dma_attrs*)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, i64, i64, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, void (%struct.device*, %struct.scatterlist*, i32, i32)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 (%struct.device*, i64)*, i32 }
%struct.dma_attrs = type { [1 x i64] }
%struct.sg_table = type { %struct.scatterlist*, i32, i32 }
%struct.device_node = type { i8*, i8*, i32, i8*, %struct.property*, %struct.property*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.device_node*, %struct.kobject, i64, i8* }
%struct.property = type { i8*, i32, i8*, %struct.property*, i64, i32, %struct.bin_attribute }
%struct.acpi_dev_node = type { %struct.acpi_device* }
%struct.acpi_device = type opaque
%struct.klist_node = type { i8*, %struct.list_head, %struct.kref }
%struct.kref = type { %struct.atomic_t }
%struct.class = type { i8*, %struct.module*, %struct.class_attribute*, %struct.attribute_group**, %struct.kobject*, i32 (%struct.device*, %struct.kobj_uevent_env*)*, i8* (%struct.device*, i16*)*, void (%struct.class*)*, void (%struct.device*)*, i32 (%struct.device*, i32)*, i32 (%struct.device*)*, %struct.kobj_ns_type_operations*, i8* (%struct.device*)*, %struct.dev_pm_ops*, %struct.subsys_private* }
%struct.class_attribute = type { %struct.attribute, i64 (%struct.class*, %struct.class_attribute*, i8*)*, i64 (%struct.class*, %struct.class_attribute*, i8*, i64)* }
%struct.iommu_group = type opaque
%struct.dsa_chip_data = type { %struct.device*, i32, [12 x i8*], i8* }
%struct.dsa_switch = type { %struct.dsa_switch_tree*, i32, %struct.dsa_chip_data*, %struct.dsa_switch_driver*, %struct.mii_bus*, i32, i32, %struct.mii_bus*, [12 x %struct.net_device*] }
%struct.dsa_switch_driver = type { %struct.list_head, i16, i32, i8* (%struct.mii_bus*, i32)*, i32 (%struct.dsa_switch*)*, i32 (%struct.dsa_switch*, i8*)*, i32 (%struct.dsa_switch*, i32, i32)*, i32 (%struct.dsa_switch*, i32, i32, i16)*, void (%struct.dsa_switch*)*, void (%struct.dsa_switch*, i32, i8*)*, void (%struct.dsa_switch*, i32, i64*)*, i32 (%struct.dsa_switch*)* }
%struct.mii_bus = type opaque
%struct.tipc_bearer = type opaque
%struct.in_device = type opaque
%struct.dn_dev = type opaque
%struct.inet6_dev = type { %struct.net_device*, %struct.list_head, %struct.ifmcaddr6*, %struct.ifmcaddr6*, %struct.spinlock, i8, i8, i8, i8, i64, i64, i64, i64, %struct.timer_list, %struct.timer_list, %struct.timer_list, %struct.ifacaddr6*, %struct.rwlock_t, %struct.atomic_t, i32, i32, [8 x i8], %struct.timer_list, %struct.list_head, %struct.in6_addr, %struct.neigh_parms*, %struct.ipv6_devconf, %struct.ipv6_devstat, %struct.timer_list, i8, i8, i64, %struct.callback_head }
%struct.ifmcaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.ifmcaddr6*, %struct.ip6_sf_list*, %struct.ip6_sf_list*, i32, i8, [2 x i64], %struct.timer_list, i32, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.in6_addr = type { %union.anon.77 }
%union.anon.77 = type { [4 x i32] }
%struct.ip6_sf_list = type { %struct.ip6_sf_list*, %struct.in6_addr, [2 x i64], i8, i8, i8 }
%struct.ifacaddr6 = type { %struct.in6_addr, %struct.inet6_dev*, %struct.rt6_info*, %struct.ifacaddr6*, i32, %struct.atomic_t, %struct.spinlock, i64, i64 }
%struct.ipv6_devstat = type { %struct.proc_dir_entry*, %struct.ipstats_mib*, %struct.icmpv6_mib_device*, %struct.icmpv6msg_mib_device* }
%struct.icmpv6_mib_device = type { [6 x %struct.atomic64_t] }
%struct.icmpv6msg_mib_device = type { [512 x %struct.atomic64_t] }
%struct.wireless_dev = type opaque
%struct.netdev_rx_queue = type { %struct.rps_map*, %struct.rps_dev_flow_table*, %struct.kobject, %struct.net_device*, [40 x i8] }
%struct.rps_map = type { i32, %struct.callback_head, [0 x i16] }
%struct.rps_dev_flow_table = type { i32, %struct.callback_head, [0 x %struct.rps_dev_flow] }
%struct.rps_dev_flow = type { i16, i16, i32 }
%struct.netdev_queue = type { %struct.net_device*, %struct.Qdisc*, %struct.Qdisc*, %struct.kobject, i32, [36 x i8], %struct.spinlock, i32, i64, i64, i64, [32 x i8], %struct.dql }
%struct.Qdisc = type opaque
%struct.dql = type { i32, i32, i32, [52 x i8], i32, i32, i32, i32, i32, i32, i64, i32, i32, i32, [20 x i8] }
%struct.xps_dev_maps = type { %struct.callback_head, [0 x %struct.xps_map*] }
%struct.xps_map = type { i32, i32, %struct.callback_head, [0 x i16] }
%struct.cpu_rmap = type opaque
%union.anon.68 = type { i8* }
%struct.garp_port = type opaque
%struct.mrp_port = type opaque
%struct.rtnl_link_ops = type { %struct.list_head, i8*, i64, void (%struct.net_device*)*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, void (%struct.net_device*, %struct.list_head*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i64 (%struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*)*, i32 ()*, i32 ()*, i32, %struct.nla_policy*, i32 (%struct.nlattr**, %struct.nlattr**)*, i32 (%struct.net_device*, %struct.net_device*, %struct.nlattr**, %struct.nlattr**)*, i64 (%struct.net_device*, %struct.net_device*)*, i32 (%struct.sk_buff*, %struct.net_device*, %struct.net_device*)* }
%struct.nla_policy = type { i16, i16 }
%struct.dcbnl_rtnl_ops = type { i32 (%struct.net_device*, %struct.ieee_ets*)*, i32 (%struct.net_device*, %struct.ieee_ets*)*, i32 (%struct.net_device*, %struct.ieee_maxrate*)*, i32 (%struct.net_device*, %struct.ieee_maxrate*)*, i32 (%struct.net_device*, %struct.ieee_pfc*)*, i32 (%struct.net_device*, %struct.ieee_pfc*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.ieee_ets*)*, i32 (%struct.net_device*, %struct.ieee_pfc*)*, i8 (%struct.net_device*)*, i8 (%struct.net_device*, i8)*, void (%struct.net_device*, i8*)*, void (%struct.net_device*, i32, i8, i8, i8, i8)*, void (%struct.net_device*, i32, i8)*, void (%struct.net_device*, i32, i8, i8, i8, i8)*, void (%struct.net_device*, i32, i8)*, void (%struct.net_device*, i32, i8*, i8*, i8*, i8*)*, void (%struct.net_device*, i32, i8*)*, void (%struct.net_device*, i32, i8*, i8*, i8*, i8*)*, void (%struct.net_device*, i32, i8*)*, void (%struct.net_device*, i32, i8)*, void (%struct.net_device*, i32, i8*)*, i8 (%struct.net_device*)*, i8 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i8*)*, i32 (%struct.net_device*, i32, i8)*, i8 (%struct.net_device*)*, void (%struct.net_device*, i8)*, void (%struct.net_device*, i32, i32*)*, void (%struct.net_device*, i32, i32)*, void (%struct.net_device*, i32, i8*)*, void (%struct.net_device*, i32, i8)*, i32 (%struct.net_device*, i8, i16, i8)*, i32 (%struct.net_device*, i8, i16)*, i8 (%struct.net_device*, i32, i8*)*, i8 (%struct.net_device*, i32, i8)*, i8 (%struct.net_device*)*, i8 (%struct.net_device*, i8)*, i32 (%struct.net_device*, %struct.dcb_peer_app_info*, i16*)*, i32 (%struct.net_device*, %struct.dcb_app*)*, i32 (%struct.net_device*, %struct.cee_pg*)*, i32 (%struct.net_device*, %struct.cee_pfc*)* }
%struct.ieee_ets = type { i8, i8, i8, [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8], [8 x i8] }
%struct.ieee_maxrate = type { [8 x i64] }
%struct.ieee_pfc = type { i8, i8, i8, i16, [8 x i64], [8 x i64] }
%struct.dcb_app = type { i8, i8, i16 }
%struct.dcb_peer_app_info = type { i8, i8 }
%struct.cee_pg = type { i8, i8, i8, i8, [8 x i8], [8 x i8] }
%struct.cee_pfc = type { i8, i8, i8, i8 }
%struct.netdev_tc_txq = type { i16, i16 }
%struct.phy_device = type opaque
%struct.pm_qos_request = type { %struct.plist_node, i32, %struct.delayed_work }
%struct.sec_path = type opaque
%union.anon.58 = type { i32 }
%struct.nf_conntrack = type { %struct.atomic_t }
%struct.nf_bridge_info = type { %struct.atomic_t, i32, %struct.net_device*, %struct.net_device*, [4 x i64] }
%union.anon.60 = type { i32 }
%union.anon.61 = type { i32 }
%struct.request_sock_ops = type { i32, i32, %struct.kmem_cache*, i8*, i32 (%struct.sock*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*, %struct.request_sock*)*, void (%struct.sock*, %struct.sk_buff*)*, void (%struct.request_sock*)*, void (%struct.sock*, %struct.request_sock*)* }
%struct.request_sock = type { %struct.sock_common, %struct.request_sock*, i16, i8, i8, i32, i32, i32, i64, %struct.request_sock_ops*, %struct.sock*, i32, i32 }
%struct.timewait_sock_ops = type { %struct.kmem_cache*, i8*, i32, i32 (%struct.sock*, %struct.sock*, i8*)*, void (%struct.sock*)* }
%union.anon.81 = type { %struct.inet_hashinfo* }
%struct.inet_hashinfo = type opaque
%union.anon.78 = type { %struct.hlist_node }
%struct.socket_lock_t = type { %struct.spinlock, i32, %struct.__wait_queue_head }
%struct.anon.79 = type { %struct.atomic_t, i32, %struct.sk_buff*, %struct.sk_buff* }
%struct.sk_filter = type { %struct.atomic_t, %struct.callback_head, %struct.bpf_prog* }
%struct.bpf_prog = type { i8, [3 x i8], %struct.sock_fprog_kern*, i32 (%struct.sk_buff*, %struct.bpf_insn*)*, %union.anon.80 }
%struct.sock_fprog_kern = type { i16, %struct.sock_filter* }
%struct.sock_filter = type { i16, i8, i8, i32 }
%struct.bpf_insn = type { i8, i8, i16, i32 }
%union.anon.80 = type { %struct.work_struct }
%struct.socket_wq = type { %struct.__wait_queue_head, %struct.fasync_struct*, %struct.callback_head, [16 x i8] }
%struct.xfrm_policy = type opaque
%struct.socket = type { i32, i16, i64, %struct.socket_wq*, %struct.file*, %struct.sock*, %struct.proto_ops* }
%struct.proto_ops = type { i32, %struct.module*, i32 (%struct.socket*)*, i32 (%struct.socket*, %struct.sockaddr*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32, i32)*, i32 (%struct.socket*, %struct.socket*)*, i32 (%struct.socket*, %struct.socket*, i32)*, i32 (%struct.socket*, %struct.sockaddr*, i32*, i32)*, i32 (%struct.file*, %struct.socket*, %struct.poll_table_struct*)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32, i64)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.socket*, i32, i32, i8*, i32)*, i32 (%struct.socket*, i32, i32, i8*, i32*)*, i32 (%struct.kiocb*, %struct.socket*, %struct.msghdr*, i64)*, i32 (%struct.kiocb*, %struct.socket*, %struct.msghdr*, i64, i32)*, i32 (%struct.file*, %struct.socket*, %struct.vm_area_struct*)*, i64 (%struct.socket*, %struct.page*, i32, i64, i32)*, i64 (%struct.socket*, i64*, %struct.pipe_inode_info*, i64, i32)*, i32 (%struct.sock*, i32)* }
%struct.page_frag = type { %struct.page*, i32, i32 }
%struct.cg_proto = type { %struct.res_counter, %struct.percpu_counter, i32, [3 x i64], i64, %struct.mem_cgroup* }
%struct.res_counter = type { i64, i64, i64, i64, i64, %struct.spinlock, %struct.res_counter* }
%struct.mem_cgroup = type opaque
%struct.kernfs_node = type { %struct.atomic_t, %struct.atomic_t, %struct.kernfs_node*, i8*, %struct.rb_node, i8*, i32, %union.anon.10, i8*, i16, i16, i32, %struct.kernfs_iattrs* }
%union.anon.10 = type { %struct.kernfs_elem_attr }
%struct.kernfs_elem_attr = type { %struct.kernfs_ops*, %struct.kernfs_open_node*, i64, %struct.kernfs_node* }
%struct.kernfs_ops = type { i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i64, i64 (%struct.kernfs_open_file*, i8*, i64, i64)*, i32 (%struct.kernfs_open_file*, %struct.vm_area_struct*)* }
%struct.kernfs_open_file = type { %struct.kernfs_node*, %struct.file*, i8*, %struct.mutex, i32, %struct.list_head, i64, i8, %struct.vm_operations_struct* }
%struct.kernfs_open_node = type opaque
%struct.kernfs_iattrs = type opaque
%struct.module_param_attrs = type opaque
%struct.module_attribute = type { %struct.attribute, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*)*, i64 (%struct.module_attribute*, %struct.module_kobject*, i8*, i64)*, void (%struct.module*, i8*)*, i32 (%struct.module*)*, void (%struct.module*)* }
%struct.kernel_symbol = type { i64, i8* }
%struct.kernel_param = type { i8*, %struct.kernel_param_ops*, i16, i16, %union.anon.12 }
%struct.kernel_param_ops = type { i32, i32 (i8*, %struct.kernel_param*)*, i32 (i8*, %struct.kernel_param*)*, void (i8*)* }
%union.anon.12 = type { i8* }
%struct.exception_table_entry = type { i32, i32 }
%struct.mod_arch_specific = type {}
%struct.bug_entry = type { i32, i32, i16, i16 }
%struct.elf64_sym = type { i32, i8, i8, i16, i64, i64 }
%struct.module_sect_attrs = type opaque
%struct.module_notes_attrs = type opaque
%struct.tracepoint = type opaque
%struct.ftrace_event_call = type opaque
%struct.module_ref = type { i64, i64 }
%struct.super_operations = type { %struct.inode* (%struct.super_block*)*, void (%struct.inode*)*, void (%struct.inode*, i32)*, i32 (%struct.inode*, %struct.writeback_control*)*, i32 (%struct.inode*)*, void (%struct.inode*)*, void (%struct.super_block*)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*)*, i32 (%struct.super_block*)*, i32 (%struct.dentry*, %struct.kstatfs*)*, i32 (%struct.super_block*, i32*, i8*)*, void (%struct.super_block*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i32 (%struct.seq_file*, %struct.dentry*)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i64 (%struct.super_block*, i32, i8*, i64, i64)*, i32 (%struct.super_block*, %struct.page*, i32)*, i64 (%struct.super_block*, i32)*, i64 (%struct.super_block*, i64, i32)* }
%struct.writeback_control = type opaque
%struct.kstatfs = type opaque
%struct.dquot_operations = type { i32 (%struct.dquot*)*, %struct.dquot* (%struct.super_block*, i32)*, void (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.super_block*, i32)*, i64* (%struct.inode*)* }
%struct.dquot = type { %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.mutex, %struct.atomic_t, %struct.__wait_queue_head, %struct.super_block*, %struct.kqid, i64, i64, %struct.mem_dqblk }
%struct.kqid = type { %union.anon.13, i32 }
%union.anon.13 = type { %struct.kuid_t }
%struct.mem_dqblk = type { i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.quotactl_ops = type { i32 (%struct.super_block*, i32, i32, %struct.path*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i32, %struct.if_dqinfo*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, i64, %struct.fs_disk_quota*)*, i32 (%struct.super_block*, %struct.fs_quota_stat*)*, i32 (%struct.super_block*, i32, i32)*, i32 (%struct.super_block*, %struct.fs_quota_statv*)*, i32 (%struct.super_block*, i32)* }
%struct.if_dqinfo = type { i64, i64, i32, i32 }
%struct.fs_disk_quota = type { i8, i8, i16, i32, i64, i64, i64, i64, i64, i64, i32, i32, i16, i16, i32, i64, i64, i64, i32, i16, i16, [8 x i8] }
%struct.fs_quota_stat = type { i8, i16, i8, %struct.fs_qfilestat, %struct.fs_qfilestat, i32, i32, i32, i32, i16, i16 }
%struct.fs_qfilestat = type { i64, i64, i32 }
%struct.fs_quota_statv = type { i8, i8, i16, i32, %struct.fs_qfilestatv, %struct.fs_qfilestatv, %struct.fs_qfilestatv, i32, i32, i32, i16, i16, [8 x i64] }
%struct.fs_qfilestatv = type { i64, i64, i32, i32 }
%struct.export_operations = type opaque
%struct.xattr_handler = type opaque
%struct.hlist_bl_head = type { %struct.hlist_bl_node* }
%struct.block_device = type { i32, i32, %struct.inode*, %struct.super_block*, %struct.mutex, %struct.list_head, i8*, i8*, i32, i8, %struct.list_head, %struct.block_device*, i32, %struct.hd_struct*, i32, i32, %struct.gendisk*, %struct.request_queue*, %struct.list_head, i64, i32, %struct.mutex }
%struct.hd_struct = type opaque
%struct.gendisk = type opaque
%struct.request_queue = type opaque
%struct.backing_dev_info = type opaque
%struct.mtd_info = type opaque
%struct.quota_info = type { i32, %struct.mutex, %struct.mutex, [2 x %struct.inode*], [2 x %struct.mem_dqinfo], [2 x %struct.quota_format_ops*] }
%struct.mem_dqinfo = type { %struct.quota_format_type*, i32, %struct.list_head, i64, i32, i32, i64, i64, i8* }
%struct.quota_format_type = type { i32, %struct.quota_format_ops*, %struct.module*, %struct.quota_format_type* }
%struct.quota_format_ops = type { i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.super_block*, i32)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)*, i32 (%struct.dquot*)* }
%struct.sb_writers = type { [3 x %struct.percpu_counter], %struct.__wait_queue_head, i32, %struct.__wait_queue_head }
%struct.shrinker = type { i64 (%struct.shrinker*, %struct.shrink_control*)*, i64 (%struct.shrinker*, %struct.shrink_control*)*, i32, i64, i64, %struct.list_head, %struct.atomic64_t* }
%struct.shrink_control = type { i32, i64, %struct.nodemask_t, i32 }
%struct.nodemask_t = type { [1 x i64] }
%struct.list_lru = type { %struct.list_lru_node*, %struct.nodemask_t }
%struct.list_lru_node = type { %struct.spinlock, %struct.list_head, i64, [32 x i8] }
%union.anon.14 = type { %struct.list_head }
%struct.nameidata = type opaque
%struct.iattr = type { i32, i16, %struct.kuid_t, %struct.kgid_t, i64, %struct.timespec, %struct.timespec, %struct.timespec, %struct.file* }
%struct.timespec = type { i64, i64 }
%struct.kstat = type { i64, i32, i16, i32, %struct.kuid_t, %struct.kgid_t, i32, i64, %struct.timespec, %struct.timespec, %struct.timespec, i64, i64 }
%struct.fiemap_extent_info = type { i32, i32, i32, %struct.fiemap_extent* }
%struct.fiemap_extent = type { i64, i64, i64, [2 x i64], i32, [3 x i32] }
%union.anon.50 = type { i32 }
%union.anon.51 = type { %struct.callback_head }
%union.anon.52 = type { %struct.pipe_inode_info* }
%struct.radix_tree_root = type { i32, i32, %struct.radix_tree_node* }
%struct.radix_tree_node = type { i32, i32, %union.anon.1, %struct.list_head, [64 x i8*], [3 x [1 x i64]] }
%union.anon.1 = type { %struct.anon.2 }
%struct.anon.2 = type { %struct.radix_tree_node*, i8* }
%struct.address_space_operations = type { i32 (%struct.page*, %struct.writeback_control*)*, i32 (%struct.file*, %struct.page*)*, i32 (%struct.address_space*, %struct.writeback_control*)*, i32 (%struct.page*)*, i32 (%struct.file*, %struct.address_space*, %struct.list_head*, i32)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page**, i8**)*, i32 (%struct.file*, %struct.address_space*, i64, i32, i32, %struct.page*, i8*)*, i64 (%struct.address_space*, i64)*, void (%struct.page*, i32, i32)*, i32 (%struct.page*, i32)*, void (%struct.page*)*, i64 (i32, %struct.kiocb*, %struct.iov_iter*, i64)*, i32 (%struct.address_space*, i64, i32, i8**, i64*)*, i32 (%struct.address_space*, %struct.page*, %struct.page*, i32)*, i32 (%struct.page*)*, i32 (%struct.page*, i64, i64)*, void (%struct.page*, i8*, i8*)*, i32 (%struct.address_space*, %struct.page*)*, i32 (%struct.swap_info_struct*, %struct.file*, i64*)*, void (%struct.file*)* }
%struct.swap_info_struct = type opaque
%struct.anon.25 = type { %union.anon.26, %union.anon.27 }
%union.anon.26 = type { i64 }
%union.anon.27 = type { i64 }
%union.anon.31 = type { %struct.list_head }
%union.anon.33 = type { i64 }
%struct.pte_t = type { i64 }
%struct.mempolicy = type opaque
%struct.pgd_t = type { i64 }
%struct.mm_rss_stat = type { [3 x %struct.atomic64_t] }
%struct.linux_binfmt = type opaque
%struct.mm_context_t = type { i8*, i32, i16, %struct.mutex, i8* }
%struct.core_state = type { %struct.atomic_t, %struct.core_thread, %struct.completion }
%struct.core_thread = type { %struct.task_struct*, %struct.core_thread* }
%struct.kioctx_table = type opaque
%struct.mmu_notifier_mm = type opaque
%struct.uprobes_state = type {}
%struct.task_rss_stat = type { i32, [3 x i32] }
%struct.pid_link = type { %struct.hlist_node, %struct.pid* }
%struct.cputime = type { i64, i64 }
%struct.task_cputime = type { i64, i64, i64 }
%struct.sysv_sem = type { %struct.sem_undo_list* }
%struct.sem_undo_list = type opaque
%struct.sysv_shm = type { %struct.list_head }
%struct.thread_struct = type { [3 x %struct.desc_struct], i64, i64, i64, i16, i16, i16, i16, i64, i64, [4 x %struct.perf_event*], i64, i64, i64, i64, i64, %struct.fpu, i64*, i64, i32, i8 }
%struct.desc_struct = type <{ %union.anon.34 }>
%union.anon.34 = type { %struct.anon.35 }
%struct.anon.35 = type { i32, i32 }
%struct.perf_event = type opaque
%struct.fpu = type { i32, i32, %union.thread_xstate* }
%union.thread_xstate = type { %struct.i387_fxsave_struct, [576 x i8] }
%struct.i387_fxsave_struct = type { i16, i16, i16, i16, %union.anon.37, i32, i32, [32 x i32], [64 x i32], [12 x i32], %union.anon.40 }
%union.anon.37 = type { %struct.anon.38 }
%struct.anon.38 = type { i64, i64 }
%union.anon.40 = type { [12 x i32] }
%struct.fs_struct = type opaque
%struct.files_struct = type opaque
%struct.signal_struct = type { %struct.atomic_t, %struct.atomic_t, i32, %struct.list_head, %struct.__wait_queue_head, %struct.task_struct*, %struct.sigpending, i32, i32, %struct.task_struct*, i32, i32, i8, i32, %struct.list_head, %struct.hrtimer, %struct.pid*, %union.ktime, [2 x %struct.cpu_itimer], %struct.thread_group_cputimer, %struct.task_cputime, [3 x %struct.list_head], %struct.pid*, i32, %struct.tty_struct*, %struct.autogroup*, i64, i64, i64, i64, i64, i64, %struct.cputime, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, %struct.task_io_accounting, i64, [16 x %struct.rlimit], %struct.pacct_struct, %struct.taskstats*, i32, i32, %struct.tty_audit_buf*, %struct.rw_semaphore, i32, i16, i16, %struct.mutex }
%struct.sigpending = type { %struct.list_head, %struct.sigset_t }
%struct.sigset_t = type { [1 x i64] }
%struct.cpu_itimer = type { i64, i64, i32, i32 }
%struct.thread_group_cputimer = type { %struct.task_cputime, i32, %struct.raw_spinlock }
%struct.tty_struct = type opaque
%struct.autogroup = type opaque
%struct.task_io_accounting = type { i64, i64, i64, i64, i64, i64, i64 }
%struct.rlimit = type { i64, i64 }
%struct.pacct_struct = type { i32, i64, i64, i64, i64, i64, i64 }
%struct.taskstats = type { i16, i32, i8, i8, i64, i64, i64, i64, i64, i64, i64, i64, [32 x i8], i8, [3 x i8], [4 x i8], i32, i32, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.tty_audit_buf = type opaque
%struct.sighand_struct = type { %struct.atomic_t, [64 x %struct.k_sigaction], %struct.spinlock, %struct.__wait_queue_head }
%struct.k_sigaction = type { %struct.sigaction }
%struct.sigaction = type { void (i32)*, i64, void ()*, %struct.sigset_t }
%struct.audit_context = type opaque
%struct.seccomp = type { i32, %struct.seccomp_filter* }
%struct.seccomp_filter = type opaque
%struct.rt_mutex_waiter = type opaque
%struct.bio_list = type opaque
%struct.blk_plug = type opaque
%struct.reclaim_state = type opaque
%struct.io_context = type opaque
%struct.siginfo = type { i32, i32, i32, %union.anon.42 }
%union.anon.42 = type { %struct.anon.46, [80 x i8] }
%struct.anon.46 = type { i32, i32, i32, i64, i64 }
%struct.css_set = type { %struct.atomic_t, %struct.hlist_node, %struct.list_head, %struct.list_head, %struct.list_head, %struct.cgroup*, [8 x %struct.cgroup_subsys_state*], %struct.list_head, %struct.list_head, %struct.cgroup*, %struct.css_set*, [8 x %struct.list_head], %struct.callback_head }
%struct.cgroup = type { %struct.cgroup_subsys_state, i64, i32, i32, %struct.kernfs_node*, %struct.kernfs_node*, i32, i32, [8 x %struct.cgroup_subsys_state*], %struct.cgroup_root*, %struct.list_head, [8 x %struct.list_head], %struct.list_head, %struct.list_head, %struct.mutex, %struct.__wait_queue_head }
%struct.cgroup_subsys_state = type { %struct.cgroup*, %struct.cgroup_subsys*, %struct.percpu_ref, %struct.cgroup_subsys_state*, %struct.list_head, %struct.list_head, i32, i32, i64, %struct.callback_head, %struct.work_struct }
%struct.cgroup_subsys = type { %struct.cgroup_subsys_state* (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, void (%struct.cgroup_subsys_state*)*, i32 (%struct.cgroup_subsys_state*, %struct.cgroup_taskset*)*, void (%struct.cgroup_subsys_state*, %struct.cgroup_taskset*)*, void (%struct.cgroup_subsys_state*, %struct.cgroup_taskset*)*, void (%struct.task_struct*)*, void (%struct.cgroup_subsys_state*, %struct.cgroup_subsys_state*, %struct.task_struct*)*, void (%struct.cgroup_subsys_state*)*, i32, i32, i8, i8, i32, i8*, %struct.cgroup_root*, %struct.idr, %struct.list_head, %struct.cftype*, %struct.cftype*, i32 }
%struct.cgroup_taskset = type opaque
%struct.cgroup_root = type { %struct.kernfs_root*, i32, i32, %struct.cgroup, %struct.atomic_t, %struct.list_head, i32, %struct.idr, [4096 x i8], [64 x i8] }
%struct.kernfs_root = type { %struct.kernfs_node*, i32, %struct.ida, %struct.kernfs_syscall_ops*, %struct.list_head, %struct.__wait_queue_head }
%struct.ida = type { %struct.idr, %struct.ida_bitmap* }
%struct.idr = type { %struct.idr_layer*, %struct.idr_layer*, i32, i32, %struct.spinlock, i32, %struct.idr_layer* }
%struct.idr_layer = type { i32, i32, [256 x %struct.idr_layer*], i32, %union.anon.11 }
%union.anon.11 = type { [4 x i64] }
%struct.ida_bitmap = type { i64, [15 x i64] }
%struct.kernfs_syscall_ops = type { i32 (%struct.kernfs_root*, i32*, i8*)*, i32 (%struct.seq_file*, %struct.kernfs_root*)*, i32 (%struct.kernfs_node*, i8*, i16)*, i32 (%struct.kernfs_node*)*, i32 (%struct.kernfs_node*, %struct.kernfs_node*, i8*)* }
%struct.cftype = type { [64 x i8], i32, i16, i64, i32, %struct.cgroup_subsys*, %struct.list_head, %struct.kernfs_ops*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i64 (%struct.cgroup_subsys_state*, %struct.cftype*)*, i32 (%struct.seq_file*, i8*)*, i8* (%struct.seq_file*, i64*)*, i8* (%struct.seq_file*, i8*, i64*)*, void (%struct.seq_file*, i8*)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i32 (%struct.cgroup_subsys_state*, %struct.cftype*, i64)*, i64 (%struct.kernfs_open_file*, i8*, i64, i64)* }
%struct.percpu_ref = type { %struct.atomic_t, i64, void (%struct.percpu_ref*)*, void (%struct.percpu_ref*)*, %struct.callback_head }
%struct.robust_list_head = type opaque
%struct.compat_robust_list_head = type { %struct.compat_robust_list, i32, i32 }
%struct.compat_robust_list = type { i32 }
%struct.futex_pi_state = type opaque
%struct.perf_event_context = type opaque
%struct.task_delay_info = type { %struct.spinlock, i32, i64, i64, i64, i32, i32, i64, i64, i32 }
%struct.latency_record = type { [12 x i64], i32, i64, i64 }
%struct.ftrace_ret_stack = type opaque
%struct.pglist_data = type { [4 x %struct.zone], [2 x %struct.zonelist], i32, %struct.spinlock, i64, i64, i64, i32, %struct.__wait_queue_head, %struct.__wait_queue_head, %struct.task_struct*, i32, i32, [24 x i8] }
%struct.zone = type { [3 x i64], [4 x i64], i32, i32, %struct.pglist_data*, %struct.per_cpu_pageset*, i64, i64, i64, i64, i64, i64, i64, i8*, i32, %struct.seqlock_t, %struct.__wait_queue_head*, i64, i64, [8 x i8], %struct.zone_padding, %struct.spinlock, [11 x %struct.free_area], i64, [40 x i8], %struct.zone_padding, %struct.spinlock, %struct.lruvec, %struct.atomic64_t, i64, i64, [2 x i64], i32, i32, i32, i8, [19 x i8], %struct.zone_padding, [39 x %struct.atomic64_t], [8 x i8] }
%struct.per_cpu_pageset = type { %struct.per_cpu_pages, i8, i8, [39 x i8] }
%struct.per_cpu_pages = type { i32, i32, i32, [3 x %struct.list_head] }
%struct.zone_padding = type { [0 x i8] }
%struct.free_area = type { [5 x %struct.list_head], i64 }
%struct.lruvec = type { [5 x %struct.list_head], %struct.zone_reclaim_stat }
%struct.zone_reclaim_stat = type { [2 x i64], [2 x i64] }
%struct.zonelist = type { %struct.zonelist_cache*, [257 x %struct.zoneref], %struct.zonelist_cache }
%struct.zonelist_cache = type { [256 x i16], [4 x i64], i64 }
%struct.zoneref = type { %struct.zone*, i32 }
%struct.pci_driver = type { %struct.list_head, i8*, %struct.pci_device_id*, i32 (%struct.pci_dev*, %struct.pci_device_id*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*)*, i32 (%struct.pci_dev*, i32)*, %struct.pci_error_handlers*, %struct.device_driver, %struct.pci_dynids }
%struct.pci_device_id = type { i32, i32, i32, i32, i32, i32, i64 }
%struct.pci_dev = type { %struct.list_head, %struct.pci_bus*, %struct.pci_bus*, i8*, %struct.proc_dir_entry*, %struct.pci_slot*, i32, i16, i16, i16, i16, i32, i8, i8, i8, i8, i8, i8, i8, i8, i16, i8, %struct.pci_driver*, i64, %struct.device_dma_parameters, i32, i8, i8, i8, i32, i32, %struct.pcie_link_state*, i32, %struct.device, i32, i32, [17 x %struct.resource], i8, i8, i8, i8, i16, %struct.atomic_t, [16 x i32], %struct.hlist_head, %struct.bin_attribute*, i32, [17 x %struct.bin_attribute*], [17 x %struct.bin_attribute*], %struct.list_head, %struct.attribute_group**, %struct.pci_vpd*, %union.anon.93, %struct.pci_ats*, i64, i64, i8* }
%struct.pci_bus = type { %struct.list_head, %struct.pci_bus*, %struct.list_head, %struct.list_head, %struct.pci_dev*, %struct.list_head, [4 x %struct.resource*], %struct.list_head, %struct.resource, %struct.pci_ops*, %struct.msi_chip*, i8*, %struct.proc_dir_entry*, i8, i8, i8, i8, [48 x i8], i16, i16, %struct.device*, %struct.device, %struct.bin_attribute*, %struct.bin_attribute*, i8 }
%struct.resource = type { i64, i64, i8*, i64, %struct.resource*, %struct.resource*, %struct.resource* }
%struct.pci_ops = type { i32 (%struct.pci_bus*, i32, i32, i32, i32*)*, i32 (%struct.pci_bus*, i32, i32, i32, i32)* }
%struct.msi_chip = type opaque
%struct.pci_slot = type { %struct.pci_bus*, %struct.list_head, %struct.hotplug_slot*, i8, %struct.kobject }
%struct.hotplug_slot = type opaque
%struct.pcie_link_state = type opaque
%struct.pci_vpd = type opaque
%union.anon.93 = type { %struct.pci_sriov* }
%struct.pci_sriov = type opaque
%struct.pci_ats = type opaque
%struct.pci_error_handlers = type { i32 (%struct.pci_dev*, i32)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, i32 (%struct.pci_dev*)*, void (%struct.pci_dev*, i1)*, void (%struct.pci_dev*)* }
%struct.pci_dynids = type { %struct.spinlock, %struct.list_head }
%struct.e1000_info = type { i32 (%struct.e1000_hw*)*, %struct.e1000_mac_operations*, %struct.e1000_phy_operations*, %struct.e1000_nvm_operations* }
%struct.e1000_hw = type { i8*, i8*, i8*, i64, %struct.e1000_mac_info, %struct.e1000_fc_info, %struct.e1000_phy_info, %struct.e1000_nvm_info, %struct.e1000_bus_info, %struct.e1000_mbx_info, %struct.e1000_host_mng_dhcp_cookie, %union.anon.86, i16, i16, i16, i16, i8 }
%struct.e1000_mac_info = type { %struct.e1000_mac_operations, [6 x i8], [6 x i8], i32, i32, i32, i32, i32, i32, i16, i16, [128 x i32], i16, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, i8, %struct.e1000_thermal_sensor_data }
%struct.e1000_mac_operations = type { i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i1 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, void (%struct.e1000_hw*, i8*, i32)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i16*, i16*)*, i32 (%struct.e1000_hw*, i16)*, void (%struct.e1000_hw*, i16)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)* }
%struct.e1000_thermal_sensor_data = type { [3 x %struct.e1000_thermal_diode_data] }
%struct.e1000_thermal_diode_data = type { i8, i8, i8, i8 }
%struct.e1000_fc_info = type { i32, i32, i16, i8, i8, i32, i32 }
%struct.e1000_phy_info = type { %struct.e1000_phy_operations, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i8, i8, i8, i8, i8, i8, i8 }
%struct.e1000_phy_operations = type { i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i32, i16*)*, void (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i1)*, i32 (%struct.e1000_hw*, i1)*, i32 (%struct.e1000_hw*, i32, i16)*, i32 (%struct.e1000_hw*, i8, i8, i8*)*, i32 (%struct.e1000_hw*, i8, i8, i8)* }
%struct.e1000_nvm_info = type { %struct.e1000_nvm_operations, i32, i32, i32, i32, i16, i16, i16, i16, i16 }
%struct.e1000_nvm_operations = type { i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i16, i16, i16*)*, void (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i16, i16, i16*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i16*)* }
%struct.e1000_bus_info = type { i32, i32, i32, i32, i16, i16 }
%struct.e1000_mbx_info = type { %struct.e1000_mbx_operations, %struct.e1000_mbx_stats, i32, i32, i16 }
%struct.e1000_mbx_operations = type { i32 (%struct.e1000_hw*)*, i32 (%struct.e1000_hw*, i32*, i16, i16)*, i32 (%struct.e1000_hw*, i32*, i16, i16)*, i32 (%struct.e1000_hw*, i32*, i16, i16)*, i32 (%struct.e1000_hw*, i32*, i16, i16)*, i32 (%struct.e1000_hw*, i16)*, i32 (%struct.e1000_hw*, i16)*, i32 (%struct.e1000_hw*, i16)* }
%struct.e1000_mbx_stats = type { i32, i32, i32, i32, i32 }
%struct.e1000_host_mng_dhcp_cookie = type { i32, i8, i8, i16, i32, i16, i8, i8 }
%union.anon.86 = type { %struct.e1000_dev_spec_82575 }
%struct.e1000_dev_spec_82575 = type { i8, i8, i8, i8, %struct.e1000_sfp_flags, i8, i8, i8, i8 }
%struct.e1000_sfp_flags = type { i8 }
%struct.i2c_algo_bit_data = type { i8*, void (i8*, i32)*, void (i8*, i32)*, i32 (i8*)*, i32 (i8*)*, i32 (%struct.i2c_adapter*)*, void (%struct.i2c_adapter*)*, i32, i32 }
%struct.i2c_adapter = type { %struct.module*, i32, %struct.i2c_algorithm*, i8*, %struct.rt_mutex, i32, i32, %struct.device, i32, [48 x i8], %struct.completion, %struct.mutex, %struct.list_head, %struct.i2c_bus_recovery_info* }
%struct.i2c_algorithm = type { i32 (%struct.i2c_adapter*, %struct.i2c_msg*, i32)*, i32 (%struct.i2c_adapter*, i16, i16, i8, i8, i32, %union.i2c_smbus_data*)*, i32 (%struct.i2c_adapter*)* }
%struct.i2c_msg = type { i16, i16, i16, i8* }
%union.i2c_smbus_data = type { i16, [32 x i8] }
%struct.rt_mutex = type { %struct.raw_spinlock, %struct.rb_root, %struct.rb_node*, %struct.task_struct* }
%struct.i2c_bus_recovery_info = type { {}*, {}*, void (%struct.i2c_adapter*, i32)*, {}*, void (%struct.i2c_bus_recovery_info*)*, void (%struct.i2c_bus_recovery_info*)*, i32, i32 }
%struct.igb_reg_info = type { i32, i8* }
%struct.igb_adapter = type { [64 x i64], %struct.net_device*, i64, i32, i32, [10 x %struct.msix_entry], i32, i32, i16, i16, i16, i32, i32, [16 x %struct.igb_ring*], i32, [16 x %struct.igb_ring*], i32, i32, %struct.timer_list, %struct.timer_list, i16, i32, i32, i32, i16, i16, %struct.work_struct, %struct.work_struct, i8, i8, %struct.timer_list, i64, %struct.pci_dev*, %struct.spinlock, %struct.rtnl_link_stats64, %struct.e1000_hw, %struct.e1000_hw_stats, %struct.e1000_phy_info, %struct.e1000_phy_stats, i32, [44 x i8], %struct.igb_ring, %struct.igb_ring, i32, [8 x %struct.igb_q_vector*], i32, i32, i16, i16, i32, %struct.vf_data_storage*, i32, i32, i32, i32*, %struct.ptp_clock*, %struct.ptp_clock_info, %struct.delayed_work, %struct.work_struct, %struct.sk_buff*, %struct.hwtstamp_config, i64, i64, i64, %struct.spinlock, %struct.cyclecounter, %struct.timecounter, i32, i32, [32 x i8], %struct.hwmon_buff*, i8, %struct.i2c_algo_bit_data, %struct.i2c_adapter, %struct.i2c_client*, i32, [128 x i8], i64, i32, %struct.e1000_info, i16 }
%struct.msix_entry = type { i32, i16 }
%struct.igb_ring = type { %struct.igb_q_vector*, %struct.net_device*, %struct.device*, %union.anon.87, i8*, i64, i8*, i64, i32, i16, i8, i8, i16, i16, i16, %union.anon.90 }
%struct.igb_q_vector = type { %struct.igb_adapter*, i32, i32, i16, i8, i8*, %struct.igb_ring_container, %struct.igb_ring_container, %struct.napi_struct, %struct.callback_head, [25 x i8], [23 x i8], [0 x %struct.igb_ring] }
%struct.igb_ring_container = type { %struct.igb_ring*, i32, i32, i16, i8, i8 }
%union.anon.87 = type { %struct.igb_tx_buffer* }
%struct.igb_tx_buffer = type { %union.e1000_adv_tx_desc*, i64, %struct.sk_buff*, i32, i16, i16, i64, i32, i32 }
%union.e1000_adv_tx_desc = type { %struct.anon.88 }
%struct.anon.88 = type { i64, i32, i32 }
%union.anon.90 = type { %struct.anon.92 }
%struct.anon.92 = type { %struct.sk_buff*, %struct.igb_rx_queue_stats, %struct.u64_stats_sync }
%struct.igb_rx_queue_stats = type { i64, i64, i64, i64, i64 }
%struct.e1000_hw_stats = type { i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64, i64 }
%struct.e1000_phy_stats = type { i32, i32 }
%struct.vf_data_storage = type { [6 x i8], [30 x i16], i16, i16, i32, i64, i16, i16, i16, i8 }
%struct.ptp_clock = type opaque
%struct.ptp_clock_info = type { %struct.module*, [16 x i8], i32, i32, i32, i32, i32, i32, %struct.ptp_pin_desc*, i32 (%struct.ptp_clock_info*, i32)*, i32 (%struct.ptp_clock_info*, i64)*, i32 (%struct.ptp_clock_info*, %struct.timespec*)*, i32 (%struct.ptp_clock_info*, %struct.timespec*)*, i32 (%struct.ptp_clock_info*, %struct.ptp_clock_request*, i32)*, i32 (%struct.ptp_clock_info*, i32, i32, i32)* }
%struct.ptp_pin_desc = type { [64 x i8], i32, i32, i32, [5 x i32] }
%struct.ptp_clock_request = type { i32, %union.anon.94 }
%union.anon.94 = type { %struct.ptp_perout_request }
%struct.ptp_perout_request = type { %struct.ptp_clock_time, %struct.ptp_clock_time, i32, i32, [4 x i32] }
%struct.ptp_clock_time = type { i64, i32, i32 }
%struct.hwtstamp_config = type { i32, i32, i32 }
%struct.cyclecounter = type { i64 (%struct.cyclecounter*)*, i64, i32, i32 }
%struct.timecounter = type { %struct.cyclecounter*, i64, i64 }
%struct.hwmon_buff = type { %struct.attribute_group, [2 x %struct.attribute_group*], [13 x %struct.attribute*], [12 x %struct.hwmon_attr], i32 }
%struct.hwmon_attr = type { %struct.device_attribute, %struct.e1000_hw*, %struct.e1000_thermal_diode_data*, [12 x i8] }
%struct.i2c_client = type { i16, i16, [20 x i8], %struct.i2c_adapter*, %struct.device, i32, %struct.list_head }
%struct.anon.91 = type { %struct.igb_tx_queue_stats, %struct.u64_stats_sync, %struct.u64_stats_sync }
%struct.igb_tx_queue_stats = type { i64, i64, i64, i64 }
%struct.e1000_fw_version = type { i32, i16, i16, i16, i8, i8, i8, i8, i16, i16, i16 }
%struct.igb_rx_buffer = type { i64, %struct.page*, i32 }
%struct.skb_shared_info = type { i8, i8, i16, i16, i16, %struct.sk_buff*, %struct.skb_shared_hwtstamps, i32, i32, %struct.atomic_t, i8*, [17 x %struct.skb_frag_struct] }
%struct.skb_shared_hwtstamps = type { %union.ktime }
%struct.skb_frag_struct = type { %struct.anon.95, i32, i32 }
%struct.anon.95 = type { %struct.page* }
%struct.iphdr = type { i8, i8, i16, i16, i16, i8, i8, i16, i32, i32 }
%struct.tcphdr = type { i16, i16, i32, i32, i8, i8, i16, i16, i16 }
%struct.ipv6hdr = type { i8, [3 x i8], i16, i8, i8, %struct.in6_addr, %struct.in6_addr }
%union.e1000_adv_rx_desc = type { %struct.anon.96 }
%struct.anon.96 = type { i64, i64 }
%struct.netdev_hw_addr = type { %struct.list_head, [32 x i8], i8, i8, i32, i32, i32, %struct.callback_head }
%struct.anon.89 = type { i64, i32, i32 }
%struct.anon.97 = type { %struct.anon.98, %struct.anon.102 }
%struct.anon.98 = type { %struct.anon.99, %union.anon.100 }
%struct.anon.99 = type { i16, i16 }
%union.anon.100 = type { i32 }
%struct.anon.102 = type { i32, i16, i16 }
%union.anon.103 = type { i8* }
%struct.ethhdr = type <{ [6 x i8], [6 x i8], i16 }>
%struct.vlan_hdr = type { i16, i16 }
%struct.anon.28 = type { %union.anon.29, %struct.atomic_t }
%union.anon.29 = type { %struct.atomic_t }
%struct.e1000_adv_tx_context_desc = type { i32, i32, i32, i32 }
%struct.__raw_tickets = type { i16, i16 }
%struct.my_u0 = type { i64, i64 }
%struct.mii_ioctl_data = type { i16, i16, i16, i16 }

@smp_ops = external global %struct.smp_ops
@igb_driver_name = global [4 x i8] c"igb\00", align 1
@igb_driver_version = global [9 x i8] c"5.2.13-k\00", align 1
@__param_str_max_vfs = internal constant [8 x i8] c"max_vfs\00", align 1
@param_ops_uint = external global %struct.kernel_param_ops
@max_vfs = internal global i32 0, align 4
@__param_max_vfs = internal constant %struct.kernel_param { i8* getelementptr inbounds ([8 x i8]* @__param_str_max_vfs, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_uint, i16 0, i16 -1, %union.anon.12 { i8* bitcast (i32* @max_vfs to i8*) } }, section "__param", align 8
@__UNIQUE_ID_max_vfstype216 = internal constant [22 x i8] c"parmtype=max_vfs:uint\00", section ".modinfo", align 1
@__UNIQUE_ID_max_vfs217 = internal constant [83 x i8] c"parm=max_vfs:Maximum number of virtual functions to allocate per physical function\00", section ".modinfo", align 1
@__UNIQUE_ID_author246 = internal constant [62 x i8] c"author=Intel Corporation, <e1000-devel@lists.sourceforge.net>\00", section ".modinfo", align 1
@__UNIQUE_ID_description247 = internal constant [53 x i8] c"description=Intel(R) Gigabit Ethernet Network Driver\00", section ".modinfo", align 1
@__UNIQUE_ID_license248 = internal constant [12 x i8] c"license=GPL\00", section ".modinfo", align 1
@__UNIQUE_ID_version249 = internal constant [17 x i8] c"version=5.2.13-k\00", section ".modinfo", align 1
@__param_str_debug = internal constant [6 x i8] c"debug\00", align 1
@param_ops_int = external global %struct.kernel_param_ops
@debug = internal global i32 -1, align 4
@__param_debug = internal constant %struct.kernel_param { i8* getelementptr inbounds ([6 x i8]* @__param_str_debug, i32 0, i32 0), %struct.kernel_param_ops* @param_ops_int, i16 0, i16 -1, %union.anon.12 { i8* bitcast (i32* @debug to i8*) } }, section "__param", align 8
@__UNIQUE_ID_debugtype253 = internal constant [19 x i8] c"parmtype=debug:int\00", section ".modinfo", align 1
@__UNIQUE_ID_debug254 = internal constant [43 x i8] c"parm=debug:Debug level (0=none,...,16=all)\00", section ".modinfo", align 1
@.str = private unnamed_addr constant [37 x i8] c"PCIe link lost, device now detached\0A\00", align 1
@.str1 = private unnamed_addr constant [56 x i8] c"/home/bai/MyProject/EHTestDir/Kern3.17.2/igb/igb_main.c\00", align 1
@.str2 = private unnamed_addr constant [33 x i8] c"Error enabling Media Auto Sense\0A\00", align 1
@.str3 = private unnamed_addr constant [16 x i8] c"Hardware Error\0A\00", align 1
@.str4 = private unnamed_addr constant [11 x i8] c"%2d.%2d-%d\00", align 1
@.str5 = private unnamed_addr constant [24 x i8] c"%d.%d, 0x%08x, %d.%d.%d\00", align 1
@.str6 = private unnamed_addr constant [14 x i8] c"%d.%d, 0x%08x\00", align 1
@.str7 = private unnamed_addr constant [9 x i8] c"%d.%d.%d\00", align 1
@.str8 = private unnamed_addr constant [54 x i8] c"Unable to allocate memory for the Tx descriptor ring\0A\00", align 1
@.str9 = private unnamed_addr constant [54 x i8] c"Unable to allocate memory for the Rx descriptor ring\0A\00", align 1
@jiffies = external global i64
@.str10 = private unnamed_addr constant [40 x i8] c"Unsupported Speed/Duplex configuration\0A\00", align 1
@.str11 = private unnamed_addr constant [38 x i8] c"Unable to allocate memory for queues\0A\00", align 1
@.str12 = private unnamed_addr constant [28 x i8] c"Error %d getting interrupt\0A\00", align 1
@.str13 = private unnamed_addr constant [11 x i8] c"%s-TxRx-%u\00", align 1
@.str14 = private unnamed_addr constant [9 x i8] c"%s-tx-%u\00", align 1
@.str15 = private unnamed_addr constant [9 x i8] c"%s-rx-%u\00", align 1
@.str16 = private unnamed_addr constant [10 x i8] c"%s-unused\00", align 1
@.str17 = private unnamed_addr constant [33 x i8] c"Error receiving message from VF\0A\00", align 1
@.str18 = private unnamed_addr constant [104 x i8] c"VF %d attempted to override administratively set MAC address\0AReload the VF driver to resume operations\0A\00", align 1
@.str19 = private unnamed_addr constant [101 x i8] c"VF %d attempted to override administratively set VLAN tag\0AReload the VF driver to resume operations\0A\00", align 1
@.str20 = private unnamed_addr constant [20 x i8] c"Unhandled Msg %08x\0A\00", align 1
@.str21 = private unnamed_addr constant [36 x i8] c"Setting VLAN %d, QOS 0x%x on VF %d\0A\00", align 1
@.str22 = private unnamed_addr constant [56 x i8] c"The VF VLAN has been set, but the PF device is not up.\0A\00", align 1
@.str23 = private unnamed_addr constant [64 x i8] c"Bring the PF device up before attempting to use the VF device.\0A\00", align 1
@.str24 = private unnamed_addr constant [35 x i8] c"Allocation for Rx Queue %u failed\0A\00", align 1
@.str25 = private unnamed_addr constant [35 x i8] c"Allocation for Tx Queue %u failed\0A\00", align 1
@.str26 = private unnamed_addr constant [39 x i8] c"Unable to allocate memory for vectors\0A\00", align 1
@.str27 = private unnamed_addr constant [23 x i8] c"include/linux/skbuff.h\00", align 1
@.str28 = private unnamed_addr constant [41 x i8] c"include/asm-generic/dma-mapping-common.h\00", align 1
@dma_ops = external global %struct.dma_map_ops*
@numa_node = external global i32
@.str29 = private unnamed_addr constant [304 x i8] c"Detected Tx Unit Hang\0A  Tx Queue             <%d>\0A  TDH                  <%x>\0A  TDT                  <%x>\0A  next_to_use          <%x>\0A  next_to_clean        <%x>\0Abuffer_info[next_to_clean]\0A  time_stamp           <%lx>\0A  next_to_watch        <%p>\0A  jiffies              <%lx>\0A  desc.status          <%x>\0A\00", align 1
@.str30 = private unnamed_addr constant [26 x i8] c"include/linux/netdevice.h\00", align 1
@.str31 = private unnamed_addr constant [69 x i8] c"\016igb: netif_stop_queue() cannot be called before register_netdev()\0A\00", align 1
@cpu_number = external global i32
@.str32 = private unnamed_addr constant [14 x i8] c"IOV Disabled\0A\00", align 1
@node_data = external global [0 x %struct.pglist_data*]
@.str33 = private unnamed_addr constant [19 x i8] c"TX DMA map failed\0A\00", align 1
@.str34 = private unnamed_addr constant [37 x i8] c"include/linux/dynamic_queue_limits.h\00", align 1
@phys_base = external global i64
@.str35 = private unnamed_addr constant [32 x i8] c"partial checksum but proto=%x!\0A\00", align 1
@.str36 = private unnamed_addr constant [35 x i8] c"partial checksum but l4 proto=%x!\0A\00", align 1
@.str37 = private unnamed_addr constant [37 x i8] c"./arch/x86/include/asm/dma-mapping.h\00", align 1
@x86_dma_fallback_dev = external global %struct.device
@.str38 = private unnamed_addr constant [47 x i8] c"MAS: Unable to configure feature, disabling..\0A\00", align 1
@__preempt_count = external global i32
@system_wq = external global %struct.workqueue_struct*
@igb_setup_mrqc.rsskey = internal constant [10 x i32] [i32 -631874963, i32 -1039246555, i32 1025861441, i32 -1332763837, i32 -886322480, i32 -1271891026, i32 -1557279881, i32 217198720, i32 1001865834, i32 -100553538], align 16
@igb_driver = internal global %struct.pci_driver { %struct.list_head zeroinitializer, i8* getelementptr inbounds ([4 x i8]* @igb_driver_name, i32 0, i32 0), %struct.pci_device_id* getelementptr inbounds ([36 x %struct.pci_device_id]* @igb_pci_tbl, i32 0, i32 0), i32 (%struct.pci_dev*, %struct.pci_device_id*)* @igb_probe, void (%struct.pci_dev*)* @igb_remove, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*, i32)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, void (%struct.pci_dev*)* @igb_shutdown, i32 (%struct.pci_dev*, i32)* @igb_pci_sriov_configure, %struct.pci_error_handlers* @igb_err_handler, %struct.device_driver { i8* null, %struct.bus_type* null, %struct.module* null, i8* null, i8 0, %struct.of_device_id* null, %struct.acpi_device_id* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*, i32)* null, i32 (%struct.device*)* null, %struct.attribute_group** null, %struct.dev_pm_ops* @igb_pm_ops, %struct.driver_private* null }, %struct.pci_dynids zeroinitializer }, align 8
@igb_err_handler = internal constant %struct.pci_error_handlers { i32 (%struct.pci_dev*, i32)* @igb_io_error_detected, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* null, i32 (%struct.pci_dev*)* @igb_io_slot_reset, void (%struct.pci_dev*, i1)* null, void (%struct.pci_dev*)* @igb_io_resume }, align 8
@igb_pm_ops = internal constant %struct.dev_pm_ops { i32 (%struct.device*)* null, void (%struct.device*)* null, i32 (%struct.device*)* @igb_suspend, i32 (%struct.device*)* @igb_resume, i32 (%struct.device*)* @igb_suspend, i32 (%struct.device*)* @igb_resume, i32 (%struct.device*)* @igb_suspend, i32 (%struct.device*)* @igb_resume, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* null, i32 (%struct.device*)* @igb_runtime_suspend, i32 (%struct.device*)* @igb_runtime_resume, i32 (%struct.device*)* @igb_runtime_idle }, align 8
@.str39 = private unnamed_addr constant [44 x i8] c"igb: Cannot enable PCI device from suspend\0A\00", align 1
@.str40 = private unnamed_addr constant [27 x i8] c"igb_up failed after reset\0A\00", align 1
@.str41 = private unnamed_addr constant [42 x i8] c"Cannot re-enable PCI device after reset.\0A\00", align 1
@.str42 = private unnamed_addr constant [53 x i8] c"pci_cleanup_aer_uncorrect_error_status failed 0x%0x\0A\00", align 1
@cpu_online_mask = external constant %struct.cpumask*
@.str43 = private unnamed_addr constant [61 x i8] c"%d pre-allocated VFs found - override max_vfs setting of %d\0A\00", align 1
@.str44 = private unnamed_addr constant [47 x i8] c"Unable to allocate memory for VF Data Storage\0A\00", align 1
@.str45 = private unnamed_addr constant [18 x i8] c"%d VFs allocated\0A\00", align 1
@.str46 = private unnamed_addr constant [98 x i8] c"Cannot deallocate SR-IOV virtual functions while they are assigned - VFs will not be deallocated\0A\00", align 1
@system_state = external global i32
@.str47 = private unnamed_addr constant [14 x i8] c"DCA disabled\0A\00", align 1
@igb_probe.global_quad_port_a = internal global i32 0, align 4
@igb_info_tbl = internal global [1 x %struct.e1000_info*] [%struct.e1000_info* @e1000_82575_info], align 8
@.str48 = private unnamed_addr constant [36 x i8] c"\013%s (%hx:%hx) should not be a VF!\0A\00", align 1
@.str49 = private unnamed_addr constant [39 x i8] c"No usable DMA configuration, aborting\0A\00", align 1
@igb_netdev_ops = internal constant %struct.net_device_ops { i32 (%struct.net_device*)* null, void (%struct.net_device*)* null, i32 (%struct.net_device*)* @igb_open, i32 (%struct.net_device*)* @igb_close, i32 (%struct.sk_buff*, %struct.net_device*)* @igb_xmit_frame, i16 (%struct.net_device*, %struct.sk_buff*, i8*, i16 (%struct.net_device*, %struct.sk_buff*)*)* null, void (%struct.net_device*, i32)* null, void (%struct.net_device*)* @igb_set_rx_mode, i32 (%struct.net_device*, i8*)* @igb_set_mac, i32 (%struct.net_device*)* @eth_validate_addr, i32 (%struct.net_device*, %struct.ifreq*, i32)* @igb_ioctl, i32 (%struct.net_device*, %struct.ifmap*)* null, i32 (%struct.net_device*, i32)* @igb_change_mtu, i32 (%struct.net_device*, %struct.neigh_parms*)* null, void (%struct.net_device*)* @igb_tx_timeout, %struct.rtnl_link_stats64* (%struct.net_device*, %struct.rtnl_link_stats64*)* @igb_get_stats64, %struct.net_device_stats* (%struct.net_device*)* null, i32 (%struct.net_device*, i16, i16)* @igb_vlan_rx_add_vid, i32 (%struct.net_device*, i16, i16)* @igb_vlan_rx_kill_vid, void (%struct.net_device*)* @igb_netpoll, i32 (%struct.net_device*, %struct.netpoll_info*)* null, void (%struct.net_device*)* null, i32 (%struct.napi_struct*)* null, i32 (%struct.net_device*, i32, i8*)* @igb_ndo_set_vf_mac, i32 (%struct.net_device*, i32, i16, i8)* @igb_ndo_set_vf_vlan, i32 (%struct.net_device*, i32, i32, i32)* @igb_ndo_set_vf_bw, i32 (%struct.net_device*, i32, i1)* @igb_ndo_set_vf_spoofchk, i32 (%struct.net_device*, i32, %struct.ifla_vf_info*)* @igb_ndo_get_vf_config, i32 (%struct.net_device*, i32, i32)* null, i32 (%struct.net_device*, i32, %struct.nlattr**)* null, i32 (%struct.net_device*, i32, %struct.sk_buff*)* null, i32 (%struct.net_device*, i8)* null, i32 (%struct.net_device*)* null, i32 (%struct.net_device*)* null, i32 (%struct.net_device*, i16, %struct.scatterlist*, i32)* null, i32 (%struct.net_device*, i16)* null, i32 (%struct.net_device*, i16, %struct.scatterlist*, i32)* null, i32 (%struct.net_device*, %struct.netdev_fcoe_hbainfo*)* null, i32 (%struct.net_device*, i64*, i32)* null, i32 (%struct.net_device*, %struct.sk_buff*, i16, i32)* null, i32 (%struct.net_device*, %struct.net_device*)* null, i32 (%struct.net_device*, %struct.net_device*)* null, i64 (%struct.net_device*, i64)* @igb_fix_features, i32 (%struct.net_device*, i64)* @igb_set_features, i32 (%struct.neighbour*)* null, void (%struct.neighbour*)* null, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*, i16)* null, i32 (%struct.ndmsg*, %struct.nlattr**, %struct.net_device*, i8*)* null, i32 (%struct.sk_buff*, %struct.netlink_callback*, %struct.net_device*, %struct.net_device*, i32)* null, i32 (%struct.net_device*, %struct.nlmsghdr*)* null, i32 (%struct.sk_buff*, i32, i32, %struct.net_device*, i32)* null, i32 (%struct.net_device*, %struct.nlmsghdr*)* null, i32 (%struct.net_device*, i1)* null, i32 (%struct.net_device*, %struct.netdev_phys_port_id*)* null, void (%struct.net_device*, i16, i16)* null, void (%struct.net_device*, i16, i16)* null, i8* (%struct.net_device*, %struct.net_device*)* null, void (%struct.net_device*, i8*)* null, i32 (%struct.sk_buff*, %struct.net_device*, i8*)* null, i32 (%struct.net_device*)* null }, align 8
@.str50 = private unnamed_addr constant [47 x i8] c"PHY reset is blocked due to SOL/IDER session.\0A\00", align 1
@.str51 = private unnamed_addr constant [31 x i8] c"The NVM Checksum Is Not Valid\0A\00", align 1
@.str52 = private unnamed_addr constant [16 x i8] c"NVM Read Error\0A\00", align 1
@.str53 = private unnamed_addr constant [21 x i8] c"Invalid MAC Address\0A\00", align 1
@.str54 = private unnamed_addr constant [30 x i8] c"failed to init i2c interface\0A\00", align 1
@.str55 = private unnamed_addr constant [6 x i8] c"eth%d\00", align 1
@.str56 = private unnamed_addr constant [13 x i8] c"DCA enabled\0A\00", align 1
@.str57 = private unnamed_addr constant [36 x i8] c"failed to allocate sysfs resources\0A\00", align 1
@.str58 = private unnamed_addr constant [46 x i8] c"Intel(R) Gigabit Ethernet Network Connection\0A\00", align 1
@.str59 = private unnamed_addr constant [22 x i8] c"%s: (PCIe:%s:%s) %pM\0A\00", align 1
@.str60 = private unnamed_addr constant [8 x i8] c"2.5Gb/s\00", align 1
@.str61 = private unnamed_addr constant [8 x i8] c"5.0Gb/s\00", align 1
@.str62 = private unnamed_addr constant [8 x i8] c"unknown\00", align 1
@.str63 = private unnamed_addr constant [9 x i8] c"Width x4\00", align 1
@.str64 = private unnamed_addr constant [9 x i8] c"Width x2\00", align 1
@.str65 = private unnamed_addr constant [9 x i8] c"Width x1\00", align 1
@.str66 = private unnamed_addr constant [8 x i8] c"Unknown\00", align 1
@.str67 = private unnamed_addr constant [16 x i8] c"%s: PBA No: %s\0A\00", align 1
@.str68 = private unnamed_addr constant [53 x i8] c"Using %s interrupts. %d rx queue(s), %d tx queue(s)\0A\00", align 1
@.str69 = private unnamed_addr constant [6 x i8] c"MSI-X\00", align 1
@.str70 = private unnamed_addr constant [4 x i8] c"MSI\00", align 1
@.str71 = private unnamed_addr constant [7 x i8] c"legacy\00", align 1
@.str72 = private unnamed_addr constant [43 x i8] c"MAS: Enabling Media Autosense for port %d\0A\00", align 1
@.str73 = private unnamed_addr constant [44 x i8] c"MAS: Invalid port configuration, returning\0A\00", align 1
@__this_module = external global %struct.module
@igb_i2c_algo = internal constant %struct.i2c_algo_bit_data { i8* null, void (i8*, i32)* @igb_set_i2c_data, void (i8*, i32)* @igb_set_i2c_clk, i32 (i8*)* @igb_get_i2c_data, i32 (i8*)* @igb_get_i2c_clk, i32 (%struct.i2c_adapter*)* null, void (%struct.i2c_adapter*)* null, i32 5, i32 20 }, align 8
@.str74 = private unnamed_addr constant [7 x i8] c"igb BB\00", align 1
@.str75 = private unnamed_addr constant [60 x i8] c"igb: %s NIC Link is Up %d Mbps %s Duplex, Flow Control: %s\0A\00", align 1
@.str76 = private unnamed_addr constant [5 x i8] c"Full\00", align 1
@.str77 = private unnamed_addr constant [5 x i8] c"Half\00", align 1
@.str78 = private unnamed_addr constant [6 x i8] c"RX/TX\00", align 1
@.str79 = private unnamed_addr constant [3 x i8] c"RX\00", align 1
@.str80 = private unnamed_addr constant [3 x i8] c"TX\00", align 1
@.str81 = private unnamed_addr constant [5 x i8] c"None\00", align 1
@.str82 = private unnamed_addr constant [88 x i8] c"EEE Disabled: unsupported at half duplex. Re-enable using ethtool when at full duplex.\0A\00", align 1
@.str83 = private unnamed_addr constant [41 x i8] c"Link Speed was downgraded by SmartSpeed\0A\00", align 1
@.str84 = private unnamed_addr constant [70 x i8] c"The network adapter link speed was downshifted because it overheated\0A\00", align 1
@.str85 = private unnamed_addr constant [55 x i8] c"The network adapter was stopped because it overheated\0A\00", align 1
@.str86 = private unnamed_addr constant [26 x i8] c"igb: %s NIC Link is Down\0A\00", align 1
@.str87 = private unnamed_addr constant [56 x i8] c"malformed Tx packet detected and dropped, LVMMC:0x%08x\0A\00", align 1
@.str88 = private unnamed_addr constant [34 x i8] c"Spoof event(s) detected on VF %d\0A\00", align 1
@.str89 = private unnamed_addr constant [37 x i8] c"MAS: changing media to fiber/serdes\0A\00", align 1
@.str90 = private unnamed_addr constant [31 x i8] c"MAS: changing media to copper\0A\00", align 1
@.str91 = private unnamed_addr constant [42 x i8] c"AMS: Invalid media type found, returning\0A\00", align 1
@.str92 = private unnamed_addr constant [59 x i8] c"Link speed has been changed. VF Transmit rate is disabled\0A\00", align 1
@.str93 = private unnamed_addr constant [15 x i8] c"Reset adapter\0A\00", align 1
@.str94 = private unnamed_addr constant [17 x i8] c"Net device Info\0A\00", align 1
@.str95 = private unnamed_addr constant [66 x i8] c"\016igb: Device Name     state            trans_start      last_rx\0A\00", align 1
@.str96 = private unnamed_addr constant [35 x i8] c"\016igb: %-15s %016lX %016lX %016lX\0A\00", align 1
@.str97 = private unnamed_addr constant [15 x i8] c"Register Dump\0A\00", align 1
@.str98 = private unnamed_addr constant [31 x i8] c"\016igb:  Register Name   Value\0A\00", align 1
@igb_reg_info_tbl = internal constant [23 x %struct.igb_reg_info] [%struct.igb_reg_info { i32 0, i8* getelementptr inbounds ([5 x i8]* @.str127, i32 0, i32 0) }, %struct.igb_reg_info { i32 8, i8* getelementptr inbounds ([7 x i8]* @.str128, i32 0, i32 0) }, %struct.igb_reg_info { i32 24, i8* getelementptr inbounds ([9 x i8]* @.str129, i32 0, i32 0) }, %struct.igb_reg_info { i32 192, i8* getelementptr inbounds ([4 x i8]* @.str130, i32 0, i32 0) }, %struct.igb_reg_info { i32 256, i8* getelementptr inbounds ([5 x i8]* @.str131, i32 0, i32 0) }, %struct.igb_reg_info { i32 10248, i8* getelementptr inbounds ([6 x i8]* @.str132, i32 0, i32 0) }, %struct.igb_reg_info { i32 10256, i8* getelementptr inbounds ([4 x i8]* @.str133, i32 0, i32 0) }, %struct.igb_reg_info { i32 10264, i8* getelementptr inbounds ([4 x i8]* @.str134, i32 0, i32 0) }, %struct.igb_reg_info { i32 10280, i8* getelementptr inbounds ([7 x i8]* @.str135, i32 0, i32 0) }, %struct.igb_reg_info { i32 10240, i8* getelementptr inbounds ([6 x i8]* @.str136, i32 0, i32 0) }, %struct.igb_reg_info { i32 10244, i8* getelementptr inbounds ([6 x i8]* @.str137, i32 0, i32 0) }, %struct.igb_reg_info { i32 1024, i8* getelementptr inbounds ([5 x i8]* @.str138, i32 0, i32 0) }, %struct.igb_reg_info { i32 14336, i8* getelementptr inbounds ([6 x i8]* @.str139, i32 0, i32 0) }, %struct.igb_reg_info { i32 14340, i8* getelementptr inbounds ([6 x i8]* @.str140, i32 0, i32 0) }, %struct.igb_reg_info { i32 14344, i8* getelementptr inbounds ([6 x i8]* @.str141, i32 0, i32 0) }, %struct.igb_reg_info { i32 14352, i8* getelementptr inbounds ([4 x i8]* @.str142, i32 0, i32 0) }, %struct.igb_reg_info { i32 14360, i8* getelementptr inbounds ([4 x i8]* @.str143, i32 0, i32 0) }, %struct.igb_reg_info { i32 14376, i8* getelementptr inbounds ([7 x i8]* @.str144, i32 0, i32 0) }, %struct.igb_reg_info { i32 13328, i8* getelementptr inbounds ([5 x i8]* @.str145, i32 0, i32 0) }, %struct.igb_reg_info { i32 13336, i8* getelementptr inbounds ([5 x i8]* @.str146, i32 0, i32 0) }, %struct.igb_reg_info { i32 13344, i8* getelementptr inbounds ([6 x i8]* @.str147, i32 0, i32 0) }, %struct.igb_reg_info { i32 13360, i8* getelementptr inbounds ([6 x i8]* @.str148, i32 0, i32 0) }, %struct.igb_reg_info zeroinitializer], align 16
@.str99 = private unnamed_addr constant [18 x i8] c"TX Rings Summary\0A\00", align 1
@.str100 = private unnamed_addr constant [62 x i8] c"\016igb: Queue [NTU] [NTC] [bi(ntc)->dma  ] leng ntw timestamp\0A\00", align 1
@.str101 = private unnamed_addr constant [45 x i8] c"\016igb:  %5d %5X %5X %016llX %04X %p %016llX\0A\00", align 1
@.str102 = private unnamed_addr constant [15 x i8] c"TX Rings Dump\0A\00", align 1
@.str103 = private unnamed_addr constant [45 x i8] c"\016igb: ------------------------------------\0A\00", align 1
@.str104 = private unnamed_addr constant [28 x i8] c"\016igb: TX QUEUE INDEX = %d\0A\00", align 1
@.str105 = private unnamed_addr constant [107 x i8] c"\016igb: T [desc]     [address 63:0  ] [PlPOCIStDDM Ln] [bi->dma       ] leng  ntw timestamp        bi->skb\0A\00", align 1
@.str106 = private unnamed_addr constant [7 x i8] c" NTC/U\00", align 1
@.str107 = private unnamed_addr constant [5 x i8] c" NTU\00", align 1
@.str108 = private unnamed_addr constant [5 x i8] c" NTC\00", align 1
@.str109 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str110 = private unnamed_addr constant [68 x i8] c"\016igb: T [0x%03X]    %016llX %016llX %016llX %04X  %p %016llX %p%s\0A\00", align 1
@.str111 = private unnamed_addr constant [3 x i8] c"\016\00", align 1
@.str112 = private unnamed_addr constant [18 x i8] c"RX Rings Summary\0A\00", align 1
@.str113 = private unnamed_addr constant [26 x i8] c"\016igb: Queue [NTU] [NTC]\0A\00", align 1
@.str114 = private unnamed_addr constant [21 x i8] c"\016igb:  %5d %5X %5X\0A\00", align 1
@.str115 = private unnamed_addr constant [15 x i8] c"RX Rings Dump\0A\00", align 1
@.str116 = private unnamed_addr constant [28 x i8] c"\016igb: RX QUEUE INDEX = %d\0A\00", align 1
@.str117 = private unnamed_addr constant [107 x i8] c"\016igb: R  [desc]      [ PktBuf     A0] [  HeadBuf   DD] [bi->dma       ] [bi->skb] <-- Adv Rx Read format\0A\00", align 1
@.str118 = private unnamed_addr constant [113 x i8] c"\016igb: RWB[desc]      [PcsmIpSHl PtRs] [vl er S cks ln] ---------------- [bi->skb] <-- Adv Rx Write-Back format\0A\00", align 1
@.str119 = private unnamed_addr constant [59 x i8] c"\016igb: %s[0x%03X]     %016llX %016llX ---------------- %s\0A\00", align 1
@.str120 = private unnamed_addr constant [4 x i8] c"RWB\00", align 1
@.str121 = private unnamed_addr constant [50 x i8] c"\016igb: %s[0x%03X]     %016llX %016llX %016llX %s\0A\00", align 1
@.str122 = private unnamed_addr constant [4 x i8] c"R  \00", align 1
@.str123 = private unnamed_addr constant [19 x i8] c"\016igb: %-15s %08x\0A\00", align 1
@.str124 = private unnamed_addr constant [5 x i8] c"%s%s\00", align 1
@.str125 = private unnamed_addr constant [6 x i8] c"[0-3]\00", align 1
@.str126 = private unnamed_addr constant [34 x i8] c"\016igb: %-15s %08x %08x %08x %08x\0A\00", align 1
@.str127 = private unnamed_addr constant [5 x i8] c"CTRL\00", align 1
@.str128 = private unnamed_addr constant [7 x i8] c"STATUS\00", align 1
@.str129 = private unnamed_addr constant [9 x i8] c"CTRL_EXT\00", align 1
@.str130 = private unnamed_addr constant [4 x i8] c"ICR\00", align 1
@.str131 = private unnamed_addr constant [5 x i8] c"RCTL\00", align 1
@.str132 = private unnamed_addr constant [6 x i8] c"RDLEN\00", align 1
@.str133 = private unnamed_addr constant [4 x i8] c"RDH\00", align 1
@.str134 = private unnamed_addr constant [4 x i8] c"RDT\00", align 1
@.str135 = private unnamed_addr constant [7 x i8] c"RXDCTL\00", align 1
@.str136 = private unnamed_addr constant [6 x i8] c"RDBAL\00", align 1
@.str137 = private unnamed_addr constant [6 x i8] c"RDBAH\00", align 1
@.str138 = private unnamed_addr constant [5 x i8] c"TCTL\00", align 1
@.str139 = private unnamed_addr constant [6 x i8] c"TDBAL\00", align 1
@.str140 = private unnamed_addr constant [6 x i8] c"TDBAH\00", align 1
@.str141 = private unnamed_addr constant [6 x i8] c"TDLEN\00", align 1
@.str142 = private unnamed_addr constant [4 x i8] c"TDH\00", align 1
@.str143 = private unnamed_addr constant [4 x i8] c"TDT\00", align 1
@.str144 = private unnamed_addr constant [7 x i8] c"TXDCTL\00", align 1
@.str145 = private unnamed_addr constant [5 x i8] c"TDFH\00", align 1
@.str146 = private unnamed_addr constant [5 x i8] c"TDFT\00", align 1
@.str147 = private unnamed_addr constant [6 x i8] c"TDFHS\00", align 1
@.str148 = private unnamed_addr constant [6 x i8] c"TDFPC\00", align 1
@.str149 = private unnamed_addr constant [36 x i8] c"Maximum of 7 VFs per PF, using max\0A\00", align 1
@.str150 = private unnamed_addr constant [100 x i8] c"Enabling SR-IOV VFs using the module parameter is deprecated - please use the pci sysfs interface.\0A\00", align 1
@.str151 = private unnamed_addr constant [26 x i8] c"setting MAC %pM on VF %d\0A\00", align 1
@.str152 = private unnamed_addr constant [52 x i8] c"Reload the VF driver to make this change effective.\00", align 1
@.str153 = private unnamed_addr constant [63 x i8] c"The VF MAC address has been set, but the PF device is not up.\0A\00", align 1
@.str154 = private unnamed_addr constant [21 x i8] c"Invalid MTU setting\0A\00", align 1
@.str155 = private unnamed_addr constant [27 x i8] c"MTU > 9216 not supported.\0A\00", align 1
@.str156 = private unnamed_addr constant [28 x i8] c"changing MTU from %d to %d\0A\00", align 1
@e1000_82575_info = external constant %struct.e1000_info
@dca_notifier = internal global { i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32, [4 x i8] } { i32 (%struct.notifier_block*, i64, i8*)* @igb_notify_dca, %struct.notifier_block* null, i32 0, [4 x i8] undef }, align 8
@.str157 = private unnamed_addr constant [24 x i8] c"\016igb: %s - version %s\0A\00", align 1
@igb_driver_string = internal constant [41 x i8] c"Intel(R) Gigabit Ethernet Network Driver\00", align 16
@.str158 = private unnamed_addr constant [11 x i8] c"\016igb: %s\0A\00", align 1
@igb_copyright = internal constant [43 x i8] c"Copyright (c) 2007-2014 Intel Corporation.\00", align 16
@.str159 = private unnamed_addr constant [4 x i8] c"igb\00", align 1
@igb_pci_tbl = internal constant [36 x %struct.pci_device_id] [%struct.pci_device_id { i32 32902, i32 8000, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 8001, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 8005, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5433, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5427, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5430, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5431, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5432, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5499, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5500, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5409, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5410, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5411, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5412, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5390, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5391, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5415, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5392, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5393, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5398, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 1080, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 1082, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 1084, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 1088, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4297, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5386, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5400, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4326, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4327, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5389, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 5414, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4328, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4263, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4265, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id { i32 32902, i32 4310, i32 -1, i32 -1, i32 0, i32 0, i64 0 }, %struct.pci_device_id zeroinitializer], align 16
@llvm.used = appending global [10 x i8*] [i8* bitcast (%struct.kernel_param* @__param_max_vfs to i8*), i8* getelementptr inbounds ([22 x i8]* @__UNIQUE_ID_max_vfstype216, i32 0, i32 0), i8* getelementptr inbounds ([83 x i8]* @__UNIQUE_ID_max_vfs217, i32 0, i32 0), i8* getelementptr inbounds ([62 x i8]* @__UNIQUE_ID_author246, i32 0, i32 0), i8* getelementptr inbounds ([53 x i8]* @__UNIQUE_ID_description247, i32 0, i32 0), i8* getelementptr inbounds ([12 x i8]* @__UNIQUE_ID_license248, i32 0, i32 0), i8* getelementptr inbounds ([17 x i8]* @__UNIQUE_ID_version249, i32 0, i32 0), i8* bitcast (%struct.kernel_param* @__param_debug to i8*), i8* getelementptr inbounds ([19 x i8]* @__UNIQUE_ID_debugtype253, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8]* @__UNIQUE_ID_debug254, i32 0, i32 0)], section "llvm.metadata"

@__mod_pci__igb_pci_tbl_device_table = alias getelementptr inbounds ([36 x %struct.pci_device_id]* @igb_pci_tbl, i32 0, i32 0)
@init_module = alias i32 ()* @igb_init_module
@cleanup_module = alias void ()* @igb_exit_module

define internal void @smp_send_stop() nounwind inlinehint noredzone {
entry:
  %0 = load void (i32)** getelementptr inbounds (%struct.smp_ops* @smp_ops, i32 0, i32 3), align 8
  call void %0(i32 0) noredzone
  ret void
}


define internal void @smp_send_reschedule(i32 %cpu) nounwind inlinehint noredzone {
entry:
  %cpu.addr = alloca i32, align 4
  store i32 %cpu, i32* %cpu.addr, align 4
  %0 = load void (i32)** getelementptr inbounds (%struct.smp_ops* @smp_ops, i32 0, i32 4), align 8
  %1 = load i32* %cpu.addr, align 4
  call void %0(i32 %1) noredzone
  ret void
}

define internal void @smp_prepare_cpus(i32 %max_cpus) nounwind inlinehint noredzone {
entry:
  %max_cpus.addr = alloca i32, align 4
  store i32 %max_cpus, i32* %max_cpus.addr, align 4
  %0 = load void (i32)** getelementptr inbounds (%struct.smp_ops* @smp_ops, i32 0, i32 1), align 8
  %1 = load i32* %max_cpus.addr, align 4
  call void %0(i32 %1) noredzone
  ret void
}

define internal i32 @__cpu_up(i32 %cpu, %struct.task_struct* %tidle) nounwind inlinehint noredzone {
entry:
  %cpu.addr = alloca i32, align 4
  %tidle.addr = alloca %struct.task_struct*, align 8
  store i32 %cpu, i32* %cpu.addr, align 4
  store %struct.task_struct* %tidle, %struct.task_struct** %tidle.addr, align 8
  %0 = load i32 (i32, %struct.task_struct*)** getelementptr inbounds (%struct.smp_ops* @smp_ops, i32 0, i32 5), align 8
  %1 = load i32* %cpu.addr, align 4
  %2 = load %struct.task_struct** %tidle.addr, align 8
  %call = call i32 %0(i32 %1, %struct.task_struct* %2) noredzone
  ret i32 %call
}

define internal void @smp_cpus_done(i32 %max_cpus) nounwind inlinehint noredzone {
entry:
  %max_cpus.addr = alloca i32, align 4
  store i32 %max_cpus, i32* %max_cpus.addr, align 4
  %0 = load void (i32)** getelementptr inbounds (%struct.smp_ops* @smp_ops, i32 0, i32 2), align 8
  %1 = load i32* %max_cpus.addr, align 4
  call void %0(i32 %1) noredzone
  ret void
}

define internal void @smp_prepare_boot_cpu() nounwind inlinehint noredzone {
entry:
  %0 = load void ()** getelementptr inbounds (%struct.smp_ops* @smp_ops, i32 0, i32 0), align 8
  call void %0() noredzone
  ret void
}

define %struct.net_device* @igb_get_hw_dev(%struct.e1000_hw* %hw) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %back = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 0
  %1 = load i8** %back, align 8
  %2 = bitcast i8* %1 to %struct.igb_adapter*
  store %struct.igb_adapter* %2, %struct.igb_adapter** %adapter, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 1
  %4 = load %struct.net_device** %netdev, align 8
  ret %struct.net_device* %4
}

define internal i32 @igb_init_module() nounwind noredzone section ".init.text" {
entry:
  %ret = alloca i32, align 4
  %call = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([24 x i8]* @.str157, i32 0, i32 0), i8* getelementptr inbounds ([41 x i8]* @igb_driver_string, i32 0, i32 0), i8* getelementptr inbounds ([9 x i8]* @igb_driver_version, i32 0, i32 0)) noredzone
  %call1 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([11 x i8]* @.str158, i32 0, i32 0), i8* getelementptr inbounds ([43 x i8]* @igb_copyright, i32 0, i32 0)) noredzone
  call void @dca_register_notify(%struct.notifier_block* bitcast ({ i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32, [4 x i8] }* @dca_notifier to %struct.notifier_block*)) noredzone
  %call2 = call i32 @__pci_register_driver(%struct.pci_driver* @igb_driver, %struct.module* @__this_module, i8* getelementptr inbounds ([4 x i8]* @.str159, i32 0, i32 0)) noredzone
  store i32 %call2, i32* %ret, align 4
  %0 = load i32* %ret, align 4
  ret i32 %0
}

define internal void @igb_exit_module() nounwind noredzone section ".exit.text" {
entry:
  call void @dca_unregister_notify(%struct.notifier_block* bitcast ({ i32 (%struct.notifier_block*, i64, i8*)*, %struct.notifier_block*, i32, [4 x i8] }* @dca_notifier to %struct.notifier_block*)) noredzone
  call void @pci_unregister_driver(%struct.pci_driver* @igb_driver) noredzone
  ret void
}

define i32 @igb_rd32(%struct.e1000_hw* %hw, i32 %reg) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %reg.addr = alloca i32, align 4
  %igb = alloca %struct.igb_adapter*, align 8
  %__mptr = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  %value = alloca i32, align 4
  %netdev = alloca %struct.net_device*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  store %struct.e1000_hw* %0, %struct.e1000_hw** %__mptr, align 8
  %1 = load %struct.e1000_hw** %__mptr, align 8
  %2 = bitcast %struct.e1000_hw* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -1456
  %3 = bitcast i8* %add.ptr to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %igb, align 8
  %4 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr1 = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 1
  %5 = load volatile i8** %hw_addr1, align 8
  store i8* %5, i8** %hw_addr, align 8
  store i32 0, i32* %value, align 4
  %6 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %6, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load i32* %value, align 4
  %neg = xor i32 %7, -1
  store i32 %neg, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load i32* %reg.addr, align 4
  %idxprom = zext i32 %8 to i64
  %9 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %9, i64 %idxprom
  %call = call i32 @readl(i8* %arrayidx) noredzone
  store i32 %call, i32* %value, align 4
  %10 = load i32* %value, align 4
  %neg5 = xor i32 %10, -1
  %tobool6 = icmp ne i32 %neg5, 0
  br i1 %tobool6, label %if.end15, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %11 = load i32* %reg.addr, align 4
  %tobool7 = icmp ne i32 %11, 0
  br i1 %tobool7, label %lor.lhs.false, label %if.then11

lor.lhs.false:                                    ; preds = %land.lhs.true
  %12 = load i8** %hw_addr, align 8
  %call8 = call i32 @readl(i8* %12) noredzone
  %neg9 = xor i32 %call8, -1
  %tobool10 = icmp ne i32 %neg9, 0
  br i1 %tobool10, label %if.end15, label %if.then11

if.then11:                                        ; preds = %lor.lhs.false, %land.lhs.true
  %13 = load %struct.igb_adapter** %igb, align 8
  %netdev12 = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 1
  %14 = load %struct.net_device** %netdev12, align 8
  store %struct.net_device* %14, %struct.net_device** %netdev, align 8
  %15 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr13 = getelementptr inbounds %struct.e1000_hw* %15, i32 0, i32 1
  store i8* null, i8** %hw_addr13, align 8
  %16 = load %struct.net_device** %netdev, align 8
  call void @netif_device_detach(%struct.net_device* %16) noredzone
  %17 = load %struct.net_device** %netdev, align 8
  %call14 = call i32 (%struct.net_device*, i8*, ...)* @netdev_err(%struct.net_device* %17, i8* getelementptr inbounds ([37 x i8]* @.str, i32 0, i32 0)) noredzone
  br label %if.end15

if.end15:                                         ; preds = %if.then11, %lor.lhs.false, %if.end
  %18 = load i32* %value, align 4
  store i32 %18, i32* %retval
  br label %return

return:                                           ; preds = %if.end15, %if.then
  %19 = load i32* %retval
  ret i32 %19
}

declare i64 @llvm.expect.i64(i64, i64) nounwind readnone

define internal i32 @readl(i8* %addr) nounwind inlinehint noredzone {
entry:
  %addr.addr = alloca i8*, align 8
  %ret = alloca i32, align 4
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8** %addr.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = call i32 asm sideeffect "movl $1,$0", "=r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %1) nounwind, !srcloc !0
  store i32 %2, i32* %ret, align 4
  %3 = load i32* %ret, align 4
  ret i32 %3
}

declare void @netif_device_detach(%struct.net_device*) noredzone

declare i32 @netdev_err(%struct.net_device*, i8*, ...) noredzone

define void @igb_power_up_link(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  %call = call i32 @igb_reset_phy(%struct.e1000_hw* %hw) noredzone
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 35
  %phy = getelementptr inbounds %struct.e1000_hw* %hw1, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %2 = load i32* %media_type, align 4
  %cmp = icmp eq i32 %2, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 35
  call void @igb_power_up_phy_copper(%struct.e1000_hw* %hw2) noredzone
  br label %if.end

if.else:                                          ; preds = %entry
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw3 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  call void @igb_power_up_serdes_link_82575(%struct.e1000_hw* %hw3) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw4 = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 35
  %call5 = call i32 @igb_setup_link(%struct.e1000_hw* %hw4) noredzone
  ret void
}

define internal i32 @igb_reset_phy(%struct.e1000_hw* %hw) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 6
  %ops = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 0
  %reset = getelementptr inbounds %struct.e1000_phy_operations* %ops, i32 0, i32 9
  %1 = load i32 (%struct.e1000_hw*)** %reset, align 8
  %tobool = icmp ne i32 (%struct.e1000_hw*)* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.e1000_hw** %hw.addr, align 8
  %phy1 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 6
  %ops2 = getelementptr inbounds %struct.e1000_phy_info* %phy1, i32 0, i32 0
  %reset3 = getelementptr inbounds %struct.e1000_phy_operations* %ops2, i32 0, i32 9
  %3 = load i32 (%struct.e1000_hw*)** %reset3, align 8
  %4 = load %struct.e1000_hw** %hw.addr, align 8
  %call = call i32 %3(%struct.e1000_hw* %4) noredzone
  store i32 %call, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32* %retval
  ret i32 %5
}

declare void @igb_power_up_phy_copper(%struct.e1000_hw*) noredzone

declare void @igb_power_up_serdes_link_82575(%struct.e1000_hw*) noredzone

declare i32 @igb_setup_link(%struct.e1000_hw*) noredzone

define i32 @igb_up(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i = alloca i32, align 4
  %reg_data = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_configure(%struct.igb_adapter* %1) noredzone
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %3 = load i64** %addr.addr.i, align 8
  %4 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %3, i64 %4, i64* %3) nounwind, !srcloc !1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32* %i, align 4
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 4
  %7 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load i32* %i, align 4
  %idxprom = sext i32 %8 to i64
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom
  %10 = load %struct.igb_q_vector** %arrayidx, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %10, i32 0, i32 8
  call void @napi_enable(%struct.napi_struct* %napi) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %11 = load i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %12 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 3
  %13 = load i32* %flags, align 4
  %and = and i32 %13, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.end
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_configure_msix(%struct.igb_adapter* %14) noredzone
  br label %if.end

if.else:                                          ; preds = %for.end
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector2 = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 44
  %arrayidx3 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector2, i32 0, i64 0
  %16 = load %struct.igb_q_vector** %arrayidx3, align 8
  call void @igb_assign_vector(%struct.igb_q_vector* %16, i32 0) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %17 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %17, i32 192) noredzone
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_irq_enable(%struct.igb_adapter* %18) noredzone
  %19 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %19, i32 0, i32 49
  %20 = load i32* %vfs_allocated_count, align 4
  %tobool4 = icmp ne i32 %20, 0
  br i1 %tobool4, label %if.then5, label %if.end15

if.then5:                                         ; preds = %if.end
  %21 = load %struct.e1000_hw** %hw, align 8
  %call6 = call i32 @igb_rd32(%struct.e1000_hw* %21, i32 24) noredzone
  store i32 %call6, i32* %reg_data, align 4
  %22 = load i32* %reg_data, align 4
  %or = or i32 %22, 16384
  store i32 %or, i32* %reg_data, align 4
  br label %do.body

do.body:                                          ; preds = %if.then5
  %23 = load %struct.e1000_hw** %hw, align 8
  %hw_addr7 = getelementptr inbounds %struct.e1000_hw* %23, i32 0, i32 1
  %24 = load volatile i8** %hw_addr7, align 8
  store i8* %24, i8** %hw_addr, align 8
  %25 = load i8** %hw_addr, align 8
  %tobool8 = icmp ne i8* %25, null
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot10 = xor i1 %lnot9, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %do.body
  %26 = load i32* %reg_data, align 4
  %27 = load i8** %hw_addr, align 8
  %arrayidx13 = getelementptr i8* %27, i64 24
  call void @writel(i32 %26, i8* %arrayidx13) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end14
  br label %if.end15

if.end15:                                         ; preds = %do.end, %if.end
  %28 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %28, i32 0, i32 1
  %29 = load %struct.net_device** %netdev, align 8
  call void @netif_tx_start_all_queues(%struct.net_device* %29) noredzone
  %30 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %30, i32 0, i32 4
  %get_link_status = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 20
  store i8 1, i8* %get_link_status, align 1
  %31 = load %struct.igb_adapter** %adapter.addr, align 8
  %watchdog_task = getelementptr inbounds %struct.igb_adapter* %31, i32 0, i32 27
  %call16 = call zeroext i1 @schedule_work(%struct.work_struct* %watchdog_task) noredzone
  %32 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags17 = getelementptr inbounds %struct.igb_adapter* %32, i32 0, i32 3
  %33 = load i32* %flags17, align 4
  %and18 = and i32 %33, 16384
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %land.lhs.true, label %if.end22

land.lhs.true:                                    ; preds = %if.end15
  %34 = load %struct.e1000_hw** %hw, align 8
  %dev_spec = getelementptr inbounds %struct.e1000_hw* %34, i32 0, i32 11
  %_82575 = bitcast %union.anon.86* %dev_spec to %struct.e1000_dev_spec_82575*
  %eee_disable = getelementptr inbounds %struct.e1000_dev_spec_82575* %_82575, i32 0, i32 2
  %35 = load i8* %eee_disable, align 1
  %tobool20 = trunc i8 %35 to i1
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %land.lhs.true
  %36 = load %struct.igb_adapter** %adapter.addr, align 8
  %eee_advert = getelementptr inbounds %struct.igb_adapter* %36, i32 0, i32 80
  store i16 6, i16* %eee_advert, align 2
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %land.lhs.true, %if.end15
  ret i32 0
}

define internal void @igb_configure(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %i = alloca i32, align 4
  %ring = alloca %struct.igb_ring*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_get_hw_control(%struct.igb_adapter* %2) noredzone
  %3 = load %struct.net_device** %netdev, align 8
  call void @igb_set_rx_mode(%struct.net_device* %3) noredzone
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_restore_vlan(%struct.igb_adapter* %4) noredzone
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_setup_tctl(%struct.igb_adapter* %5) noredzone
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_setup_mrqc(%struct.igb_adapter* %6) noredzone
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_setup_rctl(%struct.igb_adapter* %7) noredzone
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_configure_tx(%struct.igb_adapter* %8) noredzone
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_configure_rx(%struct.igb_adapter* %9) noredzone
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 35
  call void @igb_rx_fifo_flush_82575(%struct.e1000_hw* %hw) noredzone
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %11 = load i32* %i, align 4
  %12 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 14
  %13 = load i32* %num_rx_queues, align 4
  %cmp = icmp slt i32 %11, %13
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %14 = load i32* %i, align 4
  %idxprom = sext i32 %14 to i64
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %16 = load %struct.igb_ring** %arrayidx, align 8
  store %struct.igb_ring* %16, %struct.igb_ring** %ring, align 8
  %17 = load %struct.igb_ring** %ring, align 8
  %18 = load %struct.igb_ring** %ring, align 8
  %call = call i32 @igb_desc_unused(%struct.igb_ring* %18) noredzone
  %conv = trunc i32 %call to i16
  call void @igb_alloc_rx_buffers(%struct.igb_ring* %17, i16 zeroext %conv) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %19 = load i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal void @napi_enable(%struct.napi_struct* %n) nounwind inlinehint noredzone {
entry:
  %nr.addr.i11 = alloca i64, align 8
  %addr.addr.i12 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %n.addr = alloca %struct.napi_struct*, align 8
  store %struct.napi_struct* %n, %struct.napi_struct** %n.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load %struct.napi_struct** %n.addr, align 8
  %state = getelementptr inbounds %struct.napi_struct* %0, i32 0, i32 1
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body4

do.body4:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([26 x i8]* @.str30, i32 0, i32 0), i32 492, i64 12) nounwind, !srcloc !2
  br label %do.body5

do.body5:                                         ; preds = %do.cond, %do.body4
  br label %do.cond

do.cond:                                          ; preds = %do.body5
  br i1 true, label %do.body5, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end7

do.end7:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end7, %do.body
  br label %do.end9

do.end9:                                          ; preds = %if.end
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !3
  %5 = load %struct.napi_struct** %n.addr, align 8
  %state10 = getelementptr inbounds %struct.napi_struct* %5, i32 0, i32 1
  store i64 0, i64* %nr.addr.i11, align 8
  store i64* %state10, i64** %addr.addr.i12, align 8
  %6 = load i64** %addr.addr.i12, align 8
  %7 = load i64* %nr.addr.i11, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %6, i64 %7, i64* %6) nounwind, !srcloc !1
  ret void
}

define internal void @igb_configure_msix(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %tmp = alloca i32, align 4
  %i = alloca i32, align 4
  %vector = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  %hw_addr14 = alloca i8*, align 8
  %hw_addr33 = alloca i8*, align 8
  %hw_addr56 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %vector, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw4 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw4, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 45
  store i32 0, i32* %eims_enable_mask, align 4
  %2 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %3 = load i32* %type, align 4
  switch i32 %3, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb30
    i32 3, label %sw.bb30
    i32 4, label %sw.bb30
    i32 5, label %sw.bb30
    i32 6, label %sw.bb30
    i32 7, label %sw.bb30
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %4, i32 24) noredzone
  store i32 %call, i32* %tmp, align 4
  %5 = load i32* %tmp, align 4
  %or = or i32 %5, -2147483648
  store i32 %or, i32* %tmp, align 4
  %6 = load i32* %tmp, align 4
  %or5 = or i32 %6, 16777216
  store i32 %or5, i32* %tmp, align 4
  %7 = load i32* %tmp, align 4
  %or6 = or i32 %7, 1
  store i32 %or6, i32* %tmp, align 4
  br label %do.body

do.body:                                          ; preds = %sw.bb
  %8 = load %struct.e1000_hw** %hw, align 8
  %hw_addr8 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr8, align 8
  store i8* %9, i8** %hw_addr, align 8
  %10 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %10, null
  %lnot = xor i1 %tobool, true
  %lnot9 = xor i1 %lnot, true
  %lnot10 = xor i1 %lnot9, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool11 = icmp ne i64 %expval, 0
  br i1 %tobool11, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %11 = load i32* %tmp, align 4
  %12 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %12, i64 24
  call void @writel(i32 %11, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body12

do.body12:                                        ; preds = %do.end
  %13 = load %struct.e1000_hw** %hw, align 8
  %hw_addr15 = getelementptr inbounds %struct.e1000_hw* %13, i32 0, i32 1
  %14 = load volatile i8** %hw_addr15, align 8
  store i8* %14, i8** %hw_addr14, align 8
  %15 = load i8** %hw_addr14, align 8
  %tobool16 = icmp ne i8* %15, null
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.end28, label %if.then26

if.then26:                                        ; preds = %do.body12
  %16 = load i32* %vector, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %vector, align 4
  %shl = shl i32 %16, 2
  %add = add i32 5632, %shl
  %idxprom = sext i32 %add to i64
  %17 = load i8** %hw_addr14, align 8
  %arrayidx27 = getelementptr i8* %17, i64 %idxprom
  call void @writel(i32 -2147483648, i8* %arrayidx27) noredzone
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %do.body12
  br label %do.end29

do.end29:                                         ; preds = %if.end28
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_other = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 46
  store i32 -2147483648, i32* %eims_other, align 4
  br label %sw.epilog

sw.bb30:                                          ; preds = %entry, %entry, %entry, %entry, %entry, %entry
  br label %do.body31

do.body31:                                        ; preds = %sw.bb30
  %19 = load %struct.e1000_hw** %hw, align 8
  %hw_addr34 = getelementptr inbounds %struct.e1000_hw* %19, i32 0, i32 1
  %20 = load volatile i8** %hw_addr34, align 8
  store i8* %20, i8** %hw_addr33, align 8
  %21 = load i8** %hw_addr33, align 8
  %tobool35 = icmp ne i8* %21, null
  %lnot36 = xor i1 %tobool35, true
  %lnot38 = xor i1 %lnot36, true
  %lnot40 = xor i1 %lnot38, true
  %lnot.ext41 = zext i1 %lnot40 to i32
  %conv42 = sext i32 %lnot.ext41 to i64
  %expval43 = call i64 @llvm.expect.i64(i64 %conv42, i64 0)
  %tobool44 = icmp ne i64 %expval43, 0
  br i1 %tobool44, label %if.end47, label %if.then45

if.then45:                                        ; preds = %do.body31
  %22 = load i8** %hw_addr33, align 8
  %arrayidx46 = getelementptr i8* %22, i64 5396
  call void @writel(i32 -1073741807, i8* %arrayidx46) noredzone
  br label %if.end47

if.end47:                                         ; preds = %if.then45, %do.body31
  br label %do.end48

do.end48:                                         ; preds = %if.end47
  %23 = load i32* %vector, align 4
  %shl49 = shl i32 1, %23
  %24 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_other50 = getelementptr inbounds %struct.igb_adapter* %24, i32 0, i32 46
  store i32 %shl49, i32* %eims_other50, align 4
  %25 = load i32* %vector, align 4
  %inc51 = add i32 %25, 1
  store i32 %inc51, i32* %vector, align 4
  %or52 = or i32 %25, 128
  %shl53 = shl i32 %or52, 8
  store i32 %shl53, i32* %tmp, align 4
  br label %do.body54

do.body54:                                        ; preds = %do.end48
  %26 = load %struct.e1000_hw** %hw, align 8
  %hw_addr57 = getelementptr inbounds %struct.e1000_hw* %26, i32 0, i32 1
  %27 = load volatile i8** %hw_addr57, align 8
  store i8* %27, i8** %hw_addr56, align 8
  %28 = load i8** %hw_addr56, align 8
  %tobool58 = icmp ne i8* %28, null
  %lnot59 = xor i1 %tobool58, true
  %lnot61 = xor i1 %lnot59, true
  %lnot63 = xor i1 %lnot61, true
  %lnot.ext64 = zext i1 %lnot63 to i32
  %conv65 = sext i32 %lnot.ext64 to i64
  %expval66 = call i64 @llvm.expect.i64(i64 %conv65, i64 0)
  %tobool67 = icmp ne i64 %expval66, 0
  br i1 %tobool67, label %if.end70, label %if.then68

if.then68:                                        ; preds = %do.body54
  %29 = load i32* %tmp, align 4
  %30 = load i8** %hw_addr56, align 8
  %arrayidx69 = getelementptr i8* %30, i64 5952
  call void @writel(i32 %29, i8* %arrayidx69) noredzone
  br label %if.end70

if.end70:                                         ; preds = %if.then68, %do.body54
  br label %do.end71

do.end71:                                         ; preds = %if.end70
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %do.end71, %do.end29
  %31 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_other72 = getelementptr inbounds %struct.igb_adapter* %31, i32 0, i32 46
  %32 = load i32* %eims_other72, align 4
  %33 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask73 = getelementptr inbounds %struct.igb_adapter* %33, i32 0, i32 45
  %34 = load i32* %eims_enable_mask73, align 4
  %or74 = or i32 %34, %32
  store i32 %or74, i32* %eims_enable_mask73, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.epilog
  %35 = load i32* %i, align 4
  %36 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %36, i32 0, i32 4
  %37 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %35, %37
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %38 = load i32* %i, align 4
  %idxprom76 = sext i32 %38 to i64
  %39 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 44
  %arrayidx77 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom76
  %40 = load %struct.igb_q_vector** %arrayidx77, align 8
  %41 = load i32* %vector, align 4
  %inc78 = add i32 %41, 1
  store i32 %inc78, i32* %vector, align 4
  call void @igb_assign_vector(%struct.igb_q_vector* %40, i32 %41) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %42 = load i32* %i, align 4
  %inc79 = add i32 %42, 1
  store i32 %inc79, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %43 = load %struct.e1000_hw** %hw, align 8
  %call80 = call i32 @igb_rd32(%struct.e1000_hw* %43, i32 8) noredzone
  ret void
}

define internal void @igb_assign_vector(%struct.igb_q_vector* %q_vector, i32 %msix_vector) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %msix_vector.addr = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %rx_queue = alloca i32, align 4
  %tx_queue = alloca i32, align 4
  %msixbm = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  store i32 %msix_vector, i32* %msix_vector.addr, align 4
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 0
  %1 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  store i32 -1, i32* %rx_queue, align 4
  store i32 -1, i32* %tx_queue, align 4
  store i32 0, i32* %msixbm, align 4
  %3 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %3, i32 0, i32 6
  %ring = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %4 = load %struct.igb_ring** %ring, align 8
  %tobool = icmp ne %struct.igb_ring* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx3 = getelementptr inbounds %struct.igb_q_vector* %5, i32 0, i32 6
  %ring4 = getelementptr inbounds %struct.igb_ring_container* %rx3, i32 0, i32 0
  %6 = load %struct.igb_ring** %ring4, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 11
  %7 = load i8* %reg_idx, align 1
  %conv = zext i8 %7 to i32
  store i32 %conv, i32* %rx_queue, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %8, i32 0, i32 7
  %ring5 = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 0
  %9 = load %struct.igb_ring** %ring5, align 8
  %tobool6 = icmp ne %struct.igb_ring* %9, null
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.end
  %10 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx8 = getelementptr inbounds %struct.igb_q_vector* %10, i32 0, i32 7
  %ring9 = getelementptr inbounds %struct.igb_ring_container* %tx8, i32 0, i32 0
  %11 = load %struct.igb_ring** %ring9, align 8
  %reg_idx10 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 11
  %12 = load i8* %reg_idx10, align 1
  %conv11 = zext i8 %12 to i32
  store i32 %conv11, i32* %tx_queue, align 4
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.end
  %13 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %13, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %14 = load i32* %type, align 4
  switch i32 %14, label %sw.default [
    i32 1, label %sw.bb
    i32 2, label %sw.bb36
    i32 3, label %sw.bb54
    i32 4, label %sw.bb54
    i32 5, label %sw.bb54
    i32 6, label %sw.bb54
    i32 7, label %sw.bb54
  ]

sw.bb:                                            ; preds = %if.end12
  %15 = load i32* %rx_queue, align 4
  %cmp = icmp sgt i32 %15, -1
  br i1 %cmp, label %if.then14, label %if.end15

if.then14:                                        ; preds = %sw.bb
  %16 = load i32* %rx_queue, align 4
  %shl = shl i32 1, %16
  store i32 %shl, i32* %msixbm, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %sw.bb
  %17 = load i32* %tx_queue, align 4
  %cmp16 = icmp sgt i32 %17, -1
  br i1 %cmp16, label %if.then18, label %if.end20

if.then18:                                        ; preds = %if.end15
  %18 = load i32* %tx_queue, align 4
  %shl19 = shl i32 256, %18
  %19 = load i32* %msixbm, align 4
  %or = or i32 %19, %shl19
  store i32 %or, i32* %msixbm, align 4
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end15
  %20 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 3
  %21 = load i32* %flags, align 4
  %and = and i32 %21, 8192
  %tobool21 = icmp ne i32 %and, 0
  br i1 %tobool21, label %if.end26, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end20
  %22 = load i32* %msix_vector.addr, align 4
  %cmp22 = icmp eq i32 %22, 0
  br i1 %cmp22, label %if.then24, label %if.end26

if.then24:                                        ; preds = %land.lhs.true
  %23 = load i32* %msixbm, align 4
  %or25 = or i32 %23, -2147483648
  store i32 %or25, i32* %msixbm, align 4
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %land.lhs.true, %if.end20
  br label %do.body

do.body:                                          ; preds = %if.end26
  %24 = load %struct.e1000_hw** %hw, align 8
  %hw_addr27 = getelementptr inbounds %struct.e1000_hw* %24, i32 0, i32 1
  %25 = load volatile i8** %hw_addr27, align 8
  store i8* %25, i8** %hw_addr, align 8
  %26 = load i8** %hw_addr, align 8
  %tobool28 = icmp ne i8* %26, null
  %lnot = xor i1 %tobool28, true
  %lnot29 = xor i1 %lnot, true
  %lnot30 = xor i1 %lnot29, true
  %lnot.ext = zext i1 %lnot30 to i32
  %conv31 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool32 = icmp ne i64 %expval, 0
  br i1 %tobool32, label %if.end35, label %if.then33

if.then33:                                        ; preds = %do.body
  %27 = load i32* %msixbm, align 4
  %28 = load i32* %msix_vector.addr, align 4
  %shl34 = shl i32 %28, 2
  %add = add i32 5632, %shl34
  %idxprom = sext i32 %add to i64
  %29 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %29, i64 %idxprom
  call void @writel(i32 %27, i8* %arrayidx) noredzone
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end35
  %30 = load i32* %msixbm, align 4
  %31 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %eims_value = getelementptr inbounds %struct.igb_q_vector* %31, i32 0, i32 2
  store i32 %30, i32* %eims_value, align 4
  br label %sw.epilog

sw.bb36:                                          ; preds = %if.end12
  %32 = load i32* %rx_queue, align 4
  %cmp37 = icmp sgt i32 %32, -1
  br i1 %cmp37, label %if.then39, label %if.end43

if.then39:                                        ; preds = %sw.bb36
  %33 = load %struct.e1000_hw** %hw, align 8
  %34 = load i32* %msix_vector.addr, align 4
  %35 = load i32* %rx_queue, align 4
  %and40 = and i32 %35, 7
  %36 = load i32* %rx_queue, align 4
  %and41 = and i32 %36, 8
  %shl42 = shl i32 %and41, 1
  call void @igb_write_ivar(%struct.e1000_hw* %33, i32 %34, i32 %and40, i32 %shl42) noredzone
  br label %if.end43

if.end43:                                         ; preds = %if.then39, %sw.bb36
  %37 = load i32* %tx_queue, align 4
  %cmp44 = icmp sgt i32 %37, -1
  br i1 %cmp44, label %if.then46, label %if.end51

if.then46:                                        ; preds = %if.end43
  %38 = load %struct.e1000_hw** %hw, align 8
  %39 = load i32* %msix_vector.addr, align 4
  %40 = load i32* %tx_queue, align 4
  %and47 = and i32 %40, 7
  %41 = load i32* %tx_queue, align 4
  %and48 = and i32 %41, 8
  %shl49 = shl i32 %and48, 1
  %add50 = add i32 %shl49, 8
  call void @igb_write_ivar(%struct.e1000_hw* %38, i32 %39, i32 %and47, i32 %add50) noredzone
  br label %if.end51

if.end51:                                         ; preds = %if.then46, %if.end43
  %42 = load i32* %msix_vector.addr, align 4
  %shl52 = shl i32 1, %42
  %43 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %eims_value53 = getelementptr inbounds %struct.igb_q_vector* %43, i32 0, i32 2
  store i32 %shl52, i32* %eims_value53, align 4
  br label %sw.epilog

sw.bb54:                                          ; preds = %if.end12, %if.end12, %if.end12, %if.end12, %if.end12
  %44 = load i32* %rx_queue, align 4
  %cmp55 = icmp sgt i32 %44, -1
  br i1 %cmp55, label %if.then57, label %if.end60

if.then57:                                        ; preds = %sw.bb54
  %45 = load %struct.e1000_hw** %hw, align 8
  %46 = load i32* %msix_vector.addr, align 4
  %47 = load i32* %rx_queue, align 4
  %shr = ashr i32 %47, 1
  %48 = load i32* %rx_queue, align 4
  %and58 = and i32 %48, 1
  %shl59 = shl i32 %and58, 4
  call void @igb_write_ivar(%struct.e1000_hw* %45, i32 %46, i32 %shr, i32 %shl59) noredzone
  br label %if.end60

if.end60:                                         ; preds = %if.then57, %sw.bb54
  %49 = load i32* %tx_queue, align 4
  %cmp61 = icmp sgt i32 %49, -1
  br i1 %cmp61, label %if.then63, label %if.end68

if.then63:                                        ; preds = %if.end60
  %50 = load %struct.e1000_hw** %hw, align 8
  %51 = load i32* %msix_vector.addr, align 4
  %52 = load i32* %tx_queue, align 4
  %shr64 = ashr i32 %52, 1
  %53 = load i32* %tx_queue, align 4
  %and65 = and i32 %53, 1
  %shl66 = shl i32 %and65, 4
  %add67 = add i32 %shl66, 8
  call void @igb_write_ivar(%struct.e1000_hw* %50, i32 %51, i32 %shr64, i32 %add67) noredzone
  br label %if.end68

if.end68:                                         ; preds = %if.then63, %if.end60
  %54 = load i32* %msix_vector.addr, align 4
  %shl69 = shl i32 1, %54
  %55 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %eims_value70 = getelementptr inbounds %struct.igb_q_vector* %55, i32 0, i32 2
  store i32 %shl69, i32* %eims_value70, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end12
  br label %do.body71

do.body71:                                        ; preds = %sw.default
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([56 x i8]* @.str1, i32 0, i32 0), i32 862, i64 12) nounwind, !srcloc !4
  br label %do.body72

do.body72:                                        ; preds = %do.cond, %do.body71
  br label %do.cond

do.cond:                                          ; preds = %do.body72
  br i1 true, label %do.body72, label %do.end73

do.end73:                                         ; preds = %do.cond
  br label %do.end75

do.end75:                                         ; preds = %do.end73
  br label %sw.epilog

sw.epilog:                                        ; preds = %do.end75, %if.end68, %if.end51, %do.end
  %56 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %eims_value76 = getelementptr inbounds %struct.igb_q_vector* %56, i32 0, i32 2
  %57 = load i32* %eims_value76, align 4
  %58 = load %struct.igb_adapter** %adapter, align 8
  %eims_enable_mask = getelementptr inbounds %struct.igb_adapter* %58, i32 0, i32 45
  %59 = load i32* %eims_enable_mask, align 4
  %or77 = or i32 %59, %57
  store i32 %or77, i32* %eims_enable_mask, align 4
  %60 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %set_itr = getelementptr inbounds %struct.igb_q_vector* %60, i32 0, i32 4
  store i8 1, i8* %set_itr, align 1
  ret void
}

define internal void @igb_irq_enable(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ims = alloca i32, align 4
  %regval = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr10 = alloca i8*, align 8
  %hw_addr29 = alloca i8*, align 8
  %hw_addr49 = alloca i8*, align 8
  %hw_addr68 = alloca i8*, align 8
  %hw_addr85 = alloca i8*, align 8
  %hw_addr102 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 3
  %2 = load i32* %flags, align 4
  %and = and i32 %2, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 1342177284, i32* %ims, align 4
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 5420) noredzone
  store i32 %call, i32* %regval, align 4
  br label %do.body

do.body:                                          ; preds = %if.then
  %4 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 1
  %5 = load volatile i8** %hw_addr2, align 8
  store i8* %5, i8** %hw_addr, align 8
  %6 = load i8** %hw_addr, align 8
  %tobool3 = icmp ne i8* %6, null
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %do.body
  %7 = load i32* %regval, align 4
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 45
  %9 = load i32* %eims_enable_mask, align 4
  %or = or i32 %7, %9
  %10 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %10, i64 5420
  call void @writel(i32 %or, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then7, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %11 = load %struct.e1000_hw** %hw, align 8
  %call8 = call i32 @igb_rd32(%struct.e1000_hw* %11, i32 5424) noredzone
  store i32 %call8, i32* %regval, align 4
  br label %do.body9

do.body9:                                         ; preds = %do.end
  %12 = load %struct.e1000_hw** %hw, align 8
  %hw_addr11 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 1
  %13 = load volatile i8** %hw_addr11, align 8
  store i8* %13, i8** %hw_addr10, align 8
  %14 = load i8** %hw_addr10, align 8
  %tobool12 = icmp ne i8* %14, null
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.end26, label %if.then22

if.then22:                                        ; preds = %do.body9
  %15 = load i32* %regval, align 4
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask23 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 45
  %17 = load i32* %eims_enable_mask23, align 4
  %or24 = or i32 %15, %17
  %18 = load i8** %hw_addr10, align 8
  %arrayidx25 = getelementptr i8* %18, i64 5424
  call void @writel(i32 %or24, i8* %arrayidx25) noredzone
  br label %if.end26

if.end26:                                         ; preds = %if.then22, %do.body9
  br label %do.end27

do.end27:                                         ; preds = %if.end26
  br label %do.body28

do.body28:                                        ; preds = %do.end27
  %19 = load %struct.e1000_hw** %hw, align 8
  %hw_addr30 = getelementptr inbounds %struct.e1000_hw* %19, i32 0, i32 1
  %20 = load volatile i8** %hw_addr30, align 8
  store i8* %20, i8** %hw_addr29, align 8
  %21 = load i8** %hw_addr29, align 8
  %tobool31 = icmp ne i8* %21, null
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot36 = xor i1 %lnot34, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  %conv38 = sext i32 %lnot.ext37 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %if.end44, label %if.then41

if.then41:                                        ; preds = %do.body28
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask42 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 45
  %23 = load i32* %eims_enable_mask42, align 4
  %24 = load i8** %hw_addr29, align 8
  %arrayidx43 = getelementptr i8* %24, i64 5412
  call void @writel(i32 %23, i8* %arrayidx43) noredzone
  br label %if.end44

if.end44:                                         ; preds = %if.then41, %do.body28
  br label %do.end45

do.end45:                                         ; preds = %if.end44
  %25 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 49
  %26 = load i32* %vfs_allocated_count, align 4
  %tobool46 = icmp ne i32 %26, 0
  br i1 %tobool46, label %if.then47, label %if.end66

if.then47:                                        ; preds = %do.end45
  br label %do.body48

do.body48:                                        ; preds = %if.then47
  %27 = load %struct.e1000_hw** %hw, align 8
  %hw_addr50 = getelementptr inbounds %struct.e1000_hw* %27, i32 0, i32 1
  %28 = load volatile i8** %hw_addr50, align 8
  store i8* %28, i8** %hw_addr49, align 8
  %29 = load i8** %hw_addr49, align 8
  %tobool51 = icmp ne i8* %29, null
  %lnot52 = xor i1 %tobool51, true
  %lnot54 = xor i1 %lnot52, true
  %lnot56 = xor i1 %lnot54, true
  %lnot.ext57 = zext i1 %lnot56 to i32
  %conv58 = sext i32 %lnot.ext57 to i64
  %expval59 = call i64 @llvm.expect.i64(i64 %conv58, i64 0)
  %tobool60 = icmp ne i64 %expval59, 0
  br i1 %tobool60, label %if.end63, label %if.then61

if.then61:                                        ; preds = %do.body48
  %30 = load i8** %hw_addr49, align 8
  %arrayidx62 = getelementptr i8* %30, i64 3204
  call void @writel(i32 255, i8* %arrayidx62) noredzone
  br label %if.end63

if.end63:                                         ; preds = %if.then61, %do.body48
  br label %do.end64

do.end64:                                         ; preds = %if.end63
  %31 = load i32* %ims, align 4
  %or65 = or i32 %31, 256
  store i32 %or65, i32* %ims, align 4
  br label %if.end66

if.end66:                                         ; preds = %do.end64, %do.end45
  br label %do.body67

do.body67:                                        ; preds = %if.end66
  %32 = load %struct.e1000_hw** %hw, align 8
  %hw_addr69 = getelementptr inbounds %struct.e1000_hw* %32, i32 0, i32 1
  %33 = load volatile i8** %hw_addr69, align 8
  store i8* %33, i8** %hw_addr68, align 8
  %34 = load i8** %hw_addr68, align 8
  %tobool70 = icmp ne i8* %34, null
  %lnot71 = xor i1 %tobool70, true
  %lnot73 = xor i1 %lnot71, true
  %lnot75 = xor i1 %lnot73, true
  %lnot.ext76 = zext i1 %lnot75 to i32
  %conv77 = sext i32 %lnot.ext76 to i64
  %expval78 = call i64 @llvm.expect.i64(i64 %conv77, i64 0)
  %tobool79 = icmp ne i64 %expval78, 0
  br i1 %tobool79, label %if.end82, label %if.then80

if.then80:                                        ; preds = %do.body67
  %35 = load i32* %ims, align 4
  %36 = load i8** %hw_addr68, align 8
  %arrayidx81 = getelementptr i8* %36, i64 208
  call void @writel(i32 %35, i8* %arrayidx81) noredzone
  br label %if.end82

if.end82:                                         ; preds = %if.then80, %do.body67
  br label %do.end83

do.end83:                                         ; preds = %if.end82
  br label %if.end118

if.else:                                          ; preds = %entry
  br label %do.body84

do.body84:                                        ; preds = %if.else
  %37 = load %struct.e1000_hw** %hw, align 8
  %hw_addr86 = getelementptr inbounds %struct.e1000_hw* %37, i32 0, i32 1
  %38 = load volatile i8** %hw_addr86, align 8
  store i8* %38, i8** %hw_addr85, align 8
  %39 = load i8** %hw_addr85, align 8
  %tobool87 = icmp ne i8* %39, null
  %lnot88 = xor i1 %tobool87, true
  %lnot90 = xor i1 %lnot88, true
  %lnot92 = xor i1 %lnot90, true
  %lnot.ext93 = zext i1 %lnot92 to i32
  %conv94 = sext i32 %lnot.ext93 to i64
  %expval95 = call i64 @llvm.expect.i64(i64 %conv94, i64 0)
  %tobool96 = icmp ne i64 %expval95, 0
  br i1 %tobool96, label %if.end99, label %if.then97

if.then97:                                        ; preds = %do.body84
  %40 = load i8** %hw_addr85, align 8
  %arrayidx98 = getelementptr i8* %40, i64 208
  call void @writel(i32 1342177437, i8* %arrayidx98) noredzone
  br label %if.end99

if.end99:                                         ; preds = %if.then97, %do.body84
  br label %do.end100

do.end100:                                        ; preds = %if.end99
  br label %do.body101

do.body101:                                       ; preds = %do.end100
  %41 = load %struct.e1000_hw** %hw, align 8
  %hw_addr103 = getelementptr inbounds %struct.e1000_hw* %41, i32 0, i32 1
  %42 = load volatile i8** %hw_addr103, align 8
  store i8* %42, i8** %hw_addr102, align 8
  %43 = load i8** %hw_addr102, align 8
  %tobool104 = icmp ne i8* %43, null
  %lnot105 = xor i1 %tobool104, true
  %lnot107 = xor i1 %lnot105, true
  %lnot109 = xor i1 %lnot107, true
  %lnot.ext110 = zext i1 %lnot109 to i32
  %conv111 = sext i32 %lnot.ext110 to i64
  %expval112 = call i64 @llvm.expect.i64(i64 %conv111, i64 0)
  %tobool113 = icmp ne i64 %expval112, 0
  br i1 %tobool113, label %if.end116, label %if.then114

if.then114:                                       ; preds = %do.body101
  %44 = load i8** %hw_addr102, align 8
  %arrayidx115 = getelementptr i8* %44, i64 224
  call void @writel(i32 1342177437, i8* %arrayidx115) noredzone
  br label %if.end116

if.end116:                                        ; preds = %if.then114, %do.body101
  br label %do.end117

do.end117:                                        ; preds = %if.end116
  br label %if.end118

if.end118:                                        ; preds = %do.end117, %do.end83
  ret void
}

define internal void @writel(i32 %val, i8* %addr) nounwind inlinehint noredzone {
entry:
  %val.addr = alloca i32, align 4
  %addr.addr = alloca i8*, align 8
  store i32 %val, i32* %val.addr, align 4
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i32* %val.addr, align 4
  %1 = load i8** %addr.addr, align 8
  %2 = bitcast i8* %1 to i32*
  call void asm sideeffect "movl $0,$1", "r,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32 %0, i32* %2) nounwind, !srcloc !5
  ret void
}

define internal void @netif_tx_start_all_queues(%struct.net_device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %i = alloca i32, align 4
  %txq = alloca %struct.netdev_queue*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.net_device** %dev.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.net_device* %1, i32 0, i32 80
  %2 = load i32* %num_tx_queues, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.net_device** %dev.addr, align 8
  %4 = load i32* %i, align 4
  %call = call %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %3, i32 %4) noredzone
  store %struct.netdev_queue* %call, %struct.netdev_queue** %txq, align 8
  %5 = load %struct.netdev_queue** %txq, align 8
  call void @netif_tx_start_queue(%struct.netdev_queue* %5) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal zeroext i1 @schedule_work(%struct.work_struct* %work) nounwind inlinehint noredzone {
entry:
  %work.addr = alloca %struct.work_struct*, align 8
  store %struct.work_struct* %work, %struct.work_struct** %work.addr, align 8
  %0 = load %struct.workqueue_struct** @system_wq, align 8
  %1 = load %struct.work_struct** %work.addr, align 8
  %call = call zeroext i1 @queue_work(%struct.workqueue_struct* %0, %struct.work_struct* %1) noredzone
  ret i1 %call
}

define void @igb_down(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %tctl = alloca i32, align 4
  %rctl = alloca i32, align 4
  %i = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr10 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %4 = load i64** %addr.addr.i, align 8
  %5 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %4, i64 %5, i64* %4) nounwind, !srcloc !6
  %6 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %6, i32 256) noredzone
  store i32 %call, i32* %rctl, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %7 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %7, i32 0, i32 1
  %8 = load volatile i8** %hw_addr3, align 8
  store i8* %8, i8** %hw_addr, align 8
  %9 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %9, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %10 = load i32* %rctl, align 4
  %and = and i32 %10, -3
  %11 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %11, i64 256
  call void @writel(i32 %and, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %12 = load %struct.net_device** %netdev, align 8
  call void @netif_tx_stop_all_queues(%struct.net_device* %12) noredzone
  %13 = load %struct.e1000_hw** %hw, align 8
  %call7 = call i32 @igb_rd32(%struct.e1000_hw* %13, i32 1024) noredzone
  store i32 %call7, i32* %tctl, align 4
  %14 = load i32* %tctl, align 4
  %and8 = and i32 %14, -3
  store i32 %and8, i32* %tctl, align 4
  br label %do.body9

do.body9:                                         ; preds = %do.end
  %15 = load %struct.e1000_hw** %hw, align 8
  %hw_addr11 = getelementptr inbounds %struct.e1000_hw* %15, i32 0, i32 1
  %16 = load volatile i8** %hw_addr11, align 8
  store i8* %16, i8** %hw_addr10, align 8
  %17 = load i8** %hw_addr10, align 8
  %tobool12 = icmp ne i8* %17, null
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.end24, label %if.then22

if.then22:                                        ; preds = %do.body9
  %18 = load i32* %tctl, align 4
  %19 = load i8** %hw_addr10, align 8
  %arrayidx23 = getelementptr i8* %19, i64 1024
  call void @writel(i32 %18, i8* %arrayidx23) noredzone
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %do.body9
  br label %do.end25

do.end25:                                         ; preds = %if.end24
  %20 = load %struct.e1000_hw** %hw, align 8
  %call26 = call i32 @igb_rd32(%struct.e1000_hw* %20, i32 8) noredzone
  call void @usleep_range(i64 10000, i64 11000) noredzone
  %21 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_irq_disable(%struct.igb_adapter* %21) noredzone
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 3
  %23 = load i32* %flags, align 4
  %and27 = and i32 %23, -513
  store i32 %and27, i32* %flags, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end25
  %24 = load i32* %i, align 4
  %25 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 4
  %26 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %24, %26
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %27 = load i32* %i, align 4
  %idxprom = sext i32 %27 to i64
  %28 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %28, i32 0, i32 44
  %arrayidx29 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom
  %29 = load %struct.igb_q_vector** %arrayidx29, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %29, i32 0, i32 8
  call void @napi_synchronize(%struct.napi_struct* %napi) noredzone
  %30 = load i32* %i, align 4
  %idxprom30 = sext i32 %30 to i64
  %31 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector31 = getelementptr inbounds %struct.igb_adapter* %31, i32 0, i32 44
  %arrayidx32 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector31, i32 0, i64 %idxprom30
  %32 = load %struct.igb_q_vector** %arrayidx32, align 8
  %napi33 = getelementptr inbounds %struct.igb_q_vector* %32, i32 0, i32 8
  call void @napi_disable(%struct.napi_struct* %napi33) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %33 = load i32* %i, align 4
  %inc = add i32 %33, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %34 = load %struct.igb_adapter** %adapter.addr, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 18
  %call34 = call i32 @del_timer_sync(%struct.timer_list* %watchdog_timer) noredzone
  %35 = load %struct.igb_adapter** %adapter.addr, align 8
  %phy_info_timer = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 19
  %call35 = call i32 @del_timer_sync(%struct.timer_list* %phy_info_timer) noredzone
  %36 = load %struct.net_device** %netdev, align 8
  call void @netif_carrier_off(%struct.net_device* %36) noredzone
  %37 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats64_lock = getelementptr inbounds %struct.igb_adapter* %37, i32 0, i32 33
  call void @spin_lock(%struct.spinlock* %stats64_lock) noredzone
  %38 = load %struct.igb_adapter** %adapter.addr, align 8
  %39 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats64 = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 34
  call void @igb_update_stats(%struct.igb_adapter* %38, %struct.rtnl_link_stats64* %stats64) noredzone
  %40 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats64_lock36 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 33
  call void @spin_unlock(%struct.spinlock* %stats64_lock36) noredzone
  %41 = load %struct.igb_adapter** %adapter.addr, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 24
  store i16 0, i16* %link_speed, align 2
  %42 = load %struct.igb_adapter** %adapter.addr, align 8
  %link_duplex = getelementptr inbounds %struct.igb_adapter* %42, i32 0, i32 25
  store i16 0, i16* %link_duplex, align 2
  %43 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %43, i32 0, i32 32
  %44 = load %struct.pci_dev** %pdev, align 8
  %call37 = call i32 @pci_channel_offline(%struct.pci_dev* %44) noredzone
  %tobool38 = icmp ne i32 %call37, 0
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %for.end
  %45 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_reset(%struct.igb_adapter* %45) noredzone
  br label %if.end40

if.end40:                                         ; preds = %if.then39, %for.end
  %46 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_clean_all_tx_rings(%struct.igb_adapter* %46) noredzone
  %47 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_clean_all_rx_rings(%struct.igb_adapter* %47) noredzone
  %48 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_setup_dca(%struct.igb_adapter* %48) noredzone
  ret void
}

define internal void @netif_tx_stop_all_queues(%struct.net_device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %i = alloca i32, align 4
  %txq = alloca %struct.netdev_queue*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.net_device** %dev.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.net_device* %1, i32 0, i32 80
  %2 = load i32* %num_tx_queues, align 4
  %cmp = icmp ult i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.net_device** %dev.addr, align 8
  %4 = load i32* %i, align 4
  %call = call %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %3, i32 %4) noredzone
  store %struct.netdev_queue* %call, %struct.netdev_queue** %txq, align 8
  %5 = load %struct.netdev_queue** %txq, align 8
  call void @netif_tx_stop_queue(%struct.netdev_queue* %5) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @usleep_range(i64, i64) noredzone

define internal void @igb_irq_disable(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %regval = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr10 = alloca i8*, align 8
  %hw_addr29 = alloca i8*, align 8
  %hw_addr50 = alloca i8*, align 8
  %hw_addr67 = alloca i8*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 3
  %2 = load i32* %flags, align 4
  %and = and i32 %2, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end48

if.then:                                          ; preds = %entry
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 5424) noredzone
  store i32 %call, i32* %regval, align 4
  br label %do.body

do.body:                                          ; preds = %if.then
  %4 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 1
  %5 = load volatile i8** %hw_addr2, align 8
  store i8* %5, i8** %hw_addr, align 8
  %6 = load i8** %hw_addr, align 8
  %tobool3 = icmp ne i8* %6, null
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %do.body
  %7 = load i32* %regval, align 4
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 45
  %9 = load i32* %eims_enable_mask, align 4
  %neg = xor i32 %9, -1
  %and8 = and i32 %7, %neg
  %10 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %10, i64 5424
  call void @writel(i32 %and8, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then7, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body9

do.body9:                                         ; preds = %do.end
  %11 = load %struct.e1000_hw** %hw, align 8
  %hw_addr11 = getelementptr inbounds %struct.e1000_hw* %11, i32 0, i32 1
  %12 = load volatile i8** %hw_addr11, align 8
  store i8* %12, i8** %hw_addr10, align 8
  %13 = load i8** %hw_addr10, align 8
  %tobool12 = icmp ne i8* %13, null
  %lnot13 = xor i1 %tobool12, true
  %lnot15 = xor i1 %lnot13, true
  %lnot17 = xor i1 %lnot15, true
  %lnot.ext18 = zext i1 %lnot17 to i32
  %conv19 = sext i32 %lnot.ext18 to i64
  %expval20 = call i64 @llvm.expect.i64(i64 %conv19, i64 0)
  %tobool21 = icmp ne i64 %expval20, 0
  br i1 %tobool21, label %if.end25, label %if.then22

if.then22:                                        ; preds = %do.body9
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask23 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 45
  %15 = load i32* %eims_enable_mask23, align 4
  %16 = load i8** %hw_addr10, align 8
  %arrayidx24 = getelementptr i8* %16, i64 5416
  call void @writel(i32 %15, i8* %arrayidx24) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %do.body9
  br label %do.end26

do.end26:                                         ; preds = %if.end25
  %17 = load %struct.e1000_hw** %hw, align 8
  %call27 = call i32 @igb_rd32(%struct.e1000_hw* %17, i32 5420) noredzone
  store i32 %call27, i32* %regval, align 4
  br label %do.body28

do.body28:                                        ; preds = %do.end26
  %18 = load %struct.e1000_hw** %hw, align 8
  %hw_addr30 = getelementptr inbounds %struct.e1000_hw* %18, i32 0, i32 1
  %19 = load volatile i8** %hw_addr30, align 8
  store i8* %19, i8** %hw_addr29, align 8
  %20 = load i8** %hw_addr29, align 8
  %tobool31 = icmp ne i8* %20, null
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot36 = xor i1 %lnot34, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  %conv38 = sext i32 %lnot.ext37 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %if.end46, label %if.then41

if.then41:                                        ; preds = %do.body28
  %21 = load i32* %regval, align 4
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %eims_enable_mask42 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 45
  %23 = load i32* %eims_enable_mask42, align 4
  %neg43 = xor i32 %23, -1
  %and44 = and i32 %21, %neg43
  %24 = load i8** %hw_addr29, align 8
  %arrayidx45 = getelementptr i8* %24, i64 5420
  call void @writel(i32 %and44, i8* %arrayidx45) noredzone
  br label %if.end46

if.end46:                                         ; preds = %if.then41, %do.body28
  br label %do.end47

do.end47:                                         ; preds = %if.end46
  br label %if.end48

if.end48:                                         ; preds = %do.end47, %entry
  br label %do.body49

do.body49:                                        ; preds = %if.end48
  %25 = load %struct.e1000_hw** %hw, align 8
  %hw_addr51 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 1
  %26 = load volatile i8** %hw_addr51, align 8
  store i8* %26, i8** %hw_addr50, align 8
  %27 = load i8** %hw_addr50, align 8
  %tobool52 = icmp ne i8* %27, null
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval60 = call i64 @llvm.expect.i64(i64 %conv59, i64 0)
  %tobool61 = icmp ne i64 %expval60, 0
  br i1 %tobool61, label %if.end64, label %if.then62

if.then62:                                        ; preds = %do.body49
  %28 = load i8** %hw_addr50, align 8
  %arrayidx63 = getelementptr i8* %28, i64 224
  call void @writel(i32 0, i8* %arrayidx63) noredzone
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %do.body49
  br label %do.end65

do.end65:                                         ; preds = %if.end64
  br label %do.body66

do.body66:                                        ; preds = %do.end65
  %29 = load %struct.e1000_hw** %hw, align 8
  %hw_addr68 = getelementptr inbounds %struct.e1000_hw* %29, i32 0, i32 1
  %30 = load volatile i8** %hw_addr68, align 8
  store i8* %30, i8** %hw_addr67, align 8
  %31 = load i8** %hw_addr67, align 8
  %tobool69 = icmp ne i8* %31, null
  %lnot70 = xor i1 %tobool69, true
  %lnot72 = xor i1 %lnot70, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %conv76 = sext i32 %lnot.ext75 to i64
  %expval77 = call i64 @llvm.expect.i64(i64 %conv76, i64 0)
  %tobool78 = icmp ne i64 %expval77, 0
  br i1 %tobool78, label %if.end81, label %if.then79

if.then79:                                        ; preds = %do.body66
  %32 = load i8** %hw_addr67, align 8
  %arrayidx80 = getelementptr i8* %32, i64 216
  call void @writel(i32 -1, i8* %arrayidx80) noredzone
  br label %if.end81

if.end81:                                         ; preds = %if.then79, %do.body66
  br label %do.end82

do.end82:                                         ; preds = %if.end81
  %33 = load %struct.e1000_hw** %hw, align 8
  %call83 = call i32 @igb_rd32(%struct.e1000_hw* %33, i32 8) noredzone
  %34 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags84 = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 3
  %35 = load i32* %flags84, align 4
  %and85 = and i32 %35, 8192
  %tobool86 = icmp ne i32 %and85, 0
  br i1 %tobool86, label %if.then87, label %if.else

if.then87:                                        ; preds = %do.end82
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then87
  %36 = load i32* %i, align 4
  %37 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %37, i32 0, i32 4
  %38 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %36, %38
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %39 = load i32* %i, align 4
  %idxprom = sext i32 %39 to i64
  %40 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 5
  %arrayidx89 = getelementptr [10 x %struct.msix_entry]* %msix_entries, i32 0, i64 %idxprom
  %vector = getelementptr inbounds %struct.msix_entry* %arrayidx89, i32 0, i32 0
  %41 = load i32* %vector, align 4
  call void @synchronize_irq(i32 %41) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %42 = load i32* %i, align 4
  %inc = add i32 %42, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end90

if.else:                                          ; preds = %do.end82
  %43 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %43, i32 0, i32 32
  %44 = load %struct.pci_dev** %pdev, align 8
  %irq = getelementptr inbounds %struct.pci_dev* %44, i32 0, i32 35
  %45 = load i32* %irq, align 4
  call void @synchronize_irq(i32 %45) noredzone
  br label %if.end90

if.end90:                                         ; preds = %if.else, %for.end
  ret void
}

define internal void @napi_synchronize(%struct.napi_struct* %n) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %n.addr = alloca %struct.napi_struct*, align 8
  store %struct.napi_struct* %n, %struct.napi_struct** %n.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load %struct.napi_struct** %n.addr, align 8
  %state = getelementptr inbounds %struct.napi_struct* %0, i32 0, i32 1
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @msleep(i32 1) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

define internal void @napi_disable(%struct.napi_struct* %n) nounwind inlinehint noredzone {
entry:
  %nr.addr.i4 = alloca i64, align 8
  %addr.addr.i5 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %n.addr = alloca %struct.napi_struct*, align 8
  store %struct.napi_struct* %n, %struct.napi_struct** %n.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %call = call i32 @_cond_resched() noredzone
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.napi_struct** %n.addr, align 8
  %state = getelementptr inbounds %struct.napi_struct* %0, i32 0, i32 1
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64** %addr.addr.i, align 8
  %2 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %1, i64 %2, i64* %1) nounwind, !srcloc !6
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %3 = load %struct.napi_struct** %n.addr, align 8
  %state1 = getelementptr inbounds %struct.napi_struct* %3, i32 0, i32 1
  %call2 = call i32 @test_and_set_bit(i64 0, i64* %state1) noredzone
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @msleep(i32 1) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %4 = load %struct.napi_struct** %n.addr, align 8
  %state3 = getelementptr inbounds %struct.napi_struct* %4, i32 0, i32 1
  store i64 1, i64* %nr.addr.i4, align 8
  store i64* %state3, i64** %addr.addr.i5, align 8
  %5 = load i64** %addr.addr.i5, align 8
  %6 = load i64* %nr.addr.i4, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %5, i64 %6, i64* %5) nounwind, !srcloc !1
  ret void
}

declare i32 @del_timer_sync(%struct.timer_list*) noredzone

declare void @netif_carrier_off(%struct.net_device*) noredzone

define internal void @spin_lock(%struct.spinlock* %lock) nounwind inlinehint noredzone {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.3* %1 to %struct.raw_spinlock*
  call void @_raw_spin_lock(%struct.raw_spinlock* %rlock) noredzone
  ret void
}

define void @igb_update_stats(%struct.igb_adapter* %adapter, %struct.rtnl_link_stats64* %net_stats) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %net_stats.addr = alloca %struct.rtnl_link_stats64*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %reg = alloca i32, align 4
  %mpc = alloca i32, align 4
  %phy_tmp = alloca i16, align 2
  %i = alloca i32, align 4
  %bytes = alloca i64, align 8
  %packets = alloca i64, align 8
  %start = alloca i32, align 4
  %_bytes = alloca i64, align 8
  %_packets = alloca i64, align 8
  %ring = alloca %struct.igb_ring*, align 8
  %rqdpc = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %ring47 = alloca %struct.igb_ring*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store %struct.rtnl_link_stats64* %net_stats, %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev2 = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 32
  %2 = load %struct.pci_dev** %pdev2, align 8
  store %struct.pci_dev* %2, %struct.pci_dev** %pdev, align 8
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 24
  %4 = load i16* %link_speed, align 2
  %conv = zext i16 %4 to i32
  %cmp = icmp eq i32 %conv, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end411

if.end:                                           ; preds = %entry
  %5 = load %struct.pci_dev** %pdev, align 8
  %call = call i32 @pci_channel_offline(%struct.pci_dev* %5) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then4, label %if.end5

if.then4:                                         ; preds = %if.end
  br label %if.end411

if.end5:                                          ; preds = %if.end
  store i64 0, i64* %bytes, align 8
  store i64 0, i64* %packets, align 8
  call void @rcu_read_lock() noredzone
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %6 = load i32* %i, align 4
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 14
  %8 = load i32* %num_rx_queues, align 4
  %cmp6 = icmp slt i32 %6, %8
  br i1 %cmp6, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %11 = load %struct.igb_ring** %arrayidx, align 8
  store %struct.igb_ring* %11, %struct.igb_ring** %ring, align 8
  %12 = load %struct.e1000_hw** %hw, align 8
  %13 = load i32* %i, align 4
  %mul = mul i32 %13, 64
  %add = add i32 49200, %mul
  %call8 = call i32 @igb_rd32(%struct.e1000_hw* %12, i32 %add) noredzone
  store i32 %call8, i32* %rqdpc, align 4
  %14 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %15 = load i32* %type, align 4
  %cmp9 = icmp uge i32 %15, 6
  br i1 %cmp9, label %if.then11, label %if.end24

if.then11:                                        ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then11
  %16 = load %struct.e1000_hw** %hw, align 8
  %hw_addr12 = getelementptr inbounds %struct.e1000_hw* %16, i32 0, i32 1
  %17 = load volatile i8** %hw_addr12, align 8
  store i8* %17, i8** %hw_addr, align 8
  %18 = load i8** %hw_addr, align 8
  %tobool13 = icmp ne i8* %18, null
  %lnot = xor i1 %tobool13, true
  %lnot14 = xor i1 %lnot, true
  %lnot15 = xor i1 %lnot14, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv16 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %tobool17, label %if.end23, label %if.then18

if.then18:                                        ; preds = %do.body
  %19 = load i32* %i, align 4
  %mul19 = mul i32 %19, 64
  %add20 = add i32 49200, %mul19
  %idxprom21 = sext i32 %add20 to i64
  %20 = load i8** %hw_addr, align 8
  %arrayidx22 = getelementptr i8* %20, i64 %idxprom21
  call void @writel(i32 0, i8* %arrayidx22) noredzone
  br label %if.end23

if.end23:                                         ; preds = %if.then18, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end23
  br label %if.end24

if.end24:                                         ; preds = %do.end, %for.body
  %21 = load i32* %rqdpc, align 4
  %tobool25 = icmp ne i32 %21, 0
  br i1 %tobool25, label %if.then26, label %if.end31

if.then26:                                        ; preds = %if.end24
  %22 = load i32* %rqdpc, align 4
  %conv27 = zext i32 %22 to i64
  %23 = load %struct.igb_ring** %ring, align 8
  %24 = getelementptr inbounds %struct.igb_ring* %23, i32 0, i32 15
  %25 = bitcast %union.anon.90* %24 to %struct.anon.92*
  %rx_stats = getelementptr inbounds %struct.anon.92* %25, i32 0, i32 1
  %drops = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats, i32 0, i32 2
  %26 = load i64* %drops, align 8
  %add28 = add i64 %26, %conv27
  store i64 %add28, i64* %drops, align 8
  %27 = load i32* %rqdpc, align 4
  %conv29 = zext i32 %27 to i64
  %28 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_fifo_errors = getelementptr inbounds %struct.rtnl_link_stats64* %28, i32 0, i32 14
  %29 = load i64* %rx_fifo_errors, align 8
  %add30 = add i64 %29, %conv29
  store i64 %add30, i64* %rx_fifo_errors, align 8
  br label %if.end31

if.end31:                                         ; preds = %if.then26, %if.end24
  br label %do.body32

do.body32:                                        ; preds = %do.cond, %if.end31
  %30 = load %struct.igb_ring** %ring, align 8
  %31 = getelementptr inbounds %struct.igb_ring* %30, i32 0, i32 15
  %32 = bitcast %union.anon.90* %31 to %struct.anon.92*
  %rx_syncp = getelementptr inbounds %struct.anon.92* %32, i32 0, i32 2
  %call33 = call i32 @u64_stats_fetch_begin_irq(%struct.u64_stats_sync* %rx_syncp) noredzone
  store i32 %call33, i32* %start, align 4
  %33 = load %struct.igb_ring** %ring, align 8
  %34 = getelementptr inbounds %struct.igb_ring* %33, i32 0, i32 15
  %35 = bitcast %union.anon.90* %34 to %struct.anon.92*
  %rx_stats34 = getelementptr inbounds %struct.anon.92* %35, i32 0, i32 1
  %bytes35 = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats34, i32 0, i32 1
  %36 = load i64* %bytes35, align 8
  store i64 %36, i64* %_bytes, align 8
  %37 = load %struct.igb_ring** %ring, align 8
  %38 = getelementptr inbounds %struct.igb_ring* %37, i32 0, i32 15
  %39 = bitcast %union.anon.90* %38 to %struct.anon.92*
  %rx_stats36 = getelementptr inbounds %struct.anon.92* %39, i32 0, i32 1
  %packets37 = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats36, i32 0, i32 0
  %40 = load i64* %packets37, align 8
  store i64 %40, i64* %_packets, align 8
  br label %do.cond

do.cond:                                          ; preds = %do.body32
  %41 = load %struct.igb_ring** %ring, align 8
  %42 = getelementptr inbounds %struct.igb_ring* %41, i32 0, i32 15
  %43 = bitcast %union.anon.90* %42 to %struct.anon.92*
  %rx_syncp38 = getelementptr inbounds %struct.anon.92* %43, i32 0, i32 2
  %44 = load i32* %start, align 4
  %call39 = call zeroext i1 @u64_stats_fetch_retry_irq(%struct.u64_stats_sync* %rx_syncp38, i32 %44) noredzone
  br i1 %call39, label %do.body32, label %do.end40

do.end40:                                         ; preds = %do.cond
  %45 = load i64* %_bytes, align 8
  %46 = load i64* %bytes, align 8
  %add41 = add i64 %46, %45
  store i64 %add41, i64* %bytes, align 8
  %47 = load i64* %_packets, align 8
  %48 = load i64* %packets, align 8
  %add42 = add i64 %48, %47
  store i64 %add42, i64* %packets, align 8
  br label %for.inc

for.inc:                                          ; preds = %do.end40
  %49 = load i32* %i, align 4
  %inc = add i32 %49, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %50 = load i64* %bytes, align 8
  %51 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_bytes = getelementptr inbounds %struct.rtnl_link_stats64* %51, i32 0, i32 2
  store i64 %50, i64* %rx_bytes, align 8
  %52 = load i64* %packets, align 8
  %53 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_packets = getelementptr inbounds %struct.rtnl_link_stats64* %53, i32 0, i32 0
  store i64 %52, i64* %rx_packets, align 8
  store i64 0, i64* %bytes, align 8
  store i64 0, i64* %packets, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc61, %for.end
  %54 = load i32* %i, align 4
  %55 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %55, i32 0, i32 12
  %56 = load i32* %num_tx_queues, align 4
  %cmp44 = icmp slt i32 %54, %56
  br i1 %cmp44, label %for.body46, label %for.end63

for.body46:                                       ; preds = %for.cond43
  %57 = load i32* %i, align 4
  %idxprom48 = sext i32 %57 to i64
  %58 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %58, i32 0, i32 13
  %arrayidx49 = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom48
  %59 = load %struct.igb_ring** %arrayidx49, align 8
  store %struct.igb_ring* %59, %struct.igb_ring** %ring47, align 8
  br label %do.body50

do.body50:                                        ; preds = %do.cond55, %for.body46
  %60 = load %struct.igb_ring** %ring47, align 8
  %61 = getelementptr inbounds %struct.igb_ring* %60, i32 0, i32 15
  %62 = bitcast %union.anon.90* %61 to %struct.anon.91*
  %tx_syncp = getelementptr inbounds %struct.anon.91* %62, i32 0, i32 1
  %call51 = call i32 @u64_stats_fetch_begin_irq(%struct.u64_stats_sync* %tx_syncp) noredzone
  store i32 %call51, i32* %start, align 4
  %63 = load %struct.igb_ring** %ring47, align 8
  %64 = getelementptr inbounds %struct.igb_ring* %63, i32 0, i32 15
  %65 = bitcast %union.anon.90* %64 to %struct.anon.91*
  %tx_stats = getelementptr inbounds %struct.anon.91* %65, i32 0, i32 0
  %bytes52 = getelementptr inbounds %struct.igb_tx_queue_stats* %tx_stats, i32 0, i32 1
  %66 = load i64* %bytes52, align 8
  store i64 %66, i64* %_bytes, align 8
  %67 = load %struct.igb_ring** %ring47, align 8
  %68 = getelementptr inbounds %struct.igb_ring* %67, i32 0, i32 15
  %69 = bitcast %union.anon.90* %68 to %struct.anon.91*
  %tx_stats53 = getelementptr inbounds %struct.anon.91* %69, i32 0, i32 0
  %packets54 = getelementptr inbounds %struct.igb_tx_queue_stats* %tx_stats53, i32 0, i32 0
  %70 = load i64* %packets54, align 8
  store i64 %70, i64* %_packets, align 8
  br label %do.cond55

do.cond55:                                        ; preds = %do.body50
  %71 = load %struct.igb_ring** %ring47, align 8
  %72 = getelementptr inbounds %struct.igb_ring* %71, i32 0, i32 15
  %73 = bitcast %union.anon.90* %72 to %struct.anon.91*
  %tx_syncp56 = getelementptr inbounds %struct.anon.91* %73, i32 0, i32 1
  %74 = load i32* %start, align 4
  %call57 = call zeroext i1 @u64_stats_fetch_retry_irq(%struct.u64_stats_sync* %tx_syncp56, i32 %74) noredzone
  br i1 %call57, label %do.body50, label %do.end58

do.end58:                                         ; preds = %do.cond55
  %75 = load i64* %_bytes, align 8
  %76 = load i64* %bytes, align 8
  %add59 = add i64 %76, %75
  store i64 %add59, i64* %bytes, align 8
  %77 = load i64* %_packets, align 8
  %78 = load i64* %packets, align 8
  %add60 = add i64 %78, %77
  store i64 %add60, i64* %packets, align 8
  br label %for.inc61

for.inc61:                                        ; preds = %do.end58
  %79 = load i32* %i, align 4
  %inc62 = add i32 %79, 1
  store i32 %inc62, i32* %i, align 4
  br label %for.cond43

for.end63:                                        ; preds = %for.cond43
  %80 = load i64* %bytes, align 8
  %81 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %tx_bytes = getelementptr inbounds %struct.rtnl_link_stats64* %81, i32 0, i32 3
  store i64 %80, i64* %tx_bytes, align 8
  %82 = load i64* %packets, align 8
  %83 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %tx_packets = getelementptr inbounds %struct.rtnl_link_stats64* %83, i32 0, i32 1
  store i64 %82, i64* %tx_packets, align 8
  call void @rcu_read_unlock() noredzone
  %84 = load %struct.e1000_hw** %hw, align 8
  %call64 = call i32 @igb_rd32(%struct.e1000_hw* %84, i32 16384) noredzone
  %conv65 = zext i32 %call64 to i64
  %85 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats = getelementptr inbounds %struct.igb_adapter* %85, i32 0, i32 36
  %crcerrs = getelementptr inbounds %struct.e1000_hw_stats* %stats, i32 0, i32 0
  %86 = load i64* %crcerrs, align 8
  %add66 = add i64 %86, %conv65
  store i64 %add66, i64* %crcerrs, align 8
  %87 = load %struct.e1000_hw** %hw, align 8
  %call67 = call i32 @igb_rd32(%struct.e1000_hw* %87, i32 16500) noredzone
  %conv68 = zext i32 %call67 to i64
  %88 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats69 = getelementptr inbounds %struct.igb_adapter* %88, i32 0, i32 36
  %gprc = getelementptr inbounds %struct.e1000_hw_stats* %stats69, i32 0, i32 26
  %89 = load i64* %gprc, align 8
  %add70 = add i64 %89, %conv68
  store i64 %add70, i64* %gprc, align 8
  %90 = load %struct.e1000_hw** %hw, align 8
  %call71 = call i32 @igb_rd32(%struct.e1000_hw* %90, i32 16520) noredzone
  %conv72 = zext i32 %call71 to i64
  %91 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats73 = getelementptr inbounds %struct.igb_adapter* %91, i32 0, i32 36
  %gorc = getelementptr inbounds %struct.e1000_hw_stats* %stats73, i32 0, i32 30
  %92 = load i64* %gorc, align 8
  %add74 = add i64 %92, %conv72
  store i64 %add74, i64* %gorc, align 8
  %93 = load %struct.e1000_hw** %hw, align 8
  %call75 = call i32 @igb_rd32(%struct.e1000_hw* %93, i32 16524) noredzone
  %94 = load %struct.e1000_hw** %hw, align 8
  %call76 = call i32 @igb_rd32(%struct.e1000_hw* %94, i32 16504) noredzone
  %conv77 = zext i32 %call76 to i64
  %95 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats78 = getelementptr inbounds %struct.igb_adapter* %95, i32 0, i32 36
  %bprc = getelementptr inbounds %struct.e1000_hw_stats* %stats78, i32 0, i32 27
  %96 = load i64* %bprc, align 8
  %add79 = add i64 %96, %conv77
  store i64 %add79, i64* %bprc, align 8
  %97 = load %struct.e1000_hw** %hw, align 8
  %call80 = call i32 @igb_rd32(%struct.e1000_hw* %97, i32 16508) noredzone
  %conv81 = zext i32 %call80 to i64
  %98 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats82 = getelementptr inbounds %struct.igb_adapter* %98, i32 0, i32 36
  %mprc = getelementptr inbounds %struct.e1000_hw_stats* %stats82, i32 0, i32 28
  %99 = load i64* %mprc, align 8
  %add83 = add i64 %99, %conv81
  store i64 %add83, i64* %mprc, align 8
  %100 = load %struct.e1000_hw** %hw, align 8
  %call84 = call i32 @igb_rd32(%struct.e1000_hw* %100, i32 16556) noredzone
  %conv85 = zext i32 %call84 to i64
  %101 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats86 = getelementptr inbounds %struct.igb_adapter* %101, i32 0, i32 36
  %roc = getelementptr inbounds %struct.e1000_hw_stats* %stats86, i32 0, i32 35
  %102 = load i64* %roc, align 8
  %add87 = add i64 %102, %conv85
  store i64 %add87, i64* %roc, align 8
  %103 = load %struct.e1000_hw** %hw, align 8
  %call88 = call i32 @igb_rd32(%struct.e1000_hw* %103, i32 16476) noredzone
  %conv89 = zext i32 %call88 to i64
  %104 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats90 = getelementptr inbounds %struct.igb_adapter* %104, i32 0, i32 36
  %prc64 = getelementptr inbounds %struct.e1000_hw_stats* %stats90, i32 0, i32 20
  %105 = load i64* %prc64, align 8
  %add91 = add i64 %105, %conv89
  store i64 %add91, i64* %prc64, align 8
  %106 = load %struct.e1000_hw** %hw, align 8
  %call92 = call i32 @igb_rd32(%struct.e1000_hw* %106, i32 16480) noredzone
  %conv93 = zext i32 %call92 to i64
  %107 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats94 = getelementptr inbounds %struct.igb_adapter* %107, i32 0, i32 36
  %prc127 = getelementptr inbounds %struct.e1000_hw_stats* %stats94, i32 0, i32 21
  %108 = load i64* %prc127, align 8
  %add95 = add i64 %108, %conv93
  store i64 %add95, i64* %prc127, align 8
  %109 = load %struct.e1000_hw** %hw, align 8
  %call96 = call i32 @igb_rd32(%struct.e1000_hw* %109, i32 16484) noredzone
  %conv97 = zext i32 %call96 to i64
  %110 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats98 = getelementptr inbounds %struct.igb_adapter* %110, i32 0, i32 36
  %prc255 = getelementptr inbounds %struct.e1000_hw_stats* %stats98, i32 0, i32 22
  %111 = load i64* %prc255, align 8
  %add99 = add i64 %111, %conv97
  store i64 %add99, i64* %prc255, align 8
  %112 = load %struct.e1000_hw** %hw, align 8
  %call100 = call i32 @igb_rd32(%struct.e1000_hw* %112, i32 16488) noredzone
  %conv101 = zext i32 %call100 to i64
  %113 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats102 = getelementptr inbounds %struct.igb_adapter* %113, i32 0, i32 36
  %prc511 = getelementptr inbounds %struct.e1000_hw_stats* %stats102, i32 0, i32 23
  %114 = load i64* %prc511, align 8
  %add103 = add i64 %114, %conv101
  store i64 %add103, i64* %prc511, align 8
  %115 = load %struct.e1000_hw** %hw, align 8
  %call104 = call i32 @igb_rd32(%struct.e1000_hw* %115, i32 16492) noredzone
  %conv105 = zext i32 %call104 to i64
  %116 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats106 = getelementptr inbounds %struct.igb_adapter* %116, i32 0, i32 36
  %prc1023 = getelementptr inbounds %struct.e1000_hw_stats* %stats106, i32 0, i32 24
  %117 = load i64* %prc1023, align 8
  %add107 = add i64 %117, %conv105
  store i64 %add107, i64* %prc1023, align 8
  %118 = load %struct.e1000_hw** %hw, align 8
  %call108 = call i32 @igb_rd32(%struct.e1000_hw* %118, i32 16496) noredzone
  %conv109 = zext i32 %call108 to i64
  %119 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats110 = getelementptr inbounds %struct.igb_adapter* %119, i32 0, i32 36
  %prc1522 = getelementptr inbounds %struct.e1000_hw_stats* %stats110, i32 0, i32 25
  %120 = load i64* %prc1522, align 8
  %add111 = add i64 %120, %conv109
  store i64 %add111, i64* %prc1522, align 8
  %121 = load %struct.e1000_hw** %hw, align 8
  %call112 = call i32 @igb_rd32(%struct.e1000_hw* %121, i32 16392) noredzone
  %conv113 = zext i32 %call112 to i64
  %122 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats114 = getelementptr inbounds %struct.igb_adapter* %122, i32 0, i32 36
  %symerrs = getelementptr inbounds %struct.e1000_hw_stats* %stats114, i32 0, i32 2
  %123 = load i64* %symerrs, align 8
  %add115 = add i64 %123, %conv113
  store i64 %add115, i64* %symerrs, align 8
  %124 = load %struct.e1000_hw** %hw, align 8
  %call116 = call i32 @igb_rd32(%struct.e1000_hw* %124, i32 16440) noredzone
  %conv117 = zext i32 %call116 to i64
  %125 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats118 = getelementptr inbounds %struct.igb_adapter* %125, i32 0, i32 36
  %sec = getelementptr inbounds %struct.e1000_hw_stats* %stats118, i32 0, i32 12
  %126 = load i64* %sec, align 8
  %add119 = add i64 %126, %conv117
  store i64 %add119, i64* %sec, align 8
  %127 = load %struct.e1000_hw** %hw, align 8
  %call120 = call i32 @igb_rd32(%struct.e1000_hw* %127, i32 16400) noredzone
  store i32 %call120, i32* %mpc, align 4
  %128 = load i32* %mpc, align 4
  %conv121 = zext i32 %128 to i64
  %129 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats122 = getelementptr inbounds %struct.igb_adapter* %129, i32 0, i32 36
  %mpc123 = getelementptr inbounds %struct.e1000_hw_stats* %stats122, i32 0, i32 4
  %130 = load i64* %mpc123, align 8
  %add124 = add i64 %130, %conv121
  store i64 %add124, i64* %mpc123, align 8
  %131 = load i32* %mpc, align 4
  %conv125 = zext i32 %131 to i64
  %132 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_fifo_errors126 = getelementptr inbounds %struct.rtnl_link_stats64* %132, i32 0, i32 14
  %133 = load i64* %rx_fifo_errors126, align 8
  %add127 = add i64 %133, %conv125
  store i64 %add127, i64* %rx_fifo_errors126, align 8
  %134 = load %struct.e1000_hw** %hw, align 8
  %call128 = call i32 @igb_rd32(%struct.e1000_hw* %134, i32 16404) noredzone
  %conv129 = zext i32 %call128 to i64
  %135 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats130 = getelementptr inbounds %struct.igb_adapter* %135, i32 0, i32 36
  %scc = getelementptr inbounds %struct.e1000_hw_stats* %stats130, i32 0, i32 5
  %136 = load i64* %scc, align 8
  %add131 = add i64 %136, %conv129
  store i64 %add131, i64* %scc, align 8
  %137 = load %struct.e1000_hw** %hw, align 8
  %call132 = call i32 @igb_rd32(%struct.e1000_hw* %137, i32 16408) noredzone
  %conv133 = zext i32 %call132 to i64
  %138 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats134 = getelementptr inbounds %struct.igb_adapter* %138, i32 0, i32 36
  %ecol = getelementptr inbounds %struct.e1000_hw_stats* %stats134, i32 0, i32 6
  %139 = load i64* %ecol, align 8
  %add135 = add i64 %139, %conv133
  store i64 %add135, i64* %ecol, align 8
  %140 = load %struct.e1000_hw** %hw, align 8
  %call136 = call i32 @igb_rd32(%struct.e1000_hw* %140, i32 16412) noredzone
  %conv137 = zext i32 %call136 to i64
  %141 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats138 = getelementptr inbounds %struct.igb_adapter* %141, i32 0, i32 36
  %mcc = getelementptr inbounds %struct.e1000_hw_stats* %stats138, i32 0, i32 7
  %142 = load i64* %mcc, align 8
  %add139 = add i64 %142, %conv137
  store i64 %add139, i64* %mcc, align 8
  %143 = load %struct.e1000_hw** %hw, align 8
  %call140 = call i32 @igb_rd32(%struct.e1000_hw* %143, i32 16416) noredzone
  %conv141 = zext i32 %call140 to i64
  %144 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats142 = getelementptr inbounds %struct.igb_adapter* %144, i32 0, i32 36
  %latecol = getelementptr inbounds %struct.e1000_hw_stats* %stats142, i32 0, i32 8
  %145 = load i64* %latecol, align 8
  %add143 = add i64 %145, %conv141
  store i64 %add143, i64* %latecol, align 8
  %146 = load %struct.e1000_hw** %hw, align 8
  %call144 = call i32 @igb_rd32(%struct.e1000_hw* %146, i32 16432) noredzone
  %conv145 = zext i32 %call144 to i64
  %147 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats146 = getelementptr inbounds %struct.igb_adapter* %147, i32 0, i32 36
  %dc = getelementptr inbounds %struct.e1000_hw_stats* %stats146, i32 0, i32 10
  %148 = load i64* %dc, align 8
  %add147 = add i64 %148, %conv145
  store i64 %add147, i64* %dc, align 8
  %149 = load %struct.e1000_hw** %hw, align 8
  %call148 = call i32 @igb_rd32(%struct.e1000_hw* %149, i32 16448) noredzone
  %conv149 = zext i32 %call148 to i64
  %150 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats150 = getelementptr inbounds %struct.igb_adapter* %150, i32 0, i32 36
  %rlec = getelementptr inbounds %struct.e1000_hw_stats* %stats150, i32 0, i32 14
  %151 = load i64* %rlec, align 8
  %add151 = add i64 %151, %conv149
  store i64 %add151, i64* %rlec, align 8
  %152 = load %struct.e1000_hw** %hw, align 8
  %call152 = call i32 @igb_rd32(%struct.e1000_hw* %152, i32 16456) noredzone
  %conv153 = zext i32 %call152 to i64
  %153 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats154 = getelementptr inbounds %struct.igb_adapter* %153, i32 0, i32 36
  %xonrxc = getelementptr inbounds %struct.e1000_hw_stats* %stats154, i32 0, i32 15
  %154 = load i64* %xonrxc, align 8
  %add155 = add i64 %154, %conv153
  store i64 %add155, i64* %xonrxc, align 8
  %155 = load %struct.e1000_hw** %hw, align 8
  %call156 = call i32 @igb_rd32(%struct.e1000_hw* %155, i32 16460) noredzone
  %conv157 = zext i32 %call156 to i64
  %156 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats158 = getelementptr inbounds %struct.igb_adapter* %156, i32 0, i32 36
  %xontxc = getelementptr inbounds %struct.e1000_hw_stats* %stats158, i32 0, i32 16
  %157 = load i64* %xontxc, align 8
  %add159 = add i64 %157, %conv157
  store i64 %add159, i64* %xontxc, align 8
  %158 = load %struct.e1000_hw** %hw, align 8
  %call160 = call i32 @igb_rd32(%struct.e1000_hw* %158, i32 16464) noredzone
  %conv161 = zext i32 %call160 to i64
  %159 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats162 = getelementptr inbounds %struct.igb_adapter* %159, i32 0, i32 36
  %xoffrxc = getelementptr inbounds %struct.e1000_hw_stats* %stats162, i32 0, i32 17
  %160 = load i64* %xoffrxc, align 8
  %add163 = add i64 %160, %conv161
  store i64 %add163, i64* %xoffrxc, align 8
  %161 = load %struct.e1000_hw** %hw, align 8
  %call164 = call i32 @igb_rd32(%struct.e1000_hw* %161, i32 16468) noredzone
  %conv165 = zext i32 %call164 to i64
  %162 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats166 = getelementptr inbounds %struct.igb_adapter* %162, i32 0, i32 36
  %xofftxc = getelementptr inbounds %struct.e1000_hw_stats* %stats166, i32 0, i32 18
  %163 = load i64* %xofftxc, align 8
  %add167 = add i64 %163, %conv165
  store i64 %add167, i64* %xofftxc, align 8
  %164 = load %struct.e1000_hw** %hw, align 8
  %call168 = call i32 @igb_rd32(%struct.e1000_hw* %164, i32 16472) noredzone
  %conv169 = zext i32 %call168 to i64
  %165 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats170 = getelementptr inbounds %struct.igb_adapter* %165, i32 0, i32 36
  %fcruc = getelementptr inbounds %struct.e1000_hw_stats* %stats170, i32 0, i32 19
  %166 = load i64* %fcruc, align 8
  %add171 = add i64 %166, %conv169
  store i64 %add171, i64* %fcruc, align 8
  %167 = load %struct.e1000_hw** %hw, align 8
  %call172 = call i32 @igb_rd32(%struct.e1000_hw* %167, i32 16512) noredzone
  %conv173 = zext i32 %call172 to i64
  %168 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats174 = getelementptr inbounds %struct.igb_adapter* %168, i32 0, i32 36
  %gptc = getelementptr inbounds %struct.e1000_hw_stats* %stats174, i32 0, i32 29
  %169 = load i64* %gptc, align 8
  %add175 = add i64 %169, %conv173
  store i64 %add175, i64* %gptc, align 8
  %170 = load %struct.e1000_hw** %hw, align 8
  %call176 = call i32 @igb_rd32(%struct.e1000_hw* %170, i32 16528) noredzone
  %conv177 = zext i32 %call176 to i64
  %171 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats178 = getelementptr inbounds %struct.igb_adapter* %171, i32 0, i32 36
  %gotc = getelementptr inbounds %struct.e1000_hw_stats* %stats178, i32 0, i32 31
  %172 = load i64* %gotc, align 8
  %add179 = add i64 %172, %conv177
  store i64 %add179, i64* %gotc, align 8
  %173 = load %struct.e1000_hw** %hw, align 8
  %call180 = call i32 @igb_rd32(%struct.e1000_hw* %173, i32 16532) noredzone
  %174 = load %struct.e1000_hw** %hw, align 8
  %call181 = call i32 @igb_rd32(%struct.e1000_hw* %174, i32 16544) noredzone
  %conv182 = zext i32 %call181 to i64
  %175 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats183 = getelementptr inbounds %struct.igb_adapter* %175, i32 0, i32 36
  %rnbc = getelementptr inbounds %struct.e1000_hw_stats* %stats183, i32 0, i32 32
  %176 = load i64* %rnbc, align 8
  %add184 = add i64 %176, %conv182
  store i64 %add184, i64* %rnbc, align 8
  %177 = load %struct.e1000_hw** %hw, align 8
  %call185 = call i32 @igb_rd32(%struct.e1000_hw* %177, i32 16548) noredzone
  %conv186 = zext i32 %call185 to i64
  %178 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats187 = getelementptr inbounds %struct.igb_adapter* %178, i32 0, i32 36
  %ruc = getelementptr inbounds %struct.e1000_hw_stats* %stats187, i32 0, i32 33
  %179 = load i64* %ruc, align 8
  %add188 = add i64 %179, %conv186
  store i64 %add188, i64* %ruc, align 8
  %180 = load %struct.e1000_hw** %hw, align 8
  %call189 = call i32 @igb_rd32(%struct.e1000_hw* %180, i32 16552) noredzone
  %conv190 = zext i32 %call189 to i64
  %181 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats191 = getelementptr inbounds %struct.igb_adapter* %181, i32 0, i32 36
  %rfc = getelementptr inbounds %struct.e1000_hw_stats* %stats191, i32 0, i32 34
  %182 = load i64* %rfc, align 8
  %add192 = add i64 %182, %conv190
  store i64 %add192, i64* %rfc, align 8
  %183 = load %struct.e1000_hw** %hw, align 8
  %call193 = call i32 @igb_rd32(%struct.e1000_hw* %183, i32 16560) noredzone
  %conv194 = zext i32 %call193 to i64
  %184 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats195 = getelementptr inbounds %struct.igb_adapter* %184, i32 0, i32 36
  %rjc = getelementptr inbounds %struct.e1000_hw_stats* %stats195, i32 0, i32 36
  %185 = load i64* %rjc, align 8
  %add196 = add i64 %185, %conv194
  store i64 %add196, i64* %rjc, align 8
  %186 = load %struct.e1000_hw** %hw, align 8
  %call197 = call i32 @igb_rd32(%struct.e1000_hw* %186, i32 16580) noredzone
  %conv198 = zext i32 %call197 to i64
  %187 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats199 = getelementptr inbounds %struct.igb_adapter* %187, i32 0, i32 36
  %tor = getelementptr inbounds %struct.e1000_hw_stats* %stats199, i32 0, i32 40
  %188 = load i64* %tor, align 8
  %add200 = add i64 %188, %conv198
  store i64 %add200, i64* %tor, align 8
  %189 = load %struct.e1000_hw** %hw, align 8
  %call201 = call i32 @igb_rd32(%struct.e1000_hw* %189, i32 16588) noredzone
  %conv202 = zext i32 %call201 to i64
  %190 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats203 = getelementptr inbounds %struct.igb_adapter* %190, i32 0, i32 36
  %tot = getelementptr inbounds %struct.e1000_hw_stats* %stats203, i32 0, i32 41
  %191 = load i64* %tot, align 8
  %add204 = add i64 %191, %conv202
  store i64 %add204, i64* %tot, align 8
  %192 = load %struct.e1000_hw** %hw, align 8
  %call205 = call i32 @igb_rd32(%struct.e1000_hw* %192, i32 16592) noredzone
  %conv206 = zext i32 %call205 to i64
  %193 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats207 = getelementptr inbounds %struct.igb_adapter* %193, i32 0, i32 36
  %tpr = getelementptr inbounds %struct.e1000_hw_stats* %stats207, i32 0, i32 42
  %194 = load i64* %tpr, align 8
  %add208 = add i64 %194, %conv206
  store i64 %add208, i64* %tpr, align 8
  %195 = load %struct.e1000_hw** %hw, align 8
  %call209 = call i32 @igb_rd32(%struct.e1000_hw* %195, i32 16600) noredzone
  %conv210 = zext i32 %call209 to i64
  %196 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats211 = getelementptr inbounds %struct.igb_adapter* %196, i32 0, i32 36
  %ptc64 = getelementptr inbounds %struct.e1000_hw_stats* %stats211, i32 0, i32 44
  %197 = load i64* %ptc64, align 8
  %add212 = add i64 %197, %conv210
  store i64 %add212, i64* %ptc64, align 8
  %198 = load %struct.e1000_hw** %hw, align 8
  %call213 = call i32 @igb_rd32(%struct.e1000_hw* %198, i32 16604) noredzone
  %conv214 = zext i32 %call213 to i64
  %199 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats215 = getelementptr inbounds %struct.igb_adapter* %199, i32 0, i32 36
  %ptc127 = getelementptr inbounds %struct.e1000_hw_stats* %stats215, i32 0, i32 45
  %200 = load i64* %ptc127, align 8
  %add216 = add i64 %200, %conv214
  store i64 %add216, i64* %ptc127, align 8
  %201 = load %struct.e1000_hw** %hw, align 8
  %call217 = call i32 @igb_rd32(%struct.e1000_hw* %201, i32 16608) noredzone
  %conv218 = zext i32 %call217 to i64
  %202 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats219 = getelementptr inbounds %struct.igb_adapter* %202, i32 0, i32 36
  %ptc255 = getelementptr inbounds %struct.e1000_hw_stats* %stats219, i32 0, i32 46
  %203 = load i64* %ptc255, align 8
  %add220 = add i64 %203, %conv218
  store i64 %add220, i64* %ptc255, align 8
  %204 = load %struct.e1000_hw** %hw, align 8
  %call221 = call i32 @igb_rd32(%struct.e1000_hw* %204, i32 16612) noredzone
  %conv222 = zext i32 %call221 to i64
  %205 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats223 = getelementptr inbounds %struct.igb_adapter* %205, i32 0, i32 36
  %ptc511 = getelementptr inbounds %struct.e1000_hw_stats* %stats223, i32 0, i32 47
  %206 = load i64* %ptc511, align 8
  %add224 = add i64 %206, %conv222
  store i64 %add224, i64* %ptc511, align 8
  %207 = load %struct.e1000_hw** %hw, align 8
  %call225 = call i32 @igb_rd32(%struct.e1000_hw* %207, i32 16616) noredzone
  %conv226 = zext i32 %call225 to i64
  %208 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats227 = getelementptr inbounds %struct.igb_adapter* %208, i32 0, i32 36
  %ptc1023 = getelementptr inbounds %struct.e1000_hw_stats* %stats227, i32 0, i32 48
  %209 = load i64* %ptc1023, align 8
  %add228 = add i64 %209, %conv226
  store i64 %add228, i64* %ptc1023, align 8
  %210 = load %struct.e1000_hw** %hw, align 8
  %call229 = call i32 @igb_rd32(%struct.e1000_hw* %210, i32 16620) noredzone
  %conv230 = zext i32 %call229 to i64
  %211 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats231 = getelementptr inbounds %struct.igb_adapter* %211, i32 0, i32 36
  %ptc1522 = getelementptr inbounds %struct.e1000_hw_stats* %stats231, i32 0, i32 49
  %212 = load i64* %ptc1522, align 8
  %add232 = add i64 %212, %conv230
  store i64 %add232, i64* %ptc1522, align 8
  %213 = load %struct.e1000_hw** %hw, align 8
  %call233 = call i32 @igb_rd32(%struct.e1000_hw* %213, i32 16624) noredzone
  %conv234 = zext i32 %call233 to i64
  %214 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats235 = getelementptr inbounds %struct.igb_adapter* %214, i32 0, i32 36
  %mptc = getelementptr inbounds %struct.e1000_hw_stats* %stats235, i32 0, i32 50
  %215 = load i64* %mptc, align 8
  %add236 = add i64 %215, %conv234
  store i64 %add236, i64* %mptc, align 8
  %216 = load %struct.e1000_hw** %hw, align 8
  %call237 = call i32 @igb_rd32(%struct.e1000_hw* %216, i32 16628) noredzone
  %conv238 = zext i32 %call237 to i64
  %217 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats239 = getelementptr inbounds %struct.igb_adapter* %217, i32 0, i32 36
  %bptc = getelementptr inbounds %struct.e1000_hw_stats* %stats239, i32 0, i32 51
  %218 = load i64* %bptc, align 8
  %add240 = add i64 %218, %conv238
  store i64 %add240, i64* %bptc, align 8
  %219 = load %struct.e1000_hw** %hw, align 8
  %call241 = call i32 @igb_rd32(%struct.e1000_hw* %219, i32 16596) noredzone
  %conv242 = zext i32 %call241 to i64
  %220 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats243 = getelementptr inbounds %struct.igb_adapter* %220, i32 0, i32 36
  %tpt = getelementptr inbounds %struct.e1000_hw_stats* %stats243, i32 0, i32 43
  %221 = load i64* %tpt, align 8
  %add244 = add i64 %221, %conv242
  store i64 %add244, i64* %tpt, align 8
  %222 = load %struct.e1000_hw** %hw, align 8
  %call245 = call i32 @igb_rd32(%struct.e1000_hw* %222, i32 16424) noredzone
  %conv246 = zext i32 %call245 to i64
  %223 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats247 = getelementptr inbounds %struct.igb_adapter* %223, i32 0, i32 36
  %colc = getelementptr inbounds %struct.e1000_hw_stats* %stats247, i32 0, i32 9
  %224 = load i64* %colc, align 8
  %add248 = add i64 %224, %conv246
  store i64 %add248, i64* %colc, align 8
  %225 = load %struct.e1000_hw** %hw, align 8
  %call249 = call i32 @igb_rd32(%struct.e1000_hw* %225, i32 16388) noredzone
  %conv250 = zext i32 %call249 to i64
  %226 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats251 = getelementptr inbounds %struct.igb_adapter* %226, i32 0, i32 36
  %algnerrc = getelementptr inbounds %struct.e1000_hw_stats* %stats251, i32 0, i32 1
  %227 = load i64* %algnerrc, align 8
  %add252 = add i64 %227, %conv250
  store i64 %add252, i64* %algnerrc, align 8
  %228 = load %struct.e1000_hw** %hw, align 8
  %call253 = call i32 @igb_rd32(%struct.e1000_hw* %228, i32 24) noredzone
  store i32 %call253, i32* %reg, align 4
  %229 = load i32* %reg, align 4
  %and = and i32 %229, 12582912
  %tobool254 = icmp ne i32 %and, 0
  br i1 %tobool254, label %if.end274, label %if.then255

if.then255:                                       ; preds = %for.end63
  %230 = load %struct.e1000_hw** %hw, align 8
  %call256 = call i32 @igb_rd32(%struct.e1000_hw* %230, i32 16396) noredzone
  %conv257 = zext i32 %call256 to i64
  %231 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats258 = getelementptr inbounds %struct.igb_adapter* %231, i32 0, i32 36
  %rxerrc = getelementptr inbounds %struct.e1000_hw_stats* %stats258, i32 0, i32 3
  %232 = load i64* %rxerrc, align 8
  %add259 = add i64 %232, %conv257
  store i64 %add259, i64* %rxerrc, align 8
  %233 = load %struct.e1000_hw** %hw, align 8
  %mac260 = getelementptr inbounds %struct.e1000_hw* %233, i32 0, i32 4
  %type261 = getelementptr inbounds %struct.e1000_mac_info* %mac260, i32 0, i32 3
  %234 = load i32* %type261, align 4
  %cmp262 = icmp ne i32 %234, 6
  br i1 %cmp262, label %land.lhs.true, label %if.end273

land.lhs.true:                                    ; preds = %if.then255
  %235 = load %struct.e1000_hw** %hw, align 8
  %mac264 = getelementptr inbounds %struct.e1000_hw* %235, i32 0, i32 4
  %type265 = getelementptr inbounds %struct.e1000_mac_info* %mac264, i32 0, i32 3
  %236 = load i32* %type265, align 4
  %cmp266 = icmp ne i32 %236, 7
  br i1 %cmp266, label %if.then268, label %if.end273

if.then268:                                       ; preds = %land.lhs.true
  %237 = load %struct.e1000_hw** %hw, align 8
  %call269 = call i32 @igb_rd32(%struct.e1000_hw* %237, i32 16436) noredzone
  %conv270 = zext i32 %call269 to i64
  %238 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats271 = getelementptr inbounds %struct.igb_adapter* %238, i32 0, i32 36
  %tncrs = getelementptr inbounds %struct.e1000_hw_stats* %stats271, i32 0, i32 11
  %239 = load i64* %tncrs, align 8
  %add272 = add i64 %239, %conv270
  store i64 %add272, i64* %tncrs, align 8
  br label %if.end273

if.end273:                                        ; preds = %if.then268, %land.lhs.true, %if.then255
  br label %if.end274

if.end274:                                        ; preds = %if.end273, %for.end63
  %240 = load %struct.e1000_hw** %hw, align 8
  %call275 = call i32 @igb_rd32(%struct.e1000_hw* %240, i32 16632) noredzone
  %conv276 = zext i32 %call275 to i64
  %241 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats277 = getelementptr inbounds %struct.igb_adapter* %241, i32 0, i32 36
  %tsctc = getelementptr inbounds %struct.e1000_hw_stats* %stats277, i32 0, i32 52
  %242 = load i64* %tsctc, align 8
  %add278 = add i64 %242, %conv276
  store i64 %add278, i64* %tsctc, align 8
  %243 = load %struct.e1000_hw** %hw, align 8
  %call279 = call i32 @igb_rd32(%struct.e1000_hw* %243, i32 16636) noredzone
  %conv280 = zext i32 %call279 to i64
  %244 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats281 = getelementptr inbounds %struct.igb_adapter* %244, i32 0, i32 36
  %tsctfc = getelementptr inbounds %struct.e1000_hw_stats* %stats281, i32 0, i32 53
  %245 = load i64* %tsctfc, align 8
  %add282 = add i64 %245, %conv280
  store i64 %add282, i64* %tsctfc, align 8
  %246 = load %struct.e1000_hw** %hw, align 8
  %call283 = call i32 @igb_rd32(%struct.e1000_hw* %246, i32 16640) noredzone
  %conv284 = zext i32 %call283 to i64
  %247 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats285 = getelementptr inbounds %struct.igb_adapter* %247, i32 0, i32 36
  %iac = getelementptr inbounds %struct.e1000_hw_stats* %stats285, i32 0, i32 54
  %248 = load i64* %iac, align 8
  %add286 = add i64 %248, %conv284
  store i64 %add286, i64* %iac, align 8
  %249 = load %struct.e1000_hw** %hw, align 8
  %call287 = call i32 @igb_rd32(%struct.e1000_hw* %249, i32 16676) noredzone
  %conv288 = zext i32 %call287 to i64
  %250 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats289 = getelementptr inbounds %struct.igb_adapter* %250, i32 0, i32 36
  %icrxoc = getelementptr inbounds %struct.e1000_hw_stats* %stats289, i32 0, i32 62
  %251 = load i64* %icrxoc, align 8
  %add290 = add i64 %251, %conv288
  store i64 %add290, i64* %icrxoc, align 8
  %252 = load %struct.e1000_hw** %hw, align 8
  %call291 = call i32 @igb_rd32(%struct.e1000_hw* %252, i32 16644) noredzone
  %conv292 = zext i32 %call291 to i64
  %253 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats293 = getelementptr inbounds %struct.igb_adapter* %253, i32 0, i32 36
  %icrxptc = getelementptr inbounds %struct.e1000_hw_stats* %stats293, i32 0, i32 55
  %254 = load i64* %icrxptc, align 8
  %add294 = add i64 %254, %conv292
  store i64 %add294, i64* %icrxptc, align 8
  %255 = load %struct.e1000_hw** %hw, align 8
  %call295 = call i32 @igb_rd32(%struct.e1000_hw* %255, i32 16648) noredzone
  %conv296 = zext i32 %call295 to i64
  %256 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats297 = getelementptr inbounds %struct.igb_adapter* %256, i32 0, i32 36
  %icrxatc = getelementptr inbounds %struct.e1000_hw_stats* %stats297, i32 0, i32 56
  %257 = load i64* %icrxatc, align 8
  %add298 = add i64 %257, %conv296
  store i64 %add298, i64* %icrxatc, align 8
  %258 = load %struct.e1000_hw** %hw, align 8
  %call299 = call i32 @igb_rd32(%struct.e1000_hw* %258, i32 16652) noredzone
  %conv300 = zext i32 %call299 to i64
  %259 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats301 = getelementptr inbounds %struct.igb_adapter* %259, i32 0, i32 36
  %ictxptc = getelementptr inbounds %struct.e1000_hw_stats* %stats301, i32 0, i32 57
  %260 = load i64* %ictxptc, align 8
  %add302 = add i64 %260, %conv300
  store i64 %add302, i64* %ictxptc, align 8
  %261 = load %struct.e1000_hw** %hw, align 8
  %call303 = call i32 @igb_rd32(%struct.e1000_hw* %261, i32 16656) noredzone
  %conv304 = zext i32 %call303 to i64
  %262 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats305 = getelementptr inbounds %struct.igb_adapter* %262, i32 0, i32 36
  %ictxatc = getelementptr inbounds %struct.e1000_hw_stats* %stats305, i32 0, i32 58
  %263 = load i64* %ictxatc, align 8
  %add306 = add i64 %263, %conv304
  store i64 %add306, i64* %ictxatc, align 8
  %264 = load %struct.e1000_hw** %hw, align 8
  %call307 = call i32 @igb_rd32(%struct.e1000_hw* %264, i32 16664) noredzone
  %conv308 = zext i32 %call307 to i64
  %265 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats309 = getelementptr inbounds %struct.igb_adapter* %265, i32 0, i32 36
  %ictxqec = getelementptr inbounds %struct.e1000_hw_stats* %stats309, i32 0, i32 59
  %266 = load i64* %ictxqec, align 8
  %add310 = add i64 %266, %conv308
  store i64 %add310, i64* %ictxqec, align 8
  %267 = load %struct.e1000_hw** %hw, align 8
  %call311 = call i32 @igb_rd32(%struct.e1000_hw* %267, i32 16668) noredzone
  %conv312 = zext i32 %call311 to i64
  %268 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats313 = getelementptr inbounds %struct.igb_adapter* %268, i32 0, i32 36
  %ictxqmtc = getelementptr inbounds %struct.e1000_hw_stats* %stats313, i32 0, i32 60
  %269 = load i64* %ictxqmtc, align 8
  %add314 = add i64 %269, %conv312
  store i64 %add314, i64* %ictxqmtc, align 8
  %270 = load %struct.e1000_hw** %hw, align 8
  %call315 = call i32 @igb_rd32(%struct.e1000_hw* %270, i32 16672) noredzone
  %conv316 = zext i32 %call315 to i64
  %271 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats317 = getelementptr inbounds %struct.igb_adapter* %271, i32 0, i32 36
  %icrxdmtc = getelementptr inbounds %struct.e1000_hw_stats* %stats317, i32 0, i32 61
  %272 = load i64* %icrxdmtc, align 8
  %add318 = add i64 %272, %conv316
  store i64 %add318, i64* %icrxdmtc, align 8
  %273 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats319 = getelementptr inbounds %struct.igb_adapter* %273, i32 0, i32 36
  %mprc320 = getelementptr inbounds %struct.e1000_hw_stats* %stats319, i32 0, i32 28
  %274 = load i64* %mprc320, align 8
  %275 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %multicast = getelementptr inbounds %struct.rtnl_link_stats64* %275, i32 0, i32 8
  store i64 %274, i64* %multicast, align 8
  %276 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats321 = getelementptr inbounds %struct.igb_adapter* %276, i32 0, i32 36
  %colc322 = getelementptr inbounds %struct.e1000_hw_stats* %stats321, i32 0, i32 9
  %277 = load i64* %colc322, align 8
  %278 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %collisions = getelementptr inbounds %struct.rtnl_link_stats64* %278, i32 0, i32 9
  store i64 %277, i64* %collisions, align 8
  %279 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats323 = getelementptr inbounds %struct.igb_adapter* %279, i32 0, i32 36
  %rxerrc324 = getelementptr inbounds %struct.e1000_hw_stats* %stats323, i32 0, i32 3
  %280 = load i64* %rxerrc324, align 8
  %281 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats325 = getelementptr inbounds %struct.igb_adapter* %281, i32 0, i32 36
  %crcerrs326 = getelementptr inbounds %struct.e1000_hw_stats* %stats325, i32 0, i32 0
  %282 = load i64* %crcerrs326, align 8
  %add327 = add i64 %280, %282
  %283 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats328 = getelementptr inbounds %struct.igb_adapter* %283, i32 0, i32 36
  %algnerrc329 = getelementptr inbounds %struct.e1000_hw_stats* %stats328, i32 0, i32 1
  %284 = load i64* %algnerrc329, align 8
  %add330 = add i64 %add327, %284
  %285 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats331 = getelementptr inbounds %struct.igb_adapter* %285, i32 0, i32 36
  %ruc332 = getelementptr inbounds %struct.e1000_hw_stats* %stats331, i32 0, i32 33
  %286 = load i64* %ruc332, align 8
  %add333 = add i64 %add330, %286
  %287 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats334 = getelementptr inbounds %struct.igb_adapter* %287, i32 0, i32 36
  %roc335 = getelementptr inbounds %struct.e1000_hw_stats* %stats334, i32 0, i32 35
  %288 = load i64* %roc335, align 8
  %add336 = add i64 %add333, %288
  %289 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats337 = getelementptr inbounds %struct.igb_adapter* %289, i32 0, i32 36
  %cexterr = getelementptr inbounds %struct.e1000_hw_stats* %stats337, i32 0, i32 13
  %290 = load i64* %cexterr, align 8
  %add338 = add i64 %add336, %290
  %291 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_errors = getelementptr inbounds %struct.rtnl_link_stats64* %291, i32 0, i32 4
  store i64 %add338, i64* %rx_errors, align 8
  %292 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats339 = getelementptr inbounds %struct.igb_adapter* %292, i32 0, i32 36
  %ruc340 = getelementptr inbounds %struct.e1000_hw_stats* %stats339, i32 0, i32 33
  %293 = load i64* %ruc340, align 8
  %294 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats341 = getelementptr inbounds %struct.igb_adapter* %294, i32 0, i32 36
  %roc342 = getelementptr inbounds %struct.e1000_hw_stats* %stats341, i32 0, i32 35
  %295 = load i64* %roc342, align 8
  %add343 = add i64 %293, %295
  %296 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_length_errors = getelementptr inbounds %struct.rtnl_link_stats64* %296, i32 0, i32 10
  store i64 %add343, i64* %rx_length_errors, align 8
  %297 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats344 = getelementptr inbounds %struct.igb_adapter* %297, i32 0, i32 36
  %crcerrs345 = getelementptr inbounds %struct.e1000_hw_stats* %stats344, i32 0, i32 0
  %298 = load i64* %crcerrs345, align 8
  %299 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_crc_errors = getelementptr inbounds %struct.rtnl_link_stats64* %299, i32 0, i32 12
  store i64 %298, i64* %rx_crc_errors, align 8
  %300 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats346 = getelementptr inbounds %struct.igb_adapter* %300, i32 0, i32 36
  %algnerrc347 = getelementptr inbounds %struct.e1000_hw_stats* %stats346, i32 0, i32 1
  %301 = load i64* %algnerrc347, align 8
  %302 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_frame_errors = getelementptr inbounds %struct.rtnl_link_stats64* %302, i32 0, i32 13
  store i64 %301, i64* %rx_frame_errors, align 8
  %303 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats348 = getelementptr inbounds %struct.igb_adapter* %303, i32 0, i32 36
  %mpc349 = getelementptr inbounds %struct.e1000_hw_stats* %stats348, i32 0, i32 4
  %304 = load i64* %mpc349, align 8
  %305 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %rx_missed_errors = getelementptr inbounds %struct.rtnl_link_stats64* %305, i32 0, i32 15
  store i64 %304, i64* %rx_missed_errors, align 8
  %306 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats350 = getelementptr inbounds %struct.igb_adapter* %306, i32 0, i32 36
  %ecol351 = getelementptr inbounds %struct.e1000_hw_stats* %stats350, i32 0, i32 6
  %307 = load i64* %ecol351, align 8
  %308 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats352 = getelementptr inbounds %struct.igb_adapter* %308, i32 0, i32 36
  %latecol353 = getelementptr inbounds %struct.e1000_hw_stats* %stats352, i32 0, i32 8
  %309 = load i64* %latecol353, align 8
  %add354 = add i64 %307, %309
  %310 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %tx_errors = getelementptr inbounds %struct.rtnl_link_stats64* %310, i32 0, i32 5
  store i64 %add354, i64* %tx_errors, align 8
  %311 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats355 = getelementptr inbounds %struct.igb_adapter* %311, i32 0, i32 36
  %ecol356 = getelementptr inbounds %struct.e1000_hw_stats* %stats355, i32 0, i32 6
  %312 = load i64* %ecol356, align 8
  %313 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %tx_aborted_errors = getelementptr inbounds %struct.rtnl_link_stats64* %313, i32 0, i32 16
  store i64 %312, i64* %tx_aborted_errors, align 8
  %314 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats357 = getelementptr inbounds %struct.igb_adapter* %314, i32 0, i32 36
  %latecol358 = getelementptr inbounds %struct.e1000_hw_stats* %stats357, i32 0, i32 8
  %315 = load i64* %latecol358, align 8
  %316 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %tx_window_errors = getelementptr inbounds %struct.rtnl_link_stats64* %316, i32 0, i32 20
  store i64 %315, i64* %tx_window_errors, align 8
  %317 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats359 = getelementptr inbounds %struct.igb_adapter* %317, i32 0, i32 36
  %tncrs360 = getelementptr inbounds %struct.e1000_hw_stats* %stats359, i32 0, i32 11
  %318 = load i64* %tncrs360, align 8
  %319 = load %struct.rtnl_link_stats64** %net_stats.addr, align 8
  %tx_carrier_errors = getelementptr inbounds %struct.rtnl_link_stats64* %319, i32 0, i32 17
  store i64 %318, i64* %tx_carrier_errors, align 8
  %320 = load %struct.e1000_hw** %hw, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %320, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %321 = load i32* %media_type, align 4
  %cmp361 = icmp eq i32 %321, 1
  br i1 %cmp361, label %if.then363, label %if.end378

if.then363:                                       ; preds = %if.end274
  %322 = load %struct.igb_adapter** %adapter.addr, align 8
  %link_speed364 = getelementptr inbounds %struct.igb_adapter* %322, i32 0, i32 24
  %323 = load i16* %link_speed364, align 2
  %conv365 = zext i16 %323 to i32
  %cmp366 = icmp eq i32 %conv365, 1000
  br i1 %cmp366, label %land.lhs.true368, label %if.end377

land.lhs.true368:                                 ; preds = %if.then363
  %324 = load %struct.e1000_hw** %hw, align 8
  %call369 = call i32 @igb_read_phy_reg(%struct.e1000_hw* %324, i32 10, i16* %phy_tmp) noredzone
  %tobool370 = icmp ne i32 %call369, 0
  br i1 %tobool370, label %if.end377, label %if.then371

if.then371:                                       ; preds = %land.lhs.true368
  %325 = load i16* %phy_tmp, align 2
  %conv372 = zext i16 %325 to i32
  %and373 = and i32 %conv372, 255
  %conv374 = trunc i32 %and373 to i16
  store i16 %conv374, i16* %phy_tmp, align 2
  %326 = load i16* %phy_tmp, align 2
  %conv375 = zext i16 %326 to i32
  %327 = load %struct.igb_adapter** %adapter.addr, align 8
  %phy_stats = getelementptr inbounds %struct.igb_adapter* %327, i32 0, i32 38
  %idle_errors = getelementptr inbounds %struct.e1000_phy_stats* %phy_stats, i32 0, i32 0
  %328 = load i32* %idle_errors, align 4
  %add376 = add i32 %328, %conv375
  store i32 %add376, i32* %idle_errors, align 4
  br label %if.end377

if.end377:                                        ; preds = %if.then371, %land.lhs.true368, %if.then363
  br label %if.end378

if.end378:                                        ; preds = %if.end377, %if.end274
  %329 = load %struct.e1000_hw** %hw, align 8
  %call379 = call i32 @igb_rd32(%struct.e1000_hw* %329, i32 16572) noredzone
  %conv380 = zext i32 %call379 to i64
  %330 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats381 = getelementptr inbounds %struct.igb_adapter* %330, i32 0, i32 36
  %mgptc = getelementptr inbounds %struct.e1000_hw_stats* %stats381, i32 0, i32 39
  %331 = load i64* %mgptc, align 8
  %add382 = add i64 %331, %conv380
  store i64 %add382, i64* %mgptc, align 8
  %332 = load %struct.e1000_hw** %hw, align 8
  %call383 = call i32 @igb_rd32(%struct.e1000_hw* %332, i32 16564) noredzone
  %conv384 = zext i32 %call383 to i64
  %333 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats385 = getelementptr inbounds %struct.igb_adapter* %333, i32 0, i32 36
  %mgprc = getelementptr inbounds %struct.e1000_hw_stats* %stats385, i32 0, i32 37
  %334 = load i64* %mgprc, align 8
  %add386 = add i64 %334, %conv384
  store i64 %add386, i64* %mgprc, align 8
  %335 = load %struct.e1000_hw** %hw, align 8
  %call387 = call i32 @igb_rd32(%struct.e1000_hw* %335, i32 16568) noredzone
  %conv388 = zext i32 %call387 to i64
  %336 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats389 = getelementptr inbounds %struct.igb_adapter* %336, i32 0, i32 36
  %mgpdc = getelementptr inbounds %struct.e1000_hw_stats* %stats389, i32 0, i32 38
  %337 = load i64* %mgpdc, align 8
  %add390 = add i64 %337, %conv388
  store i64 %add390, i64* %mgpdc, align 8
  %338 = load %struct.e1000_hw** %hw, align 8
  %call391 = call i32 @igb_rd32(%struct.e1000_hw* %338, i32 22560) noredzone
  store i32 %call391, i32* %reg, align 4
  %339 = load i32* %reg, align 4
  %and392 = and i32 %339, 268435456
  %tobool393 = icmp ne i32 %and392, 0
  br i1 %tobool393, label %if.then394, label %if.end411

if.then394:                                       ; preds = %if.end378
  %340 = load %struct.e1000_hw** %hw, align 8
  %call395 = call i32 @igb_rd32(%struct.e1000_hw* %340, i32 36836) noredzone
  %conv396 = zext i32 %call395 to i64
  %341 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats397 = getelementptr inbounds %struct.igb_adapter* %341, i32 0, i32 36
  %o2bgptc = getelementptr inbounds %struct.e1000_hw_stats* %stats397, i32 0, i32 76
  %342 = load i64* %o2bgptc, align 8
  %add398 = add i64 %342, %conv396
  store i64 %add398, i64* %o2bgptc, align 8
  %343 = load %struct.e1000_hw** %hw, align 8
  %call399 = call i32 @igb_rd32(%struct.e1000_hw* %343, i32 16732) noredzone
  %conv400 = zext i32 %call399 to i64
  %344 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats401 = getelementptr inbounds %struct.igb_adapter* %344, i32 0, i32 36
  %o2bspc = getelementptr inbounds %struct.e1000_hw_stats* %stats401, i32 0, i32 77
  %345 = load i64* %o2bspc, align 8
  %add402 = add i64 %345, %conv400
  store i64 %add402, i64* %o2bspc, align 8
  %346 = load %struct.e1000_hw** %hw, align 8
  %call403 = call i32 @igb_rd32(%struct.e1000_hw* %346, i32 36832) noredzone
  %conv404 = zext i32 %call403 to i64
  %347 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats405 = getelementptr inbounds %struct.igb_adapter* %347, i32 0, i32 36
  %b2ospc = getelementptr inbounds %struct.e1000_hw_stats* %stats405, i32 0, i32 78
  %348 = load i64* %b2ospc, align 8
  %add406 = add i64 %348, %conv404
  store i64 %add406, i64* %b2ospc, align 8
  %349 = load %struct.e1000_hw** %hw, align 8
  %call407 = call i32 @igb_rd32(%struct.e1000_hw* %349, i32 16728) noredzone
  %conv408 = zext i32 %call407 to i64
  %350 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats409 = getelementptr inbounds %struct.igb_adapter* %350, i32 0, i32 36
  %b2ogprc = getelementptr inbounds %struct.e1000_hw_stats* %stats409, i32 0, i32 79
  %351 = load i64* %b2ogprc, align 8
  %add410 = add i64 %351, %conv408
  store i64 %add410, i64* %b2ogprc, align 8
  br label %if.end411

if.end411:                                        ; preds = %if.then, %if.then4, %if.then394, %if.end378
  ret void
}

define internal void @spin_unlock(%struct.spinlock* %lock) nounwind inlinehint noredzone {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.3* %1 to %struct.raw_spinlock*
  call void @__raw_spin_unlock(%struct.raw_spinlock* %rlock) noredzone
  ret void
}

define internal i32 @pci_channel_offline(%struct.pci_dev* %pdev) nounwind inlinehint noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %error_state = getelementptr inbounds %struct.pci_dev* %0, i32 0, i32 32
  %1 = load i32* %error_state, align 4
  %cmp = icmp ne i32 %1, 1
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define void @igb_reset(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %mac = alloca %struct.e1000_mac_info*, align 8
  %fc = alloca %struct.e1000_fc_info*, align 8
  %pba = alloca i32, align 4
  %tx_space = alloca i32, align 4
  %min_tx_space = alloca i32, align 4
  %min_rx_space = alloca i32, align 4
  %hwm = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr46 = alloca i8*, align 8
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  %i = alloca i32, align 4
  %hw_addr83 = alloca i8*, align 8
  %hw_addr100 = alloca i8*, align 8
  %hw_addr120 = alloca i8*, align 8
  %hw_addr205 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %mac3 = getelementptr inbounds %struct.e1000_hw* %3, i32 0, i32 4
  store %struct.e1000_mac_info* %mac3, %struct.e1000_mac_info** %mac, align 8
  %4 = load %struct.e1000_hw** %hw, align 8
  %fc4 = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 5
  store %struct.e1000_fc_info* %fc4, %struct.e1000_fc_info** %fc, align 8
  store i32 0, i32* %pba, align 4
  %5 = load %struct.e1000_mac_info** %mac, align 8
  %type = getelementptr inbounds %struct.e1000_mac_info* %5, i32 0, i32 3
  %6 = load i32* %type, align 4
  switch i32 %6, label %sw.default [
    i32 4, label %sw.bb
    i32 5, label %sw.bb
    i32 3, label %sw.bb
    i32 2, label %sw.bb6
    i32 1, label %sw.bb8
    i32 6, label %sw.bb8
    i32 7, label %sw.bb8
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %7 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %7, i32 9220) noredzone
  store i32 %call, i32* %pba, align 4
  %8 = load i32* %pba, align 4
  %call5 = call zeroext i16 @igb_rxpbs_adjust_82580(i32 %8) noredzone
  %conv = zext i16 %call5 to i32
  store i32 %conv, i32* %pba, align 4
  br label %sw.epilog

sw.bb6:                                           ; preds = %entry
  %9 = load %struct.e1000_hw** %hw, align 8
  %call7 = call i32 @igb_rd32(%struct.e1000_hw* %9, i32 9220) noredzone
  store i32 %call7, i32* %pba, align 4
  %10 = load i32* %pba, align 4
  %and = and i32 %10, 127
  store i32 %and, i32* %pba, align 4
  br label %sw.epilog

sw.bb8:                                           ; preds = %entry, %entry, %entry
  br label %sw.default

sw.default:                                       ; preds = %entry, %sw.bb8
  store i32 34, i32* %pba, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb6, %sw.bb
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 16
  %12 = load i32* %max_frame_size, align 4
  %cmp = icmp ugt i32 %12, 1518
  br i1 %cmp, label %land.lhs.true, label %if.end62

land.lhs.true:                                    ; preds = %sw.epilog
  %13 = load %struct.e1000_mac_info** %mac, align 8
  %type10 = getelementptr inbounds %struct.e1000_mac_info* %13, i32 0, i32 3
  %14 = load i32* %type10, align 4
  %cmp11 = icmp ult i32 %14, 2
  br i1 %cmp11, label %if.then, label %if.end62

if.then:                                          ; preds = %land.lhs.true
  br label %do.body

do.body:                                          ; preds = %if.then
  %15 = load %struct.e1000_hw** %hw, align 8
  %hw_addr13 = getelementptr inbounds %struct.e1000_hw* %15, i32 0, i32 1
  %16 = load volatile i8** %hw_addr13, align 8
  store i8* %16, i8** %hw_addr, align 8
  %17 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %17, null
  %lnot = xor i1 %tobool, true
  %lnot14 = xor i1 %lnot, true
  %lnot15 = xor i1 %lnot14, true
  %lnot.ext = zext i1 %lnot15 to i32
  %conv16 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv16, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %tobool17, label %if.end, label %if.then18

if.then18:                                        ; preds = %do.body
  %18 = load i32* %pba, align 4
  %19 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %19, i64 4096
  call void @writel(i32 %18, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then18, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %20 = load %struct.e1000_hw** %hw, align 8
  %call19 = call i32 @igb_rd32(%struct.e1000_hw* %20, i32 4096) noredzone
  store i32 %call19, i32* %pba, align 4
  %21 = load i32* %pba, align 4
  %shr = lshr i32 %21, 16
  store i32 %shr, i32* %tx_space, align 4
  %22 = load i32* %pba, align 4
  %and20 = and i32 %22, 65535
  store i32 %and20, i32* %pba, align 4
  %23 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size21 = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 16
  %24 = load i32* %max_frame_size21, align 4
  %conv22 = zext i32 %24 to i64
  %add = add i64 %conv22, 16
  %sub = sub i64 %add, 4
  %mul = mul i64 %sub, 2
  %conv23 = trunc i64 %mul to i32
  store i32 %conv23, i32* %min_tx_space, align 4
  %25 = load i32* %min_tx_space, align 4
  %add24 = add i32 %25, 1023
  %and25 = and i32 %add24, -1024
  store i32 %and25, i32* %min_tx_space, align 4
  %26 = load i32* %min_tx_space, align 4
  %shr26 = lshr i32 %26, 10
  store i32 %shr26, i32* %min_tx_space, align 4
  %27 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size27 = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 16
  %28 = load i32* %max_frame_size27, align 4
  store i32 %28, i32* %min_rx_space, align 4
  %29 = load i32* %min_rx_space, align 4
  %add28 = add i32 %29, 1023
  %and29 = and i32 %add28, -1024
  store i32 %and29, i32* %min_rx_space, align 4
  %30 = load i32* %min_rx_space, align 4
  %shr30 = lshr i32 %30, 10
  store i32 %shr30, i32* %min_rx_space, align 4
  %31 = load i32* %tx_space, align 4
  %32 = load i32* %min_tx_space, align 4
  %cmp31 = icmp ult i32 %31, %32
  br i1 %cmp31, label %land.lhs.true33, label %if.end44

land.lhs.true33:                                  ; preds = %do.end
  %33 = load i32* %min_tx_space, align 4
  %34 = load i32* %tx_space, align 4
  %sub34 = sub i32 %33, %34
  %35 = load i32* %pba, align 4
  %cmp35 = icmp ult i32 %sub34, %35
  br i1 %cmp35, label %if.then37, label %if.end44

if.then37:                                        ; preds = %land.lhs.true33
  %36 = load i32* %pba, align 4
  %37 = load i32* %min_tx_space, align 4
  %38 = load i32* %tx_space, align 4
  %sub38 = sub i32 %37, %38
  %sub39 = sub i32 %36, %sub38
  store i32 %sub39, i32* %pba, align 4
  %39 = load i32* %pba, align 4
  %40 = load i32* %min_rx_space, align 4
  %cmp40 = icmp ult i32 %39, %40
  br i1 %cmp40, label %if.then42, label %if.end43

if.then42:                                        ; preds = %if.then37
  %41 = load i32* %min_rx_space, align 4
  store i32 %41, i32* %pba, align 4
  br label %if.end43

if.end43:                                         ; preds = %if.then42, %if.then37
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %land.lhs.true33, %do.end
  br label %do.body45

do.body45:                                        ; preds = %if.end44
  %42 = load %struct.e1000_hw** %hw, align 8
  %hw_addr47 = getelementptr inbounds %struct.e1000_hw* %42, i32 0, i32 1
  %43 = load volatile i8** %hw_addr47, align 8
  store i8* %43, i8** %hw_addr46, align 8
  %44 = load i8** %hw_addr46, align 8
  %tobool48 = icmp ne i8* %44, null
  %lnot49 = xor i1 %tobool48, true
  %lnot51 = xor i1 %lnot49, true
  %lnot53 = xor i1 %lnot51, true
  %lnot.ext54 = zext i1 %lnot53 to i32
  %conv55 = sext i32 %lnot.ext54 to i64
  %expval56 = call i64 @llvm.expect.i64(i64 %conv55, i64 0)
  %tobool57 = icmp ne i64 %expval56, 0
  br i1 %tobool57, label %if.end60, label %if.then58

if.then58:                                        ; preds = %do.body45
  %45 = load i32* %pba, align 4
  %46 = load i8** %hw_addr46, align 8
  %arrayidx59 = getelementptr i8* %46, i64 4096
  call void @writel(i32 %45, i8* %arrayidx59) noredzone
  br label %if.end60

if.end60:                                         ; preds = %if.then58, %do.body45
  br label %do.end61

do.end61:                                         ; preds = %if.end60
  br label %if.end62

if.end62:                                         ; preds = %do.end61, %land.lhs.true, %sw.epilog
  %47 = load i32* %pba, align 4
  %shl = shl i32 %47, 10
  %mul63 = mul i32 %shl, 9
  %div = udiv i32 %mul63, 10
  store i32 %div, i32* %_min1, align 4
  %48 = load i32* %pba, align 4
  %shl64 = shl i32 %48, 10
  %49 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size65 = getelementptr inbounds %struct.igb_adapter* %49, i32 0, i32 16
  %50 = load i32* %max_frame_size65, align 4
  %mul66 = mul i32 2, %50
  %sub67 = sub i32 %shl64, %mul66
  store i32 %sub67, i32* %_min2, align 4
  %cmp68 = icmp eq i32* %_min1, %_min2
  %conv69 = zext i1 %cmp68 to i32
  %51 = load i32* %_min1, align 4
  %52 = load i32* %_min2, align 4
  %cmp70 = icmp ult i32 %51, %52
  br i1 %cmp70, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end62
  %53 = load i32* %_min1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.end62
  %54 = load i32* %_min2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %53, %cond.true ], [ %54, %cond.false ]
  store i32 %cond, i32* %hwm, align 4
  %55 = load i32* %hwm, align 4
  %and72 = and i32 %55, -16
  %56 = load %struct.e1000_fc_info** %fc, align 8
  %high_water = getelementptr inbounds %struct.e1000_fc_info* %56, i32 0, i32 0
  store i32 %and72, i32* %high_water, align 4
  %57 = load %struct.e1000_fc_info** %fc, align 8
  %high_water73 = getelementptr inbounds %struct.e1000_fc_info* %57, i32 0, i32 0
  %58 = load i32* %high_water73, align 4
  %sub74 = sub i32 %58, 16
  %59 = load %struct.e1000_fc_info** %fc, align 8
  %low_water = getelementptr inbounds %struct.e1000_fc_info* %59, i32 0, i32 1
  store i32 %sub74, i32* %low_water, align 4
  %60 = load %struct.e1000_fc_info** %fc, align 8
  %pause_time = getelementptr inbounds %struct.e1000_fc_info* %60, i32 0, i32 2
  store i16 -1, i16* %pause_time, align 2
  %61 = load %struct.e1000_fc_info** %fc, align 8
  %send_xon = getelementptr inbounds %struct.e1000_fc_info* %61, i32 0, i32 3
  store i8 1, i8* %send_xon, align 1
  %62 = load %struct.e1000_fc_info** %fc, align 8
  %requested_mode = getelementptr inbounds %struct.e1000_fc_info* %62, i32 0, i32 6
  %63 = load i32* %requested_mode, align 4
  %64 = load %struct.e1000_fc_info** %fc, align 8
  %current_mode = getelementptr inbounds %struct.e1000_fc_info* %64, i32 0, i32 5
  store i32 %63, i32* %current_mode, align 4
  %65 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %65, i32 0, i32 49
  %66 = load i32* %vfs_allocated_count, align 4
  %tobool75 = icmp ne i32 %66, 0
  br i1 %tobool75, label %if.then76, label %if.end116

if.then76:                                        ; preds = %cond.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then76
  %67 = load i32* %i, align 4
  %68 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count77 = getelementptr inbounds %struct.igb_adapter* %68, i32 0, i32 49
  %69 = load i32* %vfs_allocated_count77, align 4
  %cmp78 = icmp ult i32 %67, %69
  br i1 %cmp78, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %70 = load i32* %i, align 4
  %idxprom = sext i32 %70 to i64
  %71 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %71, i32 0, i32 50
  %72 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx80 = getelementptr %struct.vf_data_storage* %72, i64 %idxprom
  %flags = getelementptr inbounds %struct.vf_data_storage* %arrayidx80, i32 0, i32 4
  %73 = load i32* %flags, align 4
  %and81 = and i32 %73, 8
  store i32 %and81, i32* %flags, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %74 = load i32* %i, align 4
  %inc = add i32 %74, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %75 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_ping_all_vfs(%struct.igb_adapter* %75) noredzone
  br label %do.body82

do.body82:                                        ; preds = %for.end
  %76 = load %struct.e1000_hw** %hw, align 8
  %hw_addr84 = getelementptr inbounds %struct.e1000_hw* %76, i32 0, i32 1
  %77 = load volatile i8** %hw_addr84, align 8
  store i8* %77, i8** %hw_addr83, align 8
  %78 = load i8** %hw_addr83, align 8
  %tobool85 = icmp ne i8* %78, null
  %lnot86 = xor i1 %tobool85, true
  %lnot88 = xor i1 %lnot86, true
  %lnot90 = xor i1 %lnot88, true
  %lnot.ext91 = zext i1 %lnot90 to i32
  %conv92 = sext i32 %lnot.ext91 to i64
  %expval93 = call i64 @llvm.expect.i64(i64 %conv92, i64 0)
  %tobool94 = icmp ne i64 %expval93, 0
  br i1 %tobool94, label %if.end97, label %if.then95

if.then95:                                        ; preds = %do.body82
  %79 = load i8** %hw_addr83, align 8
  %arrayidx96 = getelementptr i8* %79, i64 3212
  call void @writel(i32 0, i8* %arrayidx96) noredzone
  br label %if.end97

if.end97:                                         ; preds = %if.then95, %do.body82
  br label %do.end98

do.end98:                                         ; preds = %if.end97
  br label %do.body99

do.body99:                                        ; preds = %do.end98
  %80 = load %struct.e1000_hw** %hw, align 8
  %hw_addr101 = getelementptr inbounds %struct.e1000_hw* %80, i32 0, i32 1
  %81 = load volatile i8** %hw_addr101, align 8
  store i8* %81, i8** %hw_addr100, align 8
  %82 = load i8** %hw_addr100, align 8
  %tobool102 = icmp ne i8* %82, null
  %lnot103 = xor i1 %tobool102, true
  %lnot105 = xor i1 %lnot103, true
  %lnot107 = xor i1 %lnot105, true
  %lnot.ext108 = zext i1 %lnot107 to i32
  %conv109 = sext i32 %lnot.ext108 to i64
  %expval110 = call i64 @llvm.expect.i64(i64 %conv109, i64 0)
  %tobool111 = icmp ne i64 %expval110, 0
  br i1 %tobool111, label %if.end114, label %if.then112

if.then112:                                       ; preds = %do.body99
  %83 = load i8** %hw_addr100, align 8
  %arrayidx113 = getelementptr i8* %83, i64 3216
  call void @writel(i32 0, i8* %arrayidx113) noredzone
  br label %if.end114

if.end114:                                        ; preds = %if.then112, %do.body99
  br label %do.end115

do.end115:                                        ; preds = %if.end114
  br label %if.end116

if.end116:                                        ; preds = %do.end115, %cond.end
  %84 = load %struct.e1000_hw** %hw, align 8
  %mac117 = getelementptr inbounds %struct.e1000_hw* %84, i32 0, i32 4
  %ops = getelementptr inbounds %struct.e1000_mac_info* %mac117, i32 0, i32 0
  %reset_hw = getelementptr inbounds %struct.e1000_mac_operations* %ops, i32 0, i32 1
  %85 = load i32 (%struct.e1000_hw*)** %reset_hw, align 8
  %86 = load %struct.e1000_hw** %hw, align 8
  %call118 = call i32 %85(%struct.e1000_hw* %86) noredzone
  br label %do.body119

do.body119:                                       ; preds = %if.end116
  %87 = load %struct.e1000_hw** %hw, align 8
  %hw_addr121 = getelementptr inbounds %struct.e1000_hw* %87, i32 0, i32 1
  %88 = load volatile i8** %hw_addr121, align 8
  store i8* %88, i8** %hw_addr120, align 8
  %89 = load i8** %hw_addr120, align 8
  %tobool122 = icmp ne i8* %89, null
  %lnot123 = xor i1 %tobool122, true
  %lnot125 = xor i1 %lnot123, true
  %lnot127 = xor i1 %lnot125, true
  %lnot.ext128 = zext i1 %lnot127 to i32
  %conv129 = sext i32 %lnot.ext128 to i64
  %expval130 = call i64 @llvm.expect.i64(i64 %conv129, i64 0)
  %tobool131 = icmp ne i64 %expval130, 0
  br i1 %tobool131, label %if.end134, label %if.then132

if.then132:                                       ; preds = %do.body119
  %90 = load i8** %hw_addr120, align 8
  %arrayidx133 = getelementptr i8* %90, i64 22528
  call void @writel(i32 0, i8* %arrayidx133) noredzone
  br label %if.end134

if.end134:                                        ; preds = %if.then132, %do.body119
  br label %do.end135

do.end135:                                        ; preds = %if.end134
  %91 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags136 = getelementptr inbounds %struct.igb_adapter* %91, i32 0, i32 3
  %92 = load i32* %flags136, align 4
  %and137 = and i32 %92, 1024
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %if.then139, label %if.end143

if.then139:                                       ; preds = %do.end135
  %93 = load %struct.igb_adapter** %adapter.addr, align 8
  %ei = getelementptr inbounds %struct.igb_adapter* %93, i32 0, i32 79
  %get_invariants = getelementptr inbounds %struct.e1000_info* %ei, i32 0, i32 0
  %94 = load i32 (%struct.e1000_hw*)** %get_invariants, align 8
  %95 = load %struct.e1000_hw** %hw, align 8
  %call140 = call i32 %94(%struct.e1000_hw* %95) noredzone
  %96 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags141 = getelementptr inbounds %struct.igb_adapter* %96, i32 0, i32 3
  %97 = load i32* %flags141, align 4
  %and142 = and i32 %97, -1025
  store i32 %and142, i32* %flags141, align 4
  br label %if.end143

if.end143:                                        ; preds = %if.then139, %do.end135
  %98 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags144 = getelementptr inbounds %struct.igb_adapter* %98, i32 0, i32 3
  %99 = load i32* %flags144, align 4
  %and145 = and i32 %99, 4096
  %tobool146 = icmp ne i32 %and145, 0
  br i1 %tobool146, label %if.then147, label %if.end153

if.then147:                                       ; preds = %if.end143
  %100 = load %struct.igb_adapter** %adapter.addr, align 8
  %call148 = call i32 @igb_enable_mas(%struct.igb_adapter* %100) noredzone
  %tobool149 = icmp ne i32 %call148, 0
  br i1 %tobool149, label %if.then150, label %if.end152

if.then150:                                       ; preds = %if.then147
  %101 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %101, i32 0, i32 33
  %call151 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([33 x i8]* @.str2, i32 0, i32 0)) noredzone
  br label %if.end152

if.end152:                                        ; preds = %if.then150, %if.then147
  br label %if.end153

if.end153:                                        ; preds = %if.end152, %if.end143
  %102 = load %struct.e1000_hw** %hw, align 8
  %mac154 = getelementptr inbounds %struct.e1000_hw* %102, i32 0, i32 4
  %ops155 = getelementptr inbounds %struct.e1000_mac_info* %mac154, i32 0, i32 0
  %init_hw = getelementptr inbounds %struct.e1000_mac_operations* %ops155, i32 0, i32 2
  %103 = load i32 (%struct.e1000_hw*)** %init_hw, align 8
  %104 = load %struct.e1000_hw** %hw, align 8
  %call156 = call i32 %103(%struct.e1000_hw* %104) noredzone
  %tobool157 = icmp ne i32 %call156, 0
  br i1 %tobool157, label %if.then158, label %if.end161

if.then158:                                       ; preds = %if.end153
  %105 = load %struct.pci_dev** %pdev, align 8
  %dev159 = getelementptr inbounds %struct.pci_dev* %105, i32 0, i32 33
  %call160 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev159, i8* getelementptr inbounds ([16 x i8]* @.str3, i32 0, i32 0)) noredzone
  br label %if.end161

if.end161:                                        ; preds = %if.then158, %if.end153
  %106 = load %struct.e1000_hw** %hw, align 8
  %mac162 = getelementptr inbounds %struct.e1000_hw* %106, i32 0, i32 4
  %autoneg = getelementptr inbounds %struct.e1000_mac_info* %mac162, i32 0, i32 17
  %107 = load i8* %autoneg, align 1
  %tobool163 = trunc i8 %107 to i1
  br i1 %tobool163, label %if.end166, label %if.then164

if.then164:                                       ; preds = %if.end161
  %108 = load %struct.e1000_hw** %hw, align 8
  %call165 = call i32 @igb_force_mac_fc(%struct.e1000_hw* %108) noredzone
  br label %if.end166

if.end166:                                        ; preds = %if.then164, %if.end161
  %109 = load %struct.igb_adapter** %adapter.addr, align 8
  %110 = load i32* %pba, align 4
  call void @igb_init_dmac(%struct.igb_adapter* %109, i32 %110) noredzone
  br i1 true, label %cond.true167, label %cond.false170

cond.true167:                                     ; preds = %if.end166
  %111 = load %struct.igb_adapter** %adapter.addr, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %111, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %112 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %112, 63
  %shl.i = shl i64 1, %and.i
  %113 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %113, 6
  %114 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %114, i64 %shr.i
  %115 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %115
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool169 = icmp ne i32 %conv.i, 0
  br i1 %tobool169, label %if.end189, label %if.then174

cond.false170:                                    ; preds = %if.end166
  %116 = load %struct.igb_adapter** %adapter.addr, align 8
  %state171 = getelementptr inbounds %struct.igb_adapter* %116, i32 0, i32 2
  %call172 = call i32 @variable_test_bit(i64 2, i64* %state171) noredzone
  %tobool173 = icmp ne i32 %call172, 0
  br i1 %tobool173, label %if.end189, label %if.then174

if.then174:                                       ; preds = %cond.false170, %cond.true167
  %117 = load %struct.e1000_mac_info** %mac, align 8
  %type175 = getelementptr inbounds %struct.e1000_mac_info* %117, i32 0, i32 3
  %118 = load i32* %type175, align 4
  %cmp176 = icmp eq i32 %118, 4
  br i1 %cmp176, label %land.lhs.true178, label %if.end188

land.lhs.true178:                                 ; preds = %if.then174
  %119 = load %struct.e1000_hw** %hw, align 8
  %bus = getelementptr inbounds %struct.e1000_hw* %119, i32 0, i32 8
  %func = getelementptr inbounds %struct.e1000_bus_info* %bus, i32 0, i32 4
  %120 = load i16* %func, align 2
  %conv179 = zext i16 %120 to i32
  %cmp180 = icmp eq i32 %conv179, 0
  br i1 %cmp180, label %if.then182, label %if.end188

if.then182:                                       ; preds = %land.lhs.true178
  %121 = load %struct.igb_adapter** %adapter.addr, align 8
  %ets = getelementptr inbounds %struct.igb_adapter* %121, i32 0, i32 71
  %122 = load i8* %ets, align 1
  %tobool183 = trunc i8 %122 to i1
  br i1 %tobool183, label %if.then184, label %if.end187

if.then184:                                       ; preds = %if.then182
  %123 = load %struct.e1000_mac_info** %mac, align 8
  %ops185 = getelementptr inbounds %struct.e1000_mac_info* %123, i32 0, i32 0
  %init_thermal_sensor_thresh = getelementptr inbounds %struct.e1000_mac_operations* %ops185, i32 0, i32 11
  %124 = load i32 (%struct.e1000_hw*)** %init_thermal_sensor_thresh, align 8
  %125 = load %struct.e1000_hw** %hw, align 8
  %call186 = call i32 %124(%struct.e1000_hw* %125) noredzone
  br label %if.end187

if.end187:                                        ; preds = %if.then184, %if.then182
  br label %if.end188

if.end188:                                        ; preds = %if.end187, %land.lhs.true178, %if.then174
  br label %if.end189

if.end189:                                        ; preds = %if.end188, %cond.false170, %cond.true167
  %126 = load %struct.e1000_hw** %hw, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %126, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %127 = load i32* %media_type, align 4
  %cmp190 = icmp eq i32 %127, 1
  br i1 %cmp190, label %if.then192, label %if.end200

if.then192:                                       ; preds = %if.end189
  %128 = load %struct.e1000_mac_info** %mac, align 8
  %type193 = getelementptr inbounds %struct.e1000_mac_info* %128, i32 0, i32 3
  %129 = load i32* %type193, align 4
  switch i32 %129, label %sw.default198 [
    i32 4, label %sw.bb194
    i32 6, label %sw.bb194
    i32 7, label %sw.bb194
    i32 5, label %sw.bb196
  ]

sw.bb194:                                         ; preds = %if.then192, %if.then192, %if.then192
  %130 = load %struct.e1000_hw** %hw, align 8
  %call195 = call i32 @igb_set_eee_i350(%struct.e1000_hw* %130) noredzone
  br label %sw.epilog199

sw.bb196:                                         ; preds = %if.then192
  %131 = load %struct.e1000_hw** %hw, align 8
  %call197 = call i32 @igb_set_eee_i354(%struct.e1000_hw* %131) noredzone
  br label %sw.epilog199

sw.default198:                                    ; preds = %if.then192
  br label %sw.epilog199

sw.epilog199:                                     ; preds = %sw.default198, %sw.bb196, %sw.bb194
  br label %if.end200

if.end200:                                        ; preds = %sw.epilog199, %if.end189
  %132 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %132, i32 0, i32 1
  %133 = load %struct.net_device** %netdev, align 8
  %call201 = call zeroext i1 @netif_running(%struct.net_device* %133) noredzone
  br i1 %call201, label %if.end203, label %if.then202

if.then202:                                       ; preds = %if.end200
  %134 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_power_down_link(%struct.igb_adapter* %134) noredzone
  br label %if.end203

if.end203:                                        ; preds = %if.then202, %if.end200
  %135 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_update_mng_vlan(%struct.igb_adapter* %135) noredzone
  br label %do.body204

do.body204:                                       ; preds = %if.end203
  %136 = load %struct.e1000_hw** %hw, align 8
  %hw_addr206 = getelementptr inbounds %struct.e1000_hw* %136, i32 0, i32 1
  %137 = load volatile i8** %hw_addr206, align 8
  store i8* %137, i8** %hw_addr205, align 8
  %138 = load i8** %hw_addr205, align 8
  %tobool207 = icmp ne i8* %138, null
  %lnot208 = xor i1 %tobool207, true
  %lnot210 = xor i1 %lnot208, true
  %lnot212 = xor i1 %lnot210, true
  %lnot.ext213 = zext i1 %lnot212 to i32
  %conv214 = sext i32 %lnot.ext213 to i64
  %expval215 = call i64 @llvm.expect.i64(i64 %conv214, i64 0)
  %tobool216 = icmp ne i64 %expval215, 0
  br i1 %tobool216, label %if.end219, label %if.then217

if.then217:                                       ; preds = %do.body204
  %139 = load i8** %hw_addr205, align 8
  %arrayidx218 = getelementptr i8* %139, i64 56
  call void @writel(i32 33024, i8* %arrayidx218) noredzone
  br label %if.end219

if.end219:                                        ; preds = %if.then217, %do.body204
  br label %do.end220

do.end220:                                        ; preds = %if.end219
  %140 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_ptp_reset(%struct.igb_adapter* %140) noredzone
  %141 = load %struct.e1000_hw** %hw, align 8
  %call221 = call i32 @igb_get_phy_info(%struct.e1000_hw* %141) noredzone
  ret void
}

define internal void @igb_clean_all_tx_rings(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 12
  %2 = load i32* %num_tx_queues, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom
  %5 = load %struct.igb_ring** %arrayidx, align 8
  call void @igb_clean_tx_ring(%struct.igb_ring* %5) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal void @igb_clean_all_rx_rings(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 14
  %2 = load i32* %num_rx_queues, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %5 = load %struct.igb_ring** %arrayidx, align 8
  call void @igb_clean_rx_ring(%struct.igb_ring* %5) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal void @igb_setup_dca(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 3
  %2 = load i32* %flags, align 4
  %and = and i32 %2, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %3 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %3, i32 0, i32 1
  %4 = load volatile i8** %hw_addr2, align 8
  store i8* %4, i8** %hw_addr, align 8
  %5 = load i8** %hw_addr, align 8
  %tobool3 = icmp ne i8* %5, null
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %do.body
  %6 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %6, i64 23412
  call void @writel(i32 2, i8* %arrayidx) noredzone
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %do.end
  %7 = load i32* %i, align 4
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 4
  %9 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %7, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32* %i, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 44
  %arrayidx10 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom
  %12 = load %struct.igb_q_vector** %arrayidx10, align 8
  %cpu = getelementptr inbounds %struct.igb_q_vector* %12, i32 0, i32 1
  store i32 -1, i32* %cpu, align 4
  %13 = load i32* %i, align 4
  %idxprom11 = sext i32 %13 to i64
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector12 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 44
  %arrayidx13 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector12, i32 0, i64 %idxprom11
  %15 = load %struct.igb_q_vector** %arrayidx13, align 8
  call void @igb_update_dca(%struct.igb_q_vector* %15) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %16 = load i32* %i, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

define void @igb_reinit_locked(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %pfo_ret__.i = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %__ret_warn_on = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = call i32 asm "movl %gs:${1:P},$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @__preempt_count) nounwind, !srcloc !7
  store i32 %0, i32* %pfo_ret__.i, align 4
  %1 = load i32* %pfo_ret__.i, align 4
  %and.i = and i32 %1, 2147483647
  %conv = sext i32 %and.i to i64
  %and = and i64 %conv, 2096896
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %2 = load i32* %__ret_warn_on, align 4
  %tobool2 = icmp ne i32 %2, 0
  %lnot3 = xor i1 %tobool2, true
  %lnot5 = xor i1 %lnot3, true
  %lnot.ext6 = zext i1 %lnot5 to i32
  %conv7 = sext i32 %lnot.ext6 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([56 x i8]* @.str1, i32 0, i32 0), i32 1826) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %3, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 2
  %call16 = call i32 @test_and_set_bit(i64 1, i64* %state) noredzone
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @usleep_range(i64 1000, i64 2000) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_down(%struct.igb_adapter* %5) noredzone
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %call18 = call i32 @igb_up(%struct.igb_adapter* %6) noredzone
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %state19 = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 2
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state19, i64** %addr.addr.i, align 8
  %8 = load i64** %addr.addr.i, align 8
  %9 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %8, i64 %9, i64* %8) nounwind, !srcloc !1
  ret void
}

declare void @warn_slowpath_null(i8*, i32) noredzone

define internal i32 @test_and_set_bit(i64 %nr, i64* %addr) nounwind inlinehint noredzone {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  %c = alloca i8, align 1
  store i64 %nr, i64* %nr.addr, align 8
  store i64* %addr, i64** %addr.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i64** %addr.addr, align 8
  %1 = load i64* %nr.addr, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $2, $0; setc $1", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %0, i8* %c, i64 %1, i64* %0) nounwind, !srcloc !8
  %2 = load i8* %c, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  br label %do.end

do.end:                                           ; preds = %do.body
  ret i32 %conv1
}

declare zeroext i16 @igb_rxpbs_adjust_82580(i32) noredzone

define internal void @igb_ping_all_vfs(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ping = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 49
  %3 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i32 256, i32* %ping, align 4
  %4 = load i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 50
  %6 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %6, i64 %idxprom
  %flags = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 4
  %7 = load i32* %flags, align 4
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %8 = load i32* %ping, align 4
  %or = or i32 %8, 536870912
  store i32 %or, i32* %ping, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %9 = load %struct.e1000_hw** %hw, align 8
  %10 = load i32* %i, align 4
  %conv = trunc i32 %10 to i16
  %call = call i32 @igb_write_mbx(%struct.e1000_hw* %9, i32* %ping, i16 zeroext 1, i16 zeroext %conv) noredzone
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %11 = load i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal i32 @igb_enable_mas(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %connsw = alloca i32, align 4
  %ret_val = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %ret_val, align 4
  %1 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 52) noredzone
  store i32 %call, i32* %connsw, align 4
  %2 = load %struct.e1000_hw** %hw, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %3 = load i32* %media_type, align 4
  %cmp = icmp eq i32 %3, 1
  br i1 %cmp, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %4 = load i32* %ret_val, align 4
  store i32 %4, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32* %connsw, align 4
  %and = and i32 %5, 512
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then2

if.then2:                                         ; preds = %if.end
  %6 = load i32* %connsw, align 4
  %or = or i32 %6, 4
  store i32 %or, i32* %connsw, align 4
  %7 = load i32* %connsw, align 4
  %or3 = or i32 %7, 1
  store i32 %or3, i32* %connsw, align 4
  br label %do.body

do.body:                                          ; preds = %if.then2
  %8 = load %struct.e1000_hw** %hw, align 8
  %hw_addr4 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr4, align 8
  store i8* %9, i8** %hw_addr, align 8
  %10 = load i8** %hw_addr, align 8
  %tobool5 = icmp ne i8* %10, null
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %do.body
  %11 = load i32* %connsw, align 4
  %12 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %12, i64 52
  call void @writel(i32 %11, i8* %arrayidx) noredzone
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end10
  %13 = load %struct.e1000_hw** %hw, align 8
  %call11 = call i32 @igb_rd32(%struct.e1000_hw* %13, i32 8) noredzone
  br label %if.end19

if.else:                                          ; preds = %if.end
  %14 = load i32* %connsw, align 4
  %and12 = and i32 %14, 512
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.else15

if.then14:                                        ; preds = %if.else
  %15 = load i32* %ret_val, align 4
  store i32 %15, i32* %retval
  br label %return

if.else15:                                        ; preds = %if.else
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 1
  %17 = load %struct.net_device** %netdev, align 8
  %call16 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %17, i8* getelementptr inbounds ([47 x i8]* @.str38, i32 0, i32 0)) noredzone
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 3
  %19 = load i32* %flags, align 4
  %and17 = and i32 %19, -4097
  store i32 %and17, i32* %flags, align 4
  br label %if.end18

if.end18:                                         ; preds = %if.else15
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %do.end
  %20 = load i32* %ret_val, align 4
  store i32 %20, i32* %retval
  br label %return

return:                                           ; preds = %if.end19, %if.then14, %if.then
  %21 = load i32* %retval
  ret i32 %21
}

declare i32 @dev_err(%struct.device*, i8*, ...) noredzone

declare i32 @igb_force_mac_fc(%struct.e1000_hw*) noredzone

define internal void @igb_init_dmac(%struct.igb_adapter* %adapter, i32 %pba) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %pba.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %dmac_thr = alloca i32, align 4
  %hwm = alloca i16, align 2
  %reg = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr24 = alloca i8*, align 8
  %hw_addr64 = alloca i8*, align 8
  %hw_addr81 = alloca i8*, align 8
  %hw_addr98 = alloca i8*, align 8
  %hw_addr115 = alloca i8*, align 8
  %hw_addr136 = alloca i8*, align 8
  %reg158 = alloca i32, align 4
  %hw_addr161 = alloca i8*, align 8
  %hw_addr179 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %pba, i32* %pba.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  %cmp = icmp ugt i32 %2, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 3
  %4 = load i32* %flags, align 4
  %and = and i32 %4, 16
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then2, label %if.end152

if.then2:                                         ; preds = %if.then
  br label %do.body

do.body:                                          ; preds = %if.then2
  %5 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 1
  %6 = load volatile i8** %hw_addr3, align 8
  store i8* %6, i8** %hw_addr, align 8
  %7 = load i8** %hw_addr, align 8
  %tobool4 = icmp ne i8* %7, null
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.end, label %if.then8

if.then8:                                         ; preds = %do.body
  %8 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %8, i64 13648
  call void @writel(i32 0, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then8, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %9 = load i32* %pba.addr, align 4
  %mul = mul i32 64, %9
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 16
  %11 = load i32* %max_frame_size, align 4
  %div = udiv i32 %11, 16
  %sub = sub i32 %mul, %div
  %conv9 = trunc i32 %sub to i16
  store i16 %conv9, i16* %hwm, align 2
  %12 = load i16* %hwm, align 2
  %conv10 = zext i16 %12 to i32
  %13 = load i32* %pba.addr, align 4
  %sub11 = sub i32 %13, 6
  %mul12 = mul i32 64, %sub11
  %cmp13 = icmp ult i32 %conv10, %mul12
  br i1 %cmp13, label %if.then15, label %if.end19

if.then15:                                        ; preds = %do.end
  %14 = load i32* %pba.addr, align 4
  %sub16 = sub i32 %14, 6
  %mul17 = mul i32 64, %sub16
  %conv18 = trunc i32 %mul17 to i16
  store i16 %conv18, i16* %hwm, align 2
  br label %if.end19

if.end19:                                         ; preds = %if.then15, %do.end
  %15 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %15, i32 8560) noredzone
  store i32 %call, i32* %reg, align 4
  %16 = load i32* %reg, align 4
  %and20 = and i32 %16, -262129
  store i32 %and20, i32* %reg, align 4
  %17 = load i16* %hwm, align 2
  %conv21 = zext i16 %17 to i32
  %shl = shl i32 %conv21, 4
  %and22 = and i32 %shl, 262128
  %18 = load i32* %reg, align 4
  %or = or i32 %18, %and22
  store i32 %or, i32* %reg, align 4
  br label %do.body23

do.body23:                                        ; preds = %if.end19
  %19 = load %struct.e1000_hw** %hw, align 8
  %hw_addr25 = getelementptr inbounds %struct.e1000_hw* %19, i32 0, i32 1
  %20 = load volatile i8** %hw_addr25, align 8
  store i8* %20, i8** %hw_addr24, align 8
  %21 = load i8** %hw_addr24, align 8
  %tobool26 = icmp ne i8* %21, null
  %lnot27 = xor i1 %tobool26, true
  %lnot29 = xor i1 %lnot27, true
  %lnot31 = xor i1 %lnot29, true
  %lnot.ext32 = zext i1 %lnot31 to i32
  %conv33 = sext i32 %lnot.ext32 to i64
  %expval34 = call i64 @llvm.expect.i64(i64 %conv33, i64 0)
  %tobool35 = icmp ne i64 %expval34, 0
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %do.body23
  %22 = load i32* %reg, align 4
  %23 = load i8** %hw_addr24, align 8
  %arrayidx37 = getelementptr i8* %23, i64 8560
  call void @writel(i32 %22, i8* %arrayidx37) noredzone
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %do.body23
  br label %do.end39

do.end39:                                         ; preds = %if.end38
  %24 = load i32* %pba.addr, align 4
  %25 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size40 = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 16
  %26 = load i32* %max_frame_size40, align 4
  %div41 = udiv i32 %26, 512
  %sub42 = sub i32 %24, %div41
  store i32 %sub42, i32* %dmac_thr, align 4
  %27 = load i32* %dmac_thr, align 4
  %28 = load i32* %pba.addr, align 4
  %sub43 = sub i32 %28, 10
  %cmp44 = icmp ult i32 %27, %sub43
  br i1 %cmp44, label %if.then46, label %if.end48

if.then46:                                        ; preds = %do.end39
  %29 = load i32* %pba.addr, align 4
  %sub47 = sub i32 %29, 10
  store i32 %sub47, i32* %dmac_thr, align 4
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %do.end39
  %30 = load %struct.e1000_hw** %hw, align 8
  %call49 = call i32 @igb_rd32(%struct.e1000_hw* %30, i32 9480) noredzone
  store i32 %call49, i32* %reg, align 4
  %31 = load i32* %reg, align 4
  %and50 = and i32 %31, -16711681
  store i32 %and50, i32* %reg, align 4
  %32 = load i32* %dmac_thr, align 4
  %shl51 = shl i32 %32, 16
  %and52 = and i32 %shl51, 16711680
  %33 = load i32* %reg, align 4
  %or53 = or i32 %33, %and52
  store i32 %or53, i32* %reg, align 4
  %34 = load i32* %reg, align 4
  %or54 = or i32 %34, -1342177280
  store i32 %or54, i32* %reg, align 4
  %35 = load i32* %reg, align 4
  %or55 = or i32 %35, 31
  store i32 %or55, i32* %reg, align 4
  %36 = load %struct.e1000_hw** %hw, align 8
  %mac56 = getelementptr inbounds %struct.e1000_hw* %36, i32 0, i32 4
  %type57 = getelementptr inbounds %struct.e1000_mac_info* %mac56, i32 0, i32 3
  %37 = load i32* %type57, align 4
  %cmp58 = icmp ne i32 %37, 5
  br i1 %cmp58, label %if.then60, label %if.end62

if.then60:                                        ; preds = %if.end48
  %38 = load i32* %reg, align 4
  %and61 = and i32 %38, -32769
  store i32 %and61, i32* %reg, align 4
  br label %if.end62

if.end62:                                         ; preds = %if.then60, %if.end48
  br label %do.body63

do.body63:                                        ; preds = %if.end62
  %39 = load %struct.e1000_hw** %hw, align 8
  %hw_addr65 = getelementptr inbounds %struct.e1000_hw* %39, i32 0, i32 1
  %40 = load volatile i8** %hw_addr65, align 8
  store i8* %40, i8** %hw_addr64, align 8
  %41 = load i8** %hw_addr64, align 8
  %tobool66 = icmp ne i8* %41, null
  %lnot67 = xor i1 %tobool66, true
  %lnot69 = xor i1 %lnot67, true
  %lnot71 = xor i1 %lnot69, true
  %lnot.ext72 = zext i1 %lnot71 to i32
  %conv73 = sext i32 %lnot.ext72 to i64
  %expval74 = call i64 @llvm.expect.i64(i64 %conv73, i64 0)
  %tobool75 = icmp ne i64 %expval74, 0
  br i1 %tobool75, label %if.end78, label %if.then76

if.then76:                                        ; preds = %do.body63
  %42 = load i32* %reg, align 4
  %43 = load i8** %hw_addr64, align 8
  %arrayidx77 = getelementptr i8* %43, i64 9480
  call void @writel(i32 %42, i8* %arrayidx77) noredzone
  br label %if.end78

if.end78:                                         ; preds = %if.then76, %do.body63
  br label %do.end79

do.end79:                                         ; preds = %if.end78
  br label %do.body80

do.body80:                                        ; preds = %do.end79
  %44 = load %struct.e1000_hw** %hw, align 8
  %hw_addr82 = getelementptr inbounds %struct.e1000_hw* %44, i32 0, i32 1
  %45 = load volatile i8** %hw_addr82, align 8
  store i8* %45, i8** %hw_addr81, align 8
  %46 = load i8** %hw_addr81, align 8
  %tobool83 = icmp ne i8* %46, null
  %lnot84 = xor i1 %tobool83, true
  %lnot86 = xor i1 %lnot84, true
  %lnot88 = xor i1 %lnot86, true
  %lnot.ext89 = zext i1 %lnot88 to i32
  %conv90 = sext i32 %lnot.ext89 to i64
  %expval91 = call i64 @llvm.expect.i64(i64 %conv90, i64 0)
  %tobool92 = icmp ne i64 %expval91, 0
  br i1 %tobool92, label %if.end95, label %if.then93

if.then93:                                        ; preds = %do.body80
  %47 = load i8** %hw_addr81, align 8
  %arrayidx94 = getelementptr i8* %47, i64 24016
  call void @writel(i32 0, i8* %arrayidx94) noredzone
  br label %if.end95

if.end95:                                         ; preds = %if.then93, %do.body80
  br label %do.end96

do.end96:                                         ; preds = %if.end95
  store i32 -2147483644, i32* %reg, align 4
  br label %do.body97

do.body97:                                        ; preds = %do.end96
  %48 = load %struct.e1000_hw** %hw, align 8
  %hw_addr99 = getelementptr inbounds %struct.e1000_hw* %48, i32 0, i32 1
  %49 = load volatile i8** %hw_addr99, align 8
  store i8* %49, i8** %hw_addr98, align 8
  %50 = load i8** %hw_addr98, align 8
  %tobool100 = icmp ne i8* %50, null
  %lnot101 = xor i1 %tobool100, true
  %lnot103 = xor i1 %lnot101, true
  %lnot105 = xor i1 %lnot103, true
  %lnot.ext106 = zext i1 %lnot105 to i32
  %conv107 = sext i32 %lnot.ext106 to i64
  %expval108 = call i64 @llvm.expect.i64(i64 %conv107, i64 0)
  %tobool109 = icmp ne i64 %expval108, 0
  br i1 %tobool109, label %if.end112, label %if.then110

if.then110:                                       ; preds = %do.body97
  %51 = load i32* %reg, align 4
  %52 = load i8** %hw_addr98, align 8
  %arrayidx111 = getelementptr i8* %52, i64 9492
  call void @writel(i32 %51, i8* %arrayidx111) noredzone
  br label %if.end112

if.end112:                                        ; preds = %if.then110, %do.body97
  br label %do.end113

do.end113:                                        ; preds = %if.end112
  br label %do.body114

do.body114:                                       ; preds = %do.end113
  %53 = load %struct.e1000_hw** %hw, align 8
  %hw_addr116 = getelementptr inbounds %struct.e1000_hw* %53, i32 0, i32 1
  %54 = load volatile i8** %hw_addr116, align 8
  store i8* %54, i8** %hw_addr115, align 8
  %55 = load i8** %hw_addr115, align 8
  %tobool117 = icmp ne i8* %55, null
  %lnot118 = xor i1 %tobool117, true
  %lnot120 = xor i1 %lnot118, true
  %lnot122 = xor i1 %lnot120, true
  %lnot.ext123 = zext i1 %lnot122 to i32
  %conv124 = sext i32 %lnot.ext123 to i64
  %expval125 = call i64 @llvm.expect.i64(i64 %conv124, i64 0)
  %tobool126 = icmp ne i64 %expval125, 0
  br i1 %tobool126, label %if.end131, label %if.then127

if.then127:                                       ; preds = %do.body114
  %56 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size128 = getelementptr inbounds %struct.igb_adapter* %56, i32 0, i32 16
  %57 = load i32* %max_frame_size128, align 4
  %add = add i32 4096, %57
  %sub129 = sub i32 20408, %add
  %shr = lshr i32 %sub129, 6
  %58 = load i8** %hw_addr115, align 8
  %arrayidx130 = getelementptr i8* %58, i64 13648
  call void @writel(i32 %shr, i8* %arrayidx130) noredzone
  br label %if.end131

if.end131:                                        ; preds = %if.then127, %do.body114
  br label %do.end132

do.end132:                                        ; preds = %if.end131
  %59 = load %struct.e1000_hw** %hw, align 8
  %call133 = call i32 @igb_rd32(%struct.e1000_hw* %59, i32 23480) noredzone
  store i32 %call133, i32* %reg, align 4
  %60 = load i32* %reg, align 4
  %and134 = and i32 %60, -129
  store i32 %and134, i32* %reg, align 4
  br label %do.body135

do.body135:                                       ; preds = %do.end132
  %61 = load %struct.e1000_hw** %hw, align 8
  %hw_addr137 = getelementptr inbounds %struct.e1000_hw* %61, i32 0, i32 1
  %62 = load volatile i8** %hw_addr137, align 8
  store i8* %62, i8** %hw_addr136, align 8
  %63 = load i8** %hw_addr136, align 8
  %tobool138 = icmp ne i8* %63, null
  %lnot139 = xor i1 %tobool138, true
  %lnot141 = xor i1 %lnot139, true
  %lnot143 = xor i1 %lnot141, true
  %lnot.ext144 = zext i1 %lnot143 to i32
  %conv145 = sext i32 %lnot.ext144 to i64
  %expval146 = call i64 @llvm.expect.i64(i64 %conv145, i64 0)
  %tobool147 = icmp ne i64 %expval146, 0
  br i1 %tobool147, label %if.end150, label %if.then148

if.then148:                                       ; preds = %do.body135
  %64 = load i32* %reg, align 4
  %65 = load i8** %hw_addr136, align 8
  %arrayidx149 = getelementptr i8* %65, i64 23480
  call void @writel(i32 %64, i8* %arrayidx149) noredzone
  br label %if.end150

if.end150:                                        ; preds = %if.then148, %do.body135
  br label %do.end151

do.end151:                                        ; preds = %if.end150
  br label %if.end152

if.end152:                                        ; preds = %do.end151, %if.then
  br label %if.end196

if.else:                                          ; preds = %entry
  %66 = load %struct.e1000_hw** %hw, align 8
  %mac153 = getelementptr inbounds %struct.e1000_hw* %66, i32 0, i32 4
  %type154 = getelementptr inbounds %struct.e1000_mac_info* %mac153, i32 0, i32 3
  %67 = load i32* %type154, align 4
  %cmp155 = icmp eq i32 %67, 3
  br i1 %cmp155, label %if.then157, label %if.end195

if.then157:                                       ; preds = %if.else
  %68 = load %struct.e1000_hw** %hw, align 8
  %call159 = call i32 @igb_rd32(%struct.e1000_hw* %68, i32 23480) noredzone
  store i32 %call159, i32* %reg158, align 4
  br label %do.body160

do.body160:                                       ; preds = %if.then157
  %69 = load %struct.e1000_hw** %hw, align 8
  %hw_addr162 = getelementptr inbounds %struct.e1000_hw* %69, i32 0, i32 1
  %70 = load volatile i8** %hw_addr162, align 8
  store i8* %70, i8** %hw_addr161, align 8
  %71 = load i8** %hw_addr161, align 8
  %tobool163 = icmp ne i8* %71, null
  %lnot164 = xor i1 %tobool163, true
  %lnot166 = xor i1 %lnot164, true
  %lnot168 = xor i1 %lnot166, true
  %lnot.ext169 = zext i1 %lnot168 to i32
  %conv170 = sext i32 %lnot.ext169 to i64
  %expval171 = call i64 @llvm.expect.i64(i64 %conv170, i64 0)
  %tobool172 = icmp ne i64 %expval171, 0
  br i1 %tobool172, label %if.end176, label %if.then173

if.then173:                                       ; preds = %do.body160
  %72 = load i32* %reg158, align 4
  %and174 = and i32 %72, -129
  %73 = load i8** %hw_addr161, align 8
  %arrayidx175 = getelementptr i8* %73, i64 23480
  call void @writel(i32 %and174, i8* %arrayidx175) noredzone
  br label %if.end176

if.end176:                                        ; preds = %if.then173, %do.body160
  br label %do.end177

do.end177:                                        ; preds = %if.end176
  br label %do.body178

do.body178:                                       ; preds = %do.end177
  %74 = load %struct.e1000_hw** %hw, align 8
  %hw_addr180 = getelementptr inbounds %struct.e1000_hw* %74, i32 0, i32 1
  %75 = load volatile i8** %hw_addr180, align 8
  store i8* %75, i8** %hw_addr179, align 8
  %76 = load i8** %hw_addr179, align 8
  %tobool181 = icmp ne i8* %76, null
  %lnot182 = xor i1 %tobool181, true
  %lnot184 = xor i1 %lnot182, true
  %lnot186 = xor i1 %lnot184, true
  %lnot.ext187 = zext i1 %lnot186 to i32
  %conv188 = sext i32 %lnot.ext187 to i64
  %expval189 = call i64 @llvm.expect.i64(i64 %conv188, i64 0)
  %tobool190 = icmp ne i64 %expval189, 0
  br i1 %tobool190, label %if.end193, label %if.then191

if.then191:                                       ; preds = %do.body178
  %77 = load i8** %hw_addr179, align 8
  %arrayidx192 = getelementptr i8* %77, i64 9480
  call void @writel(i32 0, i8* %arrayidx192) noredzone
  br label %if.end193

if.end193:                                        ; preds = %if.then191, %do.body178
  br label %do.end194

do.end194:                                        ; preds = %if.end193
  br label %if.end195

if.end195:                                        ; preds = %do.end194, %if.else
  br label %if.end196

if.end196:                                        ; preds = %if.end195, %if.end152
  ret void
}

define internal i32 @variable_test_bit(i64 %nr, i64* %addr) nounwind inlinehint noredzone {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  %oldbit = alloca i32, align 4
  store i64 %nr, i64* %nr.addr, align 8
  store i64* %addr, i64** %addr.addr, align 8
  %0 = load i64** %addr.addr, align 8
  %1 = load i64* %nr.addr, align 8
  %2 = call i32 asm sideeffect "bt $2,$1\0A\09sbb $0,$0", "=r,*m,Ir,~{dirflag},~{fpsr},~{flags}"(i64* %0, i64 %1) nounwind, !srcloc !9
  store i32 %2, i32* %oldbit, align 4
  %3 = load i32* %oldbit, align 4
  ret i32 %3
}

declare i32 @igb_set_eee_i350(%struct.e1000_hw*) noredzone

declare i32 @igb_set_eee_i354(%struct.e1000_hw*) noredzone

define internal zeroext i1 @netif_running(%struct.net_device* %dev) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %dev.addr = alloca %struct.net_device*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  %0 = load %struct.net_device** %dev.addr, align 8
  %state = getelementptr inbounds %struct.net_device* %0, i32 0, i32 7
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  ret i1 %tobool
}

define internal void @igb_power_down_link(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  %phy = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %1 = load i32* %media_type, align 4
  %cmp = icmp eq i32 %1, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  call void @igb_power_down_phy_copper_82575(%struct.e1000_hw* %hw1) noredzone
  br label %if.end

if.else:                                          ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 35
  call void @igb_shutdown_serdes_link_82575(%struct.e1000_hw* %hw2) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  ret void
}

define internal void @igb_update_mng_vlan(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %vid = alloca i16, align 2
  %old_vid = alloca i16, align 2
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 35
  %mng_cookie = getelementptr inbounds %struct.e1000_hw* %hw2, i32 0, i32 10
  %vlan_id = getelementptr inbounds %struct.e1000_host_mng_dhcp_cookie* %mng_cookie, i32 0, i32 3
  %2 = load i16* %vlan_id, align 2
  store i16 %2, i16* %vid, align 2
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %mng_vlan_id = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 20
  %4 = load i16* %mng_vlan_id, align 2
  store i16 %4, i16* %old_vid, align 2
  %5 = load %struct.e1000_hw** %hw, align 8
  %mng_cookie3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 10
  %status = getelementptr inbounds %struct.e1000_host_mng_dhcp_cookie* %mng_cookie3, i32 0, i32 1
  %6 = load i8* %status, align 1
  %conv = zext i8 %6 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load %struct.e1000_hw** %hw, align 8
  %8 = load i16* %vid, align 2
  %conv4 = zext i16 %8 to i32
  %call = call i32 @igb_vfta_set(%struct.e1000_hw* %7, i32 %conv4, i1 zeroext true) noredzone
  %9 = load i16* %vid, align 2
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %mng_vlan_id5 = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 20
  store i16 %9, i16* %mng_vlan_id5, align 2
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %mng_vlan_id6 = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 20
  store i16 -1, i16* %mng_vlan_id6, align 2
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %12 = load i16* %old_vid, align 2
  %conv7 = zext i16 %12 to i32
  %cmp = icmp ne i32 %conv7, 65535
  br i1 %cmp, label %land.lhs.true, label %if.end25

land.lhs.true:                                    ; preds = %if.end
  %13 = load i16* %vid, align 2
  %conv9 = zext i16 %13 to i32
  %14 = load i16* %old_vid, align 2
  %conv10 = zext i16 %14 to i32
  %cmp11 = icmp ne i32 %conv9, %conv10
  br i1 %cmp11, label %land.lhs.true13, label %if.end25

land.lhs.true13:                                  ; preds = %land.lhs.true
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true13
  %15 = load i16* %old_vid, align 2
  %conv14 = zext i16 %15 to i64
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %active_vlans = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64]* %active_vlans, i32 0, i32 0
  store i64 %conv14, i64* %nr.addr.i, align 8
  store i64* %arraydecay, i64** %addr.addr.i, align 8
  %17 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %17, 63
  %shl.i = shl i64 1, %and.i
  %18 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %18, 6
  %19 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %19, i64 %shr.i
  %20 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %20
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool16 = icmp ne i32 %conv.i, 0
  br i1 %tobool16, label %if.end25, label %if.then22

cond.false:                                       ; preds = %land.lhs.true13
  %21 = load i16* %old_vid, align 2
  %conv17 = zext i16 %21 to i64
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %active_vlans18 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 0
  %arraydecay19 = getelementptr inbounds [64 x i64]* %active_vlans18, i32 0, i32 0
  %call20 = call i32 @variable_test_bit(i64 %conv17, i64* %arraydecay19) noredzone
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.end25, label %if.then22

if.then22:                                        ; preds = %cond.false, %cond.true
  %23 = load %struct.e1000_hw** %hw, align 8
  %24 = load i16* %old_vid, align 2
  %conv23 = zext i16 %24 to i32
  %call24 = call i32 @igb_vfta_set(%struct.e1000_hw* %23, i32 %conv23, i1 zeroext false) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %cond.false, %cond.true, %land.lhs.true, %if.end
  ret void
}

declare void @igb_ptp_reset(%struct.igb_adapter*) noredzone

define internal i32 @igb_get_phy_info(%struct.e1000_hw* %hw) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 6
  %ops = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 0
  %get_phy_info = getelementptr inbounds %struct.e1000_phy_operations* %ops, i32 0, i32 6
  %1 = load i32 (%struct.e1000_hw*)** %get_phy_info, align 8
  %tobool = icmp ne i32 (%struct.e1000_hw*)* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.e1000_hw** %hw.addr, align 8
  %phy1 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 6
  %ops2 = getelementptr inbounds %struct.e1000_phy_info* %phy1, i32 0, i32 0
  %get_phy_info3 = getelementptr inbounds %struct.e1000_phy_operations* %ops2, i32 0, i32 6
  %3 = load i32 (%struct.e1000_hw*)** %get_phy_info3, align 8
  %4 = load %struct.e1000_hw** %hw.addr, align 8
  %call = call i32 %3(%struct.e1000_hw* %4) noredzone
  store i32 %call, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32* %retval
  ret i32 %5
}

define void @igb_set_fw_version(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %fw = alloca %struct.e1000_fw_version, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  call void @igb_get_fw_version(%struct.e1000_hw* %1, %struct.e1000_fw_version* %fw) noredzone
  %2 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %3 = load i32* %type, align 4
  switch i32 %3, label %sw.default [
    i32 6, label %sw.bb
    i32 7, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry
  %4 = load %struct.e1000_hw** %hw, align 8
  %call = call zeroext i1 @igb_get_flash_presence_i210(%struct.e1000_hw* %4) noredzone
  br i1 %call, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %fw_version = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 69
  %arraydecay = getelementptr inbounds [32 x i8]* %fw_version, i32 0, i32 0
  %invm_major = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 4
  %6 = load i8* %invm_major, align 1
  %conv = zext i8 %6 to i32
  %invm_minor = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 5
  %7 = load i8* %invm_minor, align 1
  %conv2 = zext i8 %7 to i32
  %invm_img_type = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 6
  %8 = load i8* %invm_img_type, align 1
  %conv3 = zext i8 %8 to i32
  %call4 = call i32 (i8*, i64, i8*, ...)* @snprintf(i8* %arraydecay, i64 32, i8* getelementptr inbounds ([11 x i8]* @.str4, i32 0, i32 0), i32 %conv, i32 %conv2, i32 %conv3) noredzone
  br label %sw.epilog

if.end:                                           ; preds = %sw.bb
  br label %sw.default

sw.default:                                       ; preds = %entry, %if.end
  %or_valid = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 7
  %9 = load i8* %or_valid, align 1
  %tobool = trunc i8 %9 to i1
  br i1 %tobool, label %if.then5, label %if.else

if.then5:                                         ; preds = %sw.default
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %fw_version6 = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 69
  %arraydecay7 = getelementptr inbounds [32 x i8]* %fw_version6, i32 0, i32 0
  %eep_major = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 1
  %11 = load i16* %eep_major, align 2
  %conv8 = zext i16 %11 to i32
  %eep_minor = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 2
  %12 = load i16* %eep_minor, align 2
  %conv9 = zext i16 %12 to i32
  %etrack_id = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 0
  %13 = load i32* %etrack_id, align 4
  %or_major = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 8
  %14 = load i16* %or_major, align 2
  %conv10 = zext i16 %14 to i32
  %or_build = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 9
  %15 = load i16* %or_build, align 2
  %conv11 = zext i16 %15 to i32
  %or_patch = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 10
  %16 = load i16* %or_patch, align 2
  %conv12 = zext i16 %16 to i32
  %call13 = call i32 (i8*, i64, i8*, ...)* @snprintf(i8* %arraydecay7, i64 32, i8* getelementptr inbounds ([24 x i8]* @.str5, i32 0, i32 0), i32 %conv8, i32 %conv9, i32 %13, i32 %conv10, i32 %conv11, i32 %conv12) noredzone
  br label %if.end35

if.else:                                          ; preds = %sw.default
  %etrack_id14 = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 0
  %17 = load i32* %etrack_id14, align 4
  %cmp = icmp ne i32 %17, 0
  br i1 %cmp, label %if.then16, label %if.else25

if.then16:                                        ; preds = %if.else
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %fw_version17 = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 69
  %arraydecay18 = getelementptr inbounds [32 x i8]* %fw_version17, i32 0, i32 0
  %eep_major19 = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 1
  %19 = load i16* %eep_major19, align 2
  %conv20 = zext i16 %19 to i32
  %eep_minor21 = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 2
  %20 = load i16* %eep_minor21, align 2
  %conv22 = zext i16 %20 to i32
  %etrack_id23 = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 0
  %21 = load i32* %etrack_id23, align 4
  %call24 = call i32 (i8*, i64, i8*, ...)* @snprintf(i8* %arraydecay18, i64 32, i8* getelementptr inbounds ([14 x i8]* @.str6, i32 0, i32 0), i32 %conv20, i32 %conv22, i32 %21) noredzone
  br label %if.end34

if.else25:                                        ; preds = %if.else
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %fw_version26 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 69
  %arraydecay27 = getelementptr inbounds [32 x i8]* %fw_version26, i32 0, i32 0
  %eep_major28 = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 1
  %23 = load i16* %eep_major28, align 2
  %conv29 = zext i16 %23 to i32
  %eep_minor30 = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 2
  %24 = load i16* %eep_minor30, align 2
  %conv31 = zext i16 %24 to i32
  %eep_build = getelementptr inbounds %struct.e1000_fw_version* %fw, i32 0, i32 3
  %25 = load i16* %eep_build, align 2
  %conv32 = zext i16 %25 to i32
  %call33 = call i32 (i8*, i64, i8*, ...)* @snprintf(i8* %arraydecay27, i64 32, i8* getelementptr inbounds ([9 x i8]* @.str7, i32 0, i32 0), i32 %conv29, i32 %conv31, i32 %conv32) noredzone
  br label %if.end34

if.end34:                                         ; preds = %if.else25, %if.then16
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.then5
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end35, %if.then
  ret void
}

declare void @igb_get_fw_version(%struct.e1000_hw*, %struct.e1000_fw_version*) noredzone

declare zeroext i1 @igb_get_flash_presence_i210(%struct.e1000_hw*) noredzone

declare i32 @snprintf(i8*, i64, i8*, ...) noredzone

define i32 @igb_setup_tx_resources(%struct.igb_ring* %tx_ring) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %dev = alloca %struct.device*, align 8
  %size = alloca i32, align 4
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev1 = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 2
  %1 = load %struct.device** %dev1, align 8
  store %struct.device* %1, %struct.device** %dev, align 8
  %2 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 9
  %3 = load i16* %count, align 2
  %conv = zext i16 %3 to i64
  %mul = mul i64 48, %conv
  %conv2 = trunc i64 %mul to i32
  store i32 %conv2, i32* %size, align 4
  %4 = load i32* %size, align 4
  %conv3 = sext i32 %4 to i64
  %call = call i8* @vzalloc(i64 %conv3) noredzone
  %5 = bitcast i8* %call to %struct.igb_tx_buffer*
  %6 = load %struct.igb_ring** %tx_ring.addr, align 8
  %7 = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %7 to %struct.igb_tx_buffer**
  store %struct.igb_tx_buffer* %5, %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %8 = load %struct.igb_ring** %tx_ring.addr, align 8
  %9 = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 3
  %tx_buffer_info4 = bitcast %union.anon.87* %9 to %struct.igb_tx_buffer**
  %10 = load %struct.igb_tx_buffer** %tx_buffer_info4, align 8
  %tobool = icmp ne %struct.igb_tx_buffer* %10, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err

if.end:                                           ; preds = %entry
  %11 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count5 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 9
  %12 = load i16* %count5, align 2
  %conv6 = zext i16 %12 to i64
  %mul7 = mul i64 %conv6, 16
  %conv8 = trunc i64 %mul7 to i32
  %13 = load %struct.igb_ring** %tx_ring.addr, align 8
  %size9 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 8
  store i32 %conv8, i32* %size9, align 4
  %14 = load %struct.igb_ring** %tx_ring.addr, align 8
  %size10 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 8
  %15 = load i32* %size10, align 4
  %add = add i32 %15, 4095
  %and = and i32 %add, -4096
  %16 = load %struct.igb_ring** %tx_ring.addr, align 8
  %size11 = getelementptr inbounds %struct.igb_ring* %16, i32 0, i32 8
  store i32 %and, i32* %size11, align 4
  %17 = load %struct.device** %dev, align 8
  %18 = load %struct.igb_ring** %tx_ring.addr, align 8
  %size12 = getelementptr inbounds %struct.igb_ring* %18, i32 0, i32 8
  %19 = load i32* %size12, align 4
  %conv13 = zext i32 %19 to i64
  %20 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dma = getelementptr inbounds %struct.igb_ring* %20, i32 0, i32 7
  %call14 = call i8* @dma_alloc_attrs(%struct.device* %17, i64 %conv13, i64* %dma, i32 208, %struct.dma_attrs* null) noredzone
  %21 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %21, i32 0, i32 4
  store i8* %call14, i8** %desc, align 8
  %22 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc15 = getelementptr inbounds %struct.igb_ring* %22, i32 0, i32 4
  %23 = load i8** %desc15, align 8
  %tobool16 = icmp ne i8* %23, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end
  br label %err

if.end18:                                         ; preds = %if.end
  %24 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %24, i32 0, i32 13
  store i16 0, i16* %next_to_use, align 2
  %25 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %25, i32 0, i32 12
  store i16 0, i16* %next_to_clean, align 2
  store i32 0, i32* %retval
  br label %return

err:                                              ; preds = %if.then17, %if.then
  %26 = load %struct.igb_ring** %tx_ring.addr, align 8
  %27 = getelementptr inbounds %struct.igb_ring* %26, i32 0, i32 3
  %tx_buffer_info19 = bitcast %union.anon.87* %27 to %struct.igb_tx_buffer**
  %28 = load %struct.igb_tx_buffer** %tx_buffer_info19, align 8
  %29 = bitcast %struct.igb_tx_buffer* %28 to i8*
  call void @vfree(i8* %29) noredzone
  %30 = load %struct.igb_ring** %tx_ring.addr, align 8
  %31 = getelementptr inbounds %struct.igb_ring* %30, i32 0, i32 3
  %tx_buffer_info20 = bitcast %union.anon.87* %31 to %struct.igb_tx_buffer**
  store %struct.igb_tx_buffer* null, %struct.igb_tx_buffer** %tx_buffer_info20, align 8
  %32 = load %struct.device** %dev, align 8
  %call21 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %32, i8* getelementptr inbounds ([54 x i8]* @.str8, i32 0, i32 0)) noredzone
  store i32 -12, i32* %retval
  br label %return

return:                                           ; preds = %err, %if.end18
  %33 = load i32* %retval
  ret i32 %33
}

declare i8* @vzalloc(i64) noredzone

define internal i8* @dma_alloc_attrs(%struct.device* %dev, i64 %size, i64* %dma_handle, i32 %gfp, %struct.dma_attrs* %attrs) nounwind inlinehint noredzone {
entry:
  %retval = alloca i8*, align 8
  %dev.addr = alloca %struct.device*, align 8
  %size.addr = alloca i64, align 8
  %dma_handle.addr = alloca i64*, align 8
  %gfp.addr = alloca i32, align 4
  %attrs.addr = alloca %struct.dma_attrs*, align 8
  %ops = alloca %struct.dma_map_ops*, align 8
  %memory = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64* %dma_handle, i64** %dma_handle.addr, align 8
  store i32 %gfp, i32* %gfp.addr, align 4
  store %struct.dma_attrs* %attrs, %struct.dma_attrs** %attrs.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  %1 = load i32* %gfp.addr, align 4
  %and = and i32 %1, -8
  store i32 %and, i32* %gfp.addr, align 4
  %2 = load %struct.device** %dev.addr, align 8
  %tobool = icmp ne %struct.device* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store %struct.device* @x86_dma_fallback_dev, %struct.device** %dev.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load %struct.device** %dev.addr, align 8
  %call1 = call i32 @is_device_dma_capable(%struct.device* %3) noredzone
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i8* null, i8** %retval
  br label %return

if.end4:                                          ; preds = %if.end
  %4 = load %struct.dma_map_ops** %ops, align 8
  %alloc = getelementptr inbounds %struct.dma_map_ops* %4, i32 0, i32 0
  %5 = load i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)** %alloc, align 8
  %tobool5 = icmp ne i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)* %5, null
  br i1 %tobool5, label %if.end7, label %if.then6

if.then6:                                         ; preds = %if.end4
  store i8* null, i8** %retval
  br label %return

if.end7:                                          ; preds = %if.end4
  %6 = load %struct.dma_map_ops** %ops, align 8
  %alloc8 = getelementptr inbounds %struct.dma_map_ops* %6, i32 0, i32 0
  %7 = load i8* (%struct.device*, i64, i64*, i32, %struct.dma_attrs*)** %alloc8, align 8
  %8 = load %struct.device** %dev.addr, align 8
  %9 = load i64* %size.addr, align 8
  %10 = load i64** %dma_handle.addr, align 8
  %11 = load %struct.device** %dev.addr, align 8
  %12 = load i32* %gfp.addr, align 4
  %call9 = call i32 @dma_alloc_coherent_gfp_flags(%struct.device* %11, i32 %12) noredzone
  %13 = load %struct.dma_attrs** %attrs.addr, align 8
  %call10 = call i8* %7(%struct.device* %8, i64 %9, i64* %10, i32 %call9, %struct.dma_attrs* %13) noredzone
  store i8* %call10, i8** %memory, align 8
  %14 = load %struct.device** %dev.addr, align 8
  %15 = load i64* %size.addr, align 8
  %16 = load i64** %dma_handle.addr, align 8
  %17 = load i64* %16, align 8
  %18 = load i8** %memory, align 8
  call void @debug_dma_alloc_coherent(%struct.device* %14, i64 %15, i64 %17, i8* %18) noredzone
  %19 = load i8** %memory, align 8
  store i8* %19, i8** %retval
  br label %return

return:                                           ; preds = %if.end7, %if.then6, %if.then3
  %20 = load i8** %retval
  ret i8* %20
}

declare void @vfree(i8*) noredzone

define void @igb_setup_tctl(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %tctl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr8 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 1
  %2 = load volatile i8** %hw_addr2, align 8
  store i8* %2, i8** %hw_addr, align 8
  %3 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %3, null
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %4 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %4, i64 14376
  call void @writel(i32 0, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %5 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %5, i32 1024) noredzone
  store i32 %call, i32* %tctl, align 4
  %6 = load i32* %tctl, align 4
  %and = and i32 %6, -4081
  store i32 %and, i32* %tctl, align 4
  %7 = load i32* %tctl, align 4
  %or = or i32 %7, 16777464
  store i32 %or, i32* %tctl, align 4
  %8 = load %struct.e1000_hw** %hw, align 8
  call void @igb_config_collision_dist(%struct.e1000_hw* %8) noredzone
  %9 = load i32* %tctl, align 4
  %or6 = or i32 %9, 2
  store i32 %or6, i32* %tctl, align 4
  br label %do.body7

do.body7:                                         ; preds = %do.end
  %10 = load %struct.e1000_hw** %hw, align 8
  %hw_addr9 = getelementptr inbounds %struct.e1000_hw* %10, i32 0, i32 1
  %11 = load volatile i8** %hw_addr9, align 8
  store i8* %11, i8** %hw_addr8, align 8
  %12 = load i8** %hw_addr8, align 8
  %tobool10 = icmp ne i8* %12, null
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot15 = xor i1 %lnot13, true
  %lnot.ext16 = zext i1 %lnot15 to i32
  %conv17 = sext i32 %lnot.ext16 to i64
  %expval18 = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool19 = icmp ne i64 %expval18, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %do.body7
  %13 = load i32* %tctl, align 4
  %14 = load i8** %hw_addr8, align 8
  %arrayidx21 = getelementptr i8* %14, i64 1024
  call void @writel(i32 %13, i8* %arrayidx21) noredzone
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %do.body7
  br label %do.end23

do.end23:                                         ; preds = %if.end22
  ret void
}

declare void @igb_config_collision_dist(%struct.e1000_hw*) noredzone

define void @igb_configure_tx_ring(%struct.igb_adapter* %adapter, %struct.igb_ring* %ring) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %ring.addr = alloca %struct.igb_ring*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %txdctl = alloca i32, align 4
  %tdba = alloca i64, align 8
  %reg_idx = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %__ms = alloca i64, align 8
  %hw_addr13 = alloca i8*, align 8
  %hw_addr44 = alloca i8*, align 8
  %hw_addr73 = alloca i8*, align 8
  %hw_addr113 = alloca i8*, align 8
  %hw_addr155 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %txdctl, align 4
  %1 = load %struct.igb_ring** %ring.addr, align 8
  %dma = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 7
  %2 = load i64* %dma, align 8
  store i64 %2, i64* %tdba, align 8
  %3 = load %struct.igb_ring** %ring.addr, align 8
  %reg_idx2 = getelementptr inbounds %struct.igb_ring* %3, i32 0, i32 11
  %4 = load i8* %reg_idx2, align 1
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %reg_idx, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %5 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 1
  %6 = load volatile i8** %hw_addr3, align 8
  store i8* %6, i8** %hw_addr, align 8
  %7 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %7, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %8 = load i32* %reg_idx, align 4
  %cmp = icmp slt i32 %8, 4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %9 = load i32* %reg_idx, align 4
  %mul = mul i32 %9, 256
  %add = add i32 14376, %mul
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %10 = load i32* %reg_idx, align 4
  %mul9 = mul i32 %10, 64
  %add10 = add i32 57384, %mul9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ %add10, %cond.false ]
  %idxprom = sext i32 %cond to i64
  %11 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %11, i64 %idxprom
  call void @writel(i32 0, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %cond.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %12 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %12, i32 8) noredzone
  store i64 10, i64* %__ms, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %do.end
  %13 = load i64* %__ms, align 8
  %dec = add i64 %13, -1
  store i64 %dec, i64* %__ms, align 8
  %tobool11 = icmp ne i64 %13, 0
  br i1 %tobool11, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @__const_udelay(i64 4295000) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  br label %do.body12

do.body12:                                        ; preds = %while.end
  %14 = load %struct.e1000_hw** %hw, align 8
  %hw_addr14 = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 1
  %15 = load volatile i8** %hw_addr14, align 8
  store i8* %15, i8** %hw_addr13, align 8
  %16 = load i8** %hw_addr13, align 8
  %tobool15 = icmp ne i8* %16, null
  %lnot16 = xor i1 %tobool15, true
  %lnot18 = xor i1 %lnot16, true
  %lnot20 = xor i1 %lnot18, true
  %lnot.ext21 = zext i1 %lnot20 to i32
  %conv22 = sext i32 %lnot.ext21 to i64
  %expval23 = call i64 @llvm.expect.i64(i64 %conv22, i64 0)
  %tobool24 = icmp ne i64 %expval23, 0
  br i1 %tobool24, label %if.end41, label %if.then25

if.then25:                                        ; preds = %do.body12
  %17 = load %struct.igb_ring** %ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 9
  %18 = load i16* %count, align 2
  %conv26 = zext i16 %18 to i64
  %mul27 = mul i64 %conv26, 16
  %conv28 = trunc i64 %mul27 to i32
  %19 = load i32* %reg_idx, align 4
  %cmp29 = icmp slt i32 %19, 4
  br i1 %cmp29, label %cond.true31, label %cond.false34

cond.true31:                                      ; preds = %if.then25
  %20 = load i32* %reg_idx, align 4
  %mul32 = mul i32 %20, 256
  %add33 = add i32 14344, %mul32
  br label %cond.end37

cond.false34:                                     ; preds = %if.then25
  %21 = load i32* %reg_idx, align 4
  %mul35 = mul i32 %21, 64
  %add36 = add i32 57352, %mul35
  br label %cond.end37

cond.end37:                                       ; preds = %cond.false34, %cond.true31
  %cond38 = phi i32 [ %add33, %cond.true31 ], [ %add36, %cond.false34 ]
  %idxprom39 = sext i32 %cond38 to i64
  %22 = load i8** %hw_addr13, align 8
  %arrayidx40 = getelementptr i8* %22, i64 %idxprom39
  call void @writel(i32 %conv28, i8* %arrayidx40) noredzone
  br label %if.end41

if.end41:                                         ; preds = %cond.end37, %do.body12
  br label %do.end42

do.end42:                                         ; preds = %if.end41
  br label %do.body43

do.body43:                                        ; preds = %do.end42
  %23 = load %struct.e1000_hw** %hw, align 8
  %hw_addr45 = getelementptr inbounds %struct.e1000_hw* %23, i32 0, i32 1
  %24 = load volatile i8** %hw_addr45, align 8
  store i8* %24, i8** %hw_addr44, align 8
  %25 = load i8** %hw_addr44, align 8
  %tobool46 = icmp ne i8* %25, null
  %lnot47 = xor i1 %tobool46, true
  %lnot49 = xor i1 %lnot47, true
  %lnot51 = xor i1 %lnot49, true
  %lnot.ext52 = zext i1 %lnot51 to i32
  %conv53 = sext i32 %lnot.ext52 to i64
  %expval54 = call i64 @llvm.expect.i64(i64 %conv53, i64 0)
  %tobool55 = icmp ne i64 %expval54, 0
  br i1 %tobool55, label %if.end70, label %if.then56

if.then56:                                        ; preds = %do.body43
  %26 = load i64* %tdba, align 8
  %and = and i64 %26, 4294967295
  %conv57 = trunc i64 %and to i32
  %27 = load i32* %reg_idx, align 4
  %cmp58 = icmp slt i32 %27, 4
  br i1 %cmp58, label %cond.true60, label %cond.false63

cond.true60:                                      ; preds = %if.then56
  %28 = load i32* %reg_idx, align 4
  %mul61 = mul i32 %28, 256
  %add62 = add i32 14336, %mul61
  br label %cond.end66

cond.false63:                                     ; preds = %if.then56
  %29 = load i32* %reg_idx, align 4
  %mul64 = mul i32 %29, 64
  %add65 = add i32 57344, %mul64
  br label %cond.end66

cond.end66:                                       ; preds = %cond.false63, %cond.true60
  %cond67 = phi i32 [ %add62, %cond.true60 ], [ %add65, %cond.false63 ]
  %idxprom68 = sext i32 %cond67 to i64
  %30 = load i8** %hw_addr44, align 8
  %arrayidx69 = getelementptr i8* %30, i64 %idxprom68
  call void @writel(i32 %conv57, i8* %arrayidx69) noredzone
  br label %if.end70

if.end70:                                         ; preds = %cond.end66, %do.body43
  br label %do.end71

do.end71:                                         ; preds = %if.end70
  br label %do.body72

do.body72:                                        ; preds = %do.end71
  %31 = load %struct.e1000_hw** %hw, align 8
  %hw_addr74 = getelementptr inbounds %struct.e1000_hw* %31, i32 0, i32 1
  %32 = load volatile i8** %hw_addr74, align 8
  store i8* %32, i8** %hw_addr73, align 8
  %33 = load i8** %hw_addr73, align 8
  %tobool75 = icmp ne i8* %33, null
  %lnot76 = xor i1 %tobool75, true
  %lnot78 = xor i1 %lnot76, true
  %lnot80 = xor i1 %lnot78, true
  %lnot.ext81 = zext i1 %lnot80 to i32
  %conv82 = sext i32 %lnot.ext81 to i64
  %expval83 = call i64 @llvm.expect.i64(i64 %conv82, i64 0)
  %tobool84 = icmp ne i64 %expval83, 0
  br i1 %tobool84, label %if.end99, label %if.then85

if.then85:                                        ; preds = %do.body72
  %34 = load i64* %tdba, align 8
  %shr = lshr i64 %34, 32
  %conv86 = trunc i64 %shr to i32
  %35 = load i32* %reg_idx, align 4
  %cmp87 = icmp slt i32 %35, 4
  br i1 %cmp87, label %cond.true89, label %cond.false92

cond.true89:                                      ; preds = %if.then85
  %36 = load i32* %reg_idx, align 4
  %mul90 = mul i32 %36, 256
  %add91 = add i32 14340, %mul90
  br label %cond.end95

cond.false92:                                     ; preds = %if.then85
  %37 = load i32* %reg_idx, align 4
  %mul93 = mul i32 %37, 64
  %add94 = add i32 57348, %mul93
  br label %cond.end95

cond.end95:                                       ; preds = %cond.false92, %cond.true89
  %cond96 = phi i32 [ %add91, %cond.true89 ], [ %add94, %cond.false92 ]
  %idxprom97 = sext i32 %cond96 to i64
  %38 = load i8** %hw_addr73, align 8
  %arrayidx98 = getelementptr i8* %38, i64 %idxprom97
  call void @writel(i32 %conv86, i8* %arrayidx98) noredzone
  br label %if.end99

if.end99:                                         ; preds = %cond.end95, %do.body72
  br label %do.end100

do.end100:                                        ; preds = %if.end99
  %39 = load %struct.e1000_hw** %hw, align 8
  %hw_addr101 = getelementptr inbounds %struct.e1000_hw* %39, i32 0, i32 1
  %40 = load i8** %hw_addr101, align 8
  %41 = load i32* %reg_idx, align 4
  %cmp102 = icmp slt i32 %41, 4
  br i1 %cmp102, label %cond.true104, label %cond.false107

cond.true104:                                     ; preds = %do.end100
  %42 = load i32* %reg_idx, align 4
  %mul105 = mul i32 %42, 256
  %add106 = add i32 14360, %mul105
  br label %cond.end110

cond.false107:                                    ; preds = %do.end100
  %43 = load i32* %reg_idx, align 4
  %mul108 = mul i32 %43, 64
  %add109 = add i32 57368, %mul108
  br label %cond.end110

cond.end110:                                      ; preds = %cond.false107, %cond.true104
  %cond111 = phi i32 [ %add106, %cond.true104 ], [ %add109, %cond.false107 ]
  %idx.ext = sext i32 %cond111 to i64
  %add.ptr = getelementptr i8* %40, i64 %idx.ext
  %44 = load %struct.igb_ring** %ring.addr, align 8
  %tail = getelementptr inbounds %struct.igb_ring* %44, i32 0, i32 6
  store i8* %add.ptr, i8** %tail, align 8
  br label %do.body112

do.body112:                                       ; preds = %cond.end110
  %45 = load %struct.e1000_hw** %hw, align 8
  %hw_addr114 = getelementptr inbounds %struct.e1000_hw* %45, i32 0, i32 1
  %46 = load volatile i8** %hw_addr114, align 8
  store i8* %46, i8** %hw_addr113, align 8
  %47 = load i8** %hw_addr113, align 8
  %tobool115 = icmp ne i8* %47, null
  %lnot116 = xor i1 %tobool115, true
  %lnot118 = xor i1 %lnot116, true
  %lnot120 = xor i1 %lnot118, true
  %lnot.ext121 = zext i1 %lnot120 to i32
  %conv122 = sext i32 %lnot.ext121 to i64
  %expval123 = call i64 @llvm.expect.i64(i64 %conv122, i64 0)
  %tobool124 = icmp ne i64 %expval123, 0
  br i1 %tobool124, label %if.end138, label %if.then125

if.then125:                                       ; preds = %do.body112
  %48 = load i32* %reg_idx, align 4
  %cmp126 = icmp slt i32 %48, 4
  br i1 %cmp126, label %cond.true128, label %cond.false131

cond.true128:                                     ; preds = %if.then125
  %49 = load i32* %reg_idx, align 4
  %mul129 = mul i32 %49, 256
  %add130 = add i32 14352, %mul129
  br label %cond.end134

cond.false131:                                    ; preds = %if.then125
  %50 = load i32* %reg_idx, align 4
  %mul132 = mul i32 %50, 64
  %add133 = add i32 57360, %mul132
  br label %cond.end134

cond.end134:                                      ; preds = %cond.false131, %cond.true128
  %cond135 = phi i32 [ %add130, %cond.true128 ], [ %add133, %cond.false131 ]
  %idxprom136 = sext i32 %cond135 to i64
  %51 = load i8** %hw_addr113, align 8
  %arrayidx137 = getelementptr i8* %51, i64 %idxprom136
  call void @writel(i32 0, i8* %arrayidx137) noredzone
  br label %if.end138

if.end138:                                        ; preds = %cond.end134, %do.body112
  br label %do.end139

do.end139:                                        ; preds = %if.end138
  %52 = load %struct.igb_ring** %ring.addr, align 8
  %tail140 = getelementptr inbounds %struct.igb_ring* %52, i32 0, i32 6
  %53 = load i8** %tail140, align 8
  call void @writel(i32 0, i8* %53) noredzone
  %54 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %54, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %55 = load i32* %type, align 4
  %cmp141 = icmp eq i32 %55, 5
  %cond143 = select i1 %cmp141, i32 20, i32 8
  %56 = load i32* %txdctl, align 4
  %or = or i32 %56, %cond143
  store i32 %or, i32* %txdctl, align 4
  %57 = load i32* %txdctl, align 4
  %or144 = or i32 %57, 256
  store i32 %or144, i32* %txdctl, align 4
  %58 = load %struct.e1000_hw** %hw, align 8
  %mac145 = getelementptr inbounds %struct.e1000_hw* %58, i32 0, i32 4
  %type146 = getelementptr inbounds %struct.e1000_mac_info* %mac145, i32 0, i32 3
  %59 = load i32* %type146, align 4
  %cmp147 = icmp eq i32 %59, 2
  br i1 %cmp147, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.end139
  %60 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %60, i32 0, i32 3
  %61 = load i32* %flags, align 4
  %and149 = and i32 %61, 8192
  %tobool150 = icmp ne i32 %and149, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.end139
  %62 = phi i1 [ false, %do.end139 ], [ %tobool150, %land.rhs ]
  %cond151 = select i1 %62, i32 1, i32 16
  %shl = shl i32 %cond151, 16
  %63 = load i32* %txdctl, align 4
  %or152 = or i32 %63, %shl
  store i32 %or152, i32* %txdctl, align 4
  %64 = load i32* %txdctl, align 4
  %or153 = or i32 %64, 33554432
  store i32 %or153, i32* %txdctl, align 4
  br label %do.body154

do.body154:                                       ; preds = %land.end
  %65 = load %struct.e1000_hw** %hw, align 8
  %hw_addr156 = getelementptr inbounds %struct.e1000_hw* %65, i32 0, i32 1
  %66 = load volatile i8** %hw_addr156, align 8
  store i8* %66, i8** %hw_addr155, align 8
  %67 = load i8** %hw_addr155, align 8
  %tobool157 = icmp ne i8* %67, null
  %lnot158 = xor i1 %tobool157, true
  %lnot160 = xor i1 %lnot158, true
  %lnot162 = xor i1 %lnot160, true
  %lnot.ext163 = zext i1 %lnot162 to i32
  %conv164 = sext i32 %lnot.ext163 to i64
  %expval165 = call i64 @llvm.expect.i64(i64 %conv164, i64 0)
  %tobool166 = icmp ne i64 %expval165, 0
  br i1 %tobool166, label %if.end180, label %if.then167

if.then167:                                       ; preds = %do.body154
  %68 = load i32* %txdctl, align 4
  %69 = load i32* %reg_idx, align 4
  %cmp168 = icmp slt i32 %69, 4
  br i1 %cmp168, label %cond.true170, label %cond.false173

cond.true170:                                     ; preds = %if.then167
  %70 = load i32* %reg_idx, align 4
  %mul171 = mul i32 %70, 256
  %add172 = add i32 14376, %mul171
  br label %cond.end176

cond.false173:                                    ; preds = %if.then167
  %71 = load i32* %reg_idx, align 4
  %mul174 = mul i32 %71, 64
  %add175 = add i32 57384, %mul174
  br label %cond.end176

cond.end176:                                      ; preds = %cond.false173, %cond.true170
  %cond177 = phi i32 [ %add172, %cond.true170 ], [ %add175, %cond.false173 ]
  %idxprom178 = sext i32 %cond177 to i64
  %72 = load i8** %hw_addr155, align 8
  %arrayidx179 = getelementptr i8* %72, i64 %idxprom178
  call void @writel(i32 %68, i8* %arrayidx179) noredzone
  br label %if.end180

if.end180:                                        ; preds = %cond.end176, %do.body154
  br label %do.end181

do.end181:                                        ; preds = %if.end180
  ret void
}

declare void @__const_udelay(i64) noredzone

define i32 @igb_setup_rx_resources(%struct.igb_ring* %rx_ring) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %dev = alloca %struct.device*, align 8
  %size = alloca i32, align 4
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev1 = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 2
  %1 = load %struct.device** %dev1, align 8
  store %struct.device* %1, %struct.device** %dev, align 8
  %2 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 9
  %3 = load i16* %count, align 2
  %conv = zext i16 %3 to i64
  %mul = mul i64 24, %conv
  %conv2 = trunc i64 %mul to i32
  store i32 %conv2, i32* %size, align 4
  %4 = load i32* %size, align 4
  %conv3 = sext i32 %4 to i64
  %call = call i8* @vzalloc(i64 %conv3) noredzone
  %5 = bitcast i8* %call to %struct.igb_rx_buffer*
  %6 = load %struct.igb_ring** %rx_ring.addr, align 8
  %7 = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %7 to %struct.igb_rx_buffer**
  store %struct.igb_rx_buffer* %5, %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %8 = load %struct.igb_ring** %rx_ring.addr, align 8
  %9 = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 3
  %rx_buffer_info4 = bitcast %union.anon.87* %9 to %struct.igb_rx_buffer**
  %10 = load %struct.igb_rx_buffer** %rx_buffer_info4, align 8
  %tobool = icmp ne %struct.igb_rx_buffer* %10, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %err

if.end:                                           ; preds = %entry
  %11 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count5 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 9
  %12 = load i16* %count5, align 2
  %conv6 = zext i16 %12 to i64
  %mul7 = mul i64 %conv6, 16
  %conv8 = trunc i64 %mul7 to i32
  %13 = load %struct.igb_ring** %rx_ring.addr, align 8
  %size9 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 8
  store i32 %conv8, i32* %size9, align 4
  %14 = load %struct.igb_ring** %rx_ring.addr, align 8
  %size10 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 8
  %15 = load i32* %size10, align 4
  %add = add i32 %15, 4095
  %and = and i32 %add, -4096
  %16 = load %struct.igb_ring** %rx_ring.addr, align 8
  %size11 = getelementptr inbounds %struct.igb_ring* %16, i32 0, i32 8
  store i32 %and, i32* %size11, align 4
  %17 = load %struct.device** %dev, align 8
  %18 = load %struct.igb_ring** %rx_ring.addr, align 8
  %size12 = getelementptr inbounds %struct.igb_ring* %18, i32 0, i32 8
  %19 = load i32* %size12, align 4
  %conv13 = zext i32 %19 to i64
  %20 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dma = getelementptr inbounds %struct.igb_ring* %20, i32 0, i32 7
  %call14 = call i8* @dma_alloc_attrs(%struct.device* %17, i64 %conv13, i64* %dma, i32 208, %struct.dma_attrs* null) noredzone
  %21 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %21, i32 0, i32 4
  store i8* %call14, i8** %desc, align 8
  %22 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc15 = getelementptr inbounds %struct.igb_ring* %22, i32 0, i32 4
  %23 = load i8** %desc15, align 8
  %tobool16 = icmp ne i8* %23, null
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end
  br label %err

if.end18:                                         ; preds = %if.end
  %24 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_alloc = getelementptr inbounds %struct.igb_ring* %24, i32 0, i32 14
  store i16 0, i16* %next_to_alloc, align 2
  %25 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %25, i32 0, i32 12
  store i16 0, i16* %next_to_clean, align 2
  %26 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %26, i32 0, i32 13
  store i16 0, i16* %next_to_use, align 2
  store i32 0, i32* %retval
  br label %return

err:                                              ; preds = %if.then17, %if.then
  %27 = load %struct.igb_ring** %rx_ring.addr, align 8
  %28 = getelementptr inbounds %struct.igb_ring* %27, i32 0, i32 3
  %rx_buffer_info19 = bitcast %union.anon.87* %28 to %struct.igb_rx_buffer**
  %29 = load %struct.igb_rx_buffer** %rx_buffer_info19, align 8
  %30 = bitcast %struct.igb_rx_buffer* %29 to i8*
  call void @vfree(i8* %30) noredzone
  %31 = load %struct.igb_ring** %rx_ring.addr, align 8
  %32 = getelementptr inbounds %struct.igb_ring* %31, i32 0, i32 3
  %rx_buffer_info20 = bitcast %union.anon.87* %32 to %struct.igb_rx_buffer**
  store %struct.igb_rx_buffer* null, %struct.igb_rx_buffer** %rx_buffer_info20, align 8
  %33 = load %struct.device** %dev, align 8
  %call21 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %33, i8* getelementptr inbounds ([54 x i8]* @.str9, i32 0, i32 0)) noredzone
  store i32 -12, i32* %retval
  br label %return

return:                                           ; preds = %err, %if.end18
  %34 = load i32* %retval
  ret i32 %34
}

define void @igb_setup_rctl(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %rctl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr14 = alloca i8*, align 8
  %hw_addr38 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 256) noredzone
  store i32 %call, i32* %rctl, align 4
  %2 = load i32* %rctl, align 4
  %and = and i32 %2, -12289
  store i32 %and, i32* %rctl, align 4
  %3 = load i32* %rctl, align 4
  %and2 = and i32 %3, -193
  store i32 %and2, i32* %rctl, align 4
  %4 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 4
  %mc_filter_type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 7
  %5 = load i32* %mc_filter_type, align 4
  %shl = shl i32 %5, 12
  %or = or i32 32770, %shl
  %6 = load i32* %rctl, align 4
  %or3 = or i32 %6, %or
  store i32 %or3, i32* %rctl, align 4
  %7 = load i32* %rctl, align 4
  %or4 = or i32 %7, 67108864
  store i32 %or4, i32* %rctl, align 4
  %8 = load i32* %rctl, align 4
  %and5 = and i32 %8, -196613
  store i32 %and5, i32* %rctl, align 4
  %9 = load i32* %rctl, align 4
  %or6 = or i32 %9, 32
  store i32 %or6, i32* %rctl, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %10 = load %struct.e1000_hw** %hw, align 8
  %hw_addr7 = getelementptr inbounds %struct.e1000_hw* %10, i32 0, i32 1
  %11 = load volatile i8** %hw_addr7, align 8
  store i8* %11, i8** %hw_addr, align 8
  %12 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %12, null
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot9 = xor i1 %lnot8, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %13 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %13, i64 10280
  call void @writel(i32 0, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 49
  %15 = load i32* %vfs_allocated_count, align 4
  %tobool11 = icmp ne i32 %15, 0
  br i1 %tobool11, label %if.then12, label %if.end30

if.then12:                                        ; preds = %do.end
  br label %do.body13

do.body13:                                        ; preds = %if.then12
  %16 = load %struct.e1000_hw** %hw, align 8
  %hw_addr15 = getelementptr inbounds %struct.e1000_hw* %16, i32 0, i32 1
  %17 = load volatile i8** %hw_addr15, align 8
  store i8* %17, i8** %hw_addr14, align 8
  %18 = load i8** %hw_addr14, align 8
  %tobool16 = icmp ne i8* %18, null
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot21 = xor i1 %lnot19, true
  %lnot.ext22 = zext i1 %lnot21 to i32
  %conv23 = sext i32 %lnot.ext22 to i64
  %expval24 = call i64 @llvm.expect.i64(i64 %conv23, i64 0)
  %tobool25 = icmp ne i64 %expval24, 0
  br i1 %tobool25, label %if.end28, label %if.then26

if.then26:                                        ; preds = %do.body13
  %19 = load i8** %hw_addr14, align 8
  %arrayidx27 = getelementptr i8* %19, i64 9224
  call void @writel(i32 65535, i8* %arrayidx27) noredzone
  br label %if.end28

if.end28:                                         ; preds = %if.then26, %do.body13
  br label %do.end29

do.end29:                                         ; preds = %if.end28
  br label %if.end30

if.end30:                                         ; preds = %do.end29, %do.end
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 1
  %21 = load %struct.net_device** %netdev, align 8
  %features = getelementptr inbounds %struct.net_device* %21, i32 0, i32 14
  %22 = load i64* %features, align 8
  %and31 = and i64 %22, 274877906944
  %tobool32 = icmp ne i64 %and31, 0
  br i1 %tobool32, label %if.then33, label %if.end36

if.then33:                                        ; preds = %if.end30
  %23 = load i32* %rctl, align 4
  %or34 = or i32 %23, 8421380
  store i32 %or34, i32* %rctl, align 4
  %24 = load i32* %rctl, align 4
  %and35 = and i32 %24, -4980737
  store i32 %and35, i32* %rctl, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then33, %if.end30
  br label %do.body37

do.body37:                                        ; preds = %if.end36
  %25 = load %struct.e1000_hw** %hw, align 8
  %hw_addr39 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 1
  %26 = load volatile i8** %hw_addr39, align 8
  store i8* %26, i8** %hw_addr38, align 8
  %27 = load i8** %hw_addr38, align 8
  %tobool40 = icmp ne i8* %27, null
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot45 = xor i1 %lnot43, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  %expval48 = call i64 @llvm.expect.i64(i64 %conv47, i64 0)
  %tobool49 = icmp ne i64 %expval48, 0
  br i1 %tobool49, label %if.end52, label %if.then50

if.then50:                                        ; preds = %do.body37
  %28 = load i32* %rctl, align 4
  %29 = load i8** %hw_addr38, align 8
  %arrayidx51 = getelementptr i8* %29, i64 256
  call void @writel(i32 %28, i8* %arrayidx51) noredzone
  br label %if.end52

if.end52:                                         ; preds = %if.then50, %do.body37
  br label %do.end53

do.end53:                                         ; preds = %if.end52
  ret void
}

define void @igb_configure_rx_ring(%struct.igb_adapter* %adapter, %struct.igb_ring* %ring) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %ring.addr = alloca %struct.igb_ring*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %rdba = alloca i64, align 8
  %reg_idx = alloca i32, align 4
  %srrctl = alloca i32, align 4
  %rxdctl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr12 = alloca i8*, align 8
  %hw_addr41 = alloca i8*, align 8
  %hw_addr70 = alloca i8*, align 8
  %hw_addr112 = alloca i8*, align 8
  %hw_addr153 = alloca i8*, align 8
  %hw_addr198 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_ring** %ring.addr, align 8
  %dma = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 7
  %2 = load i64* %dma, align 8
  store i64 %2, i64* %rdba, align 8
  %3 = load %struct.igb_ring** %ring.addr, align 8
  %reg_idx2 = getelementptr inbounds %struct.igb_ring* %3, i32 0, i32 11
  %4 = load i8* %reg_idx2, align 1
  %conv = zext i8 %4 to i32
  store i32 %conv, i32* %reg_idx, align 4
  store i32 0, i32* %srrctl, align 4
  store i32 0, i32* %rxdctl, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %5 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 1
  %6 = load volatile i8** %hw_addr3, align 8
  store i8* %6, i8** %hw_addr, align 8
  %7 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %7, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %8 = load i32* %reg_idx, align 4
  %cmp = icmp slt i32 %8, 4
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then
  %9 = load i32* %reg_idx, align 4
  %mul = mul i32 %9, 256
  %add = add i32 10280, %mul
  br label %cond.end

cond.false:                                       ; preds = %if.then
  %10 = load i32* %reg_idx, align 4
  %mul9 = mul i32 %10, 64
  %add10 = add i32 49192, %mul9
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ %add10, %cond.false ]
  %idxprom = sext i32 %cond to i64
  %11 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %11, i64 %idxprom
  call void @writel(i32 0, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %cond.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.body11

do.body11:                                        ; preds = %do.end
  %12 = load %struct.e1000_hw** %hw, align 8
  %hw_addr13 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 1
  %13 = load volatile i8** %hw_addr13, align 8
  store i8* %13, i8** %hw_addr12, align 8
  %14 = load i8** %hw_addr12, align 8
  %tobool14 = icmp ne i8* %14, null
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.end38, label %if.then24

if.then24:                                        ; preds = %do.body11
  %15 = load i64* %rdba, align 8
  %and = and i64 %15, 4294967295
  %conv25 = trunc i64 %and to i32
  %16 = load i32* %reg_idx, align 4
  %cmp26 = icmp slt i32 %16, 4
  br i1 %cmp26, label %cond.true28, label %cond.false31

cond.true28:                                      ; preds = %if.then24
  %17 = load i32* %reg_idx, align 4
  %mul29 = mul i32 %17, 256
  %add30 = add i32 10240, %mul29
  br label %cond.end34

cond.false31:                                     ; preds = %if.then24
  %18 = load i32* %reg_idx, align 4
  %mul32 = mul i32 %18, 64
  %add33 = add i32 49152, %mul32
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false31, %cond.true28
  %cond35 = phi i32 [ %add30, %cond.true28 ], [ %add33, %cond.false31 ]
  %idxprom36 = sext i32 %cond35 to i64
  %19 = load i8** %hw_addr12, align 8
  %arrayidx37 = getelementptr i8* %19, i64 %idxprom36
  call void @writel(i32 %conv25, i8* %arrayidx37) noredzone
  br label %if.end38

if.end38:                                         ; preds = %cond.end34, %do.body11
  br label %do.end39

do.end39:                                         ; preds = %if.end38
  br label %do.body40

do.body40:                                        ; preds = %do.end39
  %20 = load %struct.e1000_hw** %hw, align 8
  %hw_addr42 = getelementptr inbounds %struct.e1000_hw* %20, i32 0, i32 1
  %21 = load volatile i8** %hw_addr42, align 8
  store i8* %21, i8** %hw_addr41, align 8
  %22 = load i8** %hw_addr41, align 8
  %tobool43 = icmp ne i8* %22, null
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %expval51 = call i64 @llvm.expect.i64(i64 %conv50, i64 0)
  %tobool52 = icmp ne i64 %expval51, 0
  br i1 %tobool52, label %if.end67, label %if.then53

if.then53:                                        ; preds = %do.body40
  %23 = load i64* %rdba, align 8
  %shr = lshr i64 %23, 32
  %conv54 = trunc i64 %shr to i32
  %24 = load i32* %reg_idx, align 4
  %cmp55 = icmp slt i32 %24, 4
  br i1 %cmp55, label %cond.true57, label %cond.false60

cond.true57:                                      ; preds = %if.then53
  %25 = load i32* %reg_idx, align 4
  %mul58 = mul i32 %25, 256
  %add59 = add i32 10244, %mul58
  br label %cond.end63

cond.false60:                                     ; preds = %if.then53
  %26 = load i32* %reg_idx, align 4
  %mul61 = mul i32 %26, 64
  %add62 = add i32 49156, %mul61
  br label %cond.end63

cond.end63:                                       ; preds = %cond.false60, %cond.true57
  %cond64 = phi i32 [ %add59, %cond.true57 ], [ %add62, %cond.false60 ]
  %idxprom65 = sext i32 %cond64 to i64
  %27 = load i8** %hw_addr41, align 8
  %arrayidx66 = getelementptr i8* %27, i64 %idxprom65
  call void @writel(i32 %conv54, i8* %arrayidx66) noredzone
  br label %if.end67

if.end67:                                         ; preds = %cond.end63, %do.body40
  br label %do.end68

do.end68:                                         ; preds = %if.end67
  br label %do.body69

do.body69:                                        ; preds = %do.end68
  %28 = load %struct.e1000_hw** %hw, align 8
  %hw_addr71 = getelementptr inbounds %struct.e1000_hw* %28, i32 0, i32 1
  %29 = load volatile i8** %hw_addr71, align 8
  store i8* %29, i8** %hw_addr70, align 8
  %30 = load i8** %hw_addr70, align 8
  %tobool72 = icmp ne i8* %30, null
  %lnot73 = xor i1 %tobool72, true
  %lnot75 = xor i1 %lnot73, true
  %lnot77 = xor i1 %lnot75, true
  %lnot.ext78 = zext i1 %lnot77 to i32
  %conv79 = sext i32 %lnot.ext78 to i64
  %expval80 = call i64 @llvm.expect.i64(i64 %conv79, i64 0)
  %tobool81 = icmp ne i64 %expval80, 0
  br i1 %tobool81, label %if.end98, label %if.then82

if.then82:                                        ; preds = %do.body69
  %31 = load %struct.igb_ring** %ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %31, i32 0, i32 9
  %32 = load i16* %count, align 2
  %conv83 = zext i16 %32 to i64
  %mul84 = mul i64 %conv83, 16
  %conv85 = trunc i64 %mul84 to i32
  %33 = load i32* %reg_idx, align 4
  %cmp86 = icmp slt i32 %33, 4
  br i1 %cmp86, label %cond.true88, label %cond.false91

cond.true88:                                      ; preds = %if.then82
  %34 = load i32* %reg_idx, align 4
  %mul89 = mul i32 %34, 256
  %add90 = add i32 10248, %mul89
  br label %cond.end94

cond.false91:                                     ; preds = %if.then82
  %35 = load i32* %reg_idx, align 4
  %mul92 = mul i32 %35, 64
  %add93 = add i32 49160, %mul92
  br label %cond.end94

cond.end94:                                       ; preds = %cond.false91, %cond.true88
  %cond95 = phi i32 [ %add90, %cond.true88 ], [ %add93, %cond.false91 ]
  %idxprom96 = sext i32 %cond95 to i64
  %36 = load i8** %hw_addr70, align 8
  %arrayidx97 = getelementptr i8* %36, i64 %idxprom96
  call void @writel(i32 %conv85, i8* %arrayidx97) noredzone
  br label %if.end98

if.end98:                                         ; preds = %cond.end94, %do.body69
  br label %do.end99

do.end99:                                         ; preds = %if.end98
  %37 = load %struct.e1000_hw** %hw, align 8
  %hw_addr100 = getelementptr inbounds %struct.e1000_hw* %37, i32 0, i32 1
  %38 = load i8** %hw_addr100, align 8
  %39 = load i32* %reg_idx, align 4
  %cmp101 = icmp slt i32 %39, 4
  br i1 %cmp101, label %cond.true103, label %cond.false106

cond.true103:                                     ; preds = %do.end99
  %40 = load i32* %reg_idx, align 4
  %mul104 = mul i32 %40, 256
  %add105 = add i32 10264, %mul104
  br label %cond.end109

cond.false106:                                    ; preds = %do.end99
  %41 = load i32* %reg_idx, align 4
  %mul107 = mul i32 %41, 64
  %add108 = add i32 49176, %mul107
  br label %cond.end109

cond.end109:                                      ; preds = %cond.false106, %cond.true103
  %cond110 = phi i32 [ %add105, %cond.true103 ], [ %add108, %cond.false106 ]
  %idx.ext = sext i32 %cond110 to i64
  %add.ptr = getelementptr i8* %38, i64 %idx.ext
  %42 = load %struct.igb_ring** %ring.addr, align 8
  %tail = getelementptr inbounds %struct.igb_ring* %42, i32 0, i32 6
  store i8* %add.ptr, i8** %tail, align 8
  br label %do.body111

do.body111:                                       ; preds = %cond.end109
  %43 = load %struct.e1000_hw** %hw, align 8
  %hw_addr113 = getelementptr inbounds %struct.e1000_hw* %43, i32 0, i32 1
  %44 = load volatile i8** %hw_addr113, align 8
  store i8* %44, i8** %hw_addr112, align 8
  %45 = load i8** %hw_addr112, align 8
  %tobool114 = icmp ne i8* %45, null
  %lnot115 = xor i1 %tobool114, true
  %lnot117 = xor i1 %lnot115, true
  %lnot119 = xor i1 %lnot117, true
  %lnot.ext120 = zext i1 %lnot119 to i32
  %conv121 = sext i32 %lnot.ext120 to i64
  %expval122 = call i64 @llvm.expect.i64(i64 %conv121, i64 0)
  %tobool123 = icmp ne i64 %expval122, 0
  br i1 %tobool123, label %if.end137, label %if.then124

if.then124:                                       ; preds = %do.body111
  %46 = load i32* %reg_idx, align 4
  %cmp125 = icmp slt i32 %46, 4
  br i1 %cmp125, label %cond.true127, label %cond.false130

cond.true127:                                     ; preds = %if.then124
  %47 = load i32* %reg_idx, align 4
  %mul128 = mul i32 %47, 256
  %add129 = add i32 10256, %mul128
  br label %cond.end133

cond.false130:                                    ; preds = %if.then124
  %48 = load i32* %reg_idx, align 4
  %mul131 = mul i32 %48, 64
  %add132 = add i32 49168, %mul131
  br label %cond.end133

cond.end133:                                      ; preds = %cond.false130, %cond.true127
  %cond134 = phi i32 [ %add129, %cond.true127 ], [ %add132, %cond.false130 ]
  %idxprom135 = sext i32 %cond134 to i64
  %49 = load i8** %hw_addr112, align 8
  %arrayidx136 = getelementptr i8* %49, i64 %idxprom135
  call void @writel(i32 0, i8* %arrayidx136) noredzone
  br label %if.end137

if.end137:                                        ; preds = %cond.end133, %do.body111
  br label %do.end138

do.end138:                                        ; preds = %if.end137
  %50 = load %struct.igb_ring** %ring.addr, align 8
  %tail139 = getelementptr inbounds %struct.igb_ring* %50, i32 0, i32 6
  %51 = load i8** %tail139, align 8
  call void @writel(i32 0, i8* %51) noredzone
  store i32 1024, i32* %srrctl, align 4
  %52 = load i32* %srrctl, align 4
  %or = or i32 %52, 2
  store i32 %or, i32* %srrctl, align 4
  %53 = load i32* %srrctl, align 4
  %or140 = or i32 %53, 33554432
  store i32 %or140, i32* %srrctl, align 4
  %54 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %54, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %55 = load i32* %type, align 4
  %cmp141 = icmp uge i32 %55, 3
  br i1 %cmp141, label %if.then143, label %if.end145

if.then143:                                       ; preds = %do.end138
  %56 = load i32* %srrctl, align 4
  %or144 = or i32 %56, 1073741824
  store i32 %or144, i32* %srrctl, align 4
  br label %if.end145

if.end145:                                        ; preds = %if.then143, %do.end138
  %57 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %57, i32 0, i32 49
  %58 = load i32* %vfs_allocated_count, align 4
  %tobool146 = icmp ne i32 %58, 0
  br i1 %tobool146, label %if.then149, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end145
  %59 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %59, i32 0, i32 14
  %60 = load i32* %num_rx_queues, align 4
  %cmp147 = icmp sgt i32 %60, 1
  br i1 %cmp147, label %if.then149, label %if.end151

if.then149:                                       ; preds = %lor.lhs.false, %if.end145
  %61 = load i32* %srrctl, align 4
  %or150 = or i32 %61, -2147483648
  store i32 %or150, i32* %srrctl, align 4
  br label %if.end151

if.end151:                                        ; preds = %if.then149, %lor.lhs.false
  br label %do.body152

do.body152:                                       ; preds = %if.end151
  %62 = load %struct.e1000_hw** %hw, align 8
  %hw_addr154 = getelementptr inbounds %struct.e1000_hw* %62, i32 0, i32 1
  %63 = load volatile i8** %hw_addr154, align 8
  store i8* %63, i8** %hw_addr153, align 8
  %64 = load i8** %hw_addr153, align 8
  %tobool155 = icmp ne i8* %64, null
  %lnot156 = xor i1 %tobool155, true
  %lnot158 = xor i1 %lnot156, true
  %lnot160 = xor i1 %lnot158, true
  %lnot.ext161 = zext i1 %lnot160 to i32
  %conv162 = sext i32 %lnot.ext161 to i64
  %expval163 = call i64 @llvm.expect.i64(i64 %conv162, i64 0)
  %tobool164 = icmp ne i64 %expval163, 0
  br i1 %tobool164, label %if.end178, label %if.then165

if.then165:                                       ; preds = %do.body152
  %65 = load i32* %srrctl, align 4
  %66 = load i32* %reg_idx, align 4
  %cmp166 = icmp slt i32 %66, 4
  br i1 %cmp166, label %cond.true168, label %cond.false171

cond.true168:                                     ; preds = %if.then165
  %67 = load i32* %reg_idx, align 4
  %mul169 = mul i32 %67, 256
  %add170 = add i32 10252, %mul169
  br label %cond.end174

cond.false171:                                    ; preds = %if.then165
  %68 = load i32* %reg_idx, align 4
  %mul172 = mul i32 %68, 64
  %add173 = add i32 49164, %mul172
  br label %cond.end174

cond.end174:                                      ; preds = %cond.false171, %cond.true168
  %cond175 = phi i32 [ %add170, %cond.true168 ], [ %add173, %cond.false171 ]
  %idxprom176 = sext i32 %cond175 to i64
  %69 = load i8** %hw_addr153, align 8
  %arrayidx177 = getelementptr i8* %69, i64 %idxprom176
  call void @writel(i32 %65, i8* %arrayidx177) noredzone
  br label %if.end178

if.end178:                                        ; preds = %cond.end174, %do.body152
  br label %do.end179

do.end179:                                        ; preds = %if.end178
  %70 = load %struct.igb_adapter** %adapter.addr, align 8
  %71 = load i32* %reg_idx, align 4
  %and180 = and i32 %71, 7
  call void @igb_set_vmolr(%struct.igb_adapter* %70, i32 %and180, i1 zeroext true) noredzone
  %72 = load %struct.e1000_hw** %hw, align 8
  %mac181 = getelementptr inbounds %struct.e1000_hw* %72, i32 0, i32 4
  %type182 = getelementptr inbounds %struct.e1000_mac_info* %mac181, i32 0, i32 3
  %73 = load i32* %type182, align 4
  %cmp183 = icmp eq i32 %73, 5
  %cond185 = select i1 %cmp183, i32 12, i32 8
  %74 = load i32* %rxdctl, align 4
  %or186 = or i32 %74, %cond185
  store i32 %or186, i32* %rxdctl, align 4
  %75 = load i32* %rxdctl, align 4
  %or187 = or i32 %75, 2048
  store i32 %or187, i32* %rxdctl, align 4
  %76 = load %struct.e1000_hw** %hw, align 8
  %mac188 = getelementptr inbounds %struct.e1000_hw* %76, i32 0, i32 4
  %type189 = getelementptr inbounds %struct.e1000_mac_info* %mac188, i32 0, i32 3
  %77 = load i32* %type189, align 4
  %cmp190 = icmp eq i32 %77, 2
  br i1 %cmp190, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %do.end179
  %78 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %78, i32 0, i32 3
  %79 = load i32* %flags, align 4
  %and192 = and i32 %79, 8192
  %tobool193 = icmp ne i32 %and192, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %do.end179
  %80 = phi i1 [ false, %do.end179 ], [ %tobool193, %land.rhs ]
  %cond194 = select i1 %80, i32 1, i32 4
  %shl = shl i32 %cond194, 16
  %81 = load i32* %rxdctl, align 4
  %or195 = or i32 %81, %shl
  store i32 %or195, i32* %rxdctl, align 4
  %82 = load i32* %rxdctl, align 4
  %or196 = or i32 %82, 33554432
  store i32 %or196, i32* %rxdctl, align 4
  br label %do.body197

do.body197:                                       ; preds = %land.end
  %83 = load %struct.e1000_hw** %hw, align 8
  %hw_addr199 = getelementptr inbounds %struct.e1000_hw* %83, i32 0, i32 1
  %84 = load volatile i8** %hw_addr199, align 8
  store i8* %84, i8** %hw_addr198, align 8
  %85 = load i8** %hw_addr198, align 8
  %tobool200 = icmp ne i8* %85, null
  %lnot201 = xor i1 %tobool200, true
  %lnot203 = xor i1 %lnot201, true
  %lnot205 = xor i1 %lnot203, true
  %lnot.ext206 = zext i1 %lnot205 to i32
  %conv207 = sext i32 %lnot.ext206 to i64
  %expval208 = call i64 @llvm.expect.i64(i64 %conv207, i64 0)
  %tobool209 = icmp ne i64 %expval208, 0
  br i1 %tobool209, label %if.end223, label %if.then210

if.then210:                                       ; preds = %do.body197
  %86 = load i32* %rxdctl, align 4
  %87 = load i32* %reg_idx, align 4
  %cmp211 = icmp slt i32 %87, 4
  br i1 %cmp211, label %cond.true213, label %cond.false216

cond.true213:                                     ; preds = %if.then210
  %88 = load i32* %reg_idx, align 4
  %mul214 = mul i32 %88, 256
  %add215 = add i32 10280, %mul214
  br label %cond.end219

cond.false216:                                    ; preds = %if.then210
  %89 = load i32* %reg_idx, align 4
  %mul217 = mul i32 %89, 64
  %add218 = add i32 49192, %mul217
  br label %cond.end219

cond.end219:                                      ; preds = %cond.false216, %cond.true213
  %cond220 = phi i32 [ %add215, %cond.true213 ], [ %add218, %cond.false216 ]
  %idxprom221 = sext i32 %cond220 to i64
  %90 = load i8** %hw_addr198, align 8
  %arrayidx222 = getelementptr i8* %90, i64 %idxprom221
  call void @writel(i32 %86, i8* %arrayidx222) noredzone
  br label %if.end223

if.end223:                                        ; preds = %cond.end219, %do.body197
  br label %do.end224

do.end224:                                        ; preds = %if.end223
  ret void
}

define internal void @igb_set_vmolr(%struct.igb_adapter* %adapter, i32 %vfn, i1 zeroext %aupe) nounwind inlinehint noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vfn.addr = alloca i32, align 4
  %aupe.addr = alloca i8, align 1
  %hw = alloca %struct.e1000_hw*, align 8
  %vmolr = alloca i32, align 4
  %dvmolr = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr38 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vfn, i32* %vfn.addr, align 4
  %frombool = zext i1 %aupe to i8
  store i8 %frombool, i8* %aupe.addr, align 1
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  %cmp = icmp ult i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %do.end56

if.end:                                           ; preds = %entry
  %3 = load %struct.e1000_hw** %hw, align 8
  %4 = load i32* %vfn.addr, align 4
  %mul = mul i32 4, %4
  %add = add i32 23248, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 %add) noredzone
  store i32 %call, i32* %vmolr, align 4
  %5 = load i32* %vmolr, align 4
  %or = or i32 %5, 1073741824
  store i32 %or, i32* %vmolr, align 4
  %6 = load %struct.e1000_hw** %hw, align 8
  %mac2 = getelementptr inbounds %struct.e1000_hw* %6, i32 0, i32 4
  %type3 = getelementptr inbounds %struct.e1000_mac_info* %mac2, i32 0, i32 3
  %7 = load i32* %type3, align 4
  %cmp4 = icmp eq i32 %7, 4
  br i1 %cmp4, label %if.then5, label %if.end18

if.then5:                                         ; preds = %if.end
  %8 = load %struct.e1000_hw** %hw, align 8
  %9 = load i32* %vfn.addr, align 4
  %mul6 = mul i32 64, %9
  %add7 = add i32 49208, %mul6
  %call8 = call i32 @igb_rd32(%struct.e1000_hw* %8, i32 %add7) noredzone
  store i32 %call8, i32* %dvmolr, align 4
  %10 = load i32* %dvmolr, align 4
  %or9 = or i32 %10, 1073741824
  store i32 %or9, i32* %dvmolr, align 4
  br label %do.body

do.body:                                          ; preds = %if.then5
  %11 = load %struct.e1000_hw** %hw, align 8
  %hw_addr10 = getelementptr inbounds %struct.e1000_hw* %11, i32 0, i32 1
  %12 = load volatile i8** %hw_addr10, align 8
  store i8* %12, i8** %hw_addr, align 8
  %13 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %13, null
  %lnot = xor i1 %tobool, true
  %lnot11 = xor i1 %lnot, true
  %lnot12 = xor i1 %lnot11, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.end17, label %if.then14

if.then14:                                        ; preds = %do.body
  %14 = load i32* %dvmolr, align 4
  %15 = load i32* %vfn.addr, align 4
  %mul15 = mul i32 64, %15
  %add16 = add i32 49208, %mul15
  %idxprom = sext i32 %add16 to i64
  %16 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %16, i64 %idxprom
  call void @writel(i32 %14, i8* %arrayidx) noredzone
  br label %if.end17

if.end17:                                         ; preds = %if.then14, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end17
  br label %if.end18

if.end18:                                         ; preds = %do.end, %if.end
  %17 = load i8* %aupe.addr, align 1
  %tobool19 = trunc i8 %17 to i1
  br i1 %tobool19, label %if.then20, label %if.else

if.then20:                                        ; preds = %if.end18
  %18 = load i32* %vmolr, align 4
  %or21 = or i32 %18, 16777216
  store i32 %or21, i32* %vmolr, align 4
  br label %if.end22

if.else:                                          ; preds = %if.end18
  %19 = load i32* %vmolr, align 4
  %and = and i32 %19, -16777217
  store i32 %and, i32* %vmolr, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then20
  %20 = load i32* %vmolr, align 4
  %and23 = and i32 %20, -134348801
  store i32 %and23, i32* %vmolr, align 4
  %21 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 52
  %22 = load i32* %rss_queues, align 4
  %cmp24 = icmp ugt i32 %22, 1
  br i1 %cmp24, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %if.end22
  %23 = load i32* %vfn.addr, align 4
  %24 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %24, i32 0, i32 49
  %25 = load i32* %vfs_allocated_count, align 4
  %cmp26 = icmp eq i32 %23, %25
  br i1 %cmp26, label %if.then28, label %if.end30

if.then28:                                        ; preds = %land.lhs.true
  %26 = load i32* %vmolr, align 4
  %or29 = or i32 %26, 131072
  store i32 %or29, i32* %vmolr, align 4
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %land.lhs.true, %if.end22
  %27 = load i32* %vfn.addr, align 4
  %28 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count31 = getelementptr inbounds %struct.igb_adapter* %28, i32 0, i32 49
  %29 = load i32* %vfs_allocated_count31, align 4
  %cmp32 = icmp ule i32 %27, %29
  br i1 %cmp32, label %if.then34, label %if.end36

if.then34:                                        ; preds = %if.end30
  %30 = load i32* %vmolr, align 4
  %or35 = or i32 %30, 134217728
  store i32 %or35, i32* %vmolr, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then34, %if.end30
  br label %do.body37

do.body37:                                        ; preds = %if.end36
  %31 = load %struct.e1000_hw** %hw, align 8
  %hw_addr39 = getelementptr inbounds %struct.e1000_hw* %31, i32 0, i32 1
  %32 = load volatile i8** %hw_addr39, align 8
  store i8* %32, i8** %hw_addr38, align 8
  %33 = load i8** %hw_addr38, align 8
  %tobool40 = icmp ne i8* %33, null
  %lnot41 = xor i1 %tobool40, true
  %lnot43 = xor i1 %lnot41, true
  %lnot45 = xor i1 %lnot43, true
  %lnot.ext46 = zext i1 %lnot45 to i32
  %conv47 = sext i32 %lnot.ext46 to i64
  %expval48 = call i64 @llvm.expect.i64(i64 %conv47, i64 0)
  %tobool49 = icmp ne i64 %expval48, 0
  br i1 %tobool49, label %if.end55, label %if.then50

if.then50:                                        ; preds = %do.body37
  %34 = load i32* %vmolr, align 4
  %35 = load i32* %vfn.addr, align 4
  %mul51 = mul i32 4, %35
  %add52 = add i32 23248, %mul51
  %idxprom53 = sext i32 %add52 to i64
  %36 = load i8** %hw_addr38, align 8
  %arrayidx54 = getelementptr i8* %36, i64 %idxprom53
  call void @writel(i32 %34, i8* %arrayidx54) noredzone
  br label %if.end55

if.end55:                                         ; preds = %if.then50, %do.body37
  br label %do.end56

do.end56:                                         ; preds = %if.then, %if.end55
  ret void
}

define void @igb_free_tx_resources(%struct.igb_ring* %tx_ring) nounwind noredzone {
entry:
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  call void @igb_clean_tx_ring(%struct.igb_ring* %0) noredzone
  %1 = load %struct.igb_ring** %tx_ring.addr, align 8
  %2 = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %2 to %struct.igb_tx_buffer**
  %3 = load %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %4 = bitcast %struct.igb_tx_buffer* %3 to i8*
  call void @vfree(i8* %4) noredzone
  %5 = load %struct.igb_ring** %tx_ring.addr, align 8
  %6 = getelementptr inbounds %struct.igb_ring* %5, i32 0, i32 3
  %tx_buffer_info1 = bitcast %union.anon.87* %6 to %struct.igb_tx_buffer**
  store %struct.igb_tx_buffer* null, %struct.igb_tx_buffer** %tx_buffer_info1, align 8
  %7 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %7, i32 0, i32 4
  %8 = load i8** %desc, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %9, i32 0, i32 2
  %10 = load %struct.device** %dev, align 8
  %11 = load %struct.igb_ring** %tx_ring.addr, align 8
  %size = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 8
  %12 = load i32* %size, align 4
  %conv = zext i32 %12 to i64
  %13 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc2 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 4
  %14 = load i8** %desc2, align 8
  %15 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dma = getelementptr inbounds %struct.igb_ring* %15, i32 0, i32 7
  %16 = load i64* %dma, align 8
  call void @dma_free_attrs(%struct.device* %10, i64 %conv, i8* %14, i64 %16, %struct.dma_attrs* null) noredzone
  %17 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc3 = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 4
  store i8* null, i8** %desc3, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

define internal void @igb_clean_tx_ring(%struct.igb_ring* %tx_ring) nounwind noredzone {
entry:
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %buffer_info = alloca %struct.igb_tx_buffer*, align 8
  %size = alloca i64, align 8
  %i = alloca i16, align 2
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  %1 = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %1 to %struct.igb_tx_buffer**
  %2 = load %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %tobool = icmp ne %struct.igb_tx_buffer* %2, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  store i16 0, i16* %i, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %3 = load i16* %i, align 2
  %conv = zext i16 %3 to i32
  %4 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %4, i32 0, i32 9
  %5 = load i16* %count, align 2
  %conv1 = zext i16 %5 to i32
  %cmp = icmp slt i32 %conv, %conv1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i16* %i, align 2
  %idxprom = zext i16 %6 to i64
  %7 = load %struct.igb_ring** %tx_ring.addr, align 8
  %8 = getelementptr inbounds %struct.igb_ring* %7, i32 0, i32 3
  %tx_buffer_info3 = bitcast %union.anon.87* %8 to %struct.igb_tx_buffer**
  %9 = load %struct.igb_tx_buffer** %tx_buffer_info3, align 8
  %arrayidx = getelementptr %struct.igb_tx_buffer* %9, i64 %idxprom
  store %struct.igb_tx_buffer* %arrayidx, %struct.igb_tx_buffer** %buffer_info, align 8
  %10 = load %struct.igb_ring** %tx_ring.addr, align 8
  %11 = load %struct.igb_tx_buffer** %buffer_info, align 8
  call void @igb_unmap_and_free_tx_resource(%struct.igb_ring* %10, %struct.igb_tx_buffer* %11) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i16* %i, align 2
  %inc = add i16 %12, 1
  store i16 %inc, i16* %i, align 2
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %13 = load %struct.igb_ring** %tx_ring.addr, align 8
  %call = call %struct.netdev_queue* @txring_txq(%struct.igb_ring* %13) noredzone
  call void @netdev_tx_reset_queue(%struct.netdev_queue* %call) noredzone
  %14 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count4 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 9
  %15 = load i16* %count4, align 2
  %conv5 = zext i16 %15 to i64
  %mul = mul i64 48, %conv5
  store i64 %mul, i64* %size, align 8
  %16 = load %struct.igb_ring** %tx_ring.addr, align 8
  %17 = getelementptr inbounds %struct.igb_ring* %16, i32 0, i32 3
  %tx_buffer_info6 = bitcast %union.anon.87* %17 to %struct.igb_tx_buffer**
  %18 = load %struct.igb_tx_buffer** %tx_buffer_info6, align 8
  %19 = bitcast %struct.igb_tx_buffer* %18 to i8*
  %20 = load i64* %size, align 8
  call void @llvm.memset.p0i8.i64(i8* %19, i8 0, i64 %20, i32 8, i1 false)
  %21 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %21, i32 0, i32 4
  %22 = load i8** %desc, align 8
  %23 = load %struct.igb_ring** %tx_ring.addr, align 8
  %size7 = getelementptr inbounds %struct.igb_ring* %23, i32 0, i32 8
  %24 = load i32* %size7, align 4
  %conv8 = zext i32 %24 to i64
  call void @llvm.memset.p0i8.i64(i8* %22, i8 0, i64 %conv8, i32 1, i1 false)
  %25 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %25, i32 0, i32 13
  store i16 0, i16* %next_to_use, align 2
  %26 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %26, i32 0, i32 12
  store i16 0, i16* %next_to_clean, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then
  ret void
}

define internal void @dma_free_attrs(%struct.device* %dev, i64 %size, i8* %vaddr, i64 %bus, %struct.dma_attrs* %attrs) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %size.addr = alloca i64, align 8
  %vaddr.addr = alloca i8*, align 8
  %bus.addr = alloca i64, align 8
  %attrs.addr = alloca %struct.dma_attrs*, align 8
  %ops = alloca %struct.dma_map_ops*, align 8
  %__ret_warn_on = alloca i32, align 4
  %_flags = alloca i64, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy3 = alloca i64, align 8
  %__dummy24 = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i8* %vaddr, i8** %vaddr.addr, align 8
  store i64 %bus, i64* %bus.addr, align 8
  store %struct.dma_attrs* %attrs, %struct.dma_attrs** %attrs.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  %call1 = call i64 @arch_local_save_flags() noredzone
  store i64 %call1, i64* %_flags, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %cmp5 = icmp eq i64* %__dummy3, %__dummy24
  %conv6 = zext i1 %cmp5 to i32
  %1 = load i64* %_flags, align 8
  %call7 = call i32 @arch_irqs_disabled_flags(i64 %1) noredzone
  %tobool = icmp ne i32 %call7, 0
  %lnot = xor i1 %tobool, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %2 = load i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %2, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool15 = icmp ne i64 %expval, 0
  br i1 %tobool15, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  call void @warn_slowpath_null(i8* getelementptr inbounds ([37 x i8]* @.str37, i32 0, i32 0), i32 166) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.end
  %3 = load i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %3, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %4 = load %struct.device** %dev.addr, align 8
  %5 = load i64* %size.addr, align 8
  %6 = load i8** %vaddr.addr, align 8
  %7 = load i64* %bus.addr, align 8
  call void @debug_dma_free_coherent(%struct.device* %4, i64 %5, i8* %6, i64 %7) noredzone
  %8 = load %struct.dma_map_ops** %ops, align 8
  %free = getelementptr inbounds %struct.dma_map_ops* %8, i32 0, i32 1
  %9 = load void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)** %free, align 8
  %tobool23 = icmp ne void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)* %9, null
  br i1 %tobool23, label %if.then24, label %if.end26

if.then24:                                        ; preds = %if.end
  %10 = load %struct.dma_map_ops** %ops, align 8
  %free25 = getelementptr inbounds %struct.dma_map_ops* %10, i32 0, i32 1
  %11 = load void (%struct.device*, i64, i8*, i64, %struct.dma_attrs*)** %free25, align 8
  %12 = load %struct.device** %dev.addr, align 8
  %13 = load i64* %size.addr, align 8
  %14 = load i8** %vaddr.addr, align 8
  %15 = load i64* %bus.addr, align 8
  %16 = load %struct.dma_attrs** %attrs.addr, align 8
  call void %11(%struct.device* %12, i64 %13, i8* %14, i64 %15, %struct.dma_attrs* %16) noredzone
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %if.end
  ret void
}

define void @igb_unmap_and_free_tx_resource(%struct.igb_ring* %ring, %struct.igb_tx_buffer* %tx_buffer) nounwind noredzone {
entry:
  %ring.addr = alloca %struct.igb_ring*, align 8
  %tx_buffer.addr = alloca %struct.igb_tx_buffer*, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  store %struct.igb_tx_buffer* %tx_buffer, %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %0 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %skb = getelementptr inbounds %struct.igb_tx_buffer* %0, i32 0, i32 2
  %1 = load %struct.sk_buff** %skb, align 8
  %tobool = icmp ne %struct.sk_buff* %1, null
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %2 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %skb1 = getelementptr inbounds %struct.igb_tx_buffer* %2, i32 0, i32 2
  %3 = load %struct.sk_buff** %skb1, align 8
  call void @dev_kfree_skb_any(%struct.sk_buff* %3) noredzone
  %4 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %len = getelementptr inbounds %struct.igb_tx_buffer* %4, i32 0, i32 7
  %5 = load i32* %len, align 4
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %6 = load %struct.igb_ring** %ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 2
  %7 = load %struct.device** %dev, align 8
  %8 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %dma = getelementptr inbounds %struct.igb_tx_buffer* %8, i32 0, i32 6
  %9 = load i64* %dma, align 8
  %10 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %len4 = getelementptr inbounds %struct.igb_tx_buffer* %10, i32 0, i32 7
  %11 = load i32* %len4, align 4
  %conv = zext i32 %11 to i64
  call void @dma_unmap_single_attrs(%struct.device* %7, i64 %9, i64 %conv, i32 1, %struct.dma_attrs* null) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then3, %if.then
  br label %if.end13

if.else:                                          ; preds = %entry
  %12 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %len5 = getelementptr inbounds %struct.igb_tx_buffer* %12, i32 0, i32 7
  %13 = load i32* %len5, align 4
  %tobool6 = icmp ne i32 %13, 0
  br i1 %tobool6, label %if.then7, label %if.end12

if.then7:                                         ; preds = %if.else
  %14 = load %struct.igb_ring** %ring.addr, align 8
  %dev8 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 2
  %15 = load %struct.device** %dev8, align 8
  %16 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %dma9 = getelementptr inbounds %struct.igb_tx_buffer* %16, i32 0, i32 6
  %17 = load i64* %dma9, align 8
  %18 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %len10 = getelementptr inbounds %struct.igb_tx_buffer* %18, i32 0, i32 7
  %19 = load i32* %len10, align 4
  %conv11 = zext i32 %19 to i64
  call void @dma_unmap_page(%struct.device* %15, i64 %17, i64 %conv11, i32 1) noredzone
  br label %if.end12

if.end12:                                         ; preds = %if.then7, %if.else
  br label %if.end13

if.end13:                                         ; preds = %if.end12, %if.end
  %20 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %next_to_watch = getelementptr inbounds %struct.igb_tx_buffer* %20, i32 0, i32 0
  store %union.e1000_adv_tx_desc* null, %union.e1000_adv_tx_desc** %next_to_watch, align 8
  %21 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %skb14 = getelementptr inbounds %struct.igb_tx_buffer* %21, i32 0, i32 2
  store %struct.sk_buff* null, %struct.sk_buff** %skb14, align 8
  %22 = load %struct.igb_tx_buffer** %tx_buffer.addr, align 8
  %len15 = getelementptr inbounds %struct.igb_tx_buffer* %22, i32 0, i32 7
  store i32 0, i32* %len15, align 4
  ret void
}

define internal void @dev_kfree_skb_any(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  call void @__dev_kfree_skb_any(%struct.sk_buff* %0, i32 1) noredzone
  ret void
}

define internal void @dma_unmap_single_attrs(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir, %struct.dma_attrs* %attrs) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %attrs.addr = alloca %struct.dma_attrs*, align 8
  %ops = alloca %struct.dma_map_ops*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  store %struct.dma_attrs* %attrs, %struct.dma_attrs** %attrs.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32* %dir.addr, align 4
  %call1 = call i32 @valid_dma_direction(i32 %1) noredzone
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8]* @.str28, i32 0, i32 0), i32 36, i64 12) nounwind, !srcloc !10
  br label %do.body6

do.body6:                                         ; preds = %do.cond, %do.body5
  br label %do.cond

do.cond:                                          ; preds = %do.body6
  br i1 true, label %do.body6, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %do.body
  br label %do.end10

do.end10:                                         ; preds = %if.end
  %2 = load %struct.dma_map_ops** %ops, align 8
  %unmap_page = getelementptr inbounds %struct.dma_map_ops* %2, i32 0, i32 5
  %3 = load void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)** %unmap_page, align 8
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)* %3, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %4 = load %struct.dma_map_ops** %ops, align 8
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops* %4, i32 0, i32 5
  %5 = load void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)** %unmap_page13, align 8
  %6 = load %struct.device** %dev.addr, align 8
  %7 = load i64* %addr.addr, align 8
  %8 = load i64* %size.addr, align 8
  %9 = load i32* %dir.addr, align 4
  %10 = load %struct.dma_attrs** %attrs.addr, align 8
  call void %5(%struct.device* %6, i64 %7, i64 %8, i32 %9, %struct.dma_attrs* %10) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  %11 = load %struct.device** %dev.addr, align 8
  %12 = load i64* %addr.addr, align 8
  %13 = load i64* %size.addr, align 8
  %14 = load i32* %dir.addr, align 4
  call void @debug_dma_unmap_page(%struct.device* %11, i64 %12, i64 %13, i32 %14, i1 zeroext true) noredzone
  ret void
}

define internal void @dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %dir) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %ops = alloca %struct.dma_map_ops*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32* %dir.addr, align 4
  %call1 = call i32 @valid_dma_direction(i32 %1) noredzone
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8]* @.str28, i32 0, i32 0), i32 91, i64 12) nounwind, !srcloc !11
  br label %do.body6

do.body6:                                         ; preds = %do.cond, %do.body5
  br label %do.cond

do.cond:                                          ; preds = %do.body6
  br i1 true, label %do.body6, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %do.body
  br label %do.end10

do.end10:                                         ; preds = %if.end
  %2 = load %struct.dma_map_ops** %ops, align 8
  %unmap_page = getelementptr inbounds %struct.dma_map_ops* %2, i32 0, i32 5
  %3 = load void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)** %unmap_page, align 8
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)* %3, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %4 = load %struct.dma_map_ops** %ops, align 8
  %unmap_page13 = getelementptr inbounds %struct.dma_map_ops* %4, i32 0, i32 5
  %5 = load void (%struct.device*, i64, i64, i32, %struct.dma_attrs*)** %unmap_page13, align 8
  %6 = load %struct.device** %dev.addr, align 8
  %7 = load i64* %addr.addr, align 8
  %8 = load i64* %size.addr, align 8
  %9 = load i32* %dir.addr, align 4
  call void %5(%struct.device* %6, i64 %7, i64 %8, i32 %9, %struct.dma_attrs* null) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  %10 = load %struct.device** %dev.addr, align 8
  %11 = load i64* %addr.addr, align 8
  %12 = load i64* %size.addr, align 8
  %13 = load i32* %dir.addr, align 4
  call void @debug_dma_unmap_page(%struct.device* %10, i64 %11, i64 %12, i32 %13, i1 zeroext false) noredzone
  ret void
}

define void @igb_free_rx_resources(%struct.igb_ring* %rx_ring) nounwind noredzone {
entry:
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  call void @igb_clean_rx_ring(%struct.igb_ring* %0) noredzone
  %1 = load %struct.igb_ring** %rx_ring.addr, align 8
  %2 = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %2 to %struct.igb_rx_buffer**
  %3 = load %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %4 = bitcast %struct.igb_rx_buffer* %3 to i8*
  call void @vfree(i8* %4) noredzone
  %5 = load %struct.igb_ring** %rx_ring.addr, align 8
  %6 = getelementptr inbounds %struct.igb_ring* %5, i32 0, i32 3
  %rx_buffer_info1 = bitcast %union.anon.87* %6 to %struct.igb_rx_buffer**
  store %struct.igb_rx_buffer* null, %struct.igb_rx_buffer** %rx_buffer_info1, align 8
  %7 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %7, i32 0, i32 4
  %8 = load i8** %desc, align 8
  %tobool = icmp ne i8* %8, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %9 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %9, i32 0, i32 2
  %10 = load %struct.device** %dev, align 8
  %11 = load %struct.igb_ring** %rx_ring.addr, align 8
  %size = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 8
  %12 = load i32* %size, align 4
  %conv = zext i32 %12 to i64
  %13 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc2 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 4
  %14 = load i8** %desc2, align 8
  %15 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dma = getelementptr inbounds %struct.igb_ring* %15, i32 0, i32 7
  %16 = load i64* %dma, align 8
  call void @dma_free_attrs(%struct.device* %10, i64 %conv, i8* %14, i64 %16, %struct.dma_attrs* null) noredzone
  %17 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc3 = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 4
  store i8* null, i8** %desc3, align 8
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

define internal void @igb_clean_rx_ring(%struct.igb_ring* %rx_ring) nounwind noredzone {
entry:
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %size = alloca i64, align 8
  %i = alloca i16, align 2
  %buffer_info = alloca %struct.igb_rx_buffer*, align 8
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %1 = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 15
  %2 = bitcast %union.anon.90* %1 to %struct.anon.92*
  %skb = getelementptr inbounds %struct.anon.92* %2, i32 0, i32 0
  %3 = load %struct.sk_buff** %skb, align 8
  %tobool = icmp ne %struct.sk_buff* %3, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.igb_ring** %rx_ring.addr, align 8
  %5 = getelementptr inbounds %struct.igb_ring* %4, i32 0, i32 15
  %6 = bitcast %union.anon.90* %5 to %struct.anon.92*
  %skb1 = getelementptr inbounds %struct.anon.92* %6, i32 0, i32 0
  %7 = load %struct.sk_buff** %skb1, align 8
  call void @consume_skb(%struct.sk_buff* %7) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.igb_ring** %rx_ring.addr, align 8
  %9 = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 15
  %10 = bitcast %union.anon.90* %9 to %struct.anon.92*
  %skb2 = getelementptr inbounds %struct.anon.92* %10, i32 0, i32 0
  store %struct.sk_buff* null, %struct.sk_buff** %skb2, align 8
  %11 = load %struct.igb_ring** %rx_ring.addr, align 8
  %12 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %12 to %struct.igb_rx_buffer**
  %13 = load %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %tobool3 = icmp ne %struct.igb_rx_buffer* %13, null
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %return

if.end5:                                          ; preds = %if.end
  store i16 0, i16* %i, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end5
  %14 = load i16* %i, align 2
  %conv = zext i16 %14 to i32
  %15 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %15, i32 0, i32 9
  %16 = load i16* %count, align 2
  %conv6 = zext i16 %16 to i32
  %cmp = icmp slt i32 %conv, %conv6
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %17 = load i16* %i, align 2
  %idxprom = zext i16 %17 to i64
  %18 = load %struct.igb_ring** %rx_ring.addr, align 8
  %19 = getelementptr inbounds %struct.igb_ring* %18, i32 0, i32 3
  %rx_buffer_info8 = bitcast %union.anon.87* %19 to %struct.igb_rx_buffer**
  %20 = load %struct.igb_rx_buffer** %rx_buffer_info8, align 8
  %arrayidx = getelementptr %struct.igb_rx_buffer* %20, i64 %idxprom
  store %struct.igb_rx_buffer* %arrayidx, %struct.igb_rx_buffer** %buffer_info, align 8
  %21 = load %struct.igb_rx_buffer** %buffer_info, align 8
  %page = getelementptr inbounds %struct.igb_rx_buffer* %21, i32 0, i32 1
  %22 = load %struct.page** %page, align 8
  %tobool9 = icmp ne %struct.page* %22, null
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %for.body
  br label %for.inc

if.end11:                                         ; preds = %for.body
  %23 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %23, i32 0, i32 2
  %24 = load %struct.device** %dev, align 8
  %25 = load %struct.igb_rx_buffer** %buffer_info, align 8
  %dma = getelementptr inbounds %struct.igb_rx_buffer* %25, i32 0, i32 0
  %26 = load i64* %dma, align 8
  call void @dma_unmap_page(%struct.device* %24, i64 %26, i64 4096, i32 2) noredzone
  %27 = load %struct.igb_rx_buffer** %buffer_info, align 8
  %page12 = getelementptr inbounds %struct.igb_rx_buffer* %27, i32 0, i32 1
  %28 = load %struct.page** %page12, align 8
  call void @__free_pages(%struct.page* %28, i32 0) noredzone
  %29 = load %struct.igb_rx_buffer** %buffer_info, align 8
  %page13 = getelementptr inbounds %struct.igb_rx_buffer* %29, i32 0, i32 1
  store %struct.page* null, %struct.page** %page13, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end11, %if.then10
  %30 = load i16* %i, align 2
  %inc = add i16 %30, 1
  store i16 %inc, i16* %i, align 2
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %31 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count14 = getelementptr inbounds %struct.igb_ring* %31, i32 0, i32 9
  %32 = load i16* %count14, align 2
  %conv15 = zext i16 %32 to i64
  %mul = mul i64 24, %conv15
  store i64 %mul, i64* %size, align 8
  %33 = load %struct.igb_ring** %rx_ring.addr, align 8
  %34 = getelementptr inbounds %struct.igb_ring* %33, i32 0, i32 3
  %rx_buffer_info16 = bitcast %union.anon.87* %34 to %struct.igb_rx_buffer**
  %35 = load %struct.igb_rx_buffer** %rx_buffer_info16, align 8
  %36 = bitcast %struct.igb_rx_buffer* %35 to i8*
  %37 = load i64* %size, align 8
  call void @llvm.memset.p0i8.i64(i8* %36, i8 0, i64 %37, i32 8, i1 false)
  %38 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %38, i32 0, i32 4
  %39 = load i8** %desc, align 8
  %40 = load %struct.igb_ring** %rx_ring.addr, align 8
  %size17 = getelementptr inbounds %struct.igb_ring* %40, i32 0, i32 8
  %41 = load i32* %size17, align 4
  %conv18 = zext i32 %41 to i64
  call void @llvm.memset.p0i8.i64(i8* %39, i8 0, i64 %conv18, i32 1, i1 false)
  %42 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_alloc = getelementptr inbounds %struct.igb_ring* %42, i32 0, i32 14
  store i16 0, i16* %next_to_alloc, align 2
  %43 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %43, i32 0, i32 12
  store i16 0, i16* %next_to_clean, align 2
  %44 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %44, i32 0, i32 13
  store i16 0, i16* %next_to_use, align 2
  br label %return

return:                                           ; preds = %for.end, %if.then4
  ret void
}

define zeroext i1 @igb_has_link(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %retval = alloca i1, align 1
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %link_active = alloca i8, align 1
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i8 0, i8* %link_active, align 1
  %1 = load %struct.e1000_hw** %hw, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %2 = load i32* %media_type, align 4
  switch i32 %2, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb2
    i32 0, label %sw.bb7
  ]

sw.bb:                                            ; preds = %entry
  %3 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %3, i32 0, i32 4
  %get_link_status = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 20
  %4 = load i8* %get_link_status, align 1
  %tobool = trunc i8 %4 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.bb2

sw.bb2:                                           ; preds = %entry, %if.end
  %5 = load %struct.e1000_hw** %hw, align 8
  %mac3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 4
  %ops = getelementptr inbounds %struct.e1000_mac_info* %mac3, i32 0, i32 0
  %check_for_link = getelementptr inbounds %struct.e1000_mac_operations* %ops, i32 0, i32 0
  %6 = load i32 (%struct.e1000_hw*)** %check_for_link, align 8
  %7 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 %6(%struct.e1000_hw* %7) noredzone
  %8 = load %struct.e1000_hw** %hw, align 8
  %mac4 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 4
  %get_link_status5 = getelementptr inbounds %struct.e1000_mac_info* %mac4, i32 0, i32 20
  %9 = load i8* %get_link_status5, align 1
  %tobool6 = trunc i8 %9 to i1
  %lnot = xor i1 %tobool6, true
  %frombool = zext i1 %lnot to i8
  store i8 %frombool, i8* %link_active, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.bb7

sw.bb7:                                           ; preds = %entry, %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb7, %sw.bb2
  %10 = load %struct.e1000_hw** %hw, align 8
  %mac8 = getelementptr inbounds %struct.e1000_hw* %10, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac8, i32 0, i32 3
  %11 = load i32* %type, align 4
  %cmp = icmp eq i32 %11, 6
  br i1 %cmp, label %land.lhs.true, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %sw.epilog
  %12 = load %struct.e1000_hw** %hw, align 8
  %mac9 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 4
  %type10 = getelementptr inbounds %struct.e1000_mac_info* %mac9, i32 0, i32 3
  %13 = load i32* %type10, align 4
  %cmp11 = icmp eq i32 %13, 7
  br i1 %cmp11, label %land.lhs.true, label %if.end24

land.lhs.true:                                    ; preds = %lor.lhs.false, %sw.epilog
  %14 = load %struct.e1000_hw** %hw, align 8
  %phy12 = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 6
  %id = getelementptr inbounds %struct.e1000_phy_info* %phy12, i32 0, i32 9
  %15 = load i32* %id, align 4
  %cmp13 = icmp eq i32 %15, 21040128
  br i1 %cmp13, label %if.then14, label %if.end24

if.then14:                                        ; preds = %land.lhs.true
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 1
  %17 = load %struct.net_device** %netdev, align 8
  %call15 = call zeroext i1 @netif_carrier_ok(%struct.net_device* %17) noredzone
  br i1 %call15, label %if.else, label %if.then16

if.then16:                                        ; preds = %if.then14
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 3
  %19 = load i32* %flags, align 4
  %and = and i32 %19, -513
  store i32 %and, i32* %flags, align 4
  br label %if.end23

if.else:                                          ; preds = %if.then14
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags17 = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 3
  %21 = load i32* %flags17, align 4
  %and18 = and i32 %21, 512
  %tobool19 = icmp ne i32 %and18, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %if.else
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags21 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 3
  %23 = load i32* %flags21, align 4
  %or = or i32 %23, 512
  store i32 %or, i32* %flags21, align 4
  %24 = load volatile i64* @jiffies, align 8
  %25 = load %struct.igb_adapter** %adapter.addr, align 8
  %link_check_timeout = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 77
  store i64 %24, i64* %link_check_timeout, align 8
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %if.else
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.then16
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %land.lhs.true, %lor.lhs.false
  %26 = load i8* %link_active, align 1
  %tobool25 = trunc i8 %26 to i1
  store i1 %tobool25, i1* %retval
  br label %return

return:                                           ; preds = %if.end24, %if.then
  %27 = load i1* %retval
  ret i1 %27
}

define internal zeroext i1 @netif_carrier_ok(%struct.net_device* %dev) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %dev.addr = alloca %struct.net_device*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  %0 = load %struct.net_device** %dev.addr, align 8
  %state = getelementptr inbounds %struct.net_device* %0, i32 0, i32 7
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  %lnot = xor i1 %tobool, true
  ret i1 %lnot
}

define i32 @igb_xmit_frame_ring(%struct.sk_buff* %skb, %struct.igb_ring* %tx_ring) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %skb.addr = alloca %struct.sk_buff*, align 8
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %first = alloca %struct.igb_tx_buffer*, align 8
  %tso = alloca i32, align 4
  %tx_flags = alloca i32, align 4
  %count = alloca i16, align 2
  %protocol = alloca i16, align 2
  %hdr_len = alloca i8, align 1
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store i32 0, i32* %tx_flags, align 4
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i32 @skb_headlen(%struct.sk_buff* %0) noredzone
  %add = add i32 %call, 32768
  %sub = sub i32 %add, 1
  %div = udiv i32 %sub, 32768
  %conv = trunc i32 %div to i16
  store i16 %conv, i16* %count, align 2
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %call1 = call zeroext i16 @vlan_get_protocol(%struct.sk_buff* %1) noredzone
  store i16 %call1, i16* %protocol, align 2
  store i8 0, i8* %hdr_len, align 1
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %call2 = call i8* @skb_end_pointer(%struct.sk_buff* %2) noredzone
  %3 = bitcast i8* %call2 to %struct.skb_shared_info*
  %nr_frags = getelementptr inbounds %struct.skb_shared_info* %3, i32 0, i32 0
  %4 = load i8* %nr_frags, align 1
  %conv3 = zext i8 %4 to i32
  %5 = load i16* %count, align 2
  %conv4 = zext i16 %5 to i32
  %add5 = add i32 %conv4, %conv3
  %conv6 = trunc i32 %add5 to i16
  store i16 %conv6, i16* %count, align 2
  %6 = load %struct.igb_ring** %tx_ring.addr, align 8
  %7 = load i16* %count, align 2
  %conv7 = zext i16 %7 to i32
  %add8 = add i32 %conv7, 3
  %conv9 = trunc i32 %add8 to i16
  %call10 = call i32 @igb_maybe_stop_tx(%struct.igb_ring* %6, i16 zeroext %conv9) noredzone
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 16, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 13
  %9 = load i16* %next_to_use, align 2
  %idxprom = zext i16 %9 to i64
  %10 = load %struct.igb_ring** %tx_ring.addr, align 8
  %11 = getelementptr inbounds %struct.igb_ring* %10, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %11 to %struct.igb_tx_buffer**
  %12 = load %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %arrayidx = getelementptr %struct.igb_tx_buffer* %12, i64 %idxprom
  store %struct.igb_tx_buffer* %arrayidx, %struct.igb_tx_buffer** %first, align 8
  %13 = load %struct.sk_buff** %skb.addr, align 8
  %14 = load %struct.igb_tx_buffer** %first, align 8
  %skb11 = getelementptr inbounds %struct.igb_tx_buffer* %14, i32 0, i32 2
  store %struct.sk_buff* %13, %struct.sk_buff** %skb11, align 8
  %15 = load %struct.sk_buff** %skb.addr, align 8
  %len = getelementptr inbounds %struct.sk_buff* %15, i32 0, i32 8
  %16 = load i32* %len, align 4
  %17 = load %struct.igb_tx_buffer** %first, align 8
  %bytecount = getelementptr inbounds %struct.igb_tx_buffer* %17, i32 0, i32 3
  store i32 %16, i32* %bytecount, align 4
  %18 = load %struct.igb_tx_buffer** %first, align 8
  %gso_segs = getelementptr inbounds %struct.igb_tx_buffer* %18, i32 0, i32 4
  store i16 1, i16* %gso_segs, align 2
  %19 = load %struct.sk_buff** %skb.addr, align 8
  %call12 = call i8* @skb_end_pointer(%struct.sk_buff* %19) noredzone
  %20 = bitcast i8* %call12 to %struct.skb_shared_info*
  %tx_flags13 = getelementptr inbounds %struct.skb_shared_info* %20, i32 0, i32 1
  %21 = load i8* %tx_flags13, align 1
  %conv14 = zext i8 %21 to i32
  %and = and i32 %conv14, 1
  %tobool15 = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool15, true
  %lnot16 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv17 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv17, i64 0)
  %tobool18 = icmp ne i64 %expval, 0
  br i1 %tobool18, label %if.then19, label %if.end35

if.then19:                                        ; preds = %if.end
  %22 = load %struct.igb_ring** %tx_ring.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %22, i32 0, i32 1
  %23 = load %struct.net_device** %netdev, align 8
  %call20 = call i8* @netdev_priv(%struct.net_device* %23) noredzone
  %24 = bitcast i8* %call20 to %struct.igb_adapter*
  store %struct.igb_adapter* %24, %struct.igb_adapter** %adapter, align 8
  %25 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 2
  store i64 3, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %26 = load i64* %nr.addr.i, align 8
  %27 = load i64** %addr.addr.i, align 8
  %call.i = call i32 @test_and_set_bit(i64 %26, i64* %27) nounwind noredzone
  %tobool22 = icmp ne i32 %call.i, 0
  br i1 %tobool22, label %if.end34, label %if.then23

if.then23:                                        ; preds = %if.then19
  %28 = load %struct.sk_buff** %skb.addr, align 8
  %call24 = call i8* @skb_end_pointer(%struct.sk_buff* %28) noredzone
  %29 = bitcast i8* %call24 to %struct.skb_shared_info*
  %tx_flags25 = getelementptr inbounds %struct.skb_shared_info* %29, i32 0, i32 1
  %30 = load i8* %tx_flags25, align 1
  %conv26 = zext i8 %30 to i32
  %or = or i32 %conv26, 4
  %conv27 = trunc i32 %or to i8
  store i8 %conv27, i8* %tx_flags25, align 1
  %31 = load i32* %tx_flags, align 4
  %or28 = or i32 %31, 4
  store i32 %or28, i32* %tx_flags, align 4
  %32 = load %struct.sk_buff** %skb.addr, align 8
  %call29 = call %struct.sk_buff* @skb_get(%struct.sk_buff* %32) noredzone
  %33 = load %struct.igb_adapter** %adapter, align 8
  %ptp_tx_skb = getelementptr inbounds %struct.igb_adapter* %33, i32 0, i32 59
  store %struct.sk_buff* %call29, %struct.sk_buff** %ptp_tx_skb, align 8
  %34 = load volatile i64* @jiffies, align 8
  %35 = load %struct.igb_adapter** %adapter, align 8
  %ptp_tx_start = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 61
  store i64 %34, i64* %ptp_tx_start, align 8
  %36 = load %struct.igb_adapter** %adapter, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %36, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %37 = load i32* %type, align 4
  %cmp = icmp eq i32 %37, 2
  br i1 %cmp, label %if.then31, label %if.end33

if.then31:                                        ; preds = %if.then23
  %38 = load %struct.igb_adapter** %adapter, align 8
  %ptp_tx_work = getelementptr inbounds %struct.igb_adapter* %38, i32 0, i32 58
  %call32 = call zeroext i1 @schedule_work(%struct.work_struct* %ptp_tx_work) noredzone
  br label %if.end33

if.end33:                                         ; preds = %if.then31, %if.then23
  br label %if.end34

if.end34:                                         ; preds = %if.end33, %if.then19
  br label %if.end35

if.end35:                                         ; preds = %if.end34, %if.end
  %39 = load %struct.sk_buff** %skb.addr, align 8
  call void @skb_tx_timestamp(%struct.sk_buff* %39) noredzone
  %40 = load %struct.sk_buff** %skb.addr, align 8
  %vlan_tci = getelementptr inbounds %struct.sk_buff* %40, i32 0, i32 23
  %41 = load i16* %vlan_tci, align 2
  %conv36 = zext i16 %41 to i32
  %and37 = and i32 %conv36, 4096
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then39, label %if.end45

if.then39:                                        ; preds = %if.end35
  %42 = load i32* %tx_flags, align 4
  %or40 = or i32 %42, 1
  store i32 %or40, i32* %tx_flags, align 4
  %43 = load %struct.sk_buff** %skb.addr, align 8
  %vlan_tci41 = getelementptr inbounds %struct.sk_buff* %43, i32 0, i32 23
  %44 = load i16* %vlan_tci41, align 2
  %conv42 = zext i16 %44 to i32
  %and43 = and i32 %conv42, -4097
  %shl = shl i32 %and43, 16
  %45 = load i32* %tx_flags, align 4
  %or44 = or i32 %45, %shl
  store i32 %or44, i32* %tx_flags, align 4
  br label %if.end45

if.end45:                                         ; preds = %if.then39, %if.end35
  %46 = load i32* %tx_flags, align 4
  %47 = load %struct.igb_tx_buffer** %first, align 8
  %tx_flags46 = getelementptr inbounds %struct.igb_tx_buffer* %47, i32 0, i32 8
  store i32 %46, i32* %tx_flags46, align 4
  %48 = load i16* %protocol, align 2
  %49 = load %struct.igb_tx_buffer** %first, align 8
  %protocol47 = getelementptr inbounds %struct.igb_tx_buffer* %49, i32 0, i32 5
  store i16 %48, i16* %protocol47, align 2
  %50 = load %struct.igb_ring** %tx_ring.addr, align 8
  %51 = load %struct.igb_tx_buffer** %first, align 8
  %call48 = call i32 @igb_tso(%struct.igb_ring* %50, %struct.igb_tx_buffer* %51, i8* %hdr_len) noredzone
  store i32 %call48, i32* %tso, align 4
  %52 = load i32* %tso, align 4
  %cmp49 = icmp slt i32 %52, 0
  br i1 %cmp49, label %if.then51, label %if.else

if.then51:                                        ; preds = %if.end45
  br label %out_drop

if.else:                                          ; preds = %if.end45
  %53 = load i32* %tso, align 4
  %tobool52 = icmp ne i32 %53, 0
  br i1 %tobool52, label %if.end54, label %if.then53

if.then53:                                        ; preds = %if.else
  %54 = load %struct.igb_ring** %tx_ring.addr, align 8
  %55 = load %struct.igb_tx_buffer** %first, align 8
  call void @igb_tx_csum(%struct.igb_ring* %54, %struct.igb_tx_buffer* %55) noredzone
  br label %if.end54

if.end54:                                         ; preds = %if.then53, %if.else
  br label %if.end55

if.end55:                                         ; preds = %if.end54
  %56 = load %struct.igb_ring** %tx_ring.addr, align 8
  %57 = load %struct.igb_tx_buffer** %first, align 8
  %58 = load i8* %hdr_len, align 1
  call void @igb_tx_map(%struct.igb_ring* %56, %struct.igb_tx_buffer* %57, i8 zeroext %58) noredzone
  %59 = load %struct.igb_ring** %tx_ring.addr, align 8
  %call56 = call i32 @igb_maybe_stop_tx(%struct.igb_ring* %59, i16 zeroext 21) noredzone
  store i32 0, i32* %retval
  br label %return

out_drop:                                         ; preds = %if.then51
  %60 = load %struct.igb_ring** %tx_ring.addr, align 8
  %61 = load %struct.igb_tx_buffer** %first, align 8
  call void @igb_unmap_and_free_tx_resource(%struct.igb_ring* %60, %struct.igb_tx_buffer* %61) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %out_drop, %if.end55, %if.then
  %62 = load i32* %retval
  ret i32 %62
}

define internal i32 @skb_headlen(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %len = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 8
  %1 = load i32* %len, align 4
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %data_len = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 9
  %3 = load i32* %data_len, align 4
  %sub = sub i32 %1, %3
  ret i32 %sub
}

define internal zeroext i16 @vlan_get_protocol(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %protocol = alloca i16, align 2
  %proto = alloca i16, align 2
  %protop = alloca i16*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i16 0, i16* %protocol, align 2
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %vlan_tci = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 23
  %1 = load i16* %vlan_tci, align 2
  %conv = zext i16 %1 to i32
  %and = and i32 %conv, 4096
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %protocol1 = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 16
  %3 = load i16* %protocol1, align 2
  %conv2 = zext i16 %3 to i32
  %cmp = icmp ne i32 %conv2, 129
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %entry
  %4 = load %struct.sk_buff** %skb.addr, align 8
  %protocol4 = getelementptr inbounds %struct.sk_buff* %4, i32 0, i32 16
  %5 = load i16* %protocol4, align 2
  store i16 %5, i16* %protocol, align 2
  br label %if.end10

if.else:                                          ; preds = %lor.lhs.false
  %6 = load %struct.sk_buff** %skb.addr, align 8
  %7 = bitcast i16* %proto to i8*
  %call = call i8* @skb_header_pointer(%struct.sk_buff* %6, i32 16, i32 2, i8* %7) noredzone
  %8 = bitcast i8* %call to i16*
  store i16* %8, i16** %protop, align 8
  %9 = load i16** %protop, align 8
  %tobool5 = icmp ne i16* %9, null
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 1)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then9, label %if.end

if.then9:                                         ; preds = %if.else
  %10 = load i16** %protop, align 8
  %11 = load i16* %10, align 2
  store i16 %11, i16* %protocol, align 2
  br label %if.end

if.end:                                           ; preds = %if.then9, %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end, %if.then
  %12 = load i16* %protocol, align 2
  ret i16 %12
}

define internal i8* @skb_end_pointer(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %head = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 41
  %1 = load i8** %head, align 8
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %end = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 40
  %3 = load i32* %end, align 4
  %idx.ext = zext i32 %3 to i64
  %add.ptr = getelementptr i8* %1, i64 %idx.ext
  ret i8* %add.ptr
}

define internal i32 @igb_maybe_stop_tx(%struct.igb_ring* %tx_ring, i16 zeroext %size) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %size.addr = alloca i16, align 2
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store i16 %size, i16* %size.addr, align 2
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  %call = call i32 @igb_desc_unused(%struct.igb_ring* %0) noredzone
  %1 = load i16* %size.addr, align 2
  %conv = zext i16 %1 to i32
  %cmp = icmp sge i32 %call, %conv
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.igb_ring** %tx_ring.addr, align 8
  %3 = load i16* %size.addr, align 2
  %call2 = call i32 @__igb_maybe_stop_tx(%struct.igb_ring* %2, i16 zeroext %3) noredzone
  store i32 %call2, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

define internal i8* @netdev_priv(%struct.net_device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  %0 = load %struct.net_device** %dev.addr, align 8
  %1 = bitcast %struct.net_device* %0 to i8*
  %add.ptr = getelementptr i8* %1, i64 2240
  ret i8* %add.ptr
}

define internal %struct.sk_buff* @skb_get(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %users = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 44
  call void @atomic_inc(%struct.atomic_t* %users) noredzone
  %1 = load %struct.sk_buff** %skb.addr, align 8
  ret %struct.sk_buff* %1
}

define internal void @skb_tx_timestamp(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  call void @skb_clone_tx_timestamp(%struct.sk_buff* %0) noredzone
  %1 = load %struct.sk_buff** %skb.addr, align 8
  call void @sw_tx_timestamp(%struct.sk_buff* %1) noredzone
  ret void
}

define internal i32 @igb_tso(%struct.igb_ring* %tx_ring, %struct.igb_tx_buffer* %first, i8* %hdr_len) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %first.addr = alloca %struct.igb_tx_buffer*, align 8
  %hdr_len.addr = alloca i8*, align 8
  %skb = alloca %struct.sk_buff*, align 8
  %vlan_macip_lens = alloca i32, align 4
  %type_tucmd = alloca i32, align 4
  %mss_l4len_idx = alloca i32, align 4
  %l4len = alloca i32, align 4
  %err = alloca i32, align 4
  %iph = alloca %struct.iphdr*, align 8
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store %struct.igb_tx_buffer* %first, %struct.igb_tx_buffer** %first.addr, align 8
  store i8* %hdr_len, i8** %hdr_len.addr, align 8
  %0 = load %struct.igb_tx_buffer** %first.addr, align 8
  %skb1 = getelementptr inbounds %struct.igb_tx_buffer* %0, i32 0, i32 2
  %1 = load %struct.sk_buff** %skb1, align 8
  store %struct.sk_buff* %1, %struct.sk_buff** %skb, align 8
  %2 = load %struct.sk_buff** %skb, align 8
  %3 = bitcast %struct.sk_buff* %2 to i8*
  %bf.field.offs = getelementptr i8* %3, i32 124
  %4 = load i8* %bf.field.offs, align 4
  %5 = lshr i8 %4, 2
  %bf.clear = and i8 %5, 3
  %conv = zext i8 %bf.clear to i32
  %cmp = icmp ne i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.sk_buff** %skb, align 8
  %call = call zeroext i1 @skb_is_gso(%struct.sk_buff* %6) noredzone
  br i1 %call, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end4:                                          ; preds = %if.end
  %7 = load %struct.sk_buff** %skb, align 8
  %call5 = call i32 @skb_cow_head(%struct.sk_buff* %7, i32 0) noredzone
  store i32 %call5, i32* %err, align 4
  %8 = load i32* %err, align 4
  %cmp6 = icmp slt i32 %8, 0
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end4
  %9 = load i32* %err, align 4
  store i32 %9, i32* %retval
  br label %return

if.end9:                                          ; preds = %if.end4
  store i32 2048, i32* %type_tucmd, align 4
  %10 = load %struct.igb_tx_buffer** %first.addr, align 8
  %protocol = getelementptr inbounds %struct.igb_tx_buffer* %10, i32 0, i32 5
  %11 = load i16* %protocol, align 2
  %conv10 = zext i16 %11 to i32
  %cmp11 = icmp eq i32 %conv10, 8
  br i1 %cmp11, label %if.then13, label %if.else

if.then13:                                        ; preds = %if.end9
  %12 = load %struct.sk_buff** %skb, align 8
  %call14 = call %struct.iphdr* @ip_hdr(%struct.sk_buff* %12) noredzone
  store %struct.iphdr* %call14, %struct.iphdr** %iph, align 8
  %13 = load %struct.iphdr** %iph, align 8
  %tot_len = getelementptr inbounds %struct.iphdr* %13, i32 0, i32 2
  store i16 0, i16* %tot_len, align 2
  %14 = load %struct.iphdr** %iph, align 8
  %check = getelementptr inbounds %struct.iphdr* %14, i32 0, i32 7
  store i16 0, i16* %check, align 2
  %15 = load %struct.iphdr** %iph, align 8
  %saddr = getelementptr inbounds %struct.iphdr* %15, i32 0, i32 8
  %16 = load i32* %saddr, align 4
  %17 = load %struct.iphdr** %iph, align 8
  %daddr = getelementptr inbounds %struct.iphdr* %17, i32 0, i32 9
  %18 = load i32* %daddr, align 4
  %call15 = call zeroext i16 @csum_tcpudp_magic(i32 %16, i32 %18, i16 zeroext 0, i16 zeroext 6, i32 0) noredzone
  %conv16 = zext i16 %call15 to i32
  %neg = xor i32 %conv16, -1
  %conv17 = trunc i32 %neg to i16
  %19 = load %struct.sk_buff** %skb, align 8
  %call18 = call %struct.tcphdr* @tcp_hdr(%struct.sk_buff* %19) noredzone
  %check19 = getelementptr inbounds %struct.tcphdr* %call18, i32 0, i32 7
  store i16 %conv17, i16* %check19, align 2
  %20 = load i32* %type_tucmd, align 4
  %or = or i32 %20, 1024
  store i32 %or, i32* %type_tucmd, align 4
  %21 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags = getelementptr inbounds %struct.igb_tx_buffer* %21, i32 0, i32 8
  %22 = load i32* %tx_flags, align 4
  %or20 = or i32 %22, 50
  store i32 %or20, i32* %tx_flags, align 4
  br label %if.end37

if.else:                                          ; preds = %if.end9
  %23 = load %struct.sk_buff** %skb, align 8
  %call21 = call zeroext i1 @skb_is_gso_v6(%struct.sk_buff* %23) noredzone
  br i1 %call21, label %if.then22, label %if.end36

if.then22:                                        ; preds = %if.else
  %24 = load %struct.sk_buff** %skb, align 8
  %call23 = call %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %24) noredzone
  %payload_len = getelementptr inbounds %struct.ipv6hdr* %call23, i32 0, i32 2
  store i16 0, i16* %payload_len, align 2
  %25 = load %struct.sk_buff** %skb, align 8
  %call24 = call %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %25) noredzone
  %saddr25 = getelementptr inbounds %struct.ipv6hdr* %call24, i32 0, i32 5
  %26 = load %struct.sk_buff** %skb, align 8
  %call26 = call %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %26) noredzone
  %daddr27 = getelementptr inbounds %struct.ipv6hdr* %call26, i32 0, i32 6
  %call28 = call zeroext i16 @csum_ipv6_magic(%struct.in6_addr* %saddr25, %struct.in6_addr* %daddr27, i32 0, i16 zeroext 6, i32 0) noredzone
  %conv29 = zext i16 %call28 to i32
  %neg30 = xor i32 %conv29, -1
  %conv31 = trunc i32 %neg30 to i16
  %27 = load %struct.sk_buff** %skb, align 8
  %call32 = call %struct.tcphdr* @tcp_hdr(%struct.sk_buff* %27) noredzone
  %check33 = getelementptr inbounds %struct.tcphdr* %call32, i32 0, i32 7
  store i16 %conv31, i16* %check33, align 2
  %28 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags34 = getelementptr inbounds %struct.igb_tx_buffer* %28, i32 0, i32 8
  %29 = load i32* %tx_flags34, align 4
  %or35 = or i32 %29, 34
  store i32 %or35, i32* %tx_flags34, align 4
  br label %if.end36

if.end36:                                         ; preds = %if.then22, %if.else
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.then13
  %30 = load %struct.sk_buff** %skb, align 8
  %call38 = call i32 @tcp_hdrlen(%struct.sk_buff* %30) noredzone
  store i32 %call38, i32* %l4len, align 4
  %31 = load %struct.sk_buff** %skb, align 8
  %call39 = call i32 @skb_transport_offset(%struct.sk_buff* %31) noredzone
  %32 = load i32* %l4len, align 4
  %add = add i32 %call39, %32
  %conv40 = trunc i32 %add to i8
  %33 = load i8** %hdr_len.addr, align 8
  store i8 %conv40, i8* %33, align 1
  %34 = load %struct.sk_buff** %skb, align 8
  %call41 = call i8* @skb_end_pointer(%struct.sk_buff* %34) noredzone
  %35 = bitcast i8* %call41 to %struct.skb_shared_info*
  %gso_segs = getelementptr inbounds %struct.skb_shared_info* %35, i32 0, i32 3
  %36 = load i16* %gso_segs, align 2
  %37 = load %struct.igb_tx_buffer** %first.addr, align 8
  %gso_segs42 = getelementptr inbounds %struct.igb_tx_buffer* %37, i32 0, i32 4
  store i16 %36, i16* %gso_segs42, align 2
  %38 = load %struct.igb_tx_buffer** %first.addr, align 8
  %gso_segs43 = getelementptr inbounds %struct.igb_tx_buffer* %38, i32 0, i32 4
  %39 = load i16* %gso_segs43, align 2
  %conv44 = zext i16 %39 to i32
  %sub = sub i32 %conv44, 1
  %40 = load i8** %hdr_len.addr, align 8
  %41 = load i8* %40, align 1
  %conv45 = zext i8 %41 to i32
  %mul = mul i32 %sub, %conv45
  %42 = load %struct.igb_tx_buffer** %first.addr, align 8
  %bytecount = getelementptr inbounds %struct.igb_tx_buffer* %42, i32 0, i32 3
  %43 = load i32* %bytecount, align 4
  %add46 = add i32 %43, %mul
  store i32 %add46, i32* %bytecount, align 4
  %44 = load i32* %l4len, align 4
  %shl = shl i32 %44, 8
  store i32 %shl, i32* %mss_l4len_idx, align 4
  %45 = load %struct.sk_buff** %skb, align 8
  %call47 = call i8* @skb_end_pointer(%struct.sk_buff* %45) noredzone
  %46 = bitcast i8* %call47 to %struct.skb_shared_info*
  %gso_size = getelementptr inbounds %struct.skb_shared_info* %46, i32 0, i32 2
  %47 = load i16* %gso_size, align 2
  %conv48 = zext i16 %47 to i32
  %shl49 = shl i32 %conv48, 16
  %48 = load i32* %mss_l4len_idx, align 4
  %or50 = or i32 %48, %shl49
  store i32 %or50, i32* %mss_l4len_idx, align 4
  %49 = load %struct.sk_buff** %skb, align 8
  %call51 = call i32 @skb_network_header_len(%struct.sk_buff* %49) noredzone
  store i32 %call51, i32* %vlan_macip_lens, align 4
  %50 = load %struct.sk_buff** %skb, align 8
  %call52 = call i32 @skb_network_offset(%struct.sk_buff* %50) noredzone
  %shl53 = shl i32 %call52, 9
  %51 = load i32* %vlan_macip_lens, align 4
  %or54 = or i32 %51, %shl53
  store i32 %or54, i32* %vlan_macip_lens, align 4
  %52 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags55 = getelementptr inbounds %struct.igb_tx_buffer* %52, i32 0, i32 8
  %53 = load i32* %tx_flags55, align 4
  %and = and i32 %53, -65536
  %54 = load i32* %vlan_macip_lens, align 4
  %or56 = or i32 %54, %and
  store i32 %or56, i32* %vlan_macip_lens, align 4
  %55 = load %struct.igb_ring** %tx_ring.addr, align 8
  %56 = load i32* %vlan_macip_lens, align 4
  %57 = load i32* %type_tucmd, align 4
  %58 = load i32* %mss_l4len_idx, align 4
  call void @igb_tx_ctxtdesc(%struct.igb_ring* %55, i32 %56, i32 %57, i32 %58) noredzone
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end37, %if.then8, %if.then3, %if.then
  %59 = load i32* %retval
  ret i32 %59
}

define internal void @igb_tx_csum(%struct.igb_ring* %tx_ring, %struct.igb_tx_buffer* %first) nounwind noredzone {
entry:
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %first.addr = alloca %struct.igb_tx_buffer*, align 8
  %skb = alloca %struct.sk_buff*, align 8
  %vlan_macip_lens = alloca i32, align 4
  %mss_l4len_idx = alloca i32, align 4
  %type_tucmd = alloca i32, align 4
  %l4_hdr = alloca i8, align 1
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store %struct.igb_tx_buffer* %first, %struct.igb_tx_buffer** %first.addr, align 8
  %0 = load %struct.igb_tx_buffer** %first.addr, align 8
  %skb1 = getelementptr inbounds %struct.igb_tx_buffer* %0, i32 0, i32 2
  %1 = load %struct.sk_buff** %skb1, align 8
  store %struct.sk_buff* %1, %struct.sk_buff** %skb, align 8
  store i32 0, i32* %vlan_macip_lens, align 4
  store i32 0, i32* %mss_l4len_idx, align 4
  store i32 0, i32* %type_tucmd, align 4
  %2 = load %struct.sk_buff** %skb, align 8
  %3 = bitcast %struct.sk_buff* %2 to i8*
  %bf.field.offs = getelementptr i8* %3, i32 124
  %4 = load i8* %bf.field.offs, align 4
  %5 = lshr i8 %4, 2
  %bf.clear = and i8 %5, 3
  %conv = zext i8 %bf.clear to i32
  %cmp = icmp ne i32 %conv, 3
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags = getelementptr inbounds %struct.igb_tx_buffer* %6, i32 0, i32 8
  %7 = load i32* %tx_flags, align 4
  %and = and i32 %7, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %if.then
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end47

if.else:                                          ; preds = %entry
  store i8 0, i8* %l4_hdr, align 1
  %8 = load %struct.igb_tx_buffer** %first.addr, align 8
  %protocol = getelementptr inbounds %struct.igb_tx_buffer* %8, i32 0, i32 5
  %9 = load i16* %protocol, align 2
  %conv4 = zext i16 %9 to i32
  switch i32 %conv4, label %sw.default [
    i32 8, label %sw.bb
    i32 56710, label %sw.bb8
  ]

sw.bb:                                            ; preds = %if.else
  %10 = load %struct.sk_buff** %skb, align 8
  %call = call i32 @skb_network_header_len(%struct.sk_buff* %10) noredzone
  %11 = load i32* %vlan_macip_lens, align 4
  %or = or i32 %11, %call
  store i32 %or, i32* %vlan_macip_lens, align 4
  %12 = load i32* %type_tucmd, align 4
  %or5 = or i32 %12, 1024
  store i32 %or5, i32* %type_tucmd, align 4
  %13 = load %struct.sk_buff** %skb, align 8
  %call6 = call %struct.iphdr* @ip_hdr(%struct.sk_buff* %13) noredzone
  %protocol7 = getelementptr inbounds %struct.iphdr* %call6, i32 0, i32 6
  %14 = load i8* %protocol7, align 1
  store i8 %14, i8* %l4_hdr, align 1
  br label %sw.epilog

sw.bb8:                                           ; preds = %if.else
  %15 = load %struct.sk_buff** %skb, align 8
  %call9 = call i32 @skb_network_header_len(%struct.sk_buff* %15) noredzone
  %16 = load i32* %vlan_macip_lens, align 4
  %or10 = or i32 %16, %call9
  store i32 %or10, i32* %vlan_macip_lens, align 4
  %17 = load %struct.sk_buff** %skb, align 8
  %call11 = call %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %17) noredzone
  %nexthdr = getelementptr inbounds %struct.ipv6hdr* %call11, i32 0, i32 3
  %18 = load i8* %nexthdr, align 1
  store i8 %18, i8* %l4_hdr, align 1
  br label %sw.epilog

sw.default:                                       ; preds = %if.else
  %call12 = call i32 @net_ratelimit() noredzone
  %tobool13 = icmp ne i32 %call12, 0
  %lnot = xor i1 %tobool13, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv15 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %if.then17, label %if.end21

if.then17:                                        ; preds = %sw.default
  %19 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %19, i32 0, i32 2
  %20 = load %struct.device** %dev, align 8
  %21 = load %struct.igb_tx_buffer** %first.addr, align 8
  %protocol18 = getelementptr inbounds %struct.igb_tx_buffer* %21, i32 0, i32 5
  %22 = load i16* %protocol18, align 2
  %conv19 = zext i16 %22 to i32
  %call20 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %20, i8* getelementptr inbounds ([32 x i8]* @.str35, i32 0, i32 0), i32 %conv19) noredzone
  br label %if.end21

if.end21:                                         ; preds = %if.then17, %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end21, %sw.bb8, %sw.bb
  %23 = load i8* %l4_hdr, align 1
  %conv22 = zext i8 %23 to i32
  switch i32 %conv22, label %sw.default29 [
    i32 6, label %sw.bb23
    i32 132, label %sw.bb26
    i32 17, label %sw.bb28
  ]

sw.bb23:                                          ; preds = %sw.epilog
  %24 = load i32* %type_tucmd, align 4
  %or24 = or i32 %24, 2048
  store i32 %or24, i32* %type_tucmd, align 4
  %25 = load %struct.sk_buff** %skb, align 8
  %call25 = call i32 @tcp_hdrlen(%struct.sk_buff* %25) noredzone
  %shl = shl i32 %call25, 8
  store i32 %shl, i32* %mss_l4len_idx, align 4
  br label %sw.epilog44

sw.bb26:                                          ; preds = %sw.epilog
  %26 = load i32* %type_tucmd, align 4
  %or27 = or i32 %26, 4096
  store i32 %or27, i32* %type_tucmd, align 4
  store i32 3072, i32* %mss_l4len_idx, align 4
  br label %sw.epilog44

sw.bb28:                                          ; preds = %sw.epilog
  store i32 2048, i32* %mss_l4len_idx, align 4
  br label %sw.epilog44

sw.default29:                                     ; preds = %sw.epilog
  %call30 = call i32 @net_ratelimit() noredzone
  %tobool31 = icmp ne i32 %call30, 0
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot.ext35 = zext i1 %lnot34 to i32
  %conv36 = sext i32 %lnot.ext35 to i64
  %expval37 = call i64 @llvm.expect.i64(i64 %conv36, i64 0)
  %tobool38 = icmp ne i64 %expval37, 0
  br i1 %tobool38, label %if.then39, label %if.end43

if.then39:                                        ; preds = %sw.default29
  %27 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev40 = getelementptr inbounds %struct.igb_ring* %27, i32 0, i32 2
  %28 = load %struct.device** %dev40, align 8
  %29 = load i8* %l4_hdr, align 1
  %conv41 = zext i8 %29 to i32
  %call42 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %28, i8* getelementptr inbounds ([35 x i8]* @.str36, i32 0, i32 0), i32 %conv41) noredzone
  br label %if.end43

if.end43:                                         ; preds = %if.then39, %sw.default29
  br label %sw.epilog44

sw.epilog44:                                      ; preds = %if.end43, %sw.bb28, %sw.bb26, %sw.bb23
  %30 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags45 = getelementptr inbounds %struct.igb_tx_buffer* %30, i32 0, i32 8
  %31 = load i32* %tx_flags45, align 4
  %or46 = or i32 %31, 32
  store i32 %or46, i32* %tx_flags45, align 4
  br label %if.end47

if.end47:                                         ; preds = %sw.epilog44, %if.end
  %32 = load %struct.sk_buff** %skb, align 8
  %call48 = call i32 @skb_network_offset(%struct.sk_buff* %32) noredzone
  %shl49 = shl i32 %call48, 9
  %33 = load i32* %vlan_macip_lens, align 4
  %or50 = or i32 %33, %shl49
  store i32 %or50, i32* %vlan_macip_lens, align 4
  %34 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags51 = getelementptr inbounds %struct.igb_tx_buffer* %34, i32 0, i32 8
  %35 = load i32* %tx_flags51, align 4
  %and52 = and i32 %35, -65536
  %36 = load i32* %vlan_macip_lens, align 4
  %or53 = or i32 %36, %and52
  store i32 %or53, i32* %vlan_macip_lens, align 4
  %37 = load %struct.igb_ring** %tx_ring.addr, align 8
  %38 = load i32* %vlan_macip_lens, align 4
  %39 = load i32* %type_tucmd, align 4
  %40 = load i32* %mss_l4len_idx, align 4
  call void @igb_tx_ctxtdesc(%struct.igb_ring* %37, i32 %38, i32 %39, i32 %40) noredzone
  br label %return

return:                                           ; preds = %if.end47, %if.then3
  ret void
}

define internal void @igb_tx_map(%struct.igb_ring* %tx_ring, %struct.igb_tx_buffer* %first, i8 zeroext %hdr_len) nounwind noredzone {
entry:
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %first.addr = alloca %struct.igb_tx_buffer*, align 8
  %hdr_len.addr = alloca i8, align 1
  %skb = alloca %struct.sk_buff*, align 8
  %tx_buffer = alloca %struct.igb_tx_buffer*, align 8
  %tx_desc = alloca %union.e1000_adv_tx_desc*, align 8
  %frag = alloca %struct.skb_frag_struct*, align 8
  %dma = alloca i64, align 8
  %data_len = alloca i32, align 4
  %size = alloca i32, align 4
  %tx_flags = alloca i32, align 4
  %cmd_type = alloca i32, align 4
  %i = alloca i16, align 2
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store %struct.igb_tx_buffer* %first, %struct.igb_tx_buffer** %first.addr, align 8
  store i8 %hdr_len, i8* %hdr_len.addr, align 1
  %0 = load %struct.igb_tx_buffer** %first.addr, align 8
  %skb1 = getelementptr inbounds %struct.igb_tx_buffer* %0, i32 0, i32 2
  %1 = load %struct.sk_buff** %skb1, align 8
  store %struct.sk_buff* %1, %struct.sk_buff** %skb, align 8
  %2 = load %struct.igb_tx_buffer** %first.addr, align 8
  %tx_flags2 = getelementptr inbounds %struct.igb_tx_buffer* %2, i32 0, i32 8
  %3 = load i32* %tx_flags2, align 4
  store i32 %3, i32* %tx_flags, align 4
  %4 = load %struct.sk_buff** %skb, align 8
  %5 = load i32* %tx_flags, align 4
  %call = call i32 @igb_tx_cmd_type(%struct.sk_buff* %4, i32 %5) noredzone
  store i32 %call, i32* %cmd_type, align 4
  %6 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 13
  %7 = load i16* %next_to_use, align 2
  store i16 %7, i16* %i, align 2
  %8 = load i16* %i, align 2
  %idxprom = zext i16 %8 to i64
  %9 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %9, i32 0, i32 4
  %10 = load i8** %desc, align 8
  %11 = bitcast i8* %10 to %union.e1000_adv_tx_desc*
  %arrayidx = getelementptr %union.e1000_adv_tx_desc* %11, i64 %idxprom
  store %union.e1000_adv_tx_desc* %arrayidx, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %12 = load %struct.igb_ring** %tx_ring.addr, align 8
  %13 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %14 = load i32* %tx_flags, align 4
  %15 = load %struct.sk_buff** %skb, align 8
  %len = getelementptr inbounds %struct.sk_buff* %15, i32 0, i32 8
  %16 = load i32* %len, align 4
  %17 = load i8* %hdr_len.addr, align 1
  %conv = zext i8 %17 to i32
  %sub = sub i32 %16, %conv
  call void @igb_tx_olinfo_status(%struct.igb_ring* %12, %union.e1000_adv_tx_desc* %13, i32 %14, i32 %sub) noredzone
  %18 = load %struct.sk_buff** %skb, align 8
  %call3 = call i32 @skb_headlen(%struct.sk_buff* %18) noredzone
  store i32 %call3, i32* %size, align 4
  %19 = load %struct.sk_buff** %skb, align 8
  %data_len4 = getelementptr inbounds %struct.sk_buff* %19, i32 0, i32 9
  %20 = load i32* %data_len4, align 4
  store i32 %20, i32* %data_len, align 4
  %21 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %21, i32 0, i32 2
  %22 = load %struct.device** %dev, align 8
  %23 = load %struct.sk_buff** %skb, align 8
  %data = getelementptr inbounds %struct.sk_buff* %23, i32 0, i32 42
  %24 = load i8** %data, align 8
  %25 = load i32* %size, align 4
  %conv5 = zext i32 %25 to i64
  %call6 = call i64 @dma_map_single_attrs(%struct.device* %22, i8* %24, i64 %conv5, i32 1, %struct.dma_attrs* null) noredzone
  store i64 %call6, i64* %dma, align 8
  %26 = load %struct.igb_tx_buffer** %first.addr, align 8
  store %struct.igb_tx_buffer* %26, %struct.igb_tx_buffer** %tx_buffer, align 8
  %27 = load %struct.sk_buff** %skb, align 8
  %call7 = call i8* @skb_end_pointer(%struct.sk_buff* %27) noredzone
  %28 = bitcast i8* %call7 to %struct.skb_shared_info*
  %frags = getelementptr inbounds %struct.skb_shared_info* %28, i32 0, i32 11
  %arrayidx8 = getelementptr [17 x %struct.skb_frag_struct]* %frags, i32 0, i64 0
  store %struct.skb_frag_struct* %arrayidx8, %struct.skb_frag_struct** %frag, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %29 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev9 = getelementptr inbounds %struct.igb_ring* %29, i32 0, i32 2
  %30 = load %struct.device** %dev9, align 8
  %31 = load i64* %dma, align 8
  %call10 = call i32 @dma_mapping_error(%struct.device* %30, i64 %31) noredzone
  %tobool = icmp ne i32 %call10, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %dma_error

if.end:                                           ; preds = %for.cond
  %32 = load i32* %size, align 4
  %33 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %len11 = getelementptr inbounds %struct.igb_tx_buffer* %33, i32 0, i32 7
  store i32 %32, i32* %len11, align 4
  %34 = load i64* %dma, align 8
  %35 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %dma12 = getelementptr inbounds %struct.igb_tx_buffer* %35, i32 0, i32 6
  store i64 %34, i64* %dma12, align 8
  %36 = load i64* %dma, align 8
  %37 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read = bitcast %union.e1000_adv_tx_desc* %37 to %struct.anon.88*
  %buffer_addr = getelementptr inbounds %struct.anon.88* %read, i32 0, i32 0
  store i64 %36, i64* %buffer_addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %if.end25, %if.end
  %38 = load i32* %size, align 4
  %cmp = icmp ugt i32 %38, 32768
  %lnot = xor i1 %cmp, true
  %lnot14 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot14 to i32
  %conv15 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool16 = icmp ne i64 %expval, 0
  br i1 %tobool16, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %39 = load i32* %cmd_type, align 4
  %xor = xor i32 %39, 32768
  %40 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read17 = bitcast %union.e1000_adv_tx_desc* %40 to %struct.anon.88*
  %cmd_type_len = getelementptr inbounds %struct.anon.88* %read17, i32 0, i32 1
  store i32 %xor, i32* %cmd_type_len, align 4
  %41 = load i16* %i, align 2
  %inc = add i16 %41, 1
  store i16 %inc, i16* %i, align 2
  %42 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %incdec.ptr = getelementptr %union.e1000_adv_tx_desc* %42, i32 1
  store %union.e1000_adv_tx_desc* %incdec.ptr, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %43 = load i16* %i, align 2
  %conv18 = zext i16 %43 to i32
  %44 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %44, i32 0, i32 9
  %45 = load i16* %count, align 2
  %conv19 = zext i16 %45 to i32
  %cmp20 = icmp eq i32 %conv18, %conv19
  br i1 %cmp20, label %if.then22, label %if.end25

if.then22:                                        ; preds = %while.body
  %46 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc23 = getelementptr inbounds %struct.igb_ring* %46, i32 0, i32 4
  %47 = load i8** %desc23, align 8
  %48 = bitcast i8* %47 to %union.e1000_adv_tx_desc*
  %arrayidx24 = getelementptr %union.e1000_adv_tx_desc* %48, i64 0
  store %union.e1000_adv_tx_desc* %arrayidx24, %union.e1000_adv_tx_desc** %tx_desc, align 8
  store i16 0, i16* %i, align 2
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %while.body
  %49 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read26 = bitcast %union.e1000_adv_tx_desc* %49 to %struct.anon.88*
  %olinfo_status = getelementptr inbounds %struct.anon.88* %read26, i32 0, i32 2
  store i32 0, i32* %olinfo_status, align 4
  %50 = load i64* %dma, align 8
  %add = add i64 %50, 32768
  store i64 %add, i64* %dma, align 8
  %51 = load i32* %size, align 4
  %sub27 = sub i32 %51, 32768
  store i32 %sub27, i32* %size, align 4
  %52 = load i64* %dma, align 8
  %53 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read28 = bitcast %union.e1000_adv_tx_desc* %53 to %struct.anon.88*
  %buffer_addr29 = getelementptr inbounds %struct.anon.88* %read28, i32 0, i32 0
  store i64 %52, i64* %buffer_addr29, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %54 = load i32* %data_len, align 4
  %tobool30 = icmp ne i32 %54, 0
  %lnot31 = xor i1 %tobool30, true
  %lnot33 = xor i1 %lnot31, true
  %lnot35 = xor i1 %lnot33, true
  %lnot.ext36 = zext i1 %lnot35 to i32
  %conv37 = sext i32 %lnot.ext36 to i64
  %expval38 = call i64 @llvm.expect.i64(i64 %conv37, i64 1)
  %tobool39 = icmp ne i64 %expval38, 0
  br i1 %tobool39, label %if.then40, label %if.end41

if.then40:                                        ; preds = %while.end
  br label %for.end

if.end41:                                         ; preds = %while.end
  %55 = load i32* %cmd_type, align 4
  %56 = load i32* %size, align 4
  %xor42 = xor i32 %55, %56
  %57 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read43 = bitcast %union.e1000_adv_tx_desc* %57 to %struct.anon.88*
  %cmd_type_len44 = getelementptr inbounds %struct.anon.88* %read43, i32 0, i32 1
  store i32 %xor42, i32* %cmd_type_len44, align 4
  %58 = load i16* %i, align 2
  %inc45 = add i16 %58, 1
  store i16 %inc45, i16* %i, align 2
  %59 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %incdec.ptr46 = getelementptr %union.e1000_adv_tx_desc* %59, i32 1
  store %union.e1000_adv_tx_desc* %incdec.ptr46, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %60 = load i16* %i, align 2
  %conv47 = zext i16 %60 to i32
  %61 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count48 = getelementptr inbounds %struct.igb_ring* %61, i32 0, i32 9
  %62 = load i16* %count48, align 2
  %conv49 = zext i16 %62 to i32
  %cmp50 = icmp eq i32 %conv47, %conv49
  br i1 %cmp50, label %if.then52, label %if.end55

if.then52:                                        ; preds = %if.end41
  %63 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc53 = getelementptr inbounds %struct.igb_ring* %63, i32 0, i32 4
  %64 = load i8** %desc53, align 8
  %65 = bitcast i8* %64 to %union.e1000_adv_tx_desc*
  %arrayidx54 = getelementptr %union.e1000_adv_tx_desc* %65, i64 0
  store %union.e1000_adv_tx_desc* %arrayidx54, %union.e1000_adv_tx_desc** %tx_desc, align 8
  store i16 0, i16* %i, align 2
  br label %if.end55

if.end55:                                         ; preds = %if.then52, %if.end41
  %66 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read56 = bitcast %union.e1000_adv_tx_desc* %66 to %struct.anon.88*
  %olinfo_status57 = getelementptr inbounds %struct.anon.88* %read56, i32 0, i32 2
  store i32 0, i32* %olinfo_status57, align 4
  %67 = load %struct.skb_frag_struct** %frag, align 8
  %call58 = call i32 @skb_frag_size(%struct.skb_frag_struct* %67) noredzone
  store i32 %call58, i32* %size, align 4
  %68 = load i32* %size, align 4
  %69 = load i32* %data_len, align 4
  %sub59 = sub i32 %69, %68
  store i32 %sub59, i32* %data_len, align 4
  %70 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev60 = getelementptr inbounds %struct.igb_ring* %70, i32 0, i32 2
  %71 = load %struct.device** %dev60, align 8
  %72 = load %struct.skb_frag_struct** %frag, align 8
  %73 = load i32* %size, align 4
  %conv61 = zext i32 %73 to i64
  %call62 = call i64 @skb_frag_dma_map(%struct.device* %71, %struct.skb_frag_struct* %72, i64 0, i64 %conv61, i32 1) noredzone
  store i64 %call62, i64* %dma, align 8
  %74 = load i16* %i, align 2
  %idxprom63 = zext i16 %74 to i64
  %75 = load %struct.igb_ring** %tx_ring.addr, align 8
  %76 = getelementptr inbounds %struct.igb_ring* %75, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %76 to %struct.igb_tx_buffer**
  %77 = load %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %arrayidx64 = getelementptr %struct.igb_tx_buffer* %77, i64 %idxprom63
  store %struct.igb_tx_buffer* %arrayidx64, %struct.igb_tx_buffer** %tx_buffer, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end55
  %78 = load %struct.skb_frag_struct** %frag, align 8
  %incdec.ptr65 = getelementptr %struct.skb_frag_struct* %78, i32 1
  store %struct.skb_frag_struct* %incdec.ptr65, %struct.skb_frag_struct** %frag, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then40
  %79 = load i32* %size, align 4
  %or = or i32 %79, 150994944
  %80 = load i32* %cmd_type, align 4
  %or66 = or i32 %80, %or
  store i32 %or66, i32* %cmd_type, align 4
  %81 = load i32* %cmd_type, align 4
  %82 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %read67 = bitcast %union.e1000_adv_tx_desc* %82 to %struct.anon.88*
  %cmd_type_len68 = getelementptr inbounds %struct.anon.88* %read67, i32 0, i32 1
  store i32 %81, i32* %cmd_type_len68, align 4
  %83 = load %struct.igb_ring** %tx_ring.addr, align 8
  %call69 = call %struct.netdev_queue* @txring_txq(%struct.igb_ring* %83) noredzone
  %84 = load %struct.igb_tx_buffer** %first.addr, align 8
  %bytecount = getelementptr inbounds %struct.igb_tx_buffer* %84, i32 0, i32 3
  %85 = load i32* %bytecount, align 4
  call void @netdev_tx_sent_queue(%struct.netdev_queue* %call69, i32 %85) noredzone
  %86 = load volatile i64* @jiffies, align 8
  %87 = load %struct.igb_tx_buffer** %first.addr, align 8
  %time_stamp = getelementptr inbounds %struct.igb_tx_buffer* %87, i32 0, i32 1
  store i64 %86, i64* %time_stamp, align 8
  call void asm sideeffect "sfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !12
  %88 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %89 = load %struct.igb_tx_buffer** %first.addr, align 8
  %next_to_watch = getelementptr inbounds %struct.igb_tx_buffer* %89, i32 0, i32 0
  store %union.e1000_adv_tx_desc* %88, %union.e1000_adv_tx_desc** %next_to_watch, align 8
  %90 = load i16* %i, align 2
  %inc70 = add i16 %90, 1
  store i16 %inc70, i16* %i, align 2
  %91 = load i16* %i, align 2
  %conv71 = zext i16 %91 to i32
  %92 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count72 = getelementptr inbounds %struct.igb_ring* %92, i32 0, i32 9
  %93 = load i16* %count72, align 2
  %conv73 = zext i16 %93 to i32
  %cmp74 = icmp eq i32 %conv71, %conv73
  br i1 %cmp74, label %if.then76, label %if.end77

if.then76:                                        ; preds = %for.end
  store i16 0, i16* %i, align 2
  br label %if.end77

if.end77:                                         ; preds = %if.then76, %for.end
  %94 = load i16* %i, align 2
  %95 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use78 = getelementptr inbounds %struct.igb_ring* %95, i32 0, i32 13
  store i16 %94, i16* %next_to_use78, align 2
  %96 = load i16* %i, align 2
  %conv79 = zext i16 %96 to i32
  %97 = load %struct.igb_ring** %tx_ring.addr, align 8
  %tail = getelementptr inbounds %struct.igb_ring* %97, i32 0, i32 6
  %98 = load i8** %tail, align 8
  call void @writel(i32 %conv79, i8* %98) noredzone
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !13
  br label %return

dma_error:                                        ; preds = %if.then
  %99 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev80 = getelementptr inbounds %struct.igb_ring* %99, i32 0, i32 2
  %100 = load %struct.device** %dev80, align 8
  %call81 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %100, i8* getelementptr inbounds ([19 x i8]* @.str33, i32 0, i32 0)) noredzone
  br label %for.cond82

for.cond82:                                       ; preds = %if.end95, %dma_error
  %101 = load i16* %i, align 2
  %idxprom83 = zext i16 %101 to i64
  %102 = load %struct.igb_ring** %tx_ring.addr, align 8
  %103 = getelementptr inbounds %struct.igb_ring* %102, i32 0, i32 3
  %tx_buffer_info84 = bitcast %union.anon.87* %103 to %struct.igb_tx_buffer**
  %104 = load %struct.igb_tx_buffer** %tx_buffer_info84, align 8
  %arrayidx85 = getelementptr %struct.igb_tx_buffer* %104, i64 %idxprom83
  store %struct.igb_tx_buffer* %arrayidx85, %struct.igb_tx_buffer** %tx_buffer, align 8
  %105 = load %struct.igb_ring** %tx_ring.addr, align 8
  %106 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  call void @igb_unmap_and_free_tx_resource(%struct.igb_ring* %105, %struct.igb_tx_buffer* %106) noredzone
  %107 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %108 = load %struct.igb_tx_buffer** %first.addr, align 8
  %cmp86 = icmp eq %struct.igb_tx_buffer* %107, %108
  br i1 %cmp86, label %if.then88, label %if.end89

if.then88:                                        ; preds = %for.cond82
  br label %for.end96

if.end89:                                         ; preds = %for.cond82
  %109 = load i16* %i, align 2
  %conv90 = zext i16 %109 to i32
  %cmp91 = icmp eq i32 %conv90, 0
  br i1 %cmp91, label %if.then93, label %if.end95

if.then93:                                        ; preds = %if.end89
  %110 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count94 = getelementptr inbounds %struct.igb_ring* %110, i32 0, i32 9
  %111 = load i16* %count94, align 2
  store i16 %111, i16* %i, align 2
  br label %if.end95

if.end95:                                         ; preds = %if.then93, %if.end89
  %112 = load i16* %i, align 2
  %dec = add i16 %112, -1
  store i16 %dec, i16* %i, align 2
  br label %for.cond82

for.end96:                                        ; preds = %if.then88
  %113 = load i16* %i, align 2
  %114 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use97 = getelementptr inbounds %struct.igb_ring* %114, i32 0, i32 13
  store i16 %113, i16* %next_to_use97, align 2
  br label %return

return:                                           ; preds = %for.end96, %if.end77
  ret void
}

define internal void @rcu_read_lock() nounwind inlinehint noredzone {
entry:
  call void @__rcu_read_lock() noredzone
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  ret void
}

define internal i32 @u64_stats_fetch_begin_irq(%struct.u64_stats_sync* %syncp) nounwind inlinehint noredzone {
entry:
  %syncp.addr = alloca %struct.u64_stats_sync*, align 8
  store %struct.u64_stats_sync* %syncp, %struct.u64_stats_sync** %syncp.addr, align 8
  ret i32 0
}

define internal zeroext i1 @u64_stats_fetch_retry_irq(%struct.u64_stats_sync* %syncp, i32 %start) nounwind inlinehint noredzone {
entry:
  %syncp.addr = alloca %struct.u64_stats_sync*, align 8
  %start.addr = alloca i32, align 4
  store %struct.u64_stats_sync* %syncp, %struct.u64_stats_sync** %syncp.addr, align 8
  store i32 %start, i32* %start.addr, align 4
  ret i1 false
}

define internal void @rcu_read_unlock() nounwind inlinehint noredzone {
entry:
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body1

do.body1:                                         ; preds = %do.end
  br label %do.end2

do.end2:                                          ; preds = %do.body1
  call void @__rcu_read_unlock() noredzone
  ret void
}

define internal i32 @igb_read_phy_reg(%struct.e1000_hw* %hw, i32 %offset, i16* %data) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %offset.addr = alloca i32, align 4
  %data.addr = alloca i16*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %offset, i32* %offset.addr, align 4
  store i16* %data, i16** %data.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 6
  %ops = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 0
  %read_reg = getelementptr inbounds %struct.e1000_phy_operations* %ops, i32 0, i32 7
  %1 = load i32 (%struct.e1000_hw*, i32, i16*)** %read_reg, align 8
  %tobool = icmp ne i32 (%struct.e1000_hw*, i32, i16*)* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.e1000_hw** %hw.addr, align 8
  %phy1 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 6
  %ops2 = getelementptr inbounds %struct.e1000_phy_info* %phy1, i32 0, i32 0
  %read_reg3 = getelementptr inbounds %struct.e1000_phy_operations* %ops2, i32 0, i32 7
  %3 = load i32 (%struct.e1000_hw*, i32, i16*)** %read_reg3, align 8
  %4 = load %struct.e1000_hw** %hw.addr, align 8
  %5 = load i32* %offset.addr, align 4
  %6 = load i16** %data.addr, align 8
  %call = call i32 %3(%struct.e1000_hw* %4, i32 %5, i16* %6) noredzone
  store i32 %call, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

define void @igb_alloc_rx_buffers(%struct.igb_ring* %rx_ring, i16 zeroext %cleaned_count) nounwind noredzone {
entry:
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %cleaned_count.addr = alloca i16, align 2
  %rx_desc = alloca %union.e1000_adv_rx_desc*, align 8
  %bi = alloca %struct.igb_rx_buffer*, align 8
  %i = alloca i16, align 2
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store i16 %cleaned_count, i16* %cleaned_count.addr, align 2
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 13
  %1 = load i16* %next_to_use, align 2
  store i16 %1, i16* %i, align 2
  %2 = load i16* %cleaned_count.addr, align 2
  %tobool = icmp ne i16 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %if.end38

if.end:                                           ; preds = %entry
  %3 = load i16* %i, align 2
  %idxprom = zext i16 %3 to i64
  %4 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %4, i32 0, i32 4
  %5 = load i8** %desc, align 8
  %6 = bitcast i8* %5 to %union.e1000_adv_rx_desc*
  %arrayidx = getelementptr %union.e1000_adv_rx_desc* %6, i64 %idxprom
  store %union.e1000_adv_rx_desc* %arrayidx, %union.e1000_adv_rx_desc** %rx_desc, align 8
  %7 = load i16* %i, align 2
  %idxprom1 = zext i16 %7 to i64
  %8 = load %struct.igb_ring** %rx_ring.addr, align 8
  %9 = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %9 to %struct.igb_rx_buffer**
  %10 = load %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %arrayidx2 = getelementptr %struct.igb_rx_buffer* %10, i64 %idxprom1
  store %struct.igb_rx_buffer* %arrayidx2, %struct.igb_rx_buffer** %bi, align 8
  %11 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 9
  %12 = load i16* %count, align 2
  %conv = zext i16 %12 to i32
  %13 = load i16* %i, align 2
  %conv3 = zext i16 %13 to i32
  %sub = sub i32 %conv3, %conv
  %conv4 = trunc i32 %sub to i16
  store i16 %conv4, i16* %i, align 2
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %14 = load %struct.igb_ring** %rx_ring.addr, align 8
  %15 = load %struct.igb_rx_buffer** %bi, align 8
  %call = call zeroext i1 @igb_alloc_mapped_page(%struct.igb_ring* %14, %struct.igb_rx_buffer* %15) noredzone
  br i1 %call, label %if.end6, label %if.then5

if.then5:                                         ; preds = %do.body
  br label %do.end

if.end6:                                          ; preds = %do.body
  %16 = load %struct.igb_rx_buffer** %bi, align 8
  %dma = getelementptr inbounds %struct.igb_rx_buffer* %16, i32 0, i32 0
  %17 = load i64* %dma, align 8
  %18 = load %struct.igb_rx_buffer** %bi, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %18, i32 0, i32 2
  %19 = load i32* %page_offset, align 4
  %conv7 = zext i32 %19 to i64
  %add = add i64 %17, %conv7
  %20 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %read = bitcast %union.e1000_adv_rx_desc* %20 to %struct.anon.96*
  %pkt_addr = getelementptr inbounds %struct.anon.96* %read, i32 0, i32 0
  store i64 %add, i64* %pkt_addr, align 8
  %21 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %incdec.ptr = getelementptr %union.e1000_adv_rx_desc* %21, i32 1
  store %union.e1000_adv_rx_desc* %incdec.ptr, %union.e1000_adv_rx_desc** %rx_desc, align 8
  %22 = load %struct.igb_rx_buffer** %bi, align 8
  %incdec.ptr8 = getelementptr %struct.igb_rx_buffer* %22, i32 1
  store %struct.igb_rx_buffer* %incdec.ptr8, %struct.igb_rx_buffer** %bi, align 8
  %23 = load i16* %i, align 2
  %inc = add i16 %23, 1
  store i16 %inc, i16* %i, align 2
  %24 = load i16* %i, align 2
  %tobool9 = icmp ne i16 %24, 0
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot11 = xor i1 %lnot10, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv12 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.then14, label %if.end23

if.then14:                                        ; preds = %if.end6
  %25 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc15 = getelementptr inbounds %struct.igb_ring* %25, i32 0, i32 4
  %26 = load i8** %desc15, align 8
  %27 = bitcast i8* %26 to %union.e1000_adv_rx_desc*
  %arrayidx16 = getelementptr %union.e1000_adv_rx_desc* %27, i64 0
  store %union.e1000_adv_rx_desc* %arrayidx16, %union.e1000_adv_rx_desc** %rx_desc, align 8
  %28 = load %struct.igb_ring** %rx_ring.addr, align 8
  %29 = getelementptr inbounds %struct.igb_ring* %28, i32 0, i32 3
  %rx_buffer_info17 = bitcast %union.anon.87* %29 to %struct.igb_rx_buffer**
  %30 = load %struct.igb_rx_buffer** %rx_buffer_info17, align 8
  store %struct.igb_rx_buffer* %30, %struct.igb_rx_buffer** %bi, align 8
  %31 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count18 = getelementptr inbounds %struct.igb_ring* %31, i32 0, i32 9
  %32 = load i16* %count18, align 2
  %conv19 = zext i16 %32 to i32
  %33 = load i16* %i, align 2
  %conv20 = zext i16 %33 to i32
  %sub21 = sub i32 %conv20, %conv19
  %conv22 = trunc i32 %sub21 to i16
  store i16 %conv22, i16* %i, align 2
  br label %if.end23

if.end23:                                         ; preds = %if.then14, %if.end6
  %34 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %read24 = bitcast %union.e1000_adv_rx_desc* %34 to %struct.anon.96*
  %hdr_addr = getelementptr inbounds %struct.anon.96* %read24, i32 0, i32 1
  store i64 0, i64* %hdr_addr, align 8
  %35 = load i16* %cleaned_count.addr, align 2
  %dec = add i16 %35, -1
  store i16 %dec, i16* %cleaned_count.addr, align 2
  br label %do.cond

do.cond:                                          ; preds = %if.end23
  %36 = load i16* %cleaned_count.addr, align 2
  %tobool25 = icmp ne i16 %36, 0
  br i1 %tobool25, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond, %if.then5
  %37 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count26 = getelementptr inbounds %struct.igb_ring* %37, i32 0, i32 9
  %38 = load i16* %count26, align 2
  %conv27 = zext i16 %38 to i32
  %39 = load i16* %i, align 2
  %conv28 = zext i16 %39 to i32
  %add29 = add i32 %conv28, %conv27
  %conv30 = trunc i32 %add29 to i16
  store i16 %conv30, i16* %i, align 2
  %40 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_use31 = getelementptr inbounds %struct.igb_ring* %40, i32 0, i32 13
  %41 = load i16* %next_to_use31, align 2
  %conv32 = zext i16 %41 to i32
  %42 = load i16* %i, align 2
  %conv33 = zext i16 %42 to i32
  %cmp = icmp ne i32 %conv32, %conv33
  br i1 %cmp, label %if.then35, label %if.end38

if.then35:                                        ; preds = %do.end
  %43 = load i16* %i, align 2
  %44 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_use36 = getelementptr inbounds %struct.igb_ring* %44, i32 0, i32 13
  store i16 %43, i16* %next_to_use36, align 2
  %45 = load i16* %i, align 2
  %46 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_alloc = getelementptr inbounds %struct.igb_ring* %46, i32 0, i32 14
  store i16 %45, i16* %next_to_alloc, align 2
  call void asm sideeffect "sfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !14
  %47 = load i16* %i, align 2
  %conv37 = zext i16 %47 to i32
  %48 = load %struct.igb_ring** %rx_ring.addr, align 8
  %tail = getelementptr inbounds %struct.igb_ring* %48, i32 0, i32 6
  %49 = load i8** %tail, align 8
  call void @writel(i32 %conv37, i8* %49) noredzone
  br label %if.end38

if.end38:                                         ; preds = %if.then, %if.then35, %do.end
  ret void
}

define internal zeroext i1 @igb_alloc_mapped_page(%struct.igb_ring* %rx_ring, %struct.igb_rx_buffer* %bi) nounwind noredzone {
entry:
  %retval = alloca i1, align 1
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %bi.addr = alloca %struct.igb_rx_buffer*, align 8
  %page = alloca %struct.page*, align 8
  %dma = alloca i64, align 8
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %struct.igb_rx_buffer* %bi, %struct.igb_rx_buffer** %bi.addr, align 8
  %0 = load %struct.igb_rx_buffer** %bi.addr, align 8
  %page1 = getelementptr inbounds %struct.igb_rx_buffer* %0, i32 0, i32 1
  %1 = load %struct.page** %page1, align 8
  store %struct.page* %1, %struct.page** %page, align 8
  %2 = load %struct.page** %page, align 8
  %tobool = icmp ne %struct.page* %2, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %call = call %struct.page* @__skb_alloc_page(i32 288, %struct.sk_buff* null) noredzone
  store %struct.page* %call, %struct.page** %page, align 8
  %3 = load %struct.page** %page, align 8
  %tobool4 = icmp ne %struct.page* %3, null
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %if.then14, label %if.end15

if.then14:                                        ; preds = %if.end
  %4 = load %struct.igb_ring** %rx_ring.addr, align 8
  %5 = getelementptr inbounds %struct.igb_ring* %4, i32 0, i32 15
  %6 = bitcast %union.anon.90* %5 to %struct.anon.92*
  %rx_stats = getelementptr inbounds %struct.anon.92* %6, i32 0, i32 1
  %alloc_failed = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats, i32 0, i32 4
  %7 = load i64* %alloc_failed, align 8
  %inc = add i64 %7, 1
  store i64 %inc, i64* %alloc_failed, align 8
  store i1 false, i1* %retval
  br label %return

if.end15:                                         ; preds = %if.end
  %8 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 2
  %9 = load %struct.device** %dev, align 8
  %10 = load %struct.page** %page, align 8
  %call16 = call i64 @dma_map_page(%struct.device* %9, %struct.page* %10, i64 0, i64 4096, i32 2) noredzone
  store i64 %call16, i64* %dma, align 8
  %11 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev17 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 2
  %12 = load %struct.device** %dev17, align 8
  %13 = load i64* %dma, align 8
  %call18 = call i32 @dma_mapping_error(%struct.device* %12, i64 %13) noredzone
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end24

if.then20:                                        ; preds = %if.end15
  %14 = load %struct.page** %page, align 8
  call void @__free_pages(%struct.page* %14, i32 0) noredzone
  %15 = load %struct.igb_ring** %rx_ring.addr, align 8
  %16 = getelementptr inbounds %struct.igb_ring* %15, i32 0, i32 15
  %17 = bitcast %union.anon.90* %16 to %struct.anon.92*
  %rx_stats21 = getelementptr inbounds %struct.anon.92* %17, i32 0, i32 1
  %alloc_failed22 = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats21, i32 0, i32 4
  %18 = load i64* %alloc_failed22, align 8
  %inc23 = add i64 %18, 1
  store i64 %inc23, i64* %alloc_failed22, align 8
  store i1 false, i1* %retval
  br label %return

if.end24:                                         ; preds = %if.end15
  %19 = load i64* %dma, align 8
  %20 = load %struct.igb_rx_buffer** %bi.addr, align 8
  %dma25 = getelementptr inbounds %struct.igb_rx_buffer* %20, i32 0, i32 0
  store i64 %19, i64* %dma25, align 8
  %21 = load %struct.page** %page, align 8
  %22 = load %struct.igb_rx_buffer** %bi.addr, align 8
  %page26 = getelementptr inbounds %struct.igb_rx_buffer* %22, i32 0, i32 1
  store %struct.page* %21, %struct.page** %page26, align 8
  %23 = load %struct.igb_rx_buffer** %bi.addr, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %23, i32 0, i32 2
  store i32 0, i32* %page_offset, align 4
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end24, %if.then20, %if.then14, %if.then
  %24 = load i1* %retval
  ret i1 %24
}

define void @igb_read_pci_cfg(%struct.e1000_hw* %hw, i32 %reg, i16* %value) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %reg.addr = alloca i32, align 4
  %value.addr = alloca i16*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  store i16* %value, i16** %value.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %back = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 0
  %1 = load i8** %back, align 8
  %2 = bitcast i8* %1 to %struct.igb_adapter*
  store %struct.igb_adapter* %2, %struct.igb_adapter** %adapter, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 32
  %4 = load %struct.pci_dev** %pdev, align 8
  %5 = load i32* %reg.addr, align 4
  %6 = load i16** %value.addr, align 8
  %call = call i32 @pci_read_config_word(%struct.pci_dev* %4, i32 %5, i16* %6) noredzone
  ret void
}

define internal i32 @pci_read_config_word(%struct.pci_dev* %dev, i32 %where, i16* %val) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.pci_dev*, align 8
  %where.addr = alloca i32, align 4
  %val.addr = alloca i16*, align 8
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  store i32 %where, i32* %where.addr, align 4
  store i16* %val, i16** %val.addr, align 8
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %bus = getelementptr inbounds %struct.pci_dev* %0, i32 0, i32 1
  %1 = load %struct.pci_bus** %bus, align 8
  %2 = load %struct.pci_dev** %dev.addr, align 8
  %devfn = getelementptr inbounds %struct.pci_dev* %2, i32 0, i32 6
  %3 = load i32* %devfn, align 4
  %4 = load i32* %where.addr, align 4
  %5 = load i16** %val.addr, align 8
  %call = call i32 @pci_bus_read_config_word(%struct.pci_bus* %1, i32 %3, i32 %4, i16* %5) noredzone
  ret i32 %call
}

define void @igb_write_pci_cfg(%struct.e1000_hw* %hw, i32 %reg, i16* %value) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %reg.addr = alloca i32, align 4
  %value.addr = alloca i16*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  store i16* %value, i16** %value.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %back = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 0
  %1 = load i8** %back, align 8
  %2 = bitcast i8* %1 to %struct.igb_adapter*
  store %struct.igb_adapter* %2, %struct.igb_adapter** %adapter, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 32
  %4 = load %struct.pci_dev** %pdev, align 8
  %5 = load i32* %reg.addr, align 4
  %6 = load i16** %value.addr, align 8
  %7 = load i16* %6, align 2
  %call = call i32 @pci_write_config_word(%struct.pci_dev* %4, i32 %5, i16 zeroext %7) noredzone
  ret void
}

define internal i32 @pci_write_config_word(%struct.pci_dev* %dev, i32 %where, i16 zeroext %val) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.pci_dev*, align 8
  %where.addr = alloca i32, align 4
  %val.addr = alloca i16, align 2
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  store i32 %where, i32* %where.addr, align 4
  store i16 %val, i16* %val.addr, align 2
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %bus = getelementptr inbounds %struct.pci_dev* %0, i32 0, i32 1
  %1 = load %struct.pci_bus** %bus, align 8
  %2 = load %struct.pci_dev** %dev.addr, align 8
  %devfn = getelementptr inbounds %struct.pci_dev* %2, i32 0, i32 6
  %3 = load i32* %devfn, align 4
  %4 = load i32* %where.addr, align 4
  %5 = load i16* %val.addr, align 2
  %call = call i32 @pci_bus_write_config_word(%struct.pci_bus* %1, i32 %3, i32 %4, i16 zeroext %5) noredzone
  ret i32 %call
}

define i32 @igb_read_pcie_cap_reg(%struct.e1000_hw* %hw, i32 %reg, i16* %value) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %reg.addr = alloca i32, align 4
  %value.addr = alloca i16*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  store i16* %value, i16** %value.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %back = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 0
  %1 = load i8** %back, align 8
  %2 = bitcast i8* %1 to %struct.igb_adapter*
  store %struct.igb_adapter* %2, %struct.igb_adapter** %adapter, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 32
  %4 = load %struct.pci_dev** %pdev, align 8
  %5 = load i32* %reg.addr, align 4
  %6 = load i16** %value.addr, align 8
  %call = call i32 @pcie_capability_read_word(%struct.pci_dev* %4, i32 %5, i16* %6) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -3, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %7 = load i32* %retval
  ret i32 %7
}

declare i32 @pcie_capability_read_word(%struct.pci_dev*, i32, i16*) noredzone

define i32 @igb_write_pcie_cap_reg(%struct.e1000_hw* %hw, i32 %reg, i16* %value) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %reg.addr = alloca i32, align 4
  %value.addr = alloca i16*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %reg, i32* %reg.addr, align 4
  store i16* %value, i16** %value.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %back = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 0
  %1 = load i8** %back, align 8
  %2 = bitcast i8* %1 to %struct.igb_adapter*
  store %struct.igb_adapter* %2, %struct.igb_adapter** %adapter, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 32
  %4 = load %struct.pci_dev** %pdev, align 8
  %5 = load i32* %reg.addr, align 4
  %6 = load i16** %value.addr, align 8
  %7 = load i16* %6, align 2
  %call = call i32 @pcie_capability_write_word(%struct.pci_dev* %4, i32 %5, i16 zeroext %7) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -3, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %8 = load i32* %retval
  ret i32 %8
}

declare i32 @pcie_capability_write_word(%struct.pci_dev*, i32, i16 zeroext) noredzone

define i32 @igb_set_spd_dplx(%struct.igb_adapter* %adapter, i32 %spd, i8 zeroext %dplx) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %spd.addr = alloca i32, align 4
  %dplx.addr = alloca i8, align 1
  %pdev = alloca %struct.pci_dev*, align 8
  %mac = alloca %struct.e1000_mac_info*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %spd, i32* %spd.addr, align 4
  store i8 %dplx, i8* %dplx.addr, align 1
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  %mac2 = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  store %struct.e1000_mac_info* %mac2, %struct.e1000_mac_info** %mac, align 8
  %3 = load %struct.e1000_mac_info** %mac, align 8
  %autoneg = getelementptr inbounds %struct.e1000_mac_info* %3, i32 0, i32 17
  store i8 0, i8* %autoneg, align 1
  %4 = load i32* %spd.addr, align 4
  %and = and i32 %4, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i8* %dplx.addr, align 1
  %conv = zext i8 %5 to i32
  %and3 = and i32 %conv, -2
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %err_inval

if.end:                                           ; preds = %lor.lhs.false
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw5 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 35
  %phy = getelementptr inbounds %struct.e1000_hw* %hw5, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %7 = load i32* %media_type, align 4
  %cmp = icmp eq i32 %7, 3
  br i1 %cmp, label %if.then7, label %if.end9

if.then7:                                         ; preds = %if.end
  %8 = load i32* %spd.addr, align 4
  %9 = load i8* %dplx.addr, align 1
  %conv8 = zext i8 %9 to i32
  %add = add i32 %8, %conv8
  switch i32 %add, label %sw.default [
    i32 10, label %sw.bb
    i32 11, label %sw.bb
    i32 100, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.then7, %if.then7, %if.then7
  br label %err_inval

sw.default:                                       ; preds = %if.then7
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default
  br label %if.end9

if.end9:                                          ; preds = %sw.epilog, %if.end
  %10 = load i32* %spd.addr, align 4
  %11 = load i8* %dplx.addr, align 1
  %conv10 = zext i8 %11 to i32
  %add11 = add i32 %10, %conv10
  switch i32 %add11, label %sw.default24 [
    i32 10, label %sw.bb12
    i32 11, label %sw.bb13
    i32 100, label %sw.bb15
    i32 101, label %sw.bb17
    i32 1001, label %sw.bb19
    i32 1000, label %sw.bb23
  ]

sw.bb12:                                          ; preds = %if.end9
  %12 = load %struct.e1000_mac_info** %mac, align 8
  %forced_speed_duplex = getelementptr inbounds %struct.e1000_mac_info* %12, i32 0, i32 13
  store i8 1, i8* %forced_speed_duplex, align 1
  br label %sw.epilog25

sw.bb13:                                          ; preds = %if.end9
  %13 = load %struct.e1000_mac_info** %mac, align 8
  %forced_speed_duplex14 = getelementptr inbounds %struct.e1000_mac_info* %13, i32 0, i32 13
  store i8 2, i8* %forced_speed_duplex14, align 1
  br label %sw.epilog25

sw.bb15:                                          ; preds = %if.end9
  %14 = load %struct.e1000_mac_info** %mac, align 8
  %forced_speed_duplex16 = getelementptr inbounds %struct.e1000_mac_info* %14, i32 0, i32 13
  store i8 4, i8* %forced_speed_duplex16, align 1
  br label %sw.epilog25

sw.bb17:                                          ; preds = %if.end9
  %15 = load %struct.e1000_mac_info** %mac, align 8
  %forced_speed_duplex18 = getelementptr inbounds %struct.e1000_mac_info* %15, i32 0, i32 13
  store i8 8, i8* %forced_speed_duplex18, align 1
  br label %sw.epilog25

sw.bb19:                                          ; preds = %if.end9
  %16 = load %struct.e1000_mac_info** %mac, align 8
  %autoneg20 = getelementptr inbounds %struct.e1000_mac_info* %16, i32 0, i32 17
  store i8 1, i8* %autoneg20, align 1
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw21 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 35
  %phy22 = getelementptr inbounds %struct.e1000_hw* %hw21, i32 0, i32 6
  %autoneg_advertised = getelementptr inbounds %struct.e1000_phy_info* %phy22, i32 0, i32 13
  store i16 32, i16* %autoneg_advertised, align 2
  br label %sw.epilog25

sw.bb23:                                          ; preds = %if.end9
  br label %sw.default24

sw.default24:                                     ; preds = %if.end9, %sw.bb23
  br label %err_inval

sw.epilog25:                                      ; preds = %sw.bb19, %sw.bb17, %sw.bb15, %sw.bb13, %sw.bb12
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw26 = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 35
  %phy27 = getelementptr inbounds %struct.e1000_hw* %hw26, i32 0, i32 6
  %mdix = getelementptr inbounds %struct.e1000_phy_info* %phy27, i32 0, i32 18
  store i8 0, i8* %mdix, align 1
  store i32 0, i32* %retval
  br label %return

err_inval:                                        ; preds = %sw.default24, %sw.bb, %if.then
  %19 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %19, i32 0, i32 33
  %call = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([40 x i8]* @.str10, i32 0, i32 0)) noredzone
  store i32 -22, i32* %retval
  br label %return

return:                                           ; preds = %err_inval, %sw.epilog25
  %20 = load i32* %retval
  ret i32 %20
}

define i32 @igb_read_i2c_byte(%struct.e1000_hw* %hw, i8 zeroext %byte_offset, i8 zeroext %dev_addr, i8* %data) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %byte_offset.addr = alloca i8, align 1
  %dev_addr.addr = alloca i8, align 1
  %data.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %__mptr = alloca %struct.e1000_hw*, align 8
  %this_client = alloca %struct.i2c_client*, align 8
  %status = alloca i32, align 4
  %swfw_mask = alloca i16, align 2
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i8 %byte_offset, i8* %byte_offset.addr, align 1
  store i8 %dev_addr, i8* %dev_addr.addr, align 1
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  store %struct.e1000_hw* %0, %struct.e1000_hw** %__mptr, align 8
  %1 = load %struct.e1000_hw** %__mptr, align 8
  %2 = bitcast %struct.e1000_hw* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -1456
  %3 = bitcast i8* %add.ptr to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %i2c_client = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 74
  %5 = load %struct.i2c_client** %i2c_client, align 8
  store %struct.i2c_client* %5, %struct.i2c_client** %this_client, align 8
  store i16 0, i16* %swfw_mask, align 2
  %6 = load %struct.i2c_client** %this_client, align 8
  %tobool = icmp ne %struct.i2c_client* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 20, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i16 2, i16* %swfw_mask, align 2
  %7 = load %struct.e1000_hw** %hw.addr, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %7, i32 0, i32 4
  %ops = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 0
  %acquire_swfw_sync = getelementptr inbounds %struct.e1000_mac_operations* %ops, i32 0, i32 8
  %8 = load i32 (%struct.e1000_hw*, i16)** %acquire_swfw_sync, align 8
  %9 = load %struct.e1000_hw** %hw.addr, align 8
  %10 = load i16* %swfw_mask, align 2
  %call = call i32 %8(%struct.e1000_hw* %9, i16 zeroext %10) noredzone
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 13, i32* %retval
  br label %return

if.end3:                                          ; preds = %if.end
  %11 = load %struct.i2c_client** %this_client, align 8
  %12 = load i8* %byte_offset.addr, align 1
  %call4 = call i32 @i2c_smbus_read_byte_data(%struct.i2c_client* %11, i8 zeroext %12) noredzone
  store i32 %call4, i32* %status, align 4
  %13 = load %struct.e1000_hw** %hw.addr, align 8
  %mac5 = getelementptr inbounds %struct.e1000_hw* %13, i32 0, i32 4
  %ops6 = getelementptr inbounds %struct.e1000_mac_info* %mac5, i32 0, i32 0
  %release_swfw_sync = getelementptr inbounds %struct.e1000_mac_operations* %ops6, i32 0, i32 9
  %14 = load void (%struct.e1000_hw*, i16)** %release_swfw_sync, align 8
  %15 = load %struct.e1000_hw** %hw.addr, align 8
  %16 = load i16* %swfw_mask, align 2
  call void %14(%struct.e1000_hw* %15, i16 zeroext %16) noredzone
  %17 = load i32* %status, align 4
  %cmp = icmp slt i32 %17, 0
  br i1 %cmp, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end3
  store i32 20, i32* %retval
  br label %return

if.else:                                          ; preds = %if.end3
  %18 = load i32* %status, align 4
  %conv = trunc i32 %18 to i8
  %19 = load i8** %data.addr, align 8
  store i8 %conv, i8* %19, align 1
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then7, %if.then2, %if.then
  %20 = load i32* %retval
  ret i32 %20
}

declare i32 @i2c_smbus_read_byte_data(%struct.i2c_client*, i8 zeroext) noredzone

define i32 @igb_write_i2c_byte(%struct.e1000_hw* %hw, i8 zeroext %byte_offset, i8 zeroext %dev_addr, i8 zeroext %data) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %byte_offset.addr = alloca i8, align 1
  %dev_addr.addr = alloca i8, align 1
  %data.addr = alloca i8, align 1
  %adapter = alloca %struct.igb_adapter*, align 8
  %__mptr = alloca %struct.e1000_hw*, align 8
  %this_client = alloca %struct.i2c_client*, align 8
  %status = alloca i32, align 4
  %swfw_mask = alloca i16, align 2
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i8 %byte_offset, i8* %byte_offset.addr, align 1
  store i8 %dev_addr, i8* %dev_addr.addr, align 1
  store i8 %data, i8* %data.addr, align 1
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  store %struct.e1000_hw* %0, %struct.e1000_hw** %__mptr, align 8
  %1 = load %struct.e1000_hw** %__mptr, align 8
  %2 = bitcast %struct.e1000_hw* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -1456
  %3 = bitcast i8* %add.ptr to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %i2c_client = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 74
  %5 = load %struct.i2c_client** %i2c_client, align 8
  store %struct.i2c_client* %5, %struct.i2c_client** %this_client, align 8
  store i16 2, i16* %swfw_mask, align 2
  %6 = load %struct.i2c_client** %this_client, align 8
  %tobool = icmp ne %struct.i2c_client* %6, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 20, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.e1000_hw** %hw.addr, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %7, i32 0, i32 4
  %ops = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 0
  %acquire_swfw_sync = getelementptr inbounds %struct.e1000_mac_operations* %ops, i32 0, i32 8
  %8 = load i32 (%struct.e1000_hw*, i16)** %acquire_swfw_sync, align 8
  %9 = load %struct.e1000_hw** %hw.addr, align 8
  %10 = load i16* %swfw_mask, align 2
  %call = call i32 %8(%struct.e1000_hw* %9, i16 zeroext %10) noredzone
  %tobool1 = icmp ne i32 %call, 0
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 13, i32* %retval
  br label %return

if.end3:                                          ; preds = %if.end
  %11 = load %struct.i2c_client** %this_client, align 8
  %12 = load i8* %byte_offset.addr, align 1
  %13 = load i8* %data.addr, align 1
  %call4 = call i32 @i2c_smbus_write_byte_data(%struct.i2c_client* %11, i8 zeroext %12, i8 zeroext %13) noredzone
  store i32 %call4, i32* %status, align 4
  %14 = load %struct.e1000_hw** %hw.addr, align 8
  %mac5 = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 4
  %ops6 = getelementptr inbounds %struct.e1000_mac_info* %mac5, i32 0, i32 0
  %release_swfw_sync = getelementptr inbounds %struct.e1000_mac_operations* %ops6, i32 0, i32 9
  %15 = load void (%struct.e1000_hw*, i16)** %release_swfw_sync, align 8
  %16 = load %struct.e1000_hw** %hw.addr, align 8
  %17 = load i16* %swfw_mask, align 2
  call void %15(%struct.e1000_hw* %16, i16 zeroext %17) noredzone
  %18 = load i32* %status, align 4
  %tobool7 = icmp ne i32 %18, 0
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end3
  store i32 20, i32* %retval
  br label %return

if.else:                                          ; preds = %if.end3
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then8, %if.then2, %if.then
  %19 = load i32* %retval
  ret i32 %19
}

declare i32 @i2c_smbus_write_byte_data(%struct.i2c_client*, i8 zeroext, i8 zeroext) noredzone

define i32 @igb_reinit_queues(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %err = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 32
  %3 = load %struct.pci_dev** %pdev2, align 8
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  store i32 0, i32* %err, align 4
  %4 = load %struct.net_device** %netdev, align 8
  %call = call zeroext i1 @netif_running(%struct.net_device* %4) noredzone
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.net_device** %netdev, align 8
  %call3 = call i32 @igb_close(%struct.net_device* %5) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_reset_interrupt_capability(%struct.igb_adapter* %6) noredzone
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %call4 = call i32 @igb_init_interrupt_scheme(%struct.igb_adapter* %7, i1 zeroext true) noredzone
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %8 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %8, i32 0, i32 33
  %call6 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([38 x i8]* @.str11, i32 0, i32 0)) noredzone
  store i32 -12, i32* %retval
  br label %return

if.end7:                                          ; preds = %if.end
  %9 = load %struct.net_device** %netdev, align 8
  %call8 = call zeroext i1 @netif_running(%struct.net_device* %9) noredzone
  br i1 %call8, label %if.then9, label %if.end11

if.then9:                                         ; preds = %if.end7
  %10 = load %struct.net_device** %netdev, align 8
  %call10 = call i32 @igb_open(%struct.net_device* %10) noredzone
  store i32 %call10, i32* %err, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end7
  %11 = load i32* %err, align 4
  store i32 %11, i32* %retval
  br label %return

return:                                           ; preds = %if.end11, %if.then5
  %12 = load i32* %retval
  ret i32 %12
}

define internal i32 @igb_close(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i32 @__igb_close(%struct.net_device* %0, i1 zeroext false) noredzone
  ret i32 %call
}

define internal void @igb_reset_interrupt_capability(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %v_idx = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 4
  %1 = load i32* %num_q_vectors, align 4
  store i32 %1, i32* %v_idx, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 3
  %3 = load i32* %flags, align 4
  %and = and i32 %3, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 32
  %5 = load %struct.pci_dev** %pdev, align 8
  call void @pci_disable_msix(%struct.pci_dev* %5) noredzone
  br label %if.end6

if.else:                                          ; preds = %entry
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags1 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 3
  %7 = load i32* %flags1, align 4
  %and2 = and i32 %7, 1
  %tobool3 = icmp ne i32 %and2, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.else
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev5 = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 32
  %9 = load %struct.pci_dev** %pdev5, align 8
  call void @pci_disable_msi(%struct.pci_dev* %9) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.else
  br label %if.end6

if.end6:                                          ; preds = %if.end, %if.then
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end6
  %10 = load i32* %v_idx, align 4
  %dec = add i32 %10, -1
  store i32 %dec, i32* %v_idx, align 4
  %tobool7 = icmp ne i32 %10, 0
  br i1 %tobool7, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %12 = load i32* %v_idx, align 4
  call void @igb_reset_q_vector(%struct.igb_adapter* %11, i32 %12) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

define internal i32 @igb_init_interrupt_scheme(%struct.igb_adapter* %adapter, i1 zeroext %msix) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %msix.addr = alloca i8, align 1
  %pdev = alloca %struct.pci_dev*, align 8
  %err = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %frombool = zext i1 %msix to i8
  store i8 %frombool, i8* %msix.addr, align 1
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %3 = load i8* %msix.addr, align 1
  %tobool = trunc i8 %3 to i1
  call void @igb_set_interrupt_capability(%struct.igb_adapter* %2, i1 zeroext %tobool) noredzone
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %call = call i32 @igb_alloc_q_vectors(%struct.igb_adapter* %4) noredzone
  store i32 %call, i32* %err, align 4
  %5 = load i32* %err, align 4
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %6, i32 0, i32 33
  %call3 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([39 x i8]* @.str26, i32 0, i32 0)) noredzone
  br label %err_alloc_q_vectors

if.end:                                           ; preds = %entry
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_cache_ring_register(%struct.igb_adapter* %7) noredzone
  store i32 0, i32* %retval
  br label %return

err_alloc_q_vectors:                              ; preds = %if.then
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_reset_interrupt_capability(%struct.igb_adapter* %8) noredzone
  %9 = load i32* %err, align 4
  store i32 %9, i32* %retval
  br label %return

return:                                           ; preds = %err_alloc_q_vectors, %if.end
  %10 = load i32* %retval
  ret i32 %10
}

define internal i32 @igb_open(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i32 @__igb_open(%struct.net_device* %0, i1 zeroext false) noredzone
  ret i32 %call
}

define internal i32 @__igb_open(%struct.net_device* %netdev, i1 zeroext %resuming) nounwind noredzone {
entry:
  %nr.addr.i82 = alloca i64, align 8
  %addr.addr.i83 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %resuming.addr = alloca i8, align 1
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %err = alloca i32, align 4
  %i = alloca i32, align 4
  %__ret_warn_on = alloca i32, align 4
  %reg_data = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %frombool = zext i1 %resuming to i8
  store i8 %frombool, i8* %resuming.addr, align 1
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %pdev2 = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 32
  %4 = load %struct.pci_dev** %pdev2, align 8
  store %struct.pci_dev* %4, %struct.pci_dev** %pdev, align 8
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 2
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %6 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %6, 63
  %shl.i = shl i64 1, %and.i
  %7 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %7, 6
  %8 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %8, i64 %shr.i
  %9 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %9
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end23

cond.false:                                       ; preds = %entry
  %10 = load %struct.igb_adapter** %adapter, align 8
  %state4 = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 2
  %call5 = call i32 @variable_test_bit(i64 0, i64* %state4) noredzone
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then, label %if.end23

if.then:                                          ; preds = %cond.false, %cond.true
  %11 = load i8* %resuming.addr, align 1
  %tobool7 = trunc i8 %11 to i1
  %lnot = xor i1 %tobool7, true
  %lnot8 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot8 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %12 = load i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %12, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext13 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool14 = icmp ne i64 %expval, 0
  br i1 %tobool14, label %if.then15, label %if.end

if.then15:                                        ; preds = %if.then
  call void @warn_slowpath_null(i8* getelementptr inbounds ([56 x i8]* @.str1, i32 0, i32 0), i32 3028) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then15, %if.then
  %13 = load i32* %__ret_warn_on, align 4
  %tobool16 = icmp ne i32 %13, 0
  %lnot17 = xor i1 %tobool16, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  store i32 -16, i32* %retval
  br label %return

if.end23:                                         ; preds = %cond.false, %cond.true
  %14 = load i8* %resuming.addr, align 1
  %tobool24 = trunc i8 %14 to i1
  br i1 %tobool24, label %if.end27, label %if.then25

if.then25:                                        ; preds = %if.end23
  %15 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %15, i32 0, i32 33
  %call26 = call i32 @pm_runtime_get_sync(%struct.device* %dev) noredzone
  br label %if.end27

if.end27:                                         ; preds = %if.then25, %if.end23
  %16 = load %struct.net_device** %netdev.addr, align 8
  call void @netif_carrier_off(%struct.net_device* %16) noredzone
  %17 = load %struct.igb_adapter** %adapter, align 8
  %call28 = call i32 @igb_setup_all_tx_resources(%struct.igb_adapter* %17) noredzone
  store i32 %call28, i32* %err, align 4
  %18 = load i32* %err, align 4
  %tobool29 = icmp ne i32 %18, 0
  br i1 %tobool29, label %if.then30, label %if.end31

if.then30:                                        ; preds = %if.end27
  br label %err_setup_tx

if.end31:                                         ; preds = %if.end27
  %19 = load %struct.igb_adapter** %adapter, align 8
  %call32 = call i32 @igb_setup_all_rx_resources(%struct.igb_adapter* %19) noredzone
  store i32 %call32, i32* %err, align 4
  %20 = load i32* %err, align 4
  %tobool33 = icmp ne i32 %20, 0
  br i1 %tobool33, label %if.then34, label %if.end35

if.then34:                                        ; preds = %if.end31
  br label %err_setup_rx

if.end35:                                         ; preds = %if.end31
  %21 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_power_up_link(%struct.igb_adapter* %21) noredzone
  %22 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_configure(%struct.igb_adapter* %22) noredzone
  %23 = load %struct.igb_adapter** %adapter, align 8
  %call36 = call i32 @igb_request_irq(%struct.igb_adapter* %23) noredzone
  store i32 %call36, i32* %err, align 4
  %24 = load i32* %err, align 4
  %tobool37 = icmp ne i32 %24, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %if.end35
  br label %err_req_irq

if.end39:                                         ; preds = %if.end35
  %25 = load %struct.igb_adapter** %adapter, align 8
  %netdev40 = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 1
  %26 = load %struct.net_device** %netdev40, align 8
  %27 = load %struct.igb_adapter** %adapter, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 12
  %28 = load i32* %num_tx_queues, align 4
  %call41 = call i32 @netif_set_real_num_tx_queues(%struct.net_device* %26, i32 %28) noredzone
  store i32 %call41, i32* %err, align 4
  %29 = load i32* %err, align 4
  %tobool42 = icmp ne i32 %29, 0
  br i1 %tobool42, label %if.then43, label %if.end44

if.then43:                                        ; preds = %if.end39
  br label %err_set_queues

if.end44:                                         ; preds = %if.end39
  %30 = load %struct.igb_adapter** %adapter, align 8
  %netdev45 = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 1
  %31 = load %struct.net_device** %netdev45, align 8
  %32 = load %struct.igb_adapter** %adapter, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %32, i32 0, i32 14
  %33 = load i32* %num_rx_queues, align 4
  %call46 = call i32 @netif_set_real_num_rx_queues(%struct.net_device* %31, i32 %33) noredzone
  store i32 %call46, i32* %err, align 4
  %34 = load i32* %err, align 4
  %tobool47 = icmp ne i32 %34, 0
  br i1 %tobool47, label %if.then48, label %if.end49

if.then48:                                        ; preds = %if.end44
  br label %err_set_queues

if.end49:                                         ; preds = %if.end44
  %35 = load %struct.igb_adapter** %adapter, align 8
  %state50 = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 2
  store i64 2, i64* %nr.addr.i82, align 8
  store i64* %state50, i64** %addr.addr.i83, align 8
  %36 = load i64** %addr.addr.i83, align 8
  %37 = load i64* %nr.addr.i82, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %36, i64 %37, i64* %36) nounwind, !srcloc !1
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end49
  %38 = load i32* %i, align 4
  %39 = load %struct.igb_adapter** %adapter, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 4
  %40 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %38, %40
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %41 = load i32* %i, align 4
  %idxprom = sext i32 %41 to i64
  %42 = load %struct.igb_adapter** %adapter, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %42, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom
  %43 = load %struct.igb_q_vector** %arrayidx, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %43, i32 0, i32 8
  call void @napi_enable(%struct.napi_struct* %napi) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %44 = load i32* %i, align 4
  %inc = add i32 %44, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %45 = load %struct.e1000_hw** %hw, align 8
  %call52 = call i32 @igb_rd32(%struct.e1000_hw* %45, i32 192) noredzone
  %46 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_irq_enable(%struct.igb_adapter* %46) noredzone
  %47 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %47, i32 0, i32 49
  %48 = load i32* %vfs_allocated_count, align 4
  %tobool53 = icmp ne i32 %48, 0
  br i1 %tobool53, label %if.then54, label %if.end70

if.then54:                                        ; preds = %for.end
  %49 = load %struct.e1000_hw** %hw, align 8
  %call55 = call i32 @igb_rd32(%struct.e1000_hw* %49, i32 24) noredzone
  store i32 %call55, i32* %reg_data, align 4
  %50 = load i32* %reg_data, align 4
  %or = or i32 %50, 16384
  store i32 %or, i32* %reg_data, align 4
  br label %do.body

do.body:                                          ; preds = %if.then54
  %51 = load %struct.e1000_hw** %hw, align 8
  %hw_addr56 = getelementptr inbounds %struct.e1000_hw* %51, i32 0, i32 1
  %52 = load volatile i8** %hw_addr56, align 8
  store i8* %52, i8** %hw_addr, align 8
  %53 = load i8** %hw_addr, align 8
  %tobool57 = icmp ne i8* %53, null
  %lnot58 = xor i1 %tobool57, true
  %lnot60 = xor i1 %lnot58, true
  %lnot62 = xor i1 %lnot60, true
  %lnot.ext63 = zext i1 %lnot62 to i32
  %conv64 = sext i32 %lnot.ext63 to i64
  %expval65 = call i64 @llvm.expect.i64(i64 %conv64, i64 0)
  %tobool66 = icmp ne i64 %expval65, 0
  br i1 %tobool66, label %if.end69, label %if.then67

if.then67:                                        ; preds = %do.body
  %54 = load i32* %reg_data, align 4
  %55 = load i8** %hw_addr, align 8
  %arrayidx68 = getelementptr i8* %55, i64 24
  call void @writel(i32 %54, i8* %arrayidx68) noredzone
  br label %if.end69

if.end69:                                         ; preds = %if.then67, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end69
  br label %if.end70

if.end70:                                         ; preds = %do.end, %for.end
  %56 = load %struct.net_device** %netdev.addr, align 8
  call void @netif_tx_start_all_queues(%struct.net_device* %56) noredzone
  %57 = load i8* %resuming.addr, align 1
  %tobool71 = trunc i8 %57 to i1
  br i1 %tobool71, label %if.end75, label %if.then72

if.then72:                                        ; preds = %if.end70
  %58 = load %struct.pci_dev** %pdev, align 8
  %dev73 = getelementptr inbounds %struct.pci_dev* %58, i32 0, i32 33
  %call74 = call i32 @pm_runtime_put(%struct.device* %dev73) noredzone
  br label %if.end75

if.end75:                                         ; preds = %if.then72, %if.end70
  %59 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %59, i32 0, i32 4
  %get_link_status = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 20
  store i8 1, i8* %get_link_status, align 1
  %60 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task = getelementptr inbounds %struct.igb_adapter* %60, i32 0, i32 27
  %call76 = call zeroext i1 @schedule_work(%struct.work_struct* %watchdog_task) noredzone
  store i32 0, i32* %retval
  br label %return

err_set_queues:                                   ; preds = %if.then48, %if.then43
  %61 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_free_irq(%struct.igb_adapter* %61) noredzone
  br label %err_req_irq

err_req_irq:                                      ; preds = %err_set_queues, %if.then38
  %62 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_release_hw_control(%struct.igb_adapter* %62) noredzone
  %63 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_power_down_link(%struct.igb_adapter* %63) noredzone
  %64 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_free_all_rx_resources(%struct.igb_adapter* %64) noredzone
  br label %err_setup_rx

err_setup_rx:                                     ; preds = %err_req_irq, %if.then34
  %65 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_free_all_tx_resources(%struct.igb_adapter* %65) noredzone
  br label %err_setup_tx

err_setup_tx:                                     ; preds = %err_setup_rx, %if.then30
  %66 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %66) noredzone
  %67 = load i8* %resuming.addr, align 1
  %tobool77 = trunc i8 %67 to i1
  br i1 %tobool77, label %if.end81, label %if.then78

if.then78:                                        ; preds = %err_setup_tx
  %68 = load %struct.pci_dev** %pdev, align 8
  %dev79 = getelementptr inbounds %struct.pci_dev* %68, i32 0, i32 33
  %call80 = call i32 @pm_runtime_put(%struct.device* %dev79) noredzone
  br label %if.end81

if.end81:                                         ; preds = %if.then78, %err_setup_tx
  %69 = load i32* %err, align 4
  store i32 %69, i32* %retval
  br label %return

return:                                           ; preds = %if.end81, %if.end75, %if.end
  %70 = load i32* %retval
  ret i32 %70
}

define internal i32 @pm_runtime_get_sync(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call i32 @__pm_runtime_resume(%struct.device* %0, i32 4) noredzone
  ret i32 %call
}

define internal i32 @igb_setup_all_tx_resources(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  store i32 0, i32* %err, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %2 = load i32* %i, align 4
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 12
  %4 = load i32* %num_tx_queues, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end11

for.body:                                         ; preds = %for.cond
  %5 = load i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom
  %7 = load %struct.igb_ring** %arrayidx, align 8
  %call = call i32 @igb_setup_tx_resources(%struct.igb_ring* %7) noredzone
  store i32 %call, i32* %err, align 4
  %8 = load i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %9, i32 0, i32 33
  %10 = load i32* %i, align 4
  %call2 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8]* @.str25, i32 0, i32 0), i32 %10) noredzone
  %11 = load i32* %i, align 4
  %dec = add i32 %11, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %if.then
  %12 = load i32* %i, align 4
  %cmp4 = icmp sge i32 %12, 0
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %13 = load i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring7 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 13
  %arrayidx8 = getelementptr [16 x %struct.igb_ring*]* %tx_ring7, i32 0, i64 %idxprom6
  %15 = load %struct.igb_ring** %arrayidx8, align 8
  call void @igb_free_tx_resources(%struct.igb_ring* %15) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body5
  %16 = load i32* %i, align 4
  %dec9 = add i32 %16, -1
  store i32 %dec9, i32* %i, align 4
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  br label %for.end11

if.end:                                           ; preds = %for.body
  br label %for.inc10

for.inc10:                                        ; preds = %if.end
  %17 = load i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end11:                                        ; preds = %for.end, %for.cond
  %18 = load i32* %err, align 4
  ret i32 %18
}

define internal i32 @igb_setup_all_rx_resources(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  store i32 0, i32* %err, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %2 = load i32* %i, align 4
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 14
  %4 = load i32* %num_rx_queues, align 4
  %cmp = icmp slt i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end11

for.body:                                         ; preds = %for.cond
  %5 = load i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %7 = load %struct.igb_ring** %arrayidx, align 8
  %call = call i32 @igb_setup_rx_resources(%struct.igb_ring* %7) noredzone
  store i32 %call, i32* %err, align 4
  %8 = load i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %9, i32 0, i32 33
  %10 = load i32* %i, align 4
  %call2 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([35 x i8]* @.str24, i32 0, i32 0), i32 %10) noredzone
  %11 = load i32* %i, align 4
  %dec = add i32 %11, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond3

for.cond3:                                        ; preds = %for.inc, %if.then
  %12 = load i32* %i, align 4
  %cmp4 = icmp sge i32 %12, 0
  br i1 %cmp4, label %for.body5, label %for.end

for.body5:                                        ; preds = %for.cond3
  %13 = load i32* %i, align 4
  %idxprom6 = sext i32 %13 to i64
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring7 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 15
  %arrayidx8 = getelementptr [16 x %struct.igb_ring*]* %rx_ring7, i32 0, i64 %idxprom6
  %15 = load %struct.igb_ring** %arrayidx8, align 8
  call void @igb_free_rx_resources(%struct.igb_ring* %15) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body5
  %16 = load i32* %i, align 4
  %dec9 = add i32 %16, -1
  store i32 %dec9, i32* %i, align 4
  br label %for.cond3

for.end:                                          ; preds = %for.cond3
  br label %for.end11

if.end:                                           ; preds = %for.body
  br label %for.inc10

for.inc10:                                        ; preds = %if.end
  %17 = load i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end11:                                        ; preds = %for.end, %for.cond
  %18 = load i32* %err, align 4
  ret i32 %18
}

define internal i32 @igb_request_irq(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %err = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 32
  %3 = load %struct.pci_dev** %pdev2, align 8
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  store i32 0, i32* %err, align 4
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 3
  %5 = load i32* %flags, align 4
  %and = and i32 %5, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end11

if.then:                                          ; preds = %entry
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %call = call i32 @igb_request_msix(%struct.igb_adapter* %6) noredzone
  store i32 %call, i32* %err, align 4
  %7 = load i32* %err, align 4
  %tobool3 = icmp ne i32 %7, 0
  br i1 %tobool3, label %if.end, label %if.then4

if.then4:                                         ; preds = %if.then
  br label %request_done

if.end:                                           ; preds = %if.then
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_free_all_tx_resources(%struct.igb_adapter* %8) noredzone
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_free_all_rx_resources(%struct.igb_adapter* %9) noredzone
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_clear_interrupt_scheme(%struct.igb_adapter* %10) noredzone
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %call5 = call i32 @igb_init_interrupt_scheme(%struct.igb_adapter* %11, i1 zeroext false) noredzone
  store i32 %call5, i32* %err, align 4
  %12 = load i32* %err, align 4
  %tobool6 = icmp ne i32 %12, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %if.end
  br label %request_done

if.end8:                                          ; preds = %if.end
  %13 = load %struct.igb_adapter** %adapter.addr, align 8
  %call9 = call i32 @igb_setup_all_tx_resources(%struct.igb_adapter* %13) noredzone
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %call10 = call i32 @igb_setup_all_rx_resources(%struct.igb_adapter* %14) noredzone
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_configure(%struct.igb_adapter* %15) noredzone
  br label %if.end11

if.end11:                                         ; preds = %if.end8, %entry
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 0
  %17 = load %struct.igb_q_vector** %arrayidx, align 8
  call void @igb_assign_vector(%struct.igb_q_vector* %17, i32 0) noredzone
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags12 = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 3
  %19 = load i32* %flags12, align 4
  %and13 = and i32 %19, 1
  %tobool14 = icmp ne i32 %and13, 0
  br i1 %tobool14, label %if.then15, label %if.end22

if.then15:                                        ; preds = %if.end11
  %20 = load %struct.pci_dev** %pdev, align 8
  %irq = getelementptr inbounds %struct.pci_dev* %20, i32 0, i32 35
  %21 = load i32* %irq, align 4
  %22 = load %struct.net_device** %netdev, align 8
  %name = getelementptr inbounds %struct.net_device* %22, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8]* %name, i32 0, i32 0
  %23 = load %struct.igb_adapter** %adapter.addr, align 8
  %24 = bitcast %struct.igb_adapter* %23 to i8*
  %call16 = call i32 @request_irq(i32 %21, i32 (i32, i8*)* @igb_intr_msi, i64 0, i8* %arraydecay, i8* %24) noredzone
  store i32 %call16, i32* %err, align 4
  %25 = load i32* %err, align 4
  %tobool17 = icmp ne i32 %25, 0
  br i1 %tobool17, label %if.end19, label %if.then18

if.then18:                                        ; preds = %if.then15
  br label %request_done

if.end19:                                         ; preds = %if.then15
  %26 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_reset_interrupt_capability(%struct.igb_adapter* %26) noredzone
  %27 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags20 = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 3
  %28 = load i32* %flags20, align 4
  %and21 = and i32 %28, -2
  store i32 %and21, i32* %flags20, align 4
  br label %if.end22

if.end22:                                         ; preds = %if.end19, %if.end11
  %29 = load %struct.pci_dev** %pdev, align 8
  %irq23 = getelementptr inbounds %struct.pci_dev* %29, i32 0, i32 35
  %30 = load i32* %irq23, align 4
  %31 = load %struct.net_device** %netdev, align 8
  %name24 = getelementptr inbounds %struct.net_device* %31, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [16 x i8]* %name24, i32 0, i32 0
  %32 = load %struct.igb_adapter** %adapter.addr, align 8
  %33 = bitcast %struct.igb_adapter* %32 to i8*
  %call26 = call i32 @request_irq(i32 %30, i32 (i32, i8*)* @igb_intr, i64 128, i8* %arraydecay25, i8* %33) noredzone
  store i32 %call26, i32* %err, align 4
  %34 = load i32* %err, align 4
  %tobool27 = icmp ne i32 %34, 0
  br i1 %tobool27, label %if.then28, label %if.end30

if.then28:                                        ; preds = %if.end22
  %35 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %35, i32 0, i32 33
  %36 = load i32* %err, align 4
  %call29 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([28 x i8]* @.str12, i32 0, i32 0), i32 %36) noredzone
  br label %if.end30

if.end30:                                         ; preds = %if.then28, %if.end22
  br label %request_done

request_done:                                     ; preds = %if.end30, %if.then18, %if.then7, %if.then4
  %37 = load i32* %err, align 4
  ret i32 %37
}

declare i32 @netif_set_real_num_tx_queues(%struct.net_device*, i32) noredzone

declare i32 @netif_set_real_num_rx_queues(%struct.net_device*, i32) noredzone

define internal i32 @pm_runtime_put(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call i32 @__pm_runtime_idle(%struct.device* %0, i32 5) noredzone
  ret i32 %call
}

define internal void @igb_free_irq(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vector = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 3
  %1 = load i32* %flags, align 4
  %and = and i32 %1, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  store i32 0, i32* %vector, align 4
  %2 = load i32* %vector, align 4
  %inc = add i32 %2, 1
  store i32 %inc, i32* %vector, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 5
  %arrayidx = getelementptr [10 x %struct.msix_entry]* %msix_entries, i32 0, i64 %idxprom
  %vector1 = getelementptr inbounds %struct.msix_entry* %arrayidx, i32 0, i32 0
  %4 = load i32* %vector1, align 4
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %6 = bitcast %struct.igb_adapter* %5 to i8*
  call void @free_irq(i32 %4, i8* %6) noredzone
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %7 = load i32* %i, align 4
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 4
  %9 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %7, %9
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load i32* %vector, align 4
  %inc2 = add i32 %10, 1
  store i32 %inc2, i32* %vector, align 4
  %idxprom3 = sext i32 %10 to i64
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries4 = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 5
  %arrayidx5 = getelementptr [10 x %struct.msix_entry]* %msix_entries4, i32 0, i64 %idxprom3
  %vector6 = getelementptr inbounds %struct.msix_entry* %arrayidx5, i32 0, i32 0
  %12 = load i32* %vector6, align 4
  %13 = load i32* %i, align 4
  %idxprom7 = sext i32 %13 to i64
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 44
  %arrayidx8 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom7
  %15 = load %struct.igb_q_vector** %arrayidx8, align 8
  %16 = bitcast %struct.igb_q_vector* %15 to i8*
  call void @free_irq(i32 %12, i8* %16) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %inc9 = add i32 %17, 1
  store i32 %inc9, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.else:                                          ; preds = %entry
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 32
  %19 = load %struct.pci_dev** %pdev, align 8
  %irq = getelementptr inbounds %struct.pci_dev* %19, i32 0, i32 35
  %20 = load i32* %irq, align 4
  %21 = load %struct.igb_adapter** %adapter.addr, align 8
  %22 = bitcast %struct.igb_adapter* %21 to i8*
  call void @free_irq(i32 %20, i8* %22) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %for.end
  ret void
}

define internal void @igb_release_hw_control(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ctrl_ext = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 24) noredzone
  store i32 %call, i32* %ctrl_ext, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 1
  %3 = load volatile i8** %hw_addr2, align 8
  store i8* %3, i8** %hw_addr, align 8
  %4 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %4, null
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %5 = load i32* %ctrl_ext, align 4
  %and = and i32 %5, -268435457
  %6 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %6, i64 24
  call void @writel(i32 %and, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  ret void
}

define internal void @igb_free_all_rx_resources(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 14
  %2 = load i32* %num_rx_queues, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %5 = load %struct.igb_ring** %arrayidx, align 8
  call void @igb_free_rx_resources(%struct.igb_ring* %5) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal void @igb_free_all_tx_resources(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 12
  %2 = load i32* %num_tx_queues, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom
  %5 = load %struct.igb_ring** %arrayidx, align 8
  call void @igb_free_tx_resources(%struct.igb_ring* %5) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %6 = load i32* %i, align 4
  %inc = add i32 %6, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @free_irq(i32, i8*) noredzone

declare i32 @__pm_runtime_idle(%struct.device*, i32) noredzone

define internal i32 @igb_request_msix(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i = alloca i32, align 4
  %err = alloca i32, align 4
  %vector = alloca i32, align 4
  %free_vector = alloca i32, align 4
  %q_vector = alloca %struct.igb_q_vector*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %err, align 4
  store i32 0, i32* %vector, align 4
  store i32 0, i32* %free_vector, align 4
  %3 = load i32* %vector, align 4
  %idxprom = sext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 5
  %arrayidx = getelementptr [10 x %struct.msix_entry]* %msix_entries, i32 0, i64 %idxprom
  %vector3 = getelementptr inbounds %struct.msix_entry* %arrayidx, i32 0, i32 0
  %5 = load i32* %vector3, align 4
  %6 = load %struct.net_device** %netdev, align 8
  %name = getelementptr inbounds %struct.net_device* %6, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8]* %name, i32 0, i32 0
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %8 = bitcast %struct.igb_adapter* %7 to i8*
  %call = call i32 @request_irq(i32 %5, i32 (i32, i8*)* @igb_msix_other, i64 0, i8* %arraydecay, i8* %8) noredzone
  store i32 %call, i32* %err, align 4
  %9 = load i32* %err, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %err_out

if.end:                                           ; preds = %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32* %i, align 4
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 4
  %12 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %10, %12
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %13 = load i32* %i, align 4
  %idxprom4 = sext i32 %13 to i64
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector5 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 44
  %arrayidx6 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector5, i32 0, i64 %idxprom4
  %15 = load %struct.igb_q_vector** %arrayidx6, align 8
  store %struct.igb_q_vector* %15, %struct.igb_q_vector** %q_vector, align 8
  %16 = load i32* %vector, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %vector, align 4
  %17 = load %struct.e1000_hw** %hw, align 8
  %hw_addr = getelementptr inbounds %struct.e1000_hw* %17, i32 0, i32 1
  %18 = load i8** %hw_addr, align 8
  %19 = load i32* %vector, align 4
  %mul = mul i32 4, %19
  %add = add i32 5760, %mul
  %idx.ext = sext i32 %add to i64
  %add.ptr = getelementptr i8* %18, i64 %idx.ext
  %20 = load %struct.igb_q_vector** %q_vector, align 8
  %itr_register = getelementptr inbounds %struct.igb_q_vector* %20, i32 0, i32 5
  store i8* %add.ptr, i8** %itr_register, align 8
  %21 = load %struct.igb_q_vector** %q_vector, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %21, i32 0, i32 6
  %ring = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %22 = load %struct.igb_ring** %ring, align 8
  %tobool7 = icmp ne %struct.igb_ring* %22, null
  br i1 %tobool7, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body
  %23 = load %struct.igb_q_vector** %q_vector, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %23, i32 0, i32 7
  %ring8 = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 0
  %24 = load %struct.igb_ring** %ring8, align 8
  %tobool9 = icmp ne %struct.igb_ring* %24, null
  br i1 %tobool9, label %if.then10, label %if.else

if.then10:                                        ; preds = %land.lhs.true
  %25 = load %struct.igb_q_vector** %q_vector, align 8
  %name11 = getelementptr inbounds %struct.igb_q_vector* %25, i32 0, i32 10
  %arraydecay12 = getelementptr inbounds [25 x i8]* %name11, i32 0, i32 0
  %26 = load %struct.net_device** %netdev, align 8
  %name13 = getelementptr inbounds %struct.net_device* %26, i32 0, i32 0
  %arraydecay14 = getelementptr inbounds [16 x i8]* %name13, i32 0, i32 0
  %27 = load %struct.igb_q_vector** %q_vector, align 8
  %rx15 = getelementptr inbounds %struct.igb_q_vector* %27, i32 0, i32 6
  %ring16 = getelementptr inbounds %struct.igb_ring_container* %rx15, i32 0, i32 0
  %28 = load %struct.igb_ring** %ring16, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %28, i32 0, i32 10
  %29 = load i8* %queue_index, align 1
  %conv = zext i8 %29 to i32
  %call17 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay12, i8* getelementptr inbounds ([11 x i8]* @.str13, i32 0, i32 0), i8* %arraydecay14, i32 %conv) noredzone
  br label %if.end53

if.else:                                          ; preds = %land.lhs.true, %for.body
  %30 = load %struct.igb_q_vector** %q_vector, align 8
  %tx18 = getelementptr inbounds %struct.igb_q_vector* %30, i32 0, i32 7
  %ring19 = getelementptr inbounds %struct.igb_ring_container* %tx18, i32 0, i32 0
  %31 = load %struct.igb_ring** %ring19, align 8
  %tobool20 = icmp ne %struct.igb_ring* %31, null
  br i1 %tobool20, label %if.then21, label %if.else31

if.then21:                                        ; preds = %if.else
  %32 = load %struct.igb_q_vector** %q_vector, align 8
  %name22 = getelementptr inbounds %struct.igb_q_vector* %32, i32 0, i32 10
  %arraydecay23 = getelementptr inbounds [25 x i8]* %name22, i32 0, i32 0
  %33 = load %struct.net_device** %netdev, align 8
  %name24 = getelementptr inbounds %struct.net_device* %33, i32 0, i32 0
  %arraydecay25 = getelementptr inbounds [16 x i8]* %name24, i32 0, i32 0
  %34 = load %struct.igb_q_vector** %q_vector, align 8
  %tx26 = getelementptr inbounds %struct.igb_q_vector* %34, i32 0, i32 7
  %ring27 = getelementptr inbounds %struct.igb_ring_container* %tx26, i32 0, i32 0
  %35 = load %struct.igb_ring** %ring27, align 8
  %queue_index28 = getelementptr inbounds %struct.igb_ring* %35, i32 0, i32 10
  %36 = load i8* %queue_index28, align 1
  %conv29 = zext i8 %36 to i32
  %call30 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay23, i8* getelementptr inbounds ([9 x i8]* @.str14, i32 0, i32 0), i8* %arraydecay25, i32 %conv29) noredzone
  br label %if.end52

if.else31:                                        ; preds = %if.else
  %37 = load %struct.igb_q_vector** %q_vector, align 8
  %rx32 = getelementptr inbounds %struct.igb_q_vector* %37, i32 0, i32 6
  %ring33 = getelementptr inbounds %struct.igb_ring_container* %rx32, i32 0, i32 0
  %38 = load %struct.igb_ring** %ring33, align 8
  %tobool34 = icmp ne %struct.igb_ring* %38, null
  br i1 %tobool34, label %if.then35, label %if.else45

if.then35:                                        ; preds = %if.else31
  %39 = load %struct.igb_q_vector** %q_vector, align 8
  %name36 = getelementptr inbounds %struct.igb_q_vector* %39, i32 0, i32 10
  %arraydecay37 = getelementptr inbounds [25 x i8]* %name36, i32 0, i32 0
  %40 = load %struct.net_device** %netdev, align 8
  %name38 = getelementptr inbounds %struct.net_device* %40, i32 0, i32 0
  %arraydecay39 = getelementptr inbounds [16 x i8]* %name38, i32 0, i32 0
  %41 = load %struct.igb_q_vector** %q_vector, align 8
  %rx40 = getelementptr inbounds %struct.igb_q_vector* %41, i32 0, i32 6
  %ring41 = getelementptr inbounds %struct.igb_ring_container* %rx40, i32 0, i32 0
  %42 = load %struct.igb_ring** %ring41, align 8
  %queue_index42 = getelementptr inbounds %struct.igb_ring* %42, i32 0, i32 10
  %43 = load i8* %queue_index42, align 1
  %conv43 = zext i8 %43 to i32
  %call44 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay37, i8* getelementptr inbounds ([9 x i8]* @.str15, i32 0, i32 0), i8* %arraydecay39, i32 %conv43) noredzone
  br label %if.end51

if.else45:                                        ; preds = %if.else31
  %44 = load %struct.igb_q_vector** %q_vector, align 8
  %name46 = getelementptr inbounds %struct.igb_q_vector* %44, i32 0, i32 10
  %arraydecay47 = getelementptr inbounds [25 x i8]* %name46, i32 0, i32 0
  %45 = load %struct.net_device** %netdev, align 8
  %name48 = getelementptr inbounds %struct.net_device* %45, i32 0, i32 0
  %arraydecay49 = getelementptr inbounds [16 x i8]* %name48, i32 0, i32 0
  %call50 = call i32 (i8*, i8*, ...)* @sprintf(i8* %arraydecay47, i8* getelementptr inbounds ([10 x i8]* @.str16, i32 0, i32 0), i8* %arraydecay49) noredzone
  br label %if.end51

if.end51:                                         ; preds = %if.else45, %if.then35
  br label %if.end52

if.end52:                                         ; preds = %if.end51, %if.then21
  br label %if.end53

if.end53:                                         ; preds = %if.end52, %if.then10
  %46 = load i32* %vector, align 4
  %idxprom54 = sext i32 %46 to i64
  %47 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries55 = getelementptr inbounds %struct.igb_adapter* %47, i32 0, i32 5
  %arrayidx56 = getelementptr [10 x %struct.msix_entry]* %msix_entries55, i32 0, i64 %idxprom54
  %vector57 = getelementptr inbounds %struct.msix_entry* %arrayidx56, i32 0, i32 0
  %48 = load i32* %vector57, align 4
  %49 = load %struct.igb_q_vector** %q_vector, align 8
  %name58 = getelementptr inbounds %struct.igb_q_vector* %49, i32 0, i32 10
  %arraydecay59 = getelementptr inbounds [25 x i8]* %name58, i32 0, i32 0
  %50 = load %struct.igb_q_vector** %q_vector, align 8
  %51 = bitcast %struct.igb_q_vector* %50 to i8*
  %call60 = call i32 @request_irq(i32 %48, i32 (i32, i8*)* @igb_msix_ring, i64 0, i8* %arraydecay59, i8* %51) noredzone
  store i32 %call60, i32* %err, align 4
  %52 = load i32* %err, align 4
  %tobool61 = icmp ne i32 %52, 0
  br i1 %tobool61, label %if.then62, label %if.end63

if.then62:                                        ; preds = %if.end53
  br label %err_free

if.end63:                                         ; preds = %if.end53
  br label %for.inc

for.inc:                                          ; preds = %if.end63
  %53 = load i32* %i, align 4
  %inc64 = add i32 %53, 1
  store i32 %inc64, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %54 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_configure_msix(%struct.igb_adapter* %54) noredzone
  store i32 0, i32* %retval
  br label %return

err_free:                                         ; preds = %if.then62
  %55 = load i32* %free_vector, align 4
  %inc65 = add i32 %55, 1
  store i32 %inc65, i32* %free_vector, align 4
  %idxprom66 = sext i32 %55 to i64
  %56 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries67 = getelementptr inbounds %struct.igb_adapter* %56, i32 0, i32 5
  %arrayidx68 = getelementptr [10 x %struct.msix_entry]* %msix_entries67, i32 0, i64 %idxprom66
  %vector69 = getelementptr inbounds %struct.msix_entry* %arrayidx68, i32 0, i32 0
  %57 = load i32* %vector69, align 4
  %58 = load %struct.igb_adapter** %adapter.addr, align 8
  %59 = bitcast %struct.igb_adapter* %58 to i8*
  call void @free_irq(i32 %57, i8* %59) noredzone
  %60 = load i32* %vector, align 4
  %dec = add i32 %60, -1
  store i32 %dec, i32* %vector, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc82, %err_free
  %61 = load i32* %i, align 4
  %62 = load i32* %vector, align 4
  %cmp71 = icmp slt i32 %61, %62
  br i1 %cmp71, label %for.body73, label %for.end84

for.body73:                                       ; preds = %for.cond70
  %63 = load i32* %free_vector, align 4
  %inc74 = add i32 %63, 1
  store i32 %inc74, i32* %free_vector, align 4
  %idxprom75 = sext i32 %63 to i64
  %64 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries76 = getelementptr inbounds %struct.igb_adapter* %64, i32 0, i32 5
  %arrayidx77 = getelementptr [10 x %struct.msix_entry]* %msix_entries76, i32 0, i64 %idxprom75
  %vector78 = getelementptr inbounds %struct.msix_entry* %arrayidx77, i32 0, i32 0
  %65 = load i32* %vector78, align 4
  %66 = load i32* %i, align 4
  %idxprom79 = sext i32 %66 to i64
  %67 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector80 = getelementptr inbounds %struct.igb_adapter* %67, i32 0, i32 44
  %arrayidx81 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector80, i32 0, i64 %idxprom79
  %68 = load %struct.igb_q_vector** %arrayidx81, align 8
  %69 = bitcast %struct.igb_q_vector* %68 to i8*
  call void @free_irq(i32 %65, i8* %69) noredzone
  br label %for.inc82

for.inc82:                                        ; preds = %for.body73
  %70 = load i32* %i, align 4
  %inc83 = add i32 %70, 1
  store i32 %inc83, i32* %i, align 4
  br label %for.cond70

for.end84:                                        ; preds = %for.cond70
  br label %err_out

err_out:                                          ; preds = %for.end84, %if.then
  %71 = load i32* %err, align 4
  store i32 %71, i32* %retval
  br label %return

return:                                           ; preds = %err_out, %for.end
  %72 = load i32* %retval
  ret i32 %72
}

define internal void @igb_clear_interrupt_scheme(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_free_q_vectors(%struct.igb_adapter* %0) noredzone
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_reset_interrupt_capability(%struct.igb_adapter* %1) noredzone
  ret void
}

define internal i32 @request_irq(i32 %irq, i32 (i32, i8*)* %handler, i64 %flags, i8* %name, i8* %dev) nounwind inlinehint noredzone {
entry:
  %irq.addr = alloca i32, align 4
  %handler.addr = alloca i32 (i32, i8*)*, align 8
  %flags.addr = alloca i64, align 8
  %name.addr = alloca i8*, align 8
  %dev.addr = alloca i8*, align 8
  store i32 %irq, i32* %irq.addr, align 4
  store i32 (i32, i8*)* %handler, i32 (i32, i8*)** %handler.addr, align 8
  store i64 %flags, i64* %flags.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store i8* %dev, i8** %dev.addr, align 8
  %0 = load i32* %irq.addr, align 4
  %1 = load i32 (i32, i8*)** %handler.addr, align 8
  %2 = load i64* %flags.addr, align 8
  %3 = load i8** %name.addr, align 8
  %4 = load i8** %dev.addr, align 8
  %call = call i32 @request_threaded_irq(i32 %0, i32 (i32, i8*)* %1, i32 (i32, i8*)* null, i64 %2, i8* %3, i8* %4) noredzone
  ret i32 %call
}

define internal i32 @igb_intr_msi(i32 %irq, i8* %data) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %irq.addr = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %q_vector = alloca %struct.igb_q_vector*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %icr = alloca i32, align 4
  %tsicr = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store i32 %irq, i32* %irq.addr, align 4
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %q_vector1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector1, i32 0, i64 0
  %3 = load %struct.igb_q_vector** %arrayidx, align 8
  store %struct.igb_q_vector* %3, %struct.igb_q_vector** %q_vector, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %5 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %5, i32 192) noredzone
  store i32 %call, i32* %icr, align 4
  %6 = load %struct.igb_q_vector** %q_vector, align 8
  call void @igb_write_itr(%struct.igb_q_vector* %6) noredzone
  %7 = load i32* %icr, align 4
  %and = and i32 %7, 1073741824
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %8 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 26
  %call3 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %9 = load i32* %icr, align 4
  %and4 = and i32 %9, 268435456
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  %10 = load %struct.igb_adapter** %adapter, align 8
  %stats = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 36
  %doosync = getelementptr inbounds %struct.e1000_hw_stats* %stats, i32 0, i32 75
  %11 = load i64* %doosync, align 8
  %inc = add i64 %11, 1
  store i64 %inc, i64* %doosync, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %if.end
  %12 = load i32* %icr, align 4
  %and8 = and i32 %12, 12
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.end19

if.then10:                                        ; preds = %if.end7
  %13 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %13, i32 0, i32 4
  %get_link_status = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 20
  store i8 1, i8* %get_link_status, align 1
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then10
  %14 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %15 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %15, 63
  %shl.i = shl i64 1, %and.i
  %16 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %16, 6
  %17 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %17, i64 %shr.i
  %18 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %18
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool12 = icmp ne i32 %conv.i, 0
  br i1 %tobool12, label %if.end18, label %if.then16

cond.false:                                       ; preds = %if.then10
  %19 = load %struct.igb_adapter** %adapter, align 8
  %state13 = getelementptr inbounds %struct.igb_adapter* %19, i32 0, i32 2
  %call14 = call i32 @variable_test_bit(i64 2, i64* %state13) noredzone
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.end18, label %if.then16

if.then16:                                        ; preds = %cond.false, %cond.true
  %20 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 18
  %21 = load volatile i64* @jiffies, align 8
  %add = add i64 %21, 1
  %call17 = call i32 @mod_timer(%struct.timer_list* %watchdog_timer, i64 %add) noredzone
  br label %if.end18

if.end18:                                         ; preds = %if.then16, %cond.false, %cond.true
  br label %if.end19

if.end19:                                         ; preds = %if.end18, %if.end7
  %22 = load i32* %icr, align 4
  %and20 = and i32 %22, 524288
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.then22, label %if.end37

if.then22:                                        ; preds = %if.end19
  %23 = load %struct.e1000_hw** %hw, align 8
  %call23 = call i32 @igb_rd32(%struct.e1000_hw* %23, i32 46700) noredzone
  store i32 %call23, i32* %tsicr, align 4
  %24 = load i32* %tsicr, align 4
  %and24 = and i32 %24, 2
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end36

if.then26:                                        ; preds = %if.then22
  br label %do.body

do.body:                                          ; preds = %if.then26
  %25 = load %struct.e1000_hw** %hw, align 8
  %hw_addr27 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 1
  %26 = load volatile i8** %hw_addr27, align 8
  store i8* %26, i8** %hw_addr, align 8
  %27 = load i8** %hw_addr, align 8
  %tobool28 = icmp ne i8* %27, null
  %lnot = xor i1 %tobool28, true
  %lnot29 = xor i1 %lnot, true
  %lnot30 = xor i1 %lnot29, true
  %lnot.ext = zext i1 %lnot30 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool31 = icmp ne i64 %expval, 0
  br i1 %tobool31, label %if.end34, label %if.then32

if.then32:                                        ; preds = %do.body
  %28 = load i8** %hw_addr, align 8
  %arrayidx33 = getelementptr i8* %28, i64 46700
  call void @writel(i32 2, i8* %arrayidx33) noredzone
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end34
  %29 = load %struct.igb_adapter** %adapter, align 8
  %ptp_tx_work = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 58
  %call35 = call zeroext i1 @schedule_work(%struct.work_struct* %ptp_tx_work) noredzone
  br label %if.end36

if.end36:                                         ; preds = %do.end, %if.then22
  br label %if.end37

if.end37:                                         ; preds = %if.end36, %if.end19
  %30 = load %struct.igb_q_vector** %q_vector, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %30, i32 0, i32 8
  call void @napi_schedule(%struct.napi_struct* %napi) noredzone
  ret i32 1
}

define internal i32 @igb_intr(i32 %irq, i8* %data) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %irq.addr = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %q_vector = alloca %struct.igb_q_vector*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %icr = alloca i32, align 4
  %tsicr = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store i32 %irq, i32* %irq.addr, align 4
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %q_vector1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector1, i32 0, i64 0
  %3 = load %struct.igb_q_vector** %arrayidx, align 8
  store %struct.igb_q_vector* %3, %struct.igb_q_vector** %q_vector, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %5 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %5, i32 192) noredzone
  store i32 %call, i32* %icr, align 4
  %6 = load i32* %icr, align 4
  %and = and i32 %6, -2147483648
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.igb_q_vector** %q_vector, align 8
  call void @igb_write_itr(%struct.igb_q_vector* %7) noredzone
  %8 = load i32* %icr, align 4
  %and3 = and i32 %8, 1073741824
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end7

if.then5:                                         ; preds = %if.end
  %9 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 26
  %call6 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task) noredzone
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %10 = load i32* %icr, align 4
  %and8 = and i32 %10, 268435456
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %11 = load %struct.igb_adapter** %adapter, align 8
  %stats = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 36
  %doosync = getelementptr inbounds %struct.e1000_hw_stats* %stats, i32 0, i32 75
  %12 = load i64* %doosync, align 8
  %inc = add i64 %12, 1
  store i64 %inc, i64* %doosync, align 8
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end7
  %13 = load i32* %icr, align 4
  %and12 = and i32 %13, 12
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end23

if.then14:                                        ; preds = %if.end11
  %14 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 4
  %get_link_status = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 20
  store i8 1, i8* %get_link_status, align 1
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then14
  %15 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %16 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %16, 63
  %shl.i = shl i64 1, %and.i
  %17 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %17, 6
  %18 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %18, i64 %shr.i
  %19 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %19
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool16 = icmp ne i32 %conv.i, 0
  br i1 %tobool16, label %if.end22, label %if.then20

cond.false:                                       ; preds = %if.then14
  %20 = load %struct.igb_adapter** %adapter, align 8
  %state17 = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 2
  %call18 = call i32 @variable_test_bit(i64 2, i64* %state17) noredzone
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.end22, label %if.then20

if.then20:                                        ; preds = %cond.false, %cond.true
  %21 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 18
  %22 = load volatile i64* @jiffies, align 8
  %add = add i64 %22, 1
  %call21 = call i32 @mod_timer(%struct.timer_list* %watchdog_timer, i64 %add) noredzone
  br label %if.end22

if.end22:                                         ; preds = %if.then20, %cond.false, %cond.true
  br label %if.end23

if.end23:                                         ; preds = %if.end22, %if.end11
  %23 = load i32* %icr, align 4
  %and24 = and i32 %23, 524288
  %tobool25 = icmp ne i32 %and24, 0
  br i1 %tobool25, label %if.then26, label %if.end41

if.then26:                                        ; preds = %if.end23
  %24 = load %struct.e1000_hw** %hw, align 8
  %call27 = call i32 @igb_rd32(%struct.e1000_hw* %24, i32 46700) noredzone
  store i32 %call27, i32* %tsicr, align 4
  %25 = load i32* %tsicr, align 4
  %and28 = and i32 %25, 2
  %tobool29 = icmp ne i32 %and28, 0
  br i1 %tobool29, label %if.then30, label %if.end40

if.then30:                                        ; preds = %if.then26
  br label %do.body

do.body:                                          ; preds = %if.then30
  %26 = load %struct.e1000_hw** %hw, align 8
  %hw_addr31 = getelementptr inbounds %struct.e1000_hw* %26, i32 0, i32 1
  %27 = load volatile i8** %hw_addr31, align 8
  store i8* %27, i8** %hw_addr, align 8
  %28 = load i8** %hw_addr, align 8
  %tobool32 = icmp ne i8* %28, null
  %lnot = xor i1 %tobool32, true
  %lnot33 = xor i1 %lnot, true
  %lnot34 = xor i1 %lnot33, true
  %lnot.ext = zext i1 %lnot34 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool35 = icmp ne i64 %expval, 0
  br i1 %tobool35, label %if.end38, label %if.then36

if.then36:                                        ; preds = %do.body
  %29 = load i8** %hw_addr, align 8
  %arrayidx37 = getelementptr i8* %29, i64 46700
  call void @writel(i32 2, i8* %arrayidx37) noredzone
  br label %if.end38

if.end38:                                         ; preds = %if.then36, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end38
  %30 = load %struct.igb_adapter** %adapter, align 8
  %ptp_tx_work = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 58
  %call39 = call zeroext i1 @schedule_work(%struct.work_struct* %ptp_tx_work) noredzone
  br label %if.end40

if.end40:                                         ; preds = %do.end, %if.then26
  br label %if.end41

if.end41:                                         ; preds = %if.end40, %if.end23
  %31 = load %struct.igb_q_vector** %q_vector, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %31, i32 0, i32 8
  call void @napi_schedule(%struct.napi_struct* %napi) noredzone
  store i32 1, i32* %retval
  br label %return

return:                                           ; preds = %if.end41, %if.then
  %32 = load i32* %retval
  ret i32 %32
}

define internal void @igb_write_itr(%struct.igb_q_vector* %q_vector) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %itr_val = alloca i32, align 4
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 0
  %1 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val2 = getelementptr inbounds %struct.igb_q_vector* %2, i32 0, i32 3
  %3 = load i16* %itr_val2, align 2
  %conv = zext i16 %3 to i32
  %and = and i32 %conv, 32764
  store i32 %and, i32* %itr_val, align 4
  %4 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %set_itr = getelementptr inbounds %struct.igb_q_vector* %4, i32 0, i32 4
  %5 = load i8* %set_itr, align 1
  %tobool = icmp ne i8 %5, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %6 = load i32* %itr_val, align 4
  %tobool3 = icmp ne i32 %6, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 4, i32* %itr_val, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.then4, %if.end
  %7 = load %struct.igb_adapter** %adapter, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %8 = load i32* %type, align 4
  %cmp = icmp eq i32 %8, 1
  br i1 %cmp, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end5
  %9 = load i32* %itr_val, align 4
  %shl = shl i32 %9, 16
  %10 = load i32* %itr_val, align 4
  %or = or i32 %10, %shl
  store i32 %or, i32* %itr_val, align 4
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %11 = load i32* %itr_val, align 4
  %or8 = or i32 %11, -2147483648
  store i32 %or8, i32* %itr_val, align 4
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then7
  %12 = load i32* %itr_val, align 4
  %13 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_register = getelementptr inbounds %struct.igb_q_vector* %13, i32 0, i32 5
  %14 = load i8** %itr_register, align 8
  call void @writel(i32 %12, i8* %14) noredzone
  %15 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %set_itr10 = getelementptr inbounds %struct.igb_q_vector* %15, i32 0, i32 4
  store i8 0, i8* %set_itr10, align 1
  br label %return

return:                                           ; preds = %if.end9, %if.then
  ret void
}

declare i32 @mod_timer(%struct.timer_list*, i64) noredzone

define internal void @napi_schedule(%struct.napi_struct* %n) nounwind inlinehint noredzone {
entry:
  %n.addr = alloca %struct.napi_struct*, align 8
  store %struct.napi_struct* %n, %struct.napi_struct** %n.addr, align 8
  %0 = load %struct.napi_struct** %n.addr, align 8
  %call = call zeroext i1 @napi_schedule_prep(%struct.napi_struct* %0) noredzone
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.napi_struct** %n.addr, align 8
  call void @__napi_schedule(%struct.napi_struct* %1) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define internal zeroext i1 @napi_schedule_prep(%struct.napi_struct* %n) nounwind inlinehint noredzone {
entry:
  %n.addr = alloca %struct.napi_struct*, align 8
  store %struct.napi_struct* %n, %struct.napi_struct** %n.addr, align 8
  %0 = load %struct.napi_struct** %n.addr, align 8
  %call = call zeroext i1 @napi_disable_pending(%struct.napi_struct* %0) noredzone
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = load %struct.napi_struct** %n.addr, align 8
  %state = getelementptr inbounds %struct.napi_struct* %1, i32 0, i32 1
  %call1 = call i32 @test_and_set_bit(i64 0, i64* %state) noredzone
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %2
}

declare void @__napi_schedule(%struct.napi_struct*) noredzone

define internal zeroext i1 @napi_disable_pending(%struct.napi_struct* %n) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %n.addr = alloca %struct.napi_struct*, align 8
  store %struct.napi_struct* %n, %struct.napi_struct** %n.addr, align 8
  %0 = load %struct.napi_struct** %n.addr, align 8
  %state = getelementptr inbounds %struct.napi_struct* %0, i32 0, i32 1
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  ret i1 %tobool
}

declare i32 @request_threaded_irq(i32, i32 (i32, i8*)*, i32 (i32, i8*)*, i64, i8*, i8*) noredzone

define internal void @igb_free_q_vectors(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %v_idx = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 4
  %1 = load i32* %num_q_vectors, align 4
  store i32 %1, i32* %v_idx, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 12
  store i32 0, i32* %num_tx_queues, align 4
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 14
  store i32 0, i32* %num_rx_queues, align 4
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors1 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 4
  store i32 0, i32* %num_q_vectors1, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %5 = load i32* %v_idx, align 4
  %dec = add i32 %5, -1
  store i32 %dec, i32* %v_idx, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %7 = load i32* %v_idx, align 4
  call void @igb_reset_q_vector(%struct.igb_adapter* %6, i32 %7) noredzone
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %9 = load i32* %v_idx, align 4
  call void @igb_free_q_vector(%struct.igb_adapter* %8, i32 %9) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

define internal void @igb_reset_q_vector(%struct.igb_adapter* %adapter, i32 %v_idx) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %v_idx.addr = alloca i32, align 4
  %q_vector = alloca %struct.igb_q_vector*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %v_idx, i32* %v_idx.addr, align 4
  %0 = load i32* %v_idx.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector1 = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector1, i32 0, i64 %idxprom
  %2 = load %struct.igb_q_vector** %arrayidx, align 8
  store %struct.igb_q_vector* %2, %struct.igb_q_vector** %q_vector, align 8
  %3 = load %struct.igb_q_vector** %q_vector, align 8
  %tobool = icmp ne %struct.igb_q_vector* %3, null
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.igb_q_vector** %q_vector, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %4, i32 0, i32 7
  %ring = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 0
  %5 = load %struct.igb_ring** %ring, align 8
  %tobool2 = icmp ne %struct.igb_ring* %5, null
  br i1 %tobool2, label %if.then3, label %if.end8

if.then3:                                         ; preds = %if.end
  %6 = load %struct.igb_q_vector** %q_vector, align 8
  %tx4 = getelementptr inbounds %struct.igb_q_vector* %6, i32 0, i32 7
  %ring5 = getelementptr inbounds %struct.igb_ring_container* %tx4, i32 0, i32 0
  %7 = load %struct.igb_ring** %ring5, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %7, i32 0, i32 10
  %8 = load i8* %queue_index, align 1
  %idxprom6 = zext i8 %8 to i64
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 13
  %arrayidx7 = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom6
  store %struct.igb_ring* null, %struct.igb_ring** %arrayidx7, align 8
  br label %if.end8

if.end8:                                          ; preds = %if.then3, %if.end
  %10 = load %struct.igb_q_vector** %q_vector, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %10, i32 0, i32 6
  %ring9 = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %11 = load %struct.igb_ring** %ring9, align 8
  %tobool10 = icmp ne %struct.igb_ring* %11, null
  br i1 %tobool10, label %if.then11, label %if.end18

if.then11:                                        ; preds = %if.end8
  %12 = load %struct.igb_q_vector** %q_vector, align 8
  %rx12 = getelementptr inbounds %struct.igb_q_vector* %12, i32 0, i32 6
  %ring13 = getelementptr inbounds %struct.igb_ring_container* %rx12, i32 0, i32 0
  %13 = load %struct.igb_ring** %ring13, align 8
  %queue_index14 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 10
  %14 = load i8* %queue_index14, align 1
  %idxprom15 = zext i8 %14 to i64
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring16 = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 13
  %arrayidx17 = getelementptr [16 x %struct.igb_ring*]* %tx_ring16, i32 0, i64 %idxprom15
  store %struct.igb_ring* null, %struct.igb_ring** %arrayidx17, align 8
  br label %if.end18

if.end18:                                         ; preds = %if.then11, %if.end8
  %16 = load %struct.igb_q_vector** %q_vector, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %16, i32 0, i32 8
  call void @netif_napi_del(%struct.napi_struct* %napi) noredzone
  br label %return

return:                                           ; preds = %if.end18, %if.then
  ret void
}

define internal void @igb_free_q_vector(%struct.igb_adapter* %adapter, i32 %v_idx) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %v_idx.addr = alloca i32, align 4
  %q_vector = alloca %struct.igb_q_vector*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %v_idx, i32* %v_idx.addr, align 4
  %0 = load i32* %v_idx.addr, align 4
  %idxprom = sext i32 %0 to i64
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector1 = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector1, i32 0, i64 %idxprom
  %2 = load %struct.igb_q_vector** %arrayidx, align 8
  store %struct.igb_q_vector* %2, %struct.igb_q_vector** %q_vector, align 8
  %3 = load i32* %v_idx.addr, align 4
  %idxprom2 = sext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector3 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 44
  %arrayidx4 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector3, i32 0, i64 %idxprom2
  store %struct.igb_q_vector* null, %struct.igb_q_vector** %arrayidx4, align 8
  %5 = load %struct.igb_q_vector** %q_vector, align 8
  %6 = bitcast %struct.igb_q_vector* %5 to i8*
  call void @kfree(i8* %6) noredzone
  ret void
}

declare void @kfree(i8*) noredzone

declare void @netif_napi_del(%struct.napi_struct*) noredzone

define internal i32 @igb_msix_other(i32 %irq, i8* %data) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %irq.addr = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %icr = alloca i32, align 4
  %tsicr = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr41 = alloca i8*, align 8
  store i32 %irq, i32* %irq.addr, align 4
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 192) noredzone
  store i32 %call, i32* %icr, align 4
  %4 = load i32* %icr, align 4
  %and = and i32 %4, 1073741824
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 26
  %call2 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32* %icr, align 4
  %and3 = and i32 %6, 268435456
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %7 = load %struct.igb_adapter** %adapter, align 8
  %stats = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 36
  %doosync = getelementptr inbounds %struct.e1000_hw_stats* %stats, i32 0, i32 75
  %8 = load i64* %doosync, align 8
  %inc = add i64 %8, 1
  store i64 %inc, i64* %doosync, align 8
  %9 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_check_wvbr(%struct.igb_adapter* %9) noredzone
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %10 = load i32* %icr, align 4
  %and7 = and i32 %10, 256
  %tobool8 = icmp ne i32 %and7, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.end6
  %11 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_msg_task(%struct.igb_adapter* %11) noredzone
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %if.end6
  %12 = load i32* %icr, align 4
  %and11 = and i32 %12, 4
  %tobool12 = icmp ne i32 %and11, 0
  br i1 %tobool12, label %if.then13, label %if.end22

if.then13:                                        ; preds = %if.end10
  %13 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %13, i32 0, i32 4
  %get_link_status = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 20
  store i8 1, i8* %get_link_status, align 1
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then13
  %14 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %15 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %15, 63
  %shl.i = shl i64 1, %and.i
  %16 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %16, 6
  %17 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %17, i64 %shr.i
  %18 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %18
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool15 = icmp ne i32 %conv.i, 0
  br i1 %tobool15, label %if.end21, label %if.then19

cond.false:                                       ; preds = %if.then13
  %19 = load %struct.igb_adapter** %adapter, align 8
  %state16 = getelementptr inbounds %struct.igb_adapter* %19, i32 0, i32 2
  %call17 = call i32 @variable_test_bit(i64 2, i64* %state16) noredzone
  %tobool18 = icmp ne i32 %call17, 0
  br i1 %tobool18, label %if.end21, label %if.then19

if.then19:                                        ; preds = %cond.false, %cond.true
  %20 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 18
  %21 = load volatile i64* @jiffies, align 8
  %add = add i64 %21, 1
  %call20 = call i32 @mod_timer(%struct.timer_list* %watchdog_timer, i64 %add) noredzone
  br label %if.end21

if.end21:                                         ; preds = %if.then19, %cond.false, %cond.true
  br label %if.end22

if.end22:                                         ; preds = %if.end21, %if.end10
  %22 = load i32* %icr, align 4
  %and23 = and i32 %22, 524288
  %tobool24 = icmp ne i32 %and23, 0
  br i1 %tobool24, label %if.then25, label %if.end39

if.then25:                                        ; preds = %if.end22
  %23 = load %struct.e1000_hw** %hw, align 8
  %call26 = call i32 @igb_rd32(%struct.e1000_hw* %23, i32 46700) noredzone
  store i32 %call26, i32* %tsicr, align 4
  %24 = load i32* %tsicr, align 4
  %and27 = and i32 %24, 2
  %tobool28 = icmp ne i32 %and27, 0
  br i1 %tobool28, label %if.then29, label %if.end38

if.then29:                                        ; preds = %if.then25
  br label %do.body

do.body:                                          ; preds = %if.then29
  %25 = load %struct.e1000_hw** %hw, align 8
  %hw_addr30 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 1
  %26 = load volatile i8** %hw_addr30, align 8
  store i8* %26, i8** %hw_addr, align 8
  %27 = load i8** %hw_addr, align 8
  %tobool31 = icmp ne i8* %27, null
  %lnot = xor i1 %tobool31, true
  %lnot32 = xor i1 %lnot, true
  %lnot33 = xor i1 %lnot32, true
  %lnot.ext = zext i1 %lnot33 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool34 = icmp ne i64 %expval, 0
  br i1 %tobool34, label %if.end36, label %if.then35

if.then35:                                        ; preds = %do.body
  %28 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %28, i64 46700
  call void @writel(i32 2, i8* %arrayidx) noredzone
  br label %if.end36

if.end36:                                         ; preds = %if.then35, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end36
  %29 = load %struct.igb_adapter** %adapter, align 8
  %ptp_tx_work = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 58
  %call37 = call zeroext i1 @schedule_work(%struct.work_struct* %ptp_tx_work) noredzone
  br label %if.end38

if.end38:                                         ; preds = %do.end, %if.then25
  br label %if.end39

if.end39:                                         ; preds = %if.end38, %if.end22
  br label %do.body40

do.body40:                                        ; preds = %if.end39
  %30 = load %struct.e1000_hw** %hw, align 8
  %hw_addr42 = getelementptr inbounds %struct.e1000_hw* %30, i32 0, i32 1
  %31 = load volatile i8** %hw_addr42, align 8
  store i8* %31, i8** %hw_addr41, align 8
  %32 = load i8** %hw_addr41, align 8
  %tobool43 = icmp ne i8* %32, null
  %lnot44 = xor i1 %tobool43, true
  %lnot46 = xor i1 %lnot44, true
  %lnot48 = xor i1 %lnot46, true
  %lnot.ext49 = zext i1 %lnot48 to i32
  %conv50 = sext i32 %lnot.ext49 to i64
  %expval51 = call i64 @llvm.expect.i64(i64 %conv50, i64 0)
  %tobool52 = icmp ne i64 %expval51, 0
  br i1 %tobool52, label %if.end55, label %if.then53

if.then53:                                        ; preds = %do.body40
  %33 = load %struct.igb_adapter** %adapter, align 8
  %eims_other = getelementptr inbounds %struct.igb_adapter* %33, i32 0, i32 46
  %34 = load i32* %eims_other, align 4
  %35 = load i8** %hw_addr41, align 8
  %arrayidx54 = getelementptr i8* %35, i64 5412
  call void @writel(i32 %34, i8* %arrayidx54) noredzone
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %do.body40
  br label %do.end56

do.end56:                                         ; preds = %if.end55
  ret i32 1
}

declare i32 @sprintf(i8*, i8*, ...) noredzone

define internal i32 @igb_msix_ring(i32 %irq, i8* %data) nounwind noredzone {
entry:
  %irq.addr = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %q_vector = alloca %struct.igb_q_vector*, align 8
  store i32 %irq, i32* %irq.addr, align 4
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_q_vector*
  store %struct.igb_q_vector* %1, %struct.igb_q_vector** %q_vector, align 8
  %2 = load %struct.igb_q_vector** %q_vector, align 8
  call void @igb_write_itr(%struct.igb_q_vector* %2) noredzone
  %3 = load %struct.igb_q_vector** %q_vector, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %3, i32 0, i32 8
  call void @napi_schedule(%struct.napi_struct* %napi) noredzone
  ret i32 1
}

define internal void @igb_check_wvbr(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %wvbr = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %wvbr, align 4
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  switch i32 %2, label %sw.default [
    i32 2, label %sw.bb
    i32 4, label %sw.bb
  ]

sw.bb:                                            ; preds = %entry, %entry
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 13652) noredzone
  store i32 %call, i32* %wvbr, align 4
  %4 = load i32* %wvbr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %sw.bb
  br label %return

if.end:                                           ; preds = %sw.bb
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end
  %5 = load i32* %wvbr, align 4
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %wvbr2 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 53
  %7 = load i32* %wvbr2, align 4
  %or = or i32 %7, %5
  store i32 %or, i32* %wvbr2, align 4
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  ret void
}

define internal void @igb_msg_task(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %vf = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %vf, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %vf, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 49
  %3 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.e1000_hw** %hw, align 8
  %5 = load i32* %vf, align 4
  %conv = trunc i32 %5 to i16
  %call = call i32 @igb_check_for_rst(%struct.e1000_hw* %4, i16 zeroext %conv) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %for.body
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %7 = load i32* %vf, align 4
  call void @igb_vf_reset_event(%struct.igb_adapter* %6, i32 %7) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  %8 = load %struct.e1000_hw** %hw, align 8
  %9 = load i32* %vf, align 4
  %conv2 = trunc i32 %9 to i16
  %call3 = call i32 @igb_check_for_msg(%struct.e1000_hw* %8, i16 zeroext %conv2) noredzone
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %11 = load i32* %vf, align 4
  call void @igb_rcv_msg_from_vf(%struct.igb_adapter* %10, i32 %11) noredzone
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %if.end
  %12 = load %struct.e1000_hw** %hw, align 8
  %13 = load i32* %vf, align 4
  %conv7 = trunc i32 %13 to i16
  %call8 = call i32 @igb_check_for_ack(%struct.e1000_hw* %12, i16 zeroext %conv7) noredzone
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end6
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %15 = load i32* %vf, align 4
  call void @igb_rcv_ack_from_vf(%struct.igb_adapter* %14, i32 %15) noredzone
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %if.end6
  br label %for.inc

for.inc:                                          ; preds = %if.end11
  %16 = load i32* %vf, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %vf, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare i32 @igb_check_for_rst(%struct.e1000_hw*, i16 zeroext) noredzone

define internal void @igb_vf_reset_event(%struct.igb_adapter* %adapter, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %vf_mac = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %0 to i64
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 50
  %2 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %2, i64 %idxprom
  %vf_mac_addresses = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [6 x i8]* %vf_mac_addresses, i32 0, i32 0
  store i8* %arraydecay, i8** %vf_mac, align 8
  %3 = load i32* %vf.addr, align 4
  %idxprom1 = zext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 50
  %5 = load %struct.vf_data_storage** %vf_data2, align 8
  %arrayidx3 = getelementptr %struct.vf_data_storage* %5, i64 %idxprom1
  %flags = getelementptr inbounds %struct.vf_data_storage* %arrayidx3, i32 0, i32 4
  %6 = load i32* %flags, align 4
  %and = and i32 %6, 8
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %7 = load i8** %vf_mac, align 8
  call void @eth_zero_addr(i8* %7) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %9 = load i32* %vf.addr, align 4
  call void @igb_vf_reset(%struct.igb_adapter* %8, i32 %9) noredzone
  ret void
}

declare i32 @igb_check_for_msg(%struct.e1000_hw*, i16 zeroext) noredzone

define internal void @igb_rcv_msg_from_vf(%struct.igb_adapter* %adapter, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %pdev = alloca %struct.pci_dev*, align 8
  %msgbuf = alloca [16 x i32], align 16
  %hw = alloca %struct.e1000_hw*, align 8
  %vf_data = alloca %struct.vf_data_storage*, align 8
  %retval = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy6 = alloca i64, align 8
  %__dummy27 = alloca i64, align 8
  %__dummy29 = alloca i64, align 8
  %__dummy230 = alloca i64, align 8
  %__dummy34 = alloca i64, align 8
  %__dummy235 = alloca i64, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data3 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 50
  %5 = load %struct.vf_data_storage** %vf_data3, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %5, i64 %idxprom
  store %struct.vf_data_storage* %arrayidx, %struct.vf_data_storage** %vf_data, align 8
  %6 = load %struct.e1000_hw** %hw, align 8
  %arraydecay = getelementptr inbounds [16 x i32]* %msgbuf, i32 0, i32 0
  %7 = load i32* %vf.addr, align 4
  %conv = trunc i32 %7 to i16
  %call = call i32 @igb_read_mbx(%struct.e1000_hw* %6, i32* %arraydecay, i16 zeroext 16, i16 zeroext %conv) noredzone
  store i32 %call, i32* %retval, align 4
  %8 = load i32* %retval, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  %9 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %9, i32 0, i32 33
  %call4 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([33 x i8]* @.str17, i32 0, i32 0)) noredzone
  %10 = load %struct.vf_data_storage** %vf_data, align 8
  %flags = getelementptr inbounds %struct.vf_data_storage* %10, i32 0, i32 4
  %11 = load i32* %flags, align 4
  %and = and i32 %11, -2
  store i32 %and, i32* %flags, align 4
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv5 = zext i1 %cmp to i32
  br i1 true, label %land.lhs.true, label %if.then13

land.lhs.true:                                    ; preds = %if.then
  %cmp8 = icmp eq i64* %__dummy6, %__dummy27
  %conv9 = zext i1 %cmp8 to i32
  br i1 true, label %land.lhs.true10, label %if.then13

land.lhs.true10:                                  ; preds = %land.lhs.true
  %12 = load %struct.vf_data_storage** %vf_data, align 8
  %last_nack = getelementptr inbounds %struct.vf_data_storage* %12, i32 0, i32 5
  %13 = load i64* %last_nack, align 8
  %add = add i64 %13, 500
  %14 = load volatile i64* @jiffies, align 8
  %sub = sub i64 %add, %14
  %cmp11 = icmp slt i64 %sub, 0
  br i1 %cmp11, label %if.end, label %if.then13

if.then13:                                        ; preds = %land.lhs.true10, %land.lhs.true, %if.then
  br label %return

if.end:                                           ; preds = %land.lhs.true10
  br label %out

if.end14:                                         ; preds = %entry
  %arrayidx15 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %15 = load i32* %arrayidx15, align 4
  %and16 = and i32 %15, -1073741824
  %tobool17 = icmp ne i32 %and16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end14
  br label %return

if.end19:                                         ; preds = %if.end14
  %arrayidx20 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %16 = load i32* %arrayidx20, align 4
  %cmp21 = icmp eq i32 %16, 1
  br i1 %cmp21, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.end19
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %18 = load i32* %vf.addr, align 4
  call void @igb_vf_reset_msg(%struct.igb_adapter* %17, i32 %18) noredzone
  br label %return

if.end24:                                         ; preds = %if.end19
  %19 = load %struct.vf_data_storage** %vf_data, align 8
  %flags25 = getelementptr inbounds %struct.vf_data_storage* %19, i32 0, i32 4
  %20 = load i32* %flags25, align 4
  %and26 = and i32 %20, 1
  %tobool27 = icmp ne i32 %and26, 0
  br i1 %tobool27, label %if.end46, label %if.then28

if.then28:                                        ; preds = %if.end24
  %cmp31 = icmp eq i64* %__dummy29, %__dummy230
  %conv32 = zext i1 %cmp31 to i32
  br i1 true, label %land.lhs.true33, label %if.then44

land.lhs.true33:                                  ; preds = %if.then28
  %cmp36 = icmp eq i64* %__dummy34, %__dummy235
  %conv37 = zext i1 %cmp36 to i32
  br i1 true, label %land.lhs.true38, label %if.then44

land.lhs.true38:                                  ; preds = %land.lhs.true33
  %21 = load %struct.vf_data_storage** %vf_data, align 8
  %last_nack39 = getelementptr inbounds %struct.vf_data_storage* %21, i32 0, i32 5
  %22 = load i64* %last_nack39, align 8
  %add40 = add i64 %22, 500
  %23 = load volatile i64* @jiffies, align 8
  %sub41 = sub i64 %add40, %23
  %cmp42 = icmp slt i64 %sub41, 0
  br i1 %cmp42, label %if.end45, label %if.then44

if.then44:                                        ; preds = %land.lhs.true38, %land.lhs.true33, %if.then28
  br label %return

if.end45:                                         ; preds = %land.lhs.true38
  store i32 -1, i32* %retval, align 4
  br label %out

if.end46:                                         ; preds = %if.end24
  %arrayidx47 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %24 = load i32* %arrayidx47, align 4
  %and48 = and i32 %24, 65535
  switch i32 %and48, label %sw.default [
    i32 2, label %sw.bb
    i32 6, label %sw.bb58
    i32 3, label %sw.bb61
    i32 5, label %sw.bb64
    i32 4, label %sw.bb67
  ]

sw.bb:                                            ; preds = %if.end46
  store i32 -22, i32* %retval, align 4
  %25 = load %struct.vf_data_storage** %vf_data, align 8
  %flags49 = getelementptr inbounds %struct.vf_data_storage* %25, i32 0, i32 4
  %26 = load i32* %flags49, align 4
  %and50 = and i32 %26, 8
  %tobool51 = icmp ne i32 %and50, 0
  br i1 %tobool51, label %if.else, label %if.then52

if.then52:                                        ; preds = %sw.bb
  %27 = load %struct.igb_adapter** %adapter.addr, align 8
  %arraydecay53 = getelementptr inbounds [16 x i32]* %msgbuf, i32 0, i32 0
  %28 = load i32* %vf.addr, align 4
  %call54 = call i32 @igb_set_vf_mac_addr(%struct.igb_adapter* %27, i32* %arraydecay53, i32 %28) noredzone
  store i32 %call54, i32* %retval, align 4
  br label %if.end57

if.else:                                          ; preds = %sw.bb
  %29 = load %struct.pci_dev** %pdev, align 8
  %dev55 = getelementptr inbounds %struct.pci_dev* %29, i32 0, i32 33
  %30 = load i32* %vf.addr, align 4
  %call56 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev55, i8* getelementptr inbounds ([104 x i8]* @.str18, i32 0, i32 0), i32 %30) noredzone
  br label %if.end57

if.end57:                                         ; preds = %if.else, %if.then52
  br label %sw.epilog

sw.bb58:                                          ; preds = %if.end46
  %31 = load %struct.igb_adapter** %adapter.addr, align 8
  %arraydecay59 = getelementptr inbounds [16 x i32]* %msgbuf, i32 0, i32 0
  %32 = load i32* %vf.addr, align 4
  %call60 = call i32 @igb_set_vf_promisc(%struct.igb_adapter* %31, i32* %arraydecay59, i32 %32) noredzone
  store i32 %call60, i32* %retval, align 4
  br label %sw.epilog

sw.bb61:                                          ; preds = %if.end46
  %33 = load %struct.igb_adapter** %adapter.addr, align 8
  %arraydecay62 = getelementptr inbounds [16 x i32]* %msgbuf, i32 0, i32 0
  %34 = load i32* %vf.addr, align 4
  %call63 = call i32 @igb_set_vf_multicasts(%struct.igb_adapter* %33, i32* %arraydecay62, i32 %34) noredzone
  store i32 %call63, i32* %retval, align 4
  br label %sw.epilog

sw.bb64:                                          ; preds = %if.end46
  %35 = load %struct.igb_adapter** %adapter.addr, align 8
  %arrayidx65 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 1
  %36 = load i32* %arrayidx65, align 4
  %37 = load i32* %vf.addr, align 4
  %call66 = call i32 @igb_set_vf_rlpml(%struct.igb_adapter* %35, i32 %36, i32 %37) noredzone
  store i32 %call66, i32* %retval, align 4
  br label %sw.epilog

sw.bb67:                                          ; preds = %if.end46
  store i32 -1, i32* %retval, align 4
  %38 = load %struct.vf_data_storage** %vf_data, align 8
  %pf_vlan = getelementptr inbounds %struct.vf_data_storage* %38, i32 0, i32 6
  %39 = load i16* %pf_vlan, align 2
  %tobool68 = icmp ne i16 %39, 0
  br i1 %tobool68, label %if.then69, label %if.else72

if.then69:                                        ; preds = %sw.bb67
  %40 = load %struct.pci_dev** %pdev, align 8
  %dev70 = getelementptr inbounds %struct.pci_dev* %40, i32 0, i32 33
  %41 = load i32* %vf.addr, align 4
  %call71 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev70, i8* getelementptr inbounds ([101 x i8]* @.str19, i32 0, i32 0), i32 %41) noredzone
  br label %if.end75

if.else72:                                        ; preds = %sw.bb67
  %42 = load %struct.igb_adapter** %adapter.addr, align 8
  %arraydecay73 = getelementptr inbounds [16 x i32]* %msgbuf, i32 0, i32 0
  %43 = load i32* %vf.addr, align 4
  %call74 = call i32 @igb_set_vf_vlan(%struct.igb_adapter* %42, i32* %arraydecay73, i32 %43) noredzone
  store i32 %call74, i32* %retval, align 4
  br label %if.end75

if.end75:                                         ; preds = %if.else72, %if.then69
  br label %sw.epilog

sw.default:                                       ; preds = %if.end46
  %44 = load %struct.pci_dev** %pdev, align 8
  %dev76 = getelementptr inbounds %struct.pci_dev* %44, i32 0, i32 33
  %arrayidx77 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %45 = load i32* %arrayidx77, align 4
  %call78 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev76, i8* getelementptr inbounds ([20 x i8]* @.str20, i32 0, i32 0), i32 %45) noredzone
  store i32 -1, i32* %retval, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end75, %sw.bb64, %sw.bb61, %sw.bb58, %if.end57
  %arrayidx79 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %46 = load i32* %arrayidx79, align 4
  %or = or i32 %46, 536870912
  store i32 %or, i32* %arrayidx79, align 4
  br label %out

out:                                              ; preds = %sw.epilog, %if.end45, %if.end
  %47 = load i32* %retval, align 4
  %tobool80 = icmp ne i32 %47, 0
  br i1 %tobool80, label %if.then81, label %if.else84

if.then81:                                        ; preds = %out
  %arrayidx82 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %48 = load i32* %arrayidx82, align 4
  %or83 = or i32 %48, 1073741824
  store i32 %or83, i32* %arrayidx82, align 4
  br label %if.end87

if.else84:                                        ; preds = %out
  %arrayidx85 = getelementptr [16 x i32]* %msgbuf, i32 0, i64 0
  %49 = load i32* %arrayidx85, align 4
  %or86 = or i32 %49, -2147483648
  store i32 %or86, i32* %arrayidx85, align 4
  br label %if.end87

if.end87:                                         ; preds = %if.else84, %if.then81
  %50 = load %struct.e1000_hw** %hw, align 8
  %arraydecay88 = getelementptr inbounds [16 x i32]* %msgbuf, i32 0, i32 0
  %51 = load i32* %vf.addr, align 4
  %conv89 = trunc i32 %51 to i16
  %call90 = call i32 @igb_write_mbx(%struct.e1000_hw* %50, i32* %arraydecay88, i16 zeroext 1, i16 zeroext %conv89) noredzone
  br label %return

return:                                           ; preds = %if.end87, %if.then44, %if.then23, %if.then18, %if.then13
  ret void
}

declare i32 @igb_check_for_ack(%struct.e1000_hw*, i16 zeroext) noredzone

define internal void @igb_rcv_ack_from_vf(%struct.igb_adapter* %adapter, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %vf_data = alloca %struct.vf_data_storage*, align 8
  %msg = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy4 = alloca i64, align 8
  %__dummy25 = alloca i64, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %1 to i64
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 50
  %3 = load %struct.vf_data_storage** %vf_data2, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %3, i64 %idxprom
  store %struct.vf_data_storage* %arrayidx, %struct.vf_data_storage** %vf_data, align 8
  store i32 1073741824, i32* %msg, align 4
  %4 = load %struct.vf_data_storage** %vf_data, align 8
  %flags = getelementptr inbounds %struct.vf_data_storage* %4, i32 0, i32 4
  %5 = load i32* %flags, align 4
  %and = and i32 %5, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv = zext i1 %cmp to i32
  br i1 true, label %land.lhs.true3, label %if.end

land.lhs.true3:                                   ; preds = %land.lhs.true
  %cmp6 = icmp eq i64* %__dummy4, %__dummy25
  %conv7 = zext i1 %cmp6 to i32
  br i1 true, label %land.lhs.true8, label %if.end

land.lhs.true8:                                   ; preds = %land.lhs.true3
  %6 = load %struct.vf_data_storage** %vf_data, align 8
  %last_nack = getelementptr inbounds %struct.vf_data_storage* %6, i32 0, i32 5
  %7 = load i64* %last_nack, align 8
  %add = add i64 %7, 500
  %8 = load volatile i64* @jiffies, align 8
  %sub = sub i64 %add, %8
  %cmp9 = icmp slt i64 %sub, 0
  br i1 %cmp9, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true8
  %9 = load %struct.e1000_hw** %hw, align 8
  %10 = load i32* %vf.addr, align 4
  %conv11 = trunc i32 %10 to i16
  %call = call i32 @igb_write_mbx(%struct.e1000_hw* %9, i32* %msg, i16 zeroext 1, i16 zeroext %conv11) noredzone
  %11 = load volatile i64* @jiffies, align 8
  %12 = load %struct.vf_data_storage** %vf_data, align 8
  %last_nack12 = getelementptr inbounds %struct.vf_data_storage* %12, i32 0, i32 5
  store i64 %11, i64* %last_nack12, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true8, %land.lhs.true3, %land.lhs.true, %entry
  ret void
}

declare i32 @igb_write_mbx(%struct.e1000_hw*, i32*, i16 zeroext, i16 zeroext) noredzone

declare i32 @igb_read_mbx(%struct.e1000_hw*, i32*, i16 zeroext, i16 zeroext) noredzone

define internal void @igb_vf_reset_msg(%struct.igb_adapter* %adapter, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %vf_mac = alloca i8*, align 8
  %rar_entry = alloca i32, align 4
  %reg = alloca i32, align 4
  %msgbuf = alloca [3 x i32], align 4
  %addr = alloca i8*, align 8
  %hw_addr = alloca i8*, align 8
  %hw_addr12 = alloca i8*, align 8
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %1 to i64
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 50
  %3 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %3, i64 %idxprom
  %vf_mac_addresses = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [6 x i8]* %vf_mac_addresses, i32 0, i32 0
  store i8* %arraydecay, i8** %vf_mac, align 8
  %4 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 4
  %rar_entry_count = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 12
  %5 = load i16* %rar_entry_count, align 2
  %conv = zext i16 %5 to i32
  %6 = load i32* %vf.addr, align 4
  %add = add i32 %6, 1
  %sub = sub i32 %conv, %add
  store i32 %sub, i32* %rar_entry, align 4
  %arrayidx2 = getelementptr [3 x i32]* %msgbuf, i32 0, i64 1
  %7 = bitcast i32* %arrayidx2 to i8*
  store i8* %7, i8** %addr, align 8
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %9 = load i32* %vf.addr, align 4
  call void @igb_vf_reset(%struct.igb_adapter* %8, i32 %9) noredzone
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %11 = load i8** %vf_mac, align 8
  %12 = load i32* %rar_entry, align 4
  %13 = load i32* %vf.addr, align 4
  %conv3 = trunc i32 %13 to i8
  call void @igb_rar_set_qsel(%struct.igb_adapter* %10, i8* %11, i32 %12, i8 zeroext %conv3) noredzone
  %14 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %14, i32 3216) noredzone
  store i32 %call, i32* %reg, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %15 = load %struct.e1000_hw** %hw, align 8
  %hw_addr4 = getelementptr inbounds %struct.e1000_hw* %15, i32 0, i32 1
  %16 = load volatile i8** %hw_addr4, align 8
  store i8* %16, i8** %hw_addr, align 8
  %17 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %17, null
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv7 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv7, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %18 = load i32* %reg, align 4
  %19 = load i32* %vf.addr, align 4
  %shl = shl i32 1, %19
  %or = or i32 %18, %shl
  %20 = load i8** %hw_addr, align 8
  %arrayidx9 = getelementptr i8* %20, i64 3216
  call void @writel(i32 %or, i8* %arrayidx9) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %21 = load %struct.e1000_hw** %hw, align 8
  %call10 = call i32 @igb_rd32(%struct.e1000_hw* %21, i32 3212) noredzone
  store i32 %call10, i32* %reg, align 4
  br label %do.body11

do.body11:                                        ; preds = %do.end
  %22 = load %struct.e1000_hw** %hw, align 8
  %hw_addr13 = getelementptr inbounds %struct.e1000_hw* %22, i32 0, i32 1
  %23 = load volatile i8** %hw_addr13, align 8
  store i8* %23, i8** %hw_addr12, align 8
  %24 = load i8** %hw_addr12, align 8
  %tobool14 = icmp ne i8* %24, null
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.end28, label %if.then24

if.then24:                                        ; preds = %do.body11
  %25 = load i32* %reg, align 4
  %26 = load i32* %vf.addr, align 4
  %shl25 = shl i32 1, %26
  %or26 = or i32 %25, %shl25
  %27 = load i8** %hw_addr12, align 8
  %arrayidx27 = getelementptr i8* %27, i64 3212
  call void @writel(i32 %or26, i8* %arrayidx27) noredzone
  br label %if.end28

if.end28:                                         ; preds = %if.then24, %do.body11
  br label %do.end29

do.end29:                                         ; preds = %if.end28
  %28 = load i32* %vf.addr, align 4
  %idxprom30 = zext i32 %28 to i64
  %29 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data31 = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 50
  %30 = load %struct.vf_data_storage** %vf_data31, align 8
  %arrayidx32 = getelementptr %struct.vf_data_storage* %30, i64 %idxprom30
  %flags = getelementptr inbounds %struct.vf_data_storage* %arrayidx32, i32 0, i32 4
  %31 = load i32* %flags, align 4
  %or33 = or i32 %31, 1
  store i32 %or33, i32* %flags, align 4
  %arrayidx34 = getelementptr [3 x i32]* %msgbuf, i32 0, i64 0
  store i32 -2147483647, i32* %arrayidx34, align 4
  store i64 6, i64* %__len, align 8
  %32 = load i64* %__len, align 8
  %cmp = icmp uge i64 %32, 64
  br i1 %cmp, label %if.then36, label %if.else

if.then36:                                        ; preds = %do.end29
  %33 = load i8** %addr, align 8
  %34 = load i8** %vf_mac, align 8
  %35 = load i64* %__len, align 8
  %call37 = call i8* @__memcpy(i8* %33, i8* %34, i64 %35) noredzone
  store i8* %call37, i8** %__ret, align 8
  br label %if.end38

if.else:                                          ; preds = %do.end29
  %36 = load i8** %addr, align 8
  %37 = load i8** %vf_mac, align 8
  %38 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %36, i8* %37, i64 %38, i32 1, i1 false)
  store i8* %36, i8** %__ret, align 8
  br label %if.end38

if.end38:                                         ; preds = %if.else, %if.then36
  %39 = load i8** %__ret, align 8
  %40 = load %struct.e1000_hw** %hw, align 8
  %arraydecay39 = getelementptr inbounds [3 x i32]* %msgbuf, i32 0, i32 0
  %41 = load i32* %vf.addr, align 4
  %conv40 = trunc i32 %41 to i16
  %call41 = call i32 @igb_write_mbx(%struct.e1000_hw* %40, i32* %arraydecay39, i16 zeroext 3, i16 zeroext %conv40) noredzone
  ret void
}

define internal i32 @igb_set_vf_mac_addr(%struct.igb_adapter* %adapter, i32* %msg, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %msg.addr = alloca i32*, align 8
  %vf.addr = alloca i32, align 4
  %addr = alloca i8*, align 8
  %err = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32* %msg, i32** %msg.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load i32** %msg.addr, align 8
  %arrayidx = getelementptr i32* %0, i64 1
  %1 = bitcast i32* %arrayidx to i8*
  store i8* %1, i8** %addr, align 8
  store i32 -1, i32* %err, align 4
  %2 = load i8** %addr, align 8
  %call = call zeroext i1 @is_valid_ether_addr(i8* %2) noredzone
  br i1 %call, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %4 = load i32* %vf.addr, align 4
  %5 = load i8** %addr, align 8
  %call1 = call i32 @igb_set_vf_mac(%struct.igb_adapter* %3, i32 %4, i8* %5) noredzone
  store i32 %call1, i32* %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %6 = load i32* %err, align 4
  ret i32 %6
}

declare i32 @dev_warn(%struct.device*, i8*, ...) noredzone

define internal i32 @igb_set_vf_promisc(%struct.igb_adapter* %adapter, i32* %msgbuf, i32 %vf) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %msgbuf.addr = alloca i32*, align 8
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %vmolr = alloca i32, align 4
  %vf_data = alloca %struct.vf_data_storage*, align 8
  %j = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32* %msgbuf, i32** %msgbuf.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %2 = load i32* %vf.addr, align 4
  %mul = mul i32 4, %2
  %add = add i32 23248, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 %add) noredzone
  store i32 %call, i32* %vmolr, align 4
  %3 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %3 to i64
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 50
  %5 = load %struct.vf_data_storage** %vf_data2, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %5, i64 %idxprom
  store %struct.vf_data_storage* %arrayidx, %struct.vf_data_storage** %vf_data, align 8
  %6 = load %struct.vf_data_storage** %vf_data, align 8
  %flags = getelementptr inbounds %struct.vf_data_storage* %6, i32 0, i32 4
  %7 = load i32* %flags, align 4
  %and = and i32 %7, -7
  store i32 %and, i32* %flags, align 4
  %8 = load i32* %vmolr, align 4
  %and3 = and i32 %8, -369098753
  store i32 %and3, i32* %vmolr, align 4
  %9 = load i32** %msgbuf.addr, align 8
  %10 = load i32* %9, align 4
  %and4 = and i32 %10, 131072
  %tobool = icmp ne i32 %and4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %11 = load i32* %vmolr, align 4
  %or = or i32 %11, 268435456
  store i32 %or, i32* %vmolr, align 4
  %12 = load %struct.vf_data_storage** %vf_data, align 8
  %flags5 = getelementptr inbounds %struct.vf_data_storage* %12, i32 0, i32 4
  %13 = load i32* %flags5, align 4
  %or6 = or i32 %13, 4
  store i32 %or6, i32* %flags5, align 4
  %14 = load i32** %msgbuf.addr, align 8
  %15 = load i32* %14, align 4
  %and7 = and i32 %15, -131073
  store i32 %and7, i32* %14, align 4
  br label %if.end24

if.else:                                          ; preds = %entry
  %16 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %16, i32 0, i32 2
  %17 = load i16* %num_vf_mc_hashes, align 2
  %conv = zext i16 %17 to i32
  %cmp = icmp sgt i32 %conv, 30
  br i1 %cmp, label %if.then9, label %if.else11

if.then9:                                         ; preds = %if.else
  %18 = load i32* %vmolr, align 4
  %or10 = or i32 %18, 268435456
  store i32 %or10, i32* %vmolr, align 4
  br label %if.end23

if.else11:                                        ; preds = %if.else
  %19 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes12 = getelementptr inbounds %struct.vf_data_storage* %19, i32 0, i32 2
  %20 = load i16* %num_vf_mc_hashes12, align 2
  %tobool13 = icmp ne i16 %20, 0
  br i1 %tobool13, label %if.then14, label %if.end

if.then14:                                        ; preds = %if.else11
  %21 = load i32* %vmolr, align 4
  %or15 = or i32 %21, 33554432
  store i32 %or15, i32* %vmolr, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then14
  %22 = load i32* %j, align 4
  %23 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes16 = getelementptr inbounds %struct.vf_data_storage* %23, i32 0, i32 2
  %24 = load i16* %num_vf_mc_hashes16, align 2
  %conv17 = zext i16 %24 to i32
  %cmp18 = icmp slt i32 %22, %conv17
  br i1 %cmp18, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %25 = load %struct.e1000_hw** %hw, align 8
  %26 = load i32* %j, align 4
  %idxprom20 = sext i32 %26 to i64
  %27 = load %struct.vf_data_storage** %vf_data, align 8
  %vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %27, i32 0, i32 1
  %arrayidx21 = getelementptr [30 x i16]* %vf_mc_hashes, i32 0, i64 %idxprom20
  %28 = load i16* %arrayidx21, align 2
  %conv22 = zext i16 %28 to i32
  call void @igb_mta_set(%struct.e1000_hw* %25, i32 %conv22) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %29 = load i32* %j, align 4
  %inc = add i32 %29, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %if.else11
  br label %if.end23

if.end23:                                         ; preds = %if.end, %if.then9
  br label %if.end24

if.end24:                                         ; preds = %if.end23, %if.then
  br label %do.body

do.body:                                          ; preds = %if.end24
  %30 = load %struct.e1000_hw** %hw, align 8
  %hw_addr25 = getelementptr inbounds %struct.e1000_hw* %30, i32 0, i32 1
  %31 = load volatile i8** %hw_addr25, align 8
  store i8* %31, i8** %hw_addr, align 8
  %32 = load i8** %hw_addr, align 8
  %tobool26 = icmp ne i8* %32, null
  %lnot = xor i1 %tobool26, true
  %lnot27 = xor i1 %lnot, true
  %lnot28 = xor i1 %lnot27, true
  %lnot.ext = zext i1 %lnot28 to i32
  %conv29 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv29, i64 0)
  %tobool30 = icmp ne i64 %expval, 0
  br i1 %tobool30, label %if.end36, label %if.then31

if.then31:                                        ; preds = %do.body
  %33 = load i32* %vmolr, align 4
  %34 = load i32* %vf.addr, align 4
  %mul32 = mul i32 4, %34
  %add33 = add i32 23248, %mul32
  %idxprom34 = zext i32 %add33 to i64
  %35 = load i8** %hw_addr, align 8
  %arrayidx35 = getelementptr i8* %35, i64 %idxprom34
  call void @writel(i32 %33, i8* %arrayidx35) noredzone
  br label %if.end36

if.end36:                                         ; preds = %if.then31, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end36
  %36 = load i32** %msgbuf.addr, align 8
  %37 = load i32* %36, align 4
  %and37 = and i32 %37, 16711680
  %tobool38 = icmp ne i32 %and37, 0
  br i1 %tobool38, label %if.then39, label %if.end40

if.then39:                                        ; preds = %do.end
  store i32 -22, i32* %retval
  br label %return

if.end40:                                         ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end40, %if.then39
  %38 = load i32* %retval
  ret i32 %38
}

define internal i32 @igb_set_vf_multicasts(%struct.igb_adapter* %adapter, i32* %msgbuf, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %msgbuf.addr = alloca i32*, align 8
  %vf.addr = alloca i32, align 4
  %n = alloca i32, align 4
  %hash_list = alloca i16*, align 8
  %vf_data = alloca %struct.vf_data_storage*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32* %msgbuf, i32** %msgbuf.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load i32** %msgbuf.addr, align 8
  %arrayidx = getelementptr i32* %0, i64 0
  %1 = load i32* %arrayidx, align 4
  %and = and i32 %1, 16711680
  %shr = lshr i32 %and, 16
  store i32 %shr, i32* %n, align 4
  %2 = load i32** %msgbuf.addr, align 8
  %arrayidx1 = getelementptr i32* %2, i64 1
  %3 = bitcast i32* %arrayidx1 to i16*
  store i16* %3, i16** %hash_list, align 8
  %4 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %4 to i64
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data2 = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 50
  %6 = load %struct.vf_data_storage** %vf_data2, align 8
  %arrayidx3 = getelementptr %struct.vf_data_storage* %6, i64 %idxprom
  store %struct.vf_data_storage* %arrayidx3, %struct.vf_data_storage** %vf_data, align 8
  %7 = load i32* %n, align 4
  %conv = trunc i32 %7 to i16
  %8 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %8, i32 0, i32 2
  store i16 %conv, i16* %num_vf_mc_hashes, align 2
  %9 = load i32* %n, align 4
  %cmp = icmp sgt i32 %9, 30
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 30, i32* %n, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %10 = load i32* %i, align 4
  %11 = load i32* %n, align 4
  %cmp5 = icmp slt i32 %10, %11
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %12 = load i32* %i, align 4
  %idxprom7 = sext i32 %12 to i64
  %13 = load i16** %hash_list, align 8
  %arrayidx8 = getelementptr i16* %13, i64 %idxprom7
  %14 = load i16* %arrayidx8, align 2
  %15 = load i32* %i, align 4
  %idxprom9 = sext i32 %15 to i64
  %16 = load %struct.vf_data_storage** %vf_data, align 8
  %vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %16, i32 0, i32 1
  %arrayidx10 = getelementptr [30 x i16]* %vf_mc_hashes, i32 0, i64 %idxprom9
  store i16 %14, i16* %arrayidx10, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %17 = load i32* %i, align 4
  %inc = add i32 %17, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 1
  %19 = load %struct.net_device** %netdev, align 8
  call void @igb_set_rx_mode(%struct.net_device* %19) noredzone
  ret i32 0
}

define internal i32 @igb_set_vf_rlpml(%struct.igb_adapter* %adapter, i32 %size, i32 %vfn) nounwind inlinehint noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %size.addr = alloca i32, align 4
  %vfn.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %vmolr = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  store i32 %vfn, i32* %vfn.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i32* %vfn.addr, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 49
  %3 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %4 = load i32* %vfn.addr, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 50
  %6 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %6, i64 %idxprom
  %vlans_enabled = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 3
  %7 = load i16* %vlans_enabled, align 2
  %conv = zext i16 %7 to i32
  %tobool = icmp ne i32 %conv, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %8 = load i32* %size.addr, align 4
  %add = add i32 %8, 4
  store i32 %add, i32* %size.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %9 = load %struct.e1000_hw** %hw, align 8
  %10 = load i32* %vfn.addr, align 4
  %mul = mul i32 4, %10
  %add2 = add i32 23248, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %9, i32 %add2) noredzone
  store i32 %call, i32* %vmolr, align 4
  %11 = load i32* %vmolr, align 4
  %and = and i32 %11, -16384
  store i32 %and, i32* %vmolr, align 4
  %12 = load i32* %size.addr, align 4
  %or = or i32 %12, 65536
  %13 = load i32* %vmolr, align 4
  %or3 = or i32 %13, %or
  store i32 %or3, i32* %vmolr, align 4
  br label %do.body

do.body:                                          ; preds = %if.end
  %14 = load %struct.e1000_hw** %hw, align 8
  %hw_addr4 = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 1
  %15 = load volatile i8** %hw_addr4, align 8
  store i8* %15, i8** %hw_addr, align 8
  %16 = load i8** %hw_addr, align 8
  %tobool5 = icmp ne i8* %16, null
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.end15, label %if.then10

if.then10:                                        ; preds = %do.body
  %17 = load i32* %vmolr, align 4
  %18 = load i32* %vfn.addr, align 4
  %mul11 = mul i32 4, %18
  %add12 = add i32 23248, %mul11
  %idxprom13 = sext i32 %add12 to i64
  %19 = load i8** %hw_addr, align 8
  %arrayidx14 = getelementptr i8* %19, i64 %idxprom13
  call void @writel(i32 %17, i8* %arrayidx14) noredzone
  br label %if.end15

if.end15:                                         ; preds = %if.then10, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end15
  ret i32 0
}

define internal i32 @igb_set_vf_vlan(%struct.igb_adapter* %adapter, i32* %msgbuf, i32 %vf) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %msgbuf.addr = alloca i32*, align 8
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %add = alloca i32, align 4
  %vid = alloca i32, align 4
  %err = alloca i32, align 4
  %vlvf = alloca i32, align 4
  %bits = alloca i32, align 4
  %regndx = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32* %msgbuf, i32** %msgbuf.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i32** %msgbuf.addr, align 8
  %arrayidx = getelementptr i32* %1, i64 0
  %2 = load i32* %arrayidx, align 4
  %and = and i32 %2, 16711680
  %shr = lshr i32 %and, 16
  store i32 %shr, i32* %add, align 4
  %3 = load i32** %msgbuf.addr, align 8
  %arrayidx2 = getelementptr i32* %3, i64 1
  %4 = load i32* %arrayidx2, align 4
  %and3 = and i32 %4, 4095
  store i32 %and3, i32* %vid, align 4
  store i32 0, i32* %err, align 4
  %5 = load i32* %add, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 1
  %7 = load %struct.net_device** %netdev, align 8
  %flags = getelementptr inbounds %struct.net_device* %7, i32 0, i32 32
  %8 = load i32* %flags, align 4
  %and4 = and i32 %8, 256
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %10 = load i32* %vid, align 4
  %11 = load i32* %add, align 4
  %tobool6 = icmp ne i32 %11, 0
  %12 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 49
  %13 = load i32* %vfs_allocated_count, align 4
  %call = call i32 @igb_vlvf_set(%struct.igb_adapter* %9, i32 %10, i1 zeroext %tobool6, i32 %13) noredzone
  store i32 %call, i32* %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %14 = load i32* %err, align 4
  %tobool7 = icmp ne i32 %14, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  br label %out

if.end9:                                          ; preds = %if.end
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %16 = load i32* %vid, align 4
  %17 = load i32* %add, align 4
  %tobool10 = icmp ne i32 %17, 0
  %18 = load i32* %vf.addr, align 4
  %call11 = call i32 @igb_vlvf_set(%struct.igb_adapter* %15, i32 %16, i1 zeroext %tobool10, i32 %18) noredzone
  store i32 %call11, i32* %err, align 4
  %19 = load i32* %err, align 4
  %tobool12 = icmp ne i32 %19, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end9
  br label %out

if.end14:                                         ; preds = %if.end9
  %20 = load i32* %add, align 4
  %tobool15 = icmp ne i32 %20, 0
  br i1 %tobool15, label %if.end47, label %land.lhs.true16

land.lhs.true16:                                  ; preds = %if.end14
  %21 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev17 = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 1
  %22 = load %struct.net_device** %netdev17, align 8
  %flags18 = getelementptr inbounds %struct.net_device* %22, i32 0, i32 32
  %23 = load i32* %flags18, align 4
  %and19 = and i32 %23, 256
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.end47

if.then21:                                        ; preds = %land.lhs.true16
  %24 = load %struct.igb_adapter** %adapter.addr, align 8
  %25 = load i32* %vid, align 4
  %call22 = call i32 @igb_find_vlvf_entry(%struct.igb_adapter* %24, i32 %25) noredzone
  store i32 %call22, i32* %regndx, align 4
  %26 = load i32* %regndx, align 4
  %cmp = icmp slt i32 %26, 0
  br i1 %cmp, label %if.then23, label %if.end24

if.then23:                                        ; preds = %if.then21
  br label %out

if.end24:                                         ; preds = %if.then21
  %27 = load %struct.e1000_hw** %hw, align 8
  %28 = load i32* %regndx, align 4
  %mul = mul i32 4, %28
  %add25 = add i32 23808, %mul
  %call26 = call i32 @igb_rd32(%struct.e1000_hw* %27, i32 %add25) noredzone
  store i32 %call26, i32* %bits, align 4
  store i32 %call26, i32* %vlvf, align 4
  %29 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count27 = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 49
  %30 = load i32* %vfs_allocated_count27, align 4
  %add28 = add i32 12, %30
  %shl = shl i32 1, %add28
  %31 = load i32* %bits, align 4
  %and29 = and i32 %31, %shl
  store i32 %and29, i32* %bits, align 4
  %32 = load i32* %vlvf, align 4
  %and30 = and i32 %32, 4095
  %33 = load i32* %vid, align 4
  %cmp31 = icmp eq i32 %and30, %33
  br i1 %cmp31, label %land.lhs.true32, label %if.end46

land.lhs.true32:                                  ; preds = %if.end24
  br i1 false, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true32
  %34 = load i32* %vid, align 4
  %conv = sext i32 %34 to i64
  %35 = load %struct.igb_adapter** %adapter.addr, align 8
  %active_vlans = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64]* %active_vlans, i32 0, i32 0
  store i64 %conv, i64* %nr.addr.i, align 8
  store i64* %arraydecay, i64** %addr.addr.i, align 8
  %36 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %36, 63
  %shl.i = shl i64 1, %and.i
  %37 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %37, 6
  %38 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %38, i64 %shr.i
  %39 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %39
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool34 = icmp ne i32 %conv.i, 0
  br i1 %tobool34, label %if.end46, label %land.lhs.true40

cond.false:                                       ; preds = %land.lhs.true32
  %40 = load i32* %vid, align 4
  %conv35 = sext i32 %40 to i64
  %41 = load %struct.igb_adapter** %adapter.addr, align 8
  %active_vlans36 = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 0
  %arraydecay37 = getelementptr inbounds [64 x i64]* %active_vlans36, i32 0, i32 0
  %call38 = call i32 @variable_test_bit(i64 %conv35, i64* %arraydecay37) noredzone
  %tobool39 = icmp ne i32 %call38, 0
  br i1 %tobool39, label %if.end46, label %land.lhs.true40

land.lhs.true40:                                  ; preds = %cond.false, %cond.true
  %42 = load i32* %bits, align 4
  %tobool41 = icmp ne i32 %42, 0
  br i1 %tobool41, label %if.end46, label %if.then42

if.then42:                                        ; preds = %land.lhs.true40
  %43 = load %struct.igb_adapter** %adapter.addr, align 8
  %44 = load i32* %vid, align 4
  %45 = load i32* %add, align 4
  %tobool43 = icmp ne i32 %45, 0
  %46 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count44 = getelementptr inbounds %struct.igb_adapter* %46, i32 0, i32 49
  %47 = load i32* %vfs_allocated_count44, align 4
  %call45 = call i32 @igb_vlvf_set(%struct.igb_adapter* %43, i32 %44, i1 zeroext %tobool43, i32 %47) noredzone
  br label %if.end46

if.end46:                                         ; preds = %if.then42, %land.lhs.true40, %cond.false, %cond.true, %if.end24
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %land.lhs.true16, %if.end14
  br label %out

out:                                              ; preds = %if.end47, %if.then23, %if.then13, %if.then8
  %48 = load i32* %err, align 4
  ret i32 %48
}

define internal i32 @igb_vlvf_set(%struct.igb_adapter* %adapter, i32 %vid, i1 zeroext %add, i32 %vf) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vid.addr = alloca i32, align 4
  %add.addr = alloca i8, align 1
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %reg = alloca i32, align 4
  %i = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %size = alloca i32, align 4
  %hw_addr66 = alloca i8*, align 8
  %hw_addr104 = alloca i8*, align 8
  %size138 = alloca i32, align 4
  %hw_addr146 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vid, i32* %vid.addr, align 4
  %frombool = zext i1 %add to i8
  store i8 %frombool, i8* %add.addr, align 1
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  %cmp = icmp ult i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  store i32 -1, i32* %retval
  br label %return

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %5 = load i32* %i, align 4
  %cmp4 = icmp ult i32 %5, 32
  br i1 %cmp4, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load %struct.e1000_hw** %hw, align 8
  %7 = load i32* %i, align 4
  %mul = mul i32 4, %7
  %add5 = add i32 23808, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %6, i32 %add5) noredzone
  store i32 %call, i32* %reg, align 4
  %8 = load i32* %reg, align 4
  %and = and i32 %8, -2147483648
  %tobool6 = icmp ne i32 %and, 0
  br i1 %tobool6, label %land.lhs.true, label %if.end10

land.lhs.true:                                    ; preds = %for.body
  %9 = load i32* %vid.addr, align 4
  %10 = load i32* %reg, align 4
  %and7 = and i32 %10, 4095
  %cmp8 = icmp eq i32 %9, %and7
  br i1 %cmp8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %land.lhs.true
  br label %for.end

if.end10:                                         ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %11 = load i32* %i, align 4
  %inc = add i32 %11, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then9, %for.cond
  %12 = load i8* %add.addr, align 1
  %tobool11 = trunc i8 %12 to i1
  br i1 %tobool11, label %if.then12, label %if.else

if.then12:                                        ; preds = %for.end
  %13 = load i32* %i, align 4
  %cmp13 = icmp eq i32 %13, 32
  br i1 %cmp13, label %if.then14, label %if.end28

if.then14:                                        ; preds = %if.then12
  store i32 0, i32* %i, align 4
  br label %for.cond15

for.cond15:                                       ; preds = %for.inc25, %if.then14
  %14 = load i32* %i, align 4
  %cmp16 = icmp ult i32 %14, 32
  br i1 %cmp16, label %for.body17, label %for.end27

for.body17:                                       ; preds = %for.cond15
  %15 = load %struct.e1000_hw** %hw, align 8
  %16 = load i32* %i, align 4
  %mul18 = mul i32 4, %16
  %add19 = add i32 23808, %mul18
  %call20 = call i32 @igb_rd32(%struct.e1000_hw* %15, i32 %add19) noredzone
  store i32 %call20, i32* %reg, align 4
  %17 = load i32* %reg, align 4
  %and21 = and i32 %17, -2147483648
  %tobool22 = icmp ne i32 %and21, 0
  br i1 %tobool22, label %if.end24, label %if.then23

if.then23:                                        ; preds = %for.body17
  br label %for.end27

if.end24:                                         ; preds = %for.body17
  br label %for.inc25

for.inc25:                                        ; preds = %if.end24
  %18 = load i32* %i, align 4
  %inc26 = add i32 %18, 1
  store i32 %inc26, i32* %i, align 4
  br label %for.cond15

for.end27:                                        ; preds = %if.then23, %for.cond15
  br label %if.end28

if.end28:                                         ; preds = %for.end27, %if.then12
  %19 = load i32* %i, align 4
  %cmp29 = icmp ult i32 %19, 32
  br i1 %cmp29, label %if.then30, label %if.end91

if.then30:                                        ; preds = %if.end28
  %20 = load i32* %vf.addr, align 4
  %add31 = add i32 12, %20
  %shl = shl i32 1, %add31
  %21 = load i32* %reg, align 4
  %or = or i32 %21, %shl
  store i32 %or, i32* %reg, align 4
  %22 = load i32* %reg, align 4
  %and32 = and i32 %22, -2147483648
  %tobool33 = icmp ne i32 %and32, 0
  br i1 %tobool33, label %if.end37, label %if.then34

if.then34:                                        ; preds = %if.then30
  %23 = load %struct.e1000_hw** %hw, align 8
  %24 = load i32* %vid.addr, align 4
  %call35 = call i32 @igb_vfta_set(%struct.e1000_hw* %23, i32 %24, i1 zeroext true) noredzone
  %25 = load i32* %reg, align 4
  %or36 = or i32 %25, -2147483648
  store i32 %or36, i32* %reg, align 4
  br label %if.end37

if.end37:                                         ; preds = %if.then34, %if.then30
  %26 = load i32* %reg, align 4
  %and38 = and i32 %26, -4096
  store i32 %and38, i32* %reg, align 4
  %27 = load i32* %vid.addr, align 4
  %28 = load i32* %reg, align 4
  %or39 = or i32 %28, %27
  store i32 %or39, i32* %reg, align 4
  br label %do.body

do.body:                                          ; preds = %if.end37
  %29 = load %struct.e1000_hw** %hw, align 8
  %hw_addr40 = getelementptr inbounds %struct.e1000_hw* %29, i32 0, i32 1
  %30 = load volatile i8** %hw_addr40, align 8
  store i8* %30, i8** %hw_addr, align 8
  %31 = load i8** %hw_addr, align 8
  %tobool41 = icmp ne i8* %31, null
  %lnot = xor i1 %tobool41, true
  %lnot42 = xor i1 %lnot, true
  %lnot43 = xor i1 %lnot42, true
  %lnot.ext = zext i1 %lnot43 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool44 = icmp ne i64 %expval, 0
  br i1 %tobool44, label %if.end48, label %if.then45

if.then45:                                        ; preds = %do.body
  %32 = load i32* %reg, align 4
  %33 = load i32* %i, align 4
  %mul46 = mul i32 4, %33
  %add47 = add i32 23808, %mul46
  %idxprom = zext i32 %add47 to i64
  %34 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %34, i64 %idxprom
  call void @writel(i32 %32, i8* %arrayidx) noredzone
  br label %if.end48

if.end48:                                         ; preds = %if.then45, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end48
  %35 = load i32* %vf.addr, align 4
  %36 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count49 = getelementptr inbounds %struct.igb_adapter* %36, i32 0, i32 49
  %37 = load i32* %vfs_allocated_count49, align 4
  %cmp50 = icmp uge i32 %35, %37
  br i1 %cmp50, label %if.then52, label %if.end53

if.then52:                                        ; preds = %do.end
  store i32 0, i32* %retval
  br label %return

if.end53:                                         ; preds = %do.end
  %38 = load i32* %vf.addr, align 4
  %idxprom54 = zext i32 %38 to i64
  %39 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 50
  %40 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx55 = getelementptr %struct.vf_data_storage* %40, i64 %idxprom54
  %vlans_enabled = getelementptr inbounds %struct.vf_data_storage* %arrayidx55, i32 0, i32 3
  %41 = load i16* %vlans_enabled, align 2
  %tobool56 = icmp ne i16 %41, 0
  br i1 %tobool56, label %if.end85, label %if.then57

if.then57:                                        ; preds = %if.end53
  %42 = load %struct.e1000_hw** %hw, align 8
  %43 = load i32* %vf.addr, align 4
  %mul58 = mul i32 4, %43
  %add59 = add i32 23248, %mul58
  %call60 = call i32 @igb_rd32(%struct.e1000_hw* %42, i32 %add59) noredzone
  store i32 %call60, i32* %reg, align 4
  %44 = load i32* %reg, align 4
  %and61 = and i32 %44, 16383
  store i32 %and61, i32* %size, align 4
  %45 = load i32* %size, align 4
  %add62 = add i32 %45, 4
  store i32 %add62, i32* %size, align 4
  %46 = load i32* %reg, align 4
  %and63 = and i32 %46, -16384
  store i32 %and63, i32* %reg, align 4
  %47 = load i32* %size, align 4
  %48 = load i32* %reg, align 4
  %or64 = or i32 %48, %47
  store i32 %or64, i32* %reg, align 4
  br label %do.body65

do.body65:                                        ; preds = %if.then57
  %49 = load %struct.e1000_hw** %hw, align 8
  %hw_addr67 = getelementptr inbounds %struct.e1000_hw* %49, i32 0, i32 1
  %50 = load volatile i8** %hw_addr67, align 8
  store i8* %50, i8** %hw_addr66, align 8
  %51 = load i8** %hw_addr66, align 8
  %tobool68 = icmp ne i8* %51, null
  %lnot69 = xor i1 %tobool68, true
  %lnot71 = xor i1 %lnot69, true
  %lnot73 = xor i1 %lnot71, true
  %lnot.ext74 = zext i1 %lnot73 to i32
  %conv75 = sext i32 %lnot.ext74 to i64
  %expval76 = call i64 @llvm.expect.i64(i64 %conv75, i64 0)
  %tobool77 = icmp ne i64 %expval76, 0
  br i1 %tobool77, label %if.end83, label %if.then78

if.then78:                                        ; preds = %do.body65
  %52 = load i32* %reg, align 4
  %53 = load i32* %vf.addr, align 4
  %mul79 = mul i32 4, %53
  %add80 = add i32 23248, %mul79
  %idxprom81 = zext i32 %add80 to i64
  %54 = load i8** %hw_addr66, align 8
  %arrayidx82 = getelementptr i8* %54, i64 %idxprom81
  call void @writel(i32 %52, i8* %arrayidx82) noredzone
  br label %if.end83

if.end83:                                         ; preds = %if.then78, %do.body65
  br label %do.end84

do.end84:                                         ; preds = %if.end83
  br label %if.end85

if.end85:                                         ; preds = %do.end84, %if.end53
  %55 = load i32* %vf.addr, align 4
  %idxprom86 = zext i32 %55 to i64
  %56 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data87 = getelementptr inbounds %struct.igb_adapter* %56, i32 0, i32 50
  %57 = load %struct.vf_data_storage** %vf_data87, align 8
  %arrayidx88 = getelementptr %struct.vf_data_storage* %57, i64 %idxprom86
  %vlans_enabled89 = getelementptr inbounds %struct.vf_data_storage* %arrayidx88, i32 0, i32 3
  %58 = load i16* %vlans_enabled89, align 2
  %inc90 = add i16 %58, 1
  store i16 %inc90, i16* %vlans_enabled89, align 2
  br label %if.end91

if.end91:                                         ; preds = %if.end85, %if.end28
  br label %if.end167

if.else:                                          ; preds = %for.end
  %59 = load i32* %i, align 4
  %cmp92 = icmp ult i32 %59, 32
  br i1 %cmp92, label %if.then94, label %if.end166

if.then94:                                        ; preds = %if.else
  %60 = load i32* %vf.addr, align 4
  %add95 = add i32 12, %60
  %shl96 = shl i32 1, %add95
  %neg = xor i32 %shl96, -1
  %61 = load i32* %reg, align 4
  %and97 = and i32 %61, %neg
  store i32 %and97, i32* %reg, align 4
  %62 = load i32* %reg, align 4
  %and98 = and i32 %62, 1044480
  %tobool99 = icmp ne i32 %and98, 0
  br i1 %tobool99, label %if.end102, label %if.then100

if.then100:                                       ; preds = %if.then94
  store i32 0, i32* %reg, align 4
  %63 = load %struct.e1000_hw** %hw, align 8
  %64 = load i32* %vid.addr, align 4
  %call101 = call i32 @igb_vfta_set(%struct.e1000_hw* %63, i32 %64, i1 zeroext false) noredzone
  br label %if.end102

if.end102:                                        ; preds = %if.then100, %if.then94
  br label %do.body103

do.body103:                                       ; preds = %if.end102
  %65 = load %struct.e1000_hw** %hw, align 8
  %hw_addr105 = getelementptr inbounds %struct.e1000_hw* %65, i32 0, i32 1
  %66 = load volatile i8** %hw_addr105, align 8
  store i8* %66, i8** %hw_addr104, align 8
  %67 = load i8** %hw_addr104, align 8
  %tobool106 = icmp ne i8* %67, null
  %lnot107 = xor i1 %tobool106, true
  %lnot109 = xor i1 %lnot107, true
  %lnot111 = xor i1 %lnot109, true
  %lnot.ext112 = zext i1 %lnot111 to i32
  %conv113 = sext i32 %lnot.ext112 to i64
  %expval114 = call i64 @llvm.expect.i64(i64 %conv113, i64 0)
  %tobool115 = icmp ne i64 %expval114, 0
  br i1 %tobool115, label %if.end121, label %if.then116

if.then116:                                       ; preds = %do.body103
  %68 = load i32* %reg, align 4
  %69 = load i32* %i, align 4
  %mul117 = mul i32 4, %69
  %add118 = add i32 23808, %mul117
  %idxprom119 = zext i32 %add118 to i64
  %70 = load i8** %hw_addr104, align 8
  %arrayidx120 = getelementptr i8* %70, i64 %idxprom119
  call void @writel(i32 %68, i8* %arrayidx120) noredzone
  br label %if.end121

if.end121:                                        ; preds = %if.then116, %do.body103
  br label %do.end122

do.end122:                                        ; preds = %if.end121
  %71 = load i32* %vf.addr, align 4
  %72 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count123 = getelementptr inbounds %struct.igb_adapter* %72, i32 0, i32 49
  %73 = load i32* %vfs_allocated_count123, align 4
  %cmp124 = icmp uge i32 %71, %73
  br i1 %cmp124, label %if.then126, label %if.end127

if.then126:                                       ; preds = %do.end122
  store i32 0, i32* %retval
  br label %return

if.end127:                                        ; preds = %do.end122
  %74 = load i32* %vf.addr, align 4
  %idxprom128 = zext i32 %74 to i64
  %75 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data129 = getelementptr inbounds %struct.igb_adapter* %75, i32 0, i32 50
  %76 = load %struct.vf_data_storage** %vf_data129, align 8
  %arrayidx130 = getelementptr %struct.vf_data_storage* %76, i64 %idxprom128
  %vlans_enabled131 = getelementptr inbounds %struct.vf_data_storage* %arrayidx130, i32 0, i32 3
  %77 = load i16* %vlans_enabled131, align 2
  %dec = add i16 %77, -1
  store i16 %dec, i16* %vlans_enabled131, align 2
  %78 = load i32* %vf.addr, align 4
  %idxprom132 = zext i32 %78 to i64
  %79 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data133 = getelementptr inbounds %struct.igb_adapter* %79, i32 0, i32 50
  %80 = load %struct.vf_data_storage** %vf_data133, align 8
  %arrayidx134 = getelementptr %struct.vf_data_storage* %80, i64 %idxprom132
  %vlans_enabled135 = getelementptr inbounds %struct.vf_data_storage* %arrayidx134, i32 0, i32 3
  %81 = load i16* %vlans_enabled135, align 2
  %tobool136 = icmp ne i16 %81, 0
  br i1 %tobool136, label %if.end165, label %if.then137

if.then137:                                       ; preds = %if.end127
  %82 = load %struct.e1000_hw** %hw, align 8
  %83 = load i32* %vf.addr, align 4
  %mul139 = mul i32 4, %83
  %add140 = add i32 23248, %mul139
  %call141 = call i32 @igb_rd32(%struct.e1000_hw* %82, i32 %add140) noredzone
  store i32 %call141, i32* %reg, align 4
  %84 = load i32* %reg, align 4
  %and142 = and i32 %84, 16383
  store i32 %and142, i32* %size138, align 4
  %85 = load i32* %size138, align 4
  %sub = sub i32 %85, 4
  store i32 %sub, i32* %size138, align 4
  %86 = load i32* %reg, align 4
  %and143 = and i32 %86, -16384
  store i32 %and143, i32* %reg, align 4
  %87 = load i32* %size138, align 4
  %88 = load i32* %reg, align 4
  %or144 = or i32 %88, %87
  store i32 %or144, i32* %reg, align 4
  br label %do.body145

do.body145:                                       ; preds = %if.then137
  %89 = load %struct.e1000_hw** %hw, align 8
  %hw_addr147 = getelementptr inbounds %struct.e1000_hw* %89, i32 0, i32 1
  %90 = load volatile i8** %hw_addr147, align 8
  store i8* %90, i8** %hw_addr146, align 8
  %91 = load i8** %hw_addr146, align 8
  %tobool148 = icmp ne i8* %91, null
  %lnot149 = xor i1 %tobool148, true
  %lnot151 = xor i1 %lnot149, true
  %lnot153 = xor i1 %lnot151, true
  %lnot.ext154 = zext i1 %lnot153 to i32
  %conv155 = sext i32 %lnot.ext154 to i64
  %expval156 = call i64 @llvm.expect.i64(i64 %conv155, i64 0)
  %tobool157 = icmp ne i64 %expval156, 0
  br i1 %tobool157, label %if.end163, label %if.then158

if.then158:                                       ; preds = %do.body145
  %92 = load i32* %reg, align 4
  %93 = load i32* %vf.addr, align 4
  %mul159 = mul i32 4, %93
  %add160 = add i32 23248, %mul159
  %idxprom161 = zext i32 %add160 to i64
  %94 = load i8** %hw_addr146, align 8
  %arrayidx162 = getelementptr i8* %94, i64 %idxprom161
  call void @writel(i32 %92, i8* %arrayidx162) noredzone
  br label %if.end163

if.end163:                                        ; preds = %if.then158, %do.body145
  br label %do.end164

do.end164:                                        ; preds = %if.end163
  br label %if.end165

if.end165:                                        ; preds = %do.end164, %if.end127
  br label %if.end166

if.end166:                                        ; preds = %if.end165, %if.else
  br label %if.end167

if.end167:                                        ; preds = %if.end166, %if.end91
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end167, %if.then126, %if.then52, %if.then2, %if.then
  %95 = load i32* %retval
  ret i32 %95
}

define internal i32 @igb_find_vlvf_entry(%struct.igb_adapter* %adapter, i32 %vid) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vid.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %i = alloca i32, align 4
  %reg = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vid, i32* %vid.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %i, align 4
  %cmp = icmp slt i32 %1, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.e1000_hw** %hw, align 8
  %3 = load i32* %i, align 4
  %mul = mul i32 4, %3
  %add = add i32 23808, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %2, i32 %add) noredzone
  store i32 %call, i32* %reg, align 4
  %4 = load i32* %reg, align 4
  %and = and i32 %4, -2147483648
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %for.body
  %5 = load i32* %vid.addr, align 4
  %6 = load i32* %reg, align 4
  %and2 = and i32 %6, 4095
  %cmp3 = icmp eq i32 %5, %and2
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  br label %for.end

if.end:                                           ; preds = %land.lhs.true, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %7 = load i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  %8 = load i32* %i, align 4
  %cmp4 = icmp sge i32 %8, 32
  br i1 %cmp4, label %if.then5, label %if.end6

if.then5:                                         ; preds = %for.end
  store i32 -1, i32* %i, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then5, %for.end
  %9 = load i32* %i, align 4
  ret i32 %9
}

declare i32 @igb_vfta_set(%struct.e1000_hw*, i32, i1 zeroext) noredzone

define internal void @igb_set_rx_mode(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %vfn = alloca i32, align 4
  %rctl = alloca i32, align 4
  %vmolr = alloca i32, align 4
  %count = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr54 = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  store i32 %4, i32* %vfn, align 4
  store i32 0, i32* %vmolr, align 4
  %5 = load %struct.e1000_hw** %hw, align 8
  %call2 = call i32 @igb_rd32(%struct.e1000_hw* %5, i32 256) noredzone
  store i32 %call2, i32* %rctl, align 4
  %6 = load i32* %rctl, align 4
  %and = and i32 %6, -262169
  store i32 %and, i32* %rctl, align 4
  %7 = load %struct.net_device** %netdev.addr, align 8
  %flags = getelementptr inbounds %struct.net_device* %7, i32 0, i32 32
  %8 = load i32* %flags, align 4
  %and3 = and i32 %8, 256
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %9 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count4 = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 49
  %10 = load i32* %vfs_allocated_count4, align 4
  %tobool5 = icmp ne i32 %10, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %11 = load i32* %rctl, align 4
  %or = or i32 %11, 262144
  store i32 %or, i32* %rctl, align 4
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  %12 = load i32* %rctl, align 4
  %or7 = or i32 %12, 24
  store i32 %or7, i32* %rctl, align 4
  %13 = load i32* %vmolr, align 4
  %or8 = or i32 %13, 335544320
  store i32 %or8, i32* %vmolr, align 4
  br label %if.end34

if.else:                                          ; preds = %entry
  %14 = load %struct.net_device** %netdev.addr, align 8
  %flags9 = getelementptr inbounds %struct.net_device* %14, i32 0, i32 32
  %15 = load i32* %flags9, align 4
  %and10 = and i32 %15, 512
  %tobool11 = icmp ne i32 %and10, 0
  br i1 %tobool11, label %if.then12, label %if.else15

if.then12:                                        ; preds = %if.else
  %16 = load i32* %rctl, align 4
  %or13 = or i32 %16, 16
  store i32 %or13, i32* %rctl, align 4
  %17 = load i32* %vmolr, align 4
  %or14 = or i32 %17, 268435456
  store i32 %or14, i32* %vmolr, align 4
  br label %if.end26

if.else15:                                        ; preds = %if.else
  %18 = load %struct.net_device** %netdev.addr, align 8
  %call16 = call i32 @igb_write_mc_addr_list(%struct.net_device* %18) noredzone
  store i32 %call16, i32* %count, align 4
  %19 = load i32* %count, align 4
  %cmp = icmp slt i32 %19, 0
  br i1 %cmp, label %if.then17, label %if.else20

if.then17:                                        ; preds = %if.else15
  %20 = load i32* %rctl, align 4
  %or18 = or i32 %20, 16
  store i32 %or18, i32* %rctl, align 4
  %21 = load i32* %vmolr, align 4
  %or19 = or i32 %21, 268435456
  store i32 %or19, i32* %vmolr, align 4
  br label %if.end25

if.else20:                                        ; preds = %if.else15
  %22 = load i32* %count, align 4
  %tobool21 = icmp ne i32 %22, 0
  br i1 %tobool21, label %if.then22, label %if.end24

if.then22:                                        ; preds = %if.else20
  %23 = load i32* %vmolr, align 4
  %or23 = or i32 %23, 33554432
  store i32 %or23, i32* %vmolr, align 4
  br label %if.end24

if.end24:                                         ; preds = %if.then22, %if.else20
  br label %if.end25

if.end25:                                         ; preds = %if.end24, %if.then17
  br label %if.end26

if.end26:                                         ; preds = %if.end25, %if.then12
  %24 = load %struct.net_device** %netdev.addr, align 8
  %call27 = call i32 @igb_write_uc_addr_list(%struct.net_device* %24) noredzone
  store i32 %call27, i32* %count, align 4
  %25 = load i32* %count, align 4
  %cmp28 = icmp slt i32 %25, 0
  br i1 %cmp28, label %if.then29, label %if.end32

if.then29:                                        ; preds = %if.end26
  %26 = load i32* %rctl, align 4
  %or30 = or i32 %26, 8
  store i32 %or30, i32* %rctl, align 4
  %27 = load i32* %vmolr, align 4
  %or31 = or i32 %27, 67108864
  store i32 %or31, i32* %vmolr, align 4
  br label %if.end32

if.end32:                                         ; preds = %if.then29, %if.end26
  %28 = load i32* %rctl, align 4
  %or33 = or i32 %28, 262144
  store i32 %or33, i32* %rctl, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.end32, %if.end
  br label %do.body

do.body:                                          ; preds = %if.end34
  %29 = load %struct.e1000_hw** %hw, align 8
  %hw_addr35 = getelementptr inbounds %struct.e1000_hw* %29, i32 0, i32 1
  %30 = load volatile i8** %hw_addr35, align 8
  store i8* %30, i8** %hw_addr, align 8
  %31 = load i8** %hw_addr, align 8
  %tobool36 = icmp ne i8* %31, null
  %lnot = xor i1 %tobool36, true
  %lnot37 = xor i1 %lnot, true
  %lnot38 = xor i1 %lnot37, true
  %lnot.ext = zext i1 %lnot38 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool39 = icmp ne i64 %expval, 0
  br i1 %tobool39, label %if.end41, label %if.then40

if.then40:                                        ; preds = %do.body
  %32 = load i32* %rctl, align 4
  %33 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %33, i64 256
  call void @writel(i32 %32, i8* %arrayidx) noredzone
  br label %if.end41

if.end41:                                         ; preds = %if.then40, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end41
  %34 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %34, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %35 = load i32* %type, align 4
  %cmp42 = icmp ult i32 %35, 2
  br i1 %cmp42, label %if.then48, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %do.end
  %36 = load %struct.e1000_hw** %hw, align 8
  %mac44 = getelementptr inbounds %struct.e1000_hw* %36, i32 0, i32 4
  %type45 = getelementptr inbounds %struct.e1000_mac_info* %mac44, i32 0, i32 3
  %37 = load i32* %type45, align 4
  %cmp46 = icmp ugt i32 %37, 4
  br i1 %cmp46, label %if.then48, label %if.end49

if.then48:                                        ; preds = %lor.lhs.false, %do.end
  br label %return

if.end49:                                         ; preds = %lor.lhs.false
  %38 = load %struct.e1000_hw** %hw, align 8
  %39 = load i32* %vfn, align 4
  %mul = mul i32 4, %39
  %add = add i32 23248, %mul
  %call50 = call i32 @igb_rd32(%struct.e1000_hw* %38, i32 %add) noredzone
  %and51 = and i32 %call50, -369098753
  %40 = load i32* %vmolr, align 4
  %or52 = or i32 %40, %and51
  store i32 %or52, i32* %vmolr, align 4
  br label %do.body53

do.body53:                                        ; preds = %if.end49
  %41 = load %struct.e1000_hw** %hw, align 8
  %hw_addr55 = getelementptr inbounds %struct.e1000_hw* %41, i32 0, i32 1
  %42 = load volatile i8** %hw_addr55, align 8
  store i8* %42, i8** %hw_addr54, align 8
  %43 = load i8** %hw_addr54, align 8
  %tobool56 = icmp ne i8* %43, null
  %lnot57 = xor i1 %tobool56, true
  %lnot59 = xor i1 %lnot57, true
  %lnot61 = xor i1 %lnot59, true
  %lnot.ext62 = zext i1 %lnot61 to i32
  %conv63 = sext i32 %lnot.ext62 to i64
  %expval64 = call i64 @llvm.expect.i64(i64 %conv63, i64 0)
  %tobool65 = icmp ne i64 %expval64, 0
  br i1 %tobool65, label %if.end70, label %if.then66

if.then66:                                        ; preds = %do.body53
  %44 = load i32* %vmolr, align 4
  %45 = load i32* %vfn, align 4
  %mul67 = mul i32 4, %45
  %add68 = add i32 23248, %mul67
  %idxprom = zext i32 %add68 to i64
  %46 = load i8** %hw_addr54, align 8
  %arrayidx69 = getelementptr i8* %46, i64 %idxprom
  call void @writel(i32 %44, i8* %arrayidx69) noredzone
  br label %if.end70

if.end70:                                         ; preds = %if.then66, %do.body53
  br label %do.end71

do.end71:                                         ; preds = %if.end70
  %47 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_restore_vf_multicasts(%struct.igb_adapter* %47) noredzone
  br label %return

return:                                           ; preds = %do.end71, %if.then48
  ret void
}

define internal i32 @igb_write_mc_addr_list(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ha = alloca %struct.netdev_hw_addr*, align 8
  %mta_list = alloca i8*, align 8
  %i = alloca i32, align 4
  %__mptr = alloca %struct.list_head*, align 8
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  %__mptr25 = alloca %struct.list_head*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.net_device** %netdev.addr, align 8
  %mc = getelementptr inbounds %struct.net_device* %3, i32 0, i32 53
  %count = getelementptr inbounds %struct.netdev_hw_addr_list* %mc, i32 0, i32 1
  %4 = load i32* %count, align 4
  %cmp = icmp eq i32 %4, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.e1000_hw** %hw, align 8
  call void @igb_update_mc_addr_list(%struct.e1000_hw* %5, i8* null, i32 0) noredzone
  %6 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_restore_vf_multicasts(%struct.igb_adapter* %6) noredzone
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.net_device** %netdev.addr, align 8
  %mc2 = getelementptr inbounds %struct.net_device* %7, i32 0, i32 53
  %count3 = getelementptr inbounds %struct.netdev_hw_addr_list* %mc2, i32 0, i32 1
  %8 = load i32* %count3, align 4
  %mul = mul i32 %8, 6
  %conv = sext i32 %mul to i64
  %call4 = call i8* @kzalloc(i64 %conv, i32 32) noredzone
  store i8* %call4, i8** %mta_list, align 8
  %9 = load i8** %mta_list, align 8
  %tobool = icmp ne i8* %9, null
  br i1 %tobool, label %if.end6, label %if.then5

if.then5:                                         ; preds = %if.end
  store i32 -12, i32* %retval
  br label %return

if.end6:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  %10 = load %struct.net_device** %netdev.addr, align 8
  %mc7 = getelementptr inbounds %struct.net_device* %10, i32 0, i32 53
  %list = getelementptr inbounds %struct.netdev_hw_addr_list* %mc7, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head* %list, i32 0, i32 0
  %11 = load %struct.list_head** %next, align 8
  store %struct.list_head* %11, %struct.list_head** %__mptr, align 8
  %12 = load %struct.list_head** %__mptr, align 8
  %13 = bitcast %struct.list_head* %12 to i8*
  %add.ptr = getelementptr i8* %13, i64 0
  %14 = bitcast i8* %add.ptr to %struct.netdev_hw_addr*
  store %struct.netdev_hw_addr* %14, %struct.netdev_hw_addr** %ha, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end6
  %15 = load %struct.netdev_hw_addr** %ha, align 8
  %list8 = getelementptr inbounds %struct.netdev_hw_addr* %15, i32 0, i32 0
  %16 = load %struct.net_device** %netdev.addr, align 8
  %mc9 = getelementptr inbounds %struct.net_device* %16, i32 0, i32 53
  %list10 = getelementptr inbounds %struct.netdev_hw_addr_list* %mc9, i32 0, i32 0
  %cmp11 = icmp ne %struct.list_head* %list8, %list10
  br i1 %cmp11, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  store i64 6, i64* %__len, align 8
  %17 = load i64* %__len, align 8
  %cmp13 = icmp uge i64 %17, 64
  br i1 %cmp13, label %if.then15, label %if.else

if.then15:                                        ; preds = %for.body
  %18 = load i8** %mta_list, align 8
  %19 = load i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  %mul16 = mul i32 %19, 6
  %idx.ext = sext i32 %mul16 to i64
  %add.ptr17 = getelementptr i8* %18, i64 %idx.ext
  %20 = load %struct.netdev_hw_addr** %ha, align 8
  %addr = getelementptr inbounds %struct.netdev_hw_addr* %20, i32 0, i32 1
  %arraydecay = getelementptr inbounds [32 x i8]* %addr, i32 0, i32 0
  %21 = load i64* %__len, align 8
  %call18 = call i8* @__memcpy(i8* %add.ptr17, i8* %arraydecay, i64 %21) noredzone
  store i8* %call18, i8** %__ret, align 8
  br label %if.end24

if.else:                                          ; preds = %for.body
  %22 = load i8** %mta_list, align 8
  %23 = load i32* %i, align 4
  %inc19 = add i32 %23, 1
  store i32 %inc19, i32* %i, align 4
  %mul20 = mul i32 %23, 6
  %idx.ext21 = sext i32 %mul20 to i64
  %add.ptr22 = getelementptr i8* %22, i64 %idx.ext21
  %24 = load %struct.netdev_hw_addr** %ha, align 8
  %addr23 = getelementptr inbounds %struct.netdev_hw_addr* %24, i32 0, i32 1
  %25 = bitcast [32 x i8]* %addr23 to i8*
  %26 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %add.ptr22, i8* %25, i64 %26, i32 1, i1 false)
  store i8* %add.ptr22, i8** %__ret, align 8
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then15
  %27 = load i8** %__ret, align 8
  br label %for.inc

for.inc:                                          ; preds = %if.end24
  %28 = load %struct.netdev_hw_addr** %ha, align 8
  %list26 = getelementptr inbounds %struct.netdev_hw_addr* %28, i32 0, i32 0
  %next27 = getelementptr inbounds %struct.list_head* %list26, i32 0, i32 0
  %29 = load %struct.list_head** %next27, align 8
  store %struct.list_head* %29, %struct.list_head** %__mptr25, align 8
  %30 = load %struct.list_head** %__mptr25, align 8
  %31 = bitcast %struct.list_head* %30 to i8*
  %add.ptr28 = getelementptr i8* %31, i64 0
  %32 = bitcast i8* %add.ptr28 to %struct.netdev_hw_addr*
  store %struct.netdev_hw_addr* %32, %struct.netdev_hw_addr** %ha, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %33 = load %struct.e1000_hw** %hw, align 8
  %34 = load i8** %mta_list, align 8
  %35 = load i32* %i, align 4
  call void @igb_update_mc_addr_list(%struct.e1000_hw* %33, i8* %34, i32 %35) noredzone
  %36 = load i8** %mta_list, align 8
  call void @kfree(i8* %36) noredzone
  %37 = load %struct.net_device** %netdev.addr, align 8
  %mc29 = getelementptr inbounds %struct.net_device* %37, i32 0, i32 53
  %count30 = getelementptr inbounds %struct.netdev_hw_addr_list* %mc29, i32 0, i32 1
  %38 = load i32* %count30, align 4
  store i32 %38, i32* %retval
  br label %return

return:                                           ; preds = %for.end, %if.then5, %if.then
  %39 = load i32* %retval
  ret i32 %39
}

define internal i32 @igb_write_uc_addr_list(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %vfn = alloca i32, align 4
  %rar_entries = alloca i32, align 4
  %count = alloca i32, align 4
  %ha = alloca %struct.netdev_hw_addr*, align 8
  %__mptr = alloca %struct.list_head*, align 8
  %__mptr19 = alloca %struct.list_head*, align 8
  %hw_addr = alloca i8*, align 8
  %hw_addr43 = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  store i32 %4, i32* %vfn, align 4
  %5 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 4
  %rar_entry_count = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 12
  %6 = load i16* %rar_entry_count, align 2
  %conv = zext i16 %6 to i32
  %7 = load i32* %vfn, align 4
  %add = add i32 %7, 1
  %sub = sub i32 %conv, %add
  store i32 %sub, i32* %rar_entries, align 4
  store i32 0, i32* %count, align 4
  %8 = load %struct.net_device** %netdev.addr, align 8
  %uc = getelementptr inbounds %struct.net_device* %8, i32 0, i32 52
  %count2 = getelementptr inbounds %struct.netdev_hw_addr_list* %uc, i32 0, i32 1
  %9 = load i32* %count2, align 4
  %10 = load i32* %rar_entries, align 4
  %cmp = icmp ugt i32 %9, %10
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -12, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %11 = load %struct.net_device** %netdev.addr, align 8
  %uc4 = getelementptr inbounds %struct.net_device* %11, i32 0, i32 52
  %count5 = getelementptr inbounds %struct.netdev_hw_addr_list* %uc4, i32 0, i32 1
  %12 = load i32* %count5, align 4
  %cmp6 = icmp eq i32 %12, 0
  br i1 %cmp6, label %if.end23, label %land.lhs.true

land.lhs.true:                                    ; preds = %if.end
  %13 = load i32* %rar_entries, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then8, label %if.end23

if.then8:                                         ; preds = %land.lhs.true
  %14 = load %struct.net_device** %netdev.addr, align 8
  %uc9 = getelementptr inbounds %struct.net_device* %14, i32 0, i32 52
  %list = getelementptr inbounds %struct.netdev_hw_addr_list* %uc9, i32 0, i32 0
  %next = getelementptr inbounds %struct.list_head* %list, i32 0, i32 0
  %15 = load %struct.list_head** %next, align 8
  store %struct.list_head* %15, %struct.list_head** %__mptr, align 8
  %16 = load %struct.list_head** %__mptr, align 8
  %17 = bitcast %struct.list_head* %16 to i8*
  %add.ptr = getelementptr i8* %17, i64 0
  %18 = bitcast i8* %add.ptr to %struct.netdev_hw_addr*
  store %struct.netdev_hw_addr* %18, %struct.netdev_hw_addr** %ha, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then8
  %19 = load %struct.netdev_hw_addr** %ha, align 8
  %list10 = getelementptr inbounds %struct.netdev_hw_addr* %19, i32 0, i32 0
  %20 = load %struct.net_device** %netdev.addr, align 8
  %uc11 = getelementptr inbounds %struct.net_device* %20, i32 0, i32 52
  %list12 = getelementptr inbounds %struct.netdev_hw_addr_list* %uc11, i32 0, i32 0
  %cmp13 = icmp ne %struct.list_head* %list10, %list12
  br i1 %cmp13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %21 = load i32* %rar_entries, align 4
  %tobool15 = icmp ne i32 %21, 0
  br i1 %tobool15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %for.body
  br label %for.end

if.end17:                                         ; preds = %for.body
  %22 = load %struct.igb_adapter** %adapter, align 8
  %23 = load %struct.netdev_hw_addr** %ha, align 8
  %addr = getelementptr inbounds %struct.netdev_hw_addr* %23, i32 0, i32 1
  %arraydecay = getelementptr inbounds [32 x i8]* %addr, i32 0, i32 0
  %24 = load i32* %rar_entries, align 4
  %dec = add i32 %24, -1
  store i32 %dec, i32* %rar_entries, align 4
  %25 = load i32* %vfn, align 4
  %conv18 = trunc i32 %25 to i8
  call void @igb_rar_set_qsel(%struct.igb_adapter* %22, i8* %arraydecay, i32 %24, i8 zeroext %conv18) noredzone
  %26 = load i32* %count, align 4
  %inc = add i32 %26, 1
  store i32 %inc, i32* %count, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end17
  %27 = load %struct.netdev_hw_addr** %ha, align 8
  %list20 = getelementptr inbounds %struct.netdev_hw_addr* %27, i32 0, i32 0
  %next21 = getelementptr inbounds %struct.list_head* %list20, i32 0, i32 0
  %28 = load %struct.list_head** %next21, align 8
  store %struct.list_head* %28, %struct.list_head** %__mptr19, align 8
  %29 = load %struct.list_head** %__mptr19, align 8
  %30 = bitcast %struct.list_head* %29 to i8*
  %add.ptr22 = getelementptr i8* %30, i64 0
  %31 = bitcast i8* %add.ptr22 to %struct.netdev_hw_addr*
  store %struct.netdev_hw_addr* %31, %struct.netdev_hw_addr** %ha, align 8
  br label %for.cond

for.end:                                          ; preds = %if.then16, %for.cond
  br label %if.end23

if.end23:                                         ; preds = %for.end, %land.lhs.true, %if.end
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc71, %if.end23
  %32 = load i32* %rar_entries, align 4
  %cmp25 = icmp ugt i32 %32, 0
  br i1 %cmp25, label %for.body27, label %for.end73

for.body27:                                       ; preds = %for.cond24
  br label %do.body

do.body:                                          ; preds = %for.body27
  %33 = load %struct.e1000_hw** %hw, align 8
  %hw_addr28 = getelementptr inbounds %struct.e1000_hw* %33, i32 0, i32 1
  %34 = load volatile i8** %hw_addr28, align 8
  store i8* %34, i8** %hw_addr, align 8
  %35 = load i8** %hw_addr, align 8
  %tobool29 = icmp ne i8* %35, null
  %lnot = xor i1 %tobool29, true
  %lnot30 = xor i1 %lnot, true
  %lnot31 = xor i1 %lnot30, true
  %lnot.ext = zext i1 %lnot31 to i32
  %conv32 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv32, i64 0)
  %tobool33 = icmp ne i64 %expval, 0
  br i1 %tobool33, label %if.end41, label %if.then34

if.then34:                                        ; preds = %do.body
  %36 = load i32* %rar_entries, align 4
  %cmp35 = icmp ule i32 %36, 15
  br i1 %cmp35, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then34
  %37 = load i32* %rar_entries, align 4
  %mul = mul i32 %37, 8
  %add37 = add i32 21508, %mul
  br label %cond.end

cond.false:                                       ; preds = %if.then34
  %38 = load i32* %rar_entries, align 4
  %sub38 = sub i32 %38, 16
  %mul39 = mul i32 %sub38, 8
  %add40 = add i32 21732, %mul39
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add37, %cond.true ], [ %add40, %cond.false ]
  %idxprom = zext i32 %cond to i64
  %39 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %39, i64 %idxprom
  call void @writel(i32 0, i8* %arrayidx) noredzone
  br label %if.end41

if.end41:                                         ; preds = %cond.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end41
  br label %do.body42

do.body42:                                        ; preds = %do.end
  %40 = load %struct.e1000_hw** %hw, align 8
  %hw_addr44 = getelementptr inbounds %struct.e1000_hw* %40, i32 0, i32 1
  %41 = load volatile i8** %hw_addr44, align 8
  store i8* %41, i8** %hw_addr43, align 8
  %42 = load i8** %hw_addr43, align 8
  %tobool45 = icmp ne i8* %42, null
  %lnot46 = xor i1 %tobool45, true
  %lnot48 = xor i1 %lnot46, true
  %lnot50 = xor i1 %lnot48, true
  %lnot.ext51 = zext i1 %lnot50 to i32
  %conv52 = sext i32 %lnot.ext51 to i64
  %expval53 = call i64 @llvm.expect.i64(i64 %conv52, i64 0)
  %tobool54 = icmp ne i64 %expval53, 0
  br i1 %tobool54, label %if.end69, label %if.then55

if.then55:                                        ; preds = %do.body42
  %43 = load i32* %rar_entries, align 4
  %cmp56 = icmp ule i32 %43, 15
  br i1 %cmp56, label %cond.true58, label %cond.false61

cond.true58:                                      ; preds = %if.then55
  %44 = load i32* %rar_entries, align 4
  %mul59 = mul i32 %44, 8
  %add60 = add i32 21504, %mul59
  br label %cond.end65

cond.false61:                                     ; preds = %if.then55
  %45 = load i32* %rar_entries, align 4
  %sub62 = sub i32 %45, 16
  %mul63 = mul i32 %sub62, 8
  %add64 = add i32 21728, %mul63
  br label %cond.end65

cond.end65:                                       ; preds = %cond.false61, %cond.true58
  %cond66 = phi i32 [ %add60, %cond.true58 ], [ %add64, %cond.false61 ]
  %idxprom67 = zext i32 %cond66 to i64
  %46 = load i8** %hw_addr43, align 8
  %arrayidx68 = getelementptr i8* %46, i64 %idxprom67
  call void @writel(i32 0, i8* %arrayidx68) noredzone
  br label %if.end69

if.end69:                                         ; preds = %cond.end65, %do.body42
  br label %do.end70

do.end70:                                         ; preds = %if.end69
  br label %for.inc71

for.inc71:                                        ; preds = %do.end70
  %47 = load i32* %rar_entries, align 4
  %dec72 = add i32 %47, -1
  store i32 %dec72, i32* %rar_entries, align 4
  br label %for.cond24

for.end73:                                        ; preds = %for.cond24
  %48 = load %struct.e1000_hw** %hw, align 8
  %call74 = call i32 @igb_rd32(%struct.e1000_hw* %48, i32 8) noredzone
  %49 = load i32* %count, align 4
  store i32 %49, i32* %retval
  br label %return

return:                                           ; preds = %for.end73, %if.then
  %50 = load i32* %retval
  ret i32 %50
}

define internal void @igb_restore_vf_multicasts(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %vf_data = alloca %struct.vf_data_storage*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %vmolr = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc32, %entry
  %1 = load i32* %i, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 49
  %3 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp ult i32 %1, %3
  br i1 %cmp, label %for.body, label %for.end34

for.body:                                         ; preds = %for.cond
  %4 = load %struct.e1000_hw** %hw, align 8
  %5 = load i32* %i, align 4
  %mul = mul i32 4, %5
  %add = add i32 23248, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %4, i32 %add) noredzone
  store i32 %call, i32* %vmolr, align 4
  %6 = load i32* %vmolr, align 4
  %and = and i32 %6, -301989889
  store i32 %and, i32* %vmolr, align 4
  %7 = load i32* %i, align 4
  %idxprom = sext i32 %7 to i64
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data2 = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 50
  %9 = load %struct.vf_data_storage** %vf_data2, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %9, i64 %idxprom
  store %struct.vf_data_storage* %arrayidx, %struct.vf_data_storage** %vf_data, align 8
  %10 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %10, i32 0, i32 2
  %11 = load i16* %num_vf_mc_hashes, align 2
  %conv = zext i16 %11 to i32
  %cmp3 = icmp sgt i32 %conv, 30
  br i1 %cmp3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %12 = load %struct.vf_data_storage** %vf_data, align 8
  %flags = getelementptr inbounds %struct.vf_data_storage* %12, i32 0, i32 4
  %13 = load i32* %flags, align 4
  %and5 = and i32 %13, 4
  %tobool = icmp ne i32 %and5, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %lor.lhs.false, %for.body
  %14 = load i32* %vmolr, align 4
  %or = or i32 %14, 268435456
  store i32 %or, i32* %vmolr, align 4
  br label %if.end19

if.else:                                          ; preds = %lor.lhs.false
  %15 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes6 = getelementptr inbounds %struct.vf_data_storage* %15, i32 0, i32 2
  %16 = load i16* %num_vf_mc_hashes6, align 2
  %tobool7 = icmp ne i16 %16, 0
  br i1 %tobool7, label %if.then8, label %if.end

if.then8:                                         ; preds = %if.else
  %17 = load i32* %vmolr, align 4
  %or9 = or i32 %17, 33554432
  store i32 %or9, i32* %vmolr, align 4
  store i32 0, i32* %j, align 4
  br label %for.cond10

for.cond10:                                       ; preds = %for.inc, %if.then8
  %18 = load i32* %j, align 4
  %19 = load %struct.vf_data_storage** %vf_data, align 8
  %num_vf_mc_hashes11 = getelementptr inbounds %struct.vf_data_storage* %19, i32 0, i32 2
  %20 = load i16* %num_vf_mc_hashes11, align 2
  %conv12 = zext i16 %20 to i32
  %cmp13 = icmp slt i32 %18, %conv12
  br i1 %cmp13, label %for.body15, label %for.end

for.body15:                                       ; preds = %for.cond10
  %21 = load %struct.e1000_hw** %hw, align 8
  %22 = load i32* %j, align 4
  %idxprom16 = sext i32 %22 to i64
  %23 = load %struct.vf_data_storage** %vf_data, align 8
  %vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %23, i32 0, i32 1
  %arrayidx17 = getelementptr [30 x i16]* %vf_mc_hashes, i32 0, i64 %idxprom16
  %24 = load i16* %arrayidx17, align 2
  %conv18 = zext i16 %24 to i32
  call void @igb_mta_set(%struct.e1000_hw* %21, i32 %conv18) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body15
  %25 = load i32* %j, align 4
  %inc = add i32 %25, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond10

for.end:                                          ; preds = %for.cond10
  br label %if.end

if.end:                                           ; preds = %for.end, %if.else
  br label %if.end19

if.end19:                                         ; preds = %if.end, %if.then
  br label %do.body

do.body:                                          ; preds = %if.end19
  %26 = load %struct.e1000_hw** %hw, align 8
  %hw_addr20 = getelementptr inbounds %struct.e1000_hw* %26, i32 0, i32 1
  %27 = load volatile i8** %hw_addr20, align 8
  store i8* %27, i8** %hw_addr, align 8
  %28 = load i8** %hw_addr, align 8
  %tobool21 = icmp ne i8* %28, null
  %lnot = xor i1 %tobool21, true
  %lnot22 = xor i1 %lnot, true
  %lnot23 = xor i1 %lnot22, true
  %lnot.ext = zext i1 %lnot23 to i32
  %conv24 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool25 = icmp ne i64 %expval, 0
  br i1 %tobool25, label %if.end31, label %if.then26

if.then26:                                        ; preds = %do.body
  %29 = load i32* %vmolr, align 4
  %30 = load i32* %i, align 4
  %mul27 = mul i32 4, %30
  %add28 = add i32 23248, %mul27
  %idxprom29 = sext i32 %add28 to i64
  %31 = load i8** %hw_addr, align 8
  %arrayidx30 = getelementptr i8* %31, i64 %idxprom29
  call void @writel(i32 %29, i8* %arrayidx30) noredzone
  br label %if.end31

if.end31:                                         ; preds = %if.then26, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end31
  br label %for.inc32

for.inc32:                                        ; preds = %do.end
  %32 = load i32* %i, align 4
  %inc33 = add i32 %32, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond

for.end34:                                        ; preds = %for.cond
  ret void
}

declare void @igb_mta_set(%struct.e1000_hw*, i32) noredzone

define internal void @igb_rar_set_qsel(%struct.igb_adapter* %adapter, i8* %addr, i32 %index, i8 zeroext %qsel) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %addr.addr = alloca i8*, align 8
  %index.addr = alloca i32, align 4
  %qsel.addr = alloca i8, align 1
  %rar_low = alloca i32, align 4
  %rar_high = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  %hw_addr39 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i8* %addr, i8** %addr.addr, align 8
  store i32 %index, i32* %index.addr, align 4
  store i8 %qsel, i8* %qsel.addr, align 1
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i8** %addr.addr, align 8
  %arrayidx = getelementptr i8* %1, i64 0
  %2 = load i8* %arrayidx, align 1
  %conv = zext i8 %2 to i32
  %3 = load i8** %addr.addr, align 8
  %arrayidx2 = getelementptr i8* %3, i64 1
  %4 = load i8* %arrayidx2, align 1
  %conv3 = zext i8 %4 to i32
  %shl = shl i32 %conv3, 8
  %or = or i32 %conv, %shl
  %5 = load i8** %addr.addr, align 8
  %arrayidx4 = getelementptr i8* %5, i64 2
  %6 = load i8* %arrayidx4, align 1
  %conv5 = zext i8 %6 to i32
  %shl6 = shl i32 %conv5, 16
  %or7 = or i32 %or, %shl6
  %7 = load i8** %addr.addr, align 8
  %arrayidx8 = getelementptr i8* %7, i64 3
  %8 = load i8* %arrayidx8, align 1
  %conv9 = zext i8 %8 to i32
  %shl10 = shl i32 %conv9, 24
  %or11 = or i32 %or7, %shl10
  store i32 %or11, i32* %rar_low, align 4
  %9 = load i8** %addr.addr, align 8
  %arrayidx12 = getelementptr i8* %9, i64 4
  %10 = load i8* %arrayidx12, align 1
  %conv13 = zext i8 %10 to i32
  %11 = load i8** %addr.addr, align 8
  %arrayidx14 = getelementptr i8* %11, i64 5
  %12 = load i8* %arrayidx14, align 1
  %conv15 = zext i8 %12 to i32
  %shl16 = shl i32 %conv15, 8
  %or17 = or i32 %conv13, %shl16
  store i32 %or17, i32* %rar_high, align 4
  %13 = load i32* %rar_high, align 4
  %or18 = or i32 %13, -2147483648
  store i32 %or18, i32* %rar_high, align 4
  %14 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %15 = load i32* %type, align 4
  %cmp = icmp eq i32 %15, 1
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %16 = load i8* %qsel.addr, align 1
  %conv20 = zext i8 %16 to i32
  %mul = mul i32 262144, %conv20
  %17 = load i32* %rar_high, align 4
  %or21 = or i32 %17, %mul
  store i32 %or21, i32* %rar_high, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %18 = load i8* %qsel.addr, align 1
  %conv22 = zext i8 %18 to i32
  %shl23 = shl i32 262144, %conv22
  %19 = load i32* %rar_high, align 4
  %or24 = or i32 %19, %shl23
  store i32 %or24, i32* %rar_high, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %20 = load %struct.e1000_hw** %hw, align 8
  %hw_addr25 = getelementptr inbounds %struct.e1000_hw* %20, i32 0, i32 1
  %21 = load volatile i8** %hw_addr25, align 8
  store i8* %21, i8** %hw_addr, align 8
  %22 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %22, null
  %lnot = xor i1 %tobool, true
  %lnot26 = xor i1 %lnot, true
  %lnot27 = xor i1 %lnot26, true
  %lnot.ext = zext i1 %lnot27 to i32
  %conv28 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool29 = icmp ne i64 %expval, 0
  br i1 %tobool29, label %if.end37, label %if.then30

if.then30:                                        ; preds = %do.body
  %23 = load i32* %rar_low, align 4
  %24 = load i32* %index.addr, align 4
  %cmp31 = icmp ule i32 %24, 15
  br i1 %cmp31, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then30
  %25 = load i32* %index.addr, align 4
  %mul33 = mul i32 %25, 8
  %add = add i32 21504, %mul33
  br label %cond.end

cond.false:                                       ; preds = %if.then30
  %26 = load i32* %index.addr, align 4
  %sub = sub i32 %26, 16
  %mul34 = mul i32 %sub, 8
  %add35 = add i32 21728, %mul34
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ %add35, %cond.false ]
  %idxprom = zext i32 %cond to i64
  %27 = load i8** %hw_addr, align 8
  %arrayidx36 = getelementptr i8* %27, i64 %idxprom
  call void @writel(i32 %23, i8* %arrayidx36) noredzone
  br label %if.end37

if.end37:                                         ; preds = %cond.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end37
  %28 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %28, i32 8) noredzone
  br label %do.body38

do.body38:                                        ; preds = %do.end
  %29 = load %struct.e1000_hw** %hw, align 8
  %hw_addr40 = getelementptr inbounds %struct.e1000_hw* %29, i32 0, i32 1
  %30 = load volatile i8** %hw_addr40, align 8
  store i8* %30, i8** %hw_addr39, align 8
  %31 = load i8** %hw_addr39, align 8
  %tobool41 = icmp ne i8* %31, null
  %lnot42 = xor i1 %tobool41, true
  %lnot44 = xor i1 %lnot42, true
  %lnot46 = xor i1 %lnot44, true
  %lnot.ext47 = zext i1 %lnot46 to i32
  %conv48 = sext i32 %lnot.ext47 to i64
  %expval49 = call i64 @llvm.expect.i64(i64 %conv48, i64 0)
  %tobool50 = icmp ne i64 %expval49, 0
  br i1 %tobool50, label %if.end65, label %if.then51

if.then51:                                        ; preds = %do.body38
  %32 = load i32* %rar_high, align 4
  %33 = load i32* %index.addr, align 4
  %cmp52 = icmp ule i32 %33, 15
  br i1 %cmp52, label %cond.true54, label %cond.false57

cond.true54:                                      ; preds = %if.then51
  %34 = load i32* %index.addr, align 4
  %mul55 = mul i32 %34, 8
  %add56 = add i32 21508, %mul55
  br label %cond.end61

cond.false57:                                     ; preds = %if.then51
  %35 = load i32* %index.addr, align 4
  %sub58 = sub i32 %35, 16
  %mul59 = mul i32 %sub58, 8
  %add60 = add i32 21732, %mul59
  br label %cond.end61

cond.end61:                                       ; preds = %cond.false57, %cond.true54
  %cond62 = phi i32 [ %add56, %cond.true54 ], [ %add60, %cond.false57 ]
  %idxprom63 = zext i32 %cond62 to i64
  %36 = load i8** %hw_addr39, align 8
  %arrayidx64 = getelementptr i8* %36, i64 %idxprom63
  call void @writel(i32 %32, i8* %arrayidx64) noredzone
  br label %if.end65

if.end65:                                         ; preds = %cond.end61, %do.body38
  br label %do.end66

do.end66:                                         ; preds = %if.end65
  %37 = load %struct.e1000_hw** %hw, align 8
  %call67 = call i32 @igb_rd32(%struct.e1000_hw* %37, i32 8) noredzone
  ret void
}

declare void @igb_update_mc_addr_list(%struct.e1000_hw*, i8*, i32) noredzone

define internal i8* @kzalloc(i64 %size, i32 %flags) nounwind inlinehint noredzone {
entry:
  %size.addr.i = alloca i64, align 8
  %flags.addr.i = alloca i32, align 4
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64* %size.addr, align 8
  %1 = load i32* %flags.addr, align 4
  %or = or i32 %1, 32768
  store i64 %0, i64* %size.addr.i, align 8
  store i32 %or, i32* %flags.addr.i, align 4
  %2 = load i64* %size.addr.i, align 8
  %3 = load i32* %flags.addr.i, align 4
  %call.i = call i8* @__kmalloc(i64 %2, i32 %3) nounwind noredzone
  ret i8* %call.i
}

declare i8* @__memcpy(i8*, i8*, i64) noredzone

declare void @llvm.memcpy.p0i8.p0i8.i64(i8* nocapture, i8* nocapture, i64, i32, i1) nounwind

declare i8* @__kmalloc(i64, i32) noredzone

define internal zeroext i1 @is_valid_ether_addr(i8* %addr) nounwind inlinehint noredzone {
entry:
  %addr.addr = alloca i8*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8** %addr.addr, align 8
  %call = call zeroext i1 @is_multicast_ether_addr(i8* %0) noredzone
  br i1 %call, label %land.end, label %land.rhs

land.rhs:                                         ; preds = %entry
  %1 = load i8** %addr.addr, align 8
  %call1 = call zeroext i1 @is_zero_ether_addr(i8* %1) noredzone
  %lnot = xor i1 %call1, true
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %2 = phi i1 [ false, %entry ], [ %lnot, %land.rhs ]
  ret i1 %2
}

define internal i32 @igb_set_vf_mac(%struct.igb_adapter* %adapter, i32 %vf, i8* %mac_addr) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %mac_addr.addr = alloca i8*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %rar_entry = alloca i32, align 4
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  store i8* %mac_addr, i8** %mac_addr.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %rar_entry_count = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 12
  %2 = load i16* %rar_entry_count, align 2
  %conv = zext i16 %2 to i32
  %3 = load i32* %vf.addr, align 4
  %add = add i32 %3, 1
  %sub = sub i32 %conv, %add
  store i32 %sub, i32* %rar_entry, align 4
  store i64 6, i64* %__len, align 8
  %4 = load i64* %__len, align 8
  %cmp = icmp uge i64 %4, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i32* %vf.addr, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 50
  %7 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %7, i64 %idxprom
  %vf_mac_addresses = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [6 x i8]* %vf_mac_addresses, i32 0, i32 0
  %8 = load i8** %mac_addr.addr, align 8
  %9 = load i64* %__len, align 8
  %call = call i8* @__memcpy(i8* %arraydecay, i8* %8, i64 %9) noredzone
  store i8* %call, i8** %__ret, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %10 = load i32* %vf.addr, align 4
  %idxprom3 = sext i32 %10 to i64
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data4 = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 50
  %12 = load %struct.vf_data_storage** %vf_data4, align 8
  %arrayidx5 = getelementptr %struct.vf_data_storage* %12, i64 %idxprom3
  %vf_mac_addresses6 = getelementptr inbounds %struct.vf_data_storage* %arrayidx5, i32 0, i32 0
  %13 = bitcast [6 x i8]* %vf_mac_addresses6 to i8*
  %14 = load i8** %mac_addr.addr, align 8
  %15 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %13, i8* %14, i64 %15, i32 1, i1 false)
  store i8* %13, i8** %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load i8** %__ret, align 8
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %18 = load i8** %mac_addr.addr, align 8
  %19 = load i32* %rar_entry, align 4
  %20 = load i32* %vf.addr, align 4
  %conv7 = trunc i32 %20 to i8
  call void @igb_rar_set_qsel(%struct.igb_adapter* %17, i8* %18, i32 %19, i8 zeroext %conv7) noredzone
  ret i32 0
}

define internal zeroext i1 @is_multicast_ether_addr(i8* %addr) nounwind inlinehint noredzone {
entry:
  %addr.addr = alloca i8*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8** %addr.addr, align 8
  %arrayidx = getelementptr i8* %0, i64 0
  %1 = load i8* %arrayidx, align 1
  %conv = zext i8 %1 to i32
  %and = and i32 1, %conv
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

define internal zeroext i1 @is_zero_ether_addr(i8* %addr) nounwind inlinehint noredzone {
entry:
  %addr.addr = alloca i8*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8** %addr.addr, align 8
  %1 = bitcast i8* %0 to i32*
  %2 = load i32* %1, align 4
  %3 = load i8** %addr.addr, align 8
  %add.ptr = getelementptr i8* %3, i64 4
  %4 = bitcast i8* %add.ptr to i16*
  %5 = load i16* %4, align 2
  %conv = zext i16 %5 to i32
  %or = or i32 %2, %conv
  %cmp = icmp eq i32 %or, 0
  ret i1 %cmp
}

define internal void @igb_vf_reset(%struct.igb_adapter* %adapter, i32 %vf) nounwind inlinehint noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load i32* %vf.addr, align 4
  %idxprom = zext i32 %0 to i64
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 50
  %2 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %2, i64 %idxprom
  %flags = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 4
  %3 = load i32* %flags, align 4
  %and = and i32 %3, 8
  store i32 %and, i32* %flags, align 4
  %4 = load volatile i64* @jiffies, align 8
  %5 = load i32* %vf.addr, align 4
  %idxprom1 = zext i32 %5 to i64
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data2 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 50
  %7 = load %struct.vf_data_storage** %vf_data2, align 8
  %arrayidx3 = getelementptr %struct.vf_data_storage* %7, i64 %idxprom1
  %last_nack = getelementptr inbounds %struct.vf_data_storage* %arrayidx3, i32 0, i32 5
  store i64 %4, i64* %last_nack, align 8
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %9 = load i32* %vf.addr, align 4
  call void @igb_set_vmolr(%struct.igb_adapter* %8, i32 %9, i1 zeroext true) noredzone
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %11 = load i32* %vf.addr, align 4
  call void @igb_clear_vf_vfta(%struct.igb_adapter* %10, i32 %11) noredzone
  %12 = load i32* %vf.addr, align 4
  %idxprom4 = zext i32 %12 to i64
  %13 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data5 = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 50
  %14 = load %struct.vf_data_storage** %vf_data5, align 8
  %arrayidx6 = getelementptr %struct.vf_data_storage* %14, i64 %idxprom4
  %pf_vlan = getelementptr inbounds %struct.vf_data_storage* %arrayidx6, i32 0, i32 6
  %15 = load i16* %pf_vlan, align 2
  %tobool = icmp ne i16 %15, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 1
  %17 = load %struct.net_device** %netdev, align 8
  %18 = load i32* %vf.addr, align 4
  %19 = load i32* %vf.addr, align 4
  %idxprom7 = zext i32 %19 to i64
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data8 = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 50
  %21 = load %struct.vf_data_storage** %vf_data8, align 8
  %arrayidx9 = getelementptr %struct.vf_data_storage* %21, i64 %idxprom7
  %pf_vlan10 = getelementptr inbounds %struct.vf_data_storage* %arrayidx9, i32 0, i32 6
  %22 = load i16* %pf_vlan10, align 2
  %23 = load i32* %vf.addr, align 4
  %idxprom11 = zext i32 %23 to i64
  %24 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data12 = getelementptr inbounds %struct.igb_adapter* %24, i32 0, i32 50
  %25 = load %struct.vf_data_storage** %vf_data12, align 8
  %arrayidx13 = getelementptr %struct.vf_data_storage* %25, i64 %idxprom11
  %pf_qos = getelementptr inbounds %struct.vf_data_storage* %arrayidx13, i32 0, i32 7
  %26 = load i16* %pf_qos, align 2
  %conv = trunc i16 %26 to i8
  %call = call i32 @igb_ndo_set_vf_vlan(%struct.net_device* %17, i32 %18, i16 zeroext %22, i8 zeroext %conv) noredzone
  br label %if.end

if.else:                                          ; preds = %entry
  %27 = load %struct.igb_adapter** %adapter.addr, align 8
  %28 = load i32* %vf.addr, align 4
  call void @igb_clear_vf_vfta(%struct.igb_adapter* %27, i32 %28) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %29 = load i32* %vf.addr, align 4
  %idxprom14 = zext i32 %29 to i64
  %30 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data15 = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 50
  %31 = load %struct.vf_data_storage** %vf_data15, align 8
  %arrayidx16 = getelementptr %struct.vf_data_storage* %31, i64 %idxprom14
  %num_vf_mc_hashes = getelementptr inbounds %struct.vf_data_storage* %arrayidx16, i32 0, i32 2
  store i16 0, i16* %num_vf_mc_hashes, align 2
  %32 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev17 = getelementptr inbounds %struct.igb_adapter* %32, i32 0, i32 1
  %33 = load %struct.net_device** %netdev17, align 8
  call void @igb_set_rx_mode(%struct.net_device* %33) noredzone
  ret void
}

define internal void @igb_clear_vf_vfta(%struct.igb_adapter* %adapter, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %pool_mask = alloca i32, align 4
  %reg = alloca i32, align 4
  %vid = alloca i32, align 4
  %i = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i32* %vf.addr, align 4
  %add = add i32 12, %1
  %shl = shl i32 1, %add
  store i32 %shl, i32* %pool_mask, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32* %i, align 4
  %cmp = icmp slt i32 %2, 32
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.e1000_hw** %hw, align 8
  %4 = load i32* %i, align 4
  %mul = mul i32 4, %4
  %add2 = add i32 23808, %mul
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 %add2) noredzone
  store i32 %call, i32* %reg, align 4
  %5 = load i32* %pool_mask, align 4
  %neg = xor i32 %5, -1
  %6 = load i32* %reg, align 4
  %and = and i32 %6, %neg
  store i32 %and, i32* %reg, align 4
  %7 = load i32* %reg, align 4
  %and3 = and i32 %7, 1044480
  %tobool = icmp ne i32 %and3, 0
  br i1 %tobool, label %if.end, label %land.lhs.true

land.lhs.true:                                    ; preds = %for.body
  %8 = load i32* %reg, align 4
  %and4 = and i32 %8, -2147483648
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i32 0, i32* %reg, align 4
  %9 = load i32* %reg, align 4
  %and6 = and i32 %9, 4095
  store i32 %and6, i32* %vid, align 4
  %10 = load %struct.e1000_hw** %hw, align 8
  %11 = load i32* %vid, align 4
  %call7 = call i32 @igb_vfta_set(%struct.e1000_hw* %10, i32 %11, i1 zeroext false) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %for.body
  br label %do.body

do.body:                                          ; preds = %if.end
  %12 = load %struct.e1000_hw** %hw, align 8
  %hw_addr8 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 1
  %13 = load volatile i8** %hw_addr8, align 8
  store i8* %13, i8** %hw_addr, align 8
  %14 = load i8** %hw_addr, align 8
  %tobool9 = icmp ne i8* %14, null
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot11 = xor i1 %lnot10, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.end16, label %if.then13

if.then13:                                        ; preds = %do.body
  %15 = load i32* %reg, align 4
  %16 = load i32* %i, align 4
  %mul14 = mul i32 4, %16
  %add15 = add i32 23808, %mul14
  %idxprom = sext i32 %add15 to i64
  %17 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %17, i64 %idxprom
  call void @writel(i32 %15, i8* %arrayidx) noredzone
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end16
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %18 = load i32* %i, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %19 = load i32* %vf.addr, align 4
  %idxprom17 = zext i32 %19 to i64
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 50
  %21 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx18 = getelementptr %struct.vf_data_storage* %21, i64 %idxprom17
  %vlans_enabled = getelementptr inbounds %struct.vf_data_storage* %arrayidx18, i32 0, i32 3
  store i16 0, i16* %vlans_enabled, align 2
  ret void
}

define internal i32 @igb_ndo_set_vf_vlan(%struct.net_device* %netdev, i32 %vf, i16 zeroext %vlan, i8 zeroext %qos) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %vf.addr = alloca i32, align 4
  %vlan.addr = alloca i16, align 2
  %qos.addr = alloca i8, align 1
  %err = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  store i16 %vlan, i16* %vlan.addr, align 2
  store i8 %qos, i8* %qos.addr, align 1
  store i32 0, i32* %err, align 4
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load i32* %vf.addr, align 4
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp uge i32 %2, %4
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load i16* %vlan.addr, align 2
  %conv = zext i16 %5 to i32
  %cmp1 = icmp sgt i32 %conv, 4095
  br i1 %cmp1, label %if.then, label %lor.lhs.false3

lor.lhs.false3:                                   ; preds = %lor.lhs.false
  %6 = load i8* %qos.addr, align 1
  %conv4 = zext i8 %6 to i32
  %cmp5 = icmp sgt i32 %conv4, 7
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false3, %lor.lhs.false, %entry
  store i32 -22, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false3
  %7 = load i16* %vlan.addr, align 2
  %conv7 = zext i16 %7 to i32
  %tobool = icmp ne i32 %conv7, 0
  br i1 %tobool, label %if.then11, label %lor.lhs.false8

lor.lhs.false8:                                   ; preds = %if.end
  %8 = load i8* %qos.addr, align 1
  %conv9 = zext i8 %8 to i32
  %tobool10 = icmp ne i32 %conv9, 0
  br i1 %tobool10, label %if.then11, label %if.else

if.then11:                                        ; preds = %lor.lhs.false8, %if.end
  %9 = load %struct.igb_adapter** %adapter, align 8
  %10 = load i16* %vlan.addr, align 2
  %conv12 = zext i16 %10 to i32
  %11 = load i16* %vlan.addr, align 2
  %tobool13 = icmp ne i16 %11, 0
  %lnot = xor i1 %tobool13, true
  %lnot14 = xor i1 %lnot, true
  %12 = load i32* %vf.addr, align 4
  %call15 = call i32 @igb_vlvf_set(%struct.igb_adapter* %9, i32 %conv12, i1 zeroext %lnot14, i32 %12) noredzone
  store i32 %call15, i32* %err, align 4
  %13 = load i32* %err, align 4
  %tobool16 = icmp ne i32 %13, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.then11
  br label %out

if.end18:                                         ; preds = %if.then11
  %14 = load %struct.igb_adapter** %adapter, align 8
  %15 = load i16* %vlan.addr, align 2
  %conv19 = zext i16 %15 to i32
  %16 = load i8* %qos.addr, align 1
  %conv20 = zext i8 %16 to i32
  %shl = shl i32 %conv20, 13
  %or = or i32 %conv19, %shl
  %17 = load i32* %vf.addr, align 4
  call void @igb_set_vmvir(%struct.igb_adapter* %14, i32 %or, i32 %17) noredzone
  %18 = load %struct.igb_adapter** %adapter, align 8
  %19 = load i32* %vf.addr, align 4
  %20 = load i16* %vlan.addr, align 2
  %tobool21 = icmp ne i16 %20, 0
  %lnot22 = xor i1 %tobool21, true
  call void @igb_set_vmolr(%struct.igb_adapter* %18, i32 %19, i1 zeroext %lnot22) noredzone
  %21 = load i16* %vlan.addr, align 2
  %22 = load i32* %vf.addr, align 4
  %idxprom = sext i32 %22 to i64
  %23 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 50
  %24 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %24, i64 %idxprom
  %pf_vlan = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 6
  store i16 %21, i16* %pf_vlan, align 2
  %25 = load i8* %qos.addr, align 1
  %conv23 = zext i8 %25 to i16
  %26 = load i32* %vf.addr, align 4
  %idxprom24 = sext i32 %26 to i64
  %27 = load %struct.igb_adapter** %adapter, align 8
  %vf_data25 = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 50
  %28 = load %struct.vf_data_storage** %vf_data25, align 8
  %arrayidx26 = getelementptr %struct.vf_data_storage* %28, i64 %idxprom24
  %pf_qos = getelementptr inbounds %struct.vf_data_storage* %arrayidx26, i32 0, i32 7
  store i16 %conv23, i16* %pf_qos, align 2
  %29 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 32
  %30 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %30, i32 0, i32 33
  %31 = load i16* %vlan.addr, align 2
  %conv27 = zext i16 %31 to i32
  %32 = load i8* %qos.addr, align 1
  %conv28 = zext i8 %32 to i32
  %33 = load i32* %vf.addr, align 4
  %call29 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([36 x i8]* @.str21, i32 0, i32 0), i32 %conv27, i32 %conv28, i32 %33) noredzone
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end18
  %34 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %35 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %35, 63
  %shl.i = shl i64 1, %and.i
  %36 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %36, 6
  %37 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %37, i64 %shr.i
  %38 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %38
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool31 = icmp ne i32 %conv.i, 0
  br i1 %tobool31, label %if.then35, label %if.end42

cond.false:                                       ; preds = %if.end18
  %39 = load %struct.igb_adapter** %adapter, align 8
  %state32 = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 2
  %call33 = call i32 @variable_test_bit(i64 2, i64* %state32) noredzone
  %tobool34 = icmp ne i32 %call33, 0
  br i1 %tobool34, label %if.then35, label %if.end42

if.then35:                                        ; preds = %cond.false, %cond.true
  %40 = load %struct.igb_adapter** %adapter, align 8
  %pdev36 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 32
  %41 = load %struct.pci_dev** %pdev36, align 8
  %dev37 = getelementptr inbounds %struct.pci_dev* %41, i32 0, i32 33
  %call38 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev37, i8* getelementptr inbounds ([56 x i8]* @.str22, i32 0, i32 0)) noredzone
  %42 = load %struct.igb_adapter** %adapter, align 8
  %pdev39 = getelementptr inbounds %struct.igb_adapter* %42, i32 0, i32 32
  %43 = load %struct.pci_dev** %pdev39, align 8
  %dev40 = getelementptr inbounds %struct.pci_dev* %43, i32 0, i32 33
  %call41 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev40, i8* getelementptr inbounds ([64 x i8]* @.str23, i32 0, i32 0)) noredzone
  br label %if.end42

if.end42:                                         ; preds = %if.then35, %cond.false, %cond.true
  br label %if.end58

if.else:                                          ; preds = %lor.lhs.false8
  %44 = load %struct.igb_adapter** %adapter, align 8
  %45 = load i32* %vf.addr, align 4
  %idxprom43 = sext i32 %45 to i64
  %46 = load %struct.igb_adapter** %adapter, align 8
  %vf_data44 = getelementptr inbounds %struct.igb_adapter* %46, i32 0, i32 50
  %47 = load %struct.vf_data_storage** %vf_data44, align 8
  %arrayidx45 = getelementptr %struct.vf_data_storage* %47, i64 %idxprom43
  %pf_vlan46 = getelementptr inbounds %struct.vf_data_storage* %arrayidx45, i32 0, i32 6
  %48 = load i16* %pf_vlan46, align 2
  %conv47 = zext i16 %48 to i32
  %49 = load i32* %vf.addr, align 4
  %call48 = call i32 @igb_vlvf_set(%struct.igb_adapter* %44, i32 %conv47, i1 zeroext false, i32 %49) noredzone
  %50 = load %struct.igb_adapter** %adapter, align 8
  %51 = load i16* %vlan.addr, align 2
  %conv49 = zext i16 %51 to i32
  %52 = load i32* %vf.addr, align 4
  call void @igb_set_vmvir(%struct.igb_adapter* %50, i32 %conv49, i32 %52) noredzone
  %53 = load %struct.igb_adapter** %adapter, align 8
  %54 = load i32* %vf.addr, align 4
  call void @igb_set_vmolr(%struct.igb_adapter* %53, i32 %54, i1 zeroext true) noredzone
  %55 = load i32* %vf.addr, align 4
  %idxprom50 = sext i32 %55 to i64
  %56 = load %struct.igb_adapter** %adapter, align 8
  %vf_data51 = getelementptr inbounds %struct.igb_adapter* %56, i32 0, i32 50
  %57 = load %struct.vf_data_storage** %vf_data51, align 8
  %arrayidx52 = getelementptr %struct.vf_data_storage* %57, i64 %idxprom50
  %pf_vlan53 = getelementptr inbounds %struct.vf_data_storage* %arrayidx52, i32 0, i32 6
  store i16 0, i16* %pf_vlan53, align 2
  %58 = load i32* %vf.addr, align 4
  %idxprom54 = sext i32 %58 to i64
  %59 = load %struct.igb_adapter** %adapter, align 8
  %vf_data55 = getelementptr inbounds %struct.igb_adapter* %59, i32 0, i32 50
  %60 = load %struct.vf_data_storage** %vf_data55, align 8
  %arrayidx56 = getelementptr %struct.vf_data_storage* %60, i64 %idxprom54
  %pf_qos57 = getelementptr inbounds %struct.vf_data_storage* %arrayidx56, i32 0, i32 7
  store i16 0, i16* %pf_qos57, align 2
  br label %if.end58

if.end58:                                         ; preds = %if.else, %if.end42
  br label %out

out:                                              ; preds = %if.end58, %if.then17
  %61 = load i32* %err, align 4
  store i32 %61, i32* %retval
  br label %return

return:                                           ; preds = %out, %if.then
  %62 = load i32* %retval
  ret i32 %62
}

define internal void @igb_set_vmvir(%struct.igb_adapter* %adapter, i32 %vid, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vid.addr = alloca i32, align 4
  %vf.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  %hw_addr9 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vid, i32* %vid.addr, align 4
  store i32 %vf, i32* %vf.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load i32* %vid.addr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  br label %do.body

do.body:                                          ; preds = %if.then
  %2 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 1
  %3 = load volatile i8** %hw_addr2, align 8
  store i8* %3, i8** %hw_addr, align 8
  %4 = load i8** %hw_addr, align 8
  %tobool3 = icmp ne i8* %4, null
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end, label %if.then7

if.then7:                                         ; preds = %do.body
  %5 = load i32* %vid.addr, align 4
  %or = or i32 %5, 1073741824
  %6 = load i32* %vf.addr, align 4
  %mul = mul i32 4, %6
  %add = add i32 14080, %mul
  %idxprom = zext i32 %add to i64
  %7 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %7, i64 %idxprom
  call void @writel(i32 %or, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then7, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end28

if.else:                                          ; preds = %entry
  br label %do.body8

do.body8:                                         ; preds = %if.else
  %8 = load %struct.e1000_hw** %hw, align 8
  %hw_addr10 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr10, align 8
  store i8* %9, i8** %hw_addr9, align 8
  %10 = load i8** %hw_addr9, align 8
  %tobool11 = icmp ne i8* %10, null
  %lnot12 = xor i1 %tobool11, true
  %lnot14 = xor i1 %lnot12, true
  %lnot16 = xor i1 %lnot14, true
  %lnot.ext17 = zext i1 %lnot16 to i32
  %conv18 = sext i32 %lnot.ext17 to i64
  %expval19 = call i64 @llvm.expect.i64(i64 %conv18, i64 0)
  %tobool20 = icmp ne i64 %expval19, 0
  br i1 %tobool20, label %if.end26, label %if.then21

if.then21:                                        ; preds = %do.body8
  %11 = load i32* %vf.addr, align 4
  %mul22 = mul i32 4, %11
  %add23 = add i32 14080, %mul22
  %idxprom24 = zext i32 %add23 to i64
  %12 = load i8** %hw_addr9, align 8
  %arrayidx25 = getelementptr i8* %12, i64 %idxprom24
  call void @writel(i32 0, i8* %arrayidx25) noredzone
  br label %if.end26

if.end26:                                         ; preds = %if.then21, %do.body8
  br label %do.end27

do.end27:                                         ; preds = %if.end26
  br label %if.end28

if.end28:                                         ; preds = %do.end27, %do.end
  ret void
}

declare i32 @_dev_info(%struct.device*, i8*, ...) noredzone

define internal void @eth_zero_addr(i8* %addr) nounwind inlinehint noredzone {
entry:
  %addr.addr = alloca i8*, align 8
  store i8* %addr, i8** %addr.addr, align 8
  %0 = load i8** %addr.addr, align 8
  call void @llvm.memset.p0i8.i64(i8* %0, i8 0, i64 6, i32 1, i1 false)
  ret void
}

declare void @llvm.memset.p0i8.i64(i8* nocapture, i8, i64, i32, i1) nounwind

declare i32 @__pm_runtime_resume(%struct.device*, i32) noredzone

define internal void @igb_set_interrupt_capability(%struct.igb_adapter* %adapter, i1 zeroext %msix) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %msix.addr = alloca i8, align 1
  %err = alloca i32, align 4
  %numvecs = alloca i32, align 4
  %i = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %frombool = zext i1 %msix to i8
  store i8 %frombool, i8* %msix.addr, align 1
  %0 = load i8* %msix.addr, align 1
  %tobool = trunc i8 %0 to i1
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %msi_only

if.end:                                           ; preds = %entry
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 3
  %2 = load i32* %flags, align 4
  %or = or i32 %2, 8192
  store i32 %or, i32* %flags, align 4
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 52
  %4 = load i32* %rss_queues, align 4
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 14
  store i32 %4, i32* %num_rx_queues, align 4
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 49
  %7 = load i32* %vfs_allocated_count, align 4
  %tobool1 = icmp ne i32 %7, 0
  br i1 %tobool1, label %if.then2, label %if.else

if.then2:                                         ; preds = %if.end
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 12
  store i32 1, i32* %num_tx_queues, align 4
  br label %if.end5

if.else:                                          ; preds = %if.end
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues3 = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 52
  %10 = load i32* %rss_queues3, align 4
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues4 = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 12
  store i32 %10, i32* %num_tx_queues4, align 4
  br label %if.end5

if.end5:                                          ; preds = %if.else, %if.then2
  %12 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues6 = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 14
  %13 = load i32* %num_rx_queues6, align 4
  store i32 %13, i32* %numvecs, align 4
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags7 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 3
  %15 = load i32* %flags7, align 4
  %and = and i32 %15, 8
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %if.end11, label %if.then9

if.then9:                                         ; preds = %if.end5
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues10 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 12
  %17 = load i32* %num_tx_queues10, align 4
  %18 = load i32* %numvecs, align 4
  %add = add i32 %18, %17
  store i32 %add, i32* %numvecs, align 4
  br label %if.end11

if.end11:                                         ; preds = %if.then9, %if.end5
  %19 = load i32* %numvecs, align 4
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 4
  store i32 %19, i32* %num_q_vectors, align 4
  %21 = load i32* %numvecs, align 4
  %inc = add i32 %21, 1
  store i32 %inc, i32* %numvecs, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end11
  %22 = load i32* %i, align 4
  %23 = load i32* %numvecs, align 4
  %cmp = icmp slt i32 %22, %23
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %24 = load i32* %i, align 4
  %conv = trunc i32 %24 to i16
  %25 = load i32* %i, align 4
  %idxprom = sext i32 %25 to i64
  %26 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries = getelementptr inbounds %struct.igb_adapter* %26, i32 0, i32 5
  %arrayidx = getelementptr [10 x %struct.msix_entry]* %msix_entries, i32 0, i64 %idxprom
  %entry12 = getelementptr inbounds %struct.msix_entry* %arrayidx, i32 0, i32 1
  store i16 %conv, i16* %entry12, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %27 = load i32* %i, align 4
  %inc13 = add i32 %27, 1
  store i32 %inc13, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %28 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %28, i32 0, i32 32
  %29 = load %struct.pci_dev** %pdev, align 8
  %30 = load %struct.igb_adapter** %adapter.addr, align 8
  %msix_entries14 = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 5
  %arraydecay = getelementptr inbounds [10 x %struct.msix_entry]* %msix_entries14, i32 0, i32 0
  %31 = load i32* %numvecs, align 4
  %32 = load i32* %numvecs, align 4
  %call = call i32 @pci_enable_msix_range(%struct.pci_dev* %29, %struct.msix_entry* %arraydecay, i32 %31, i32 %32) noredzone
  store i32 %call, i32* %err, align 4
  %33 = load i32* %err, align 4
  %cmp15 = icmp sgt i32 %33, 0
  br i1 %cmp15, label %if.then17, label %if.end18

if.then17:                                        ; preds = %for.end
  br label %if.end53

if.end18:                                         ; preds = %for.end
  %34 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_reset_interrupt_capability(%struct.igb_adapter* %34) noredzone
  br label %msi_only

msi_only:                                         ; preds = %if.end18, %if.then
  %35 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags19 = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 3
  %36 = load i32* %flags19, align 4
  %and20 = and i32 %36, -8193
  store i32 %and20, i32* %flags19, align 4
  %37 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %37, i32 0, i32 50
  %38 = load %struct.vf_data_storage** %vf_data, align 8
  %tobool21 = icmp ne %struct.vf_data_storage* %38, null
  br i1 %tobool21, label %if.then22, label %if.end39

if.then22:                                        ; preds = %msi_only
  %39 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw23 = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 35
  store %struct.e1000_hw* %hw23, %struct.e1000_hw** %hw, align 8
  %40 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev24 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 32
  %41 = load %struct.pci_dev** %pdev24, align 8
  call void @pci_disable_sriov(%struct.pci_dev* %41) noredzone
  call void @msleep(i32 500) noredzone
  %42 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data25 = getelementptr inbounds %struct.igb_adapter* %42, i32 0, i32 50
  %43 = load %struct.vf_data_storage** %vf_data25, align 8
  %44 = bitcast %struct.vf_data_storage* %43 to i8*
  call void @kfree(i8* %44) noredzone
  %45 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data26 = getelementptr inbounds %struct.igb_adapter* %45, i32 0, i32 50
  store %struct.vf_data_storage* null, %struct.vf_data_storage** %vf_data26, align 8
  br label %do.body

do.body:                                          ; preds = %if.then22
  %46 = load %struct.e1000_hw** %hw, align 8
  %hw_addr27 = getelementptr inbounds %struct.e1000_hw* %46, i32 0, i32 1
  %47 = load volatile i8** %hw_addr27, align 8
  store i8* %47, i8** %hw_addr, align 8
  %48 = load i8** %hw_addr, align 8
  %tobool28 = icmp ne i8* %48, null
  %lnot = xor i1 %tobool28, true
  %lnot29 = xor i1 %lnot, true
  %lnot30 = xor i1 %lnot29, true
  %lnot.ext = zext i1 %lnot30 to i32
  %conv31 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv31, i64 0)
  %tobool32 = icmp ne i64 %expval, 0
  br i1 %tobool32, label %if.end35, label %if.then33

if.then33:                                        ; preds = %do.body
  %49 = load i8** %hw_addr, align 8
  %arrayidx34 = getelementptr i8* %49, i64 23484
  call void @writel(i32 1, i8* %arrayidx34) noredzone
  br label %if.end35

if.end35:                                         ; preds = %if.then33, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end35
  %50 = load %struct.e1000_hw** %hw, align 8
  %call36 = call i32 @igb_rd32(%struct.e1000_hw* %50, i32 8) noredzone
  call void @msleep(i32 100) noredzone
  %51 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev37 = getelementptr inbounds %struct.igb_adapter* %51, i32 0, i32 32
  %52 = load %struct.pci_dev** %pdev37, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %52, i32 0, i32 33
  %call38 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([14 x i8]* @.str32, i32 0, i32 0)) noredzone
  br label %if.end39

if.end39:                                         ; preds = %do.end, %msi_only
  %53 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count40 = getelementptr inbounds %struct.igb_adapter* %53, i32 0, i32 49
  store i32 0, i32* %vfs_allocated_count40, align 4
  %54 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues41 = getelementptr inbounds %struct.igb_adapter* %54, i32 0, i32 52
  store i32 1, i32* %rss_queues41, align 4
  %55 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags42 = getelementptr inbounds %struct.igb_adapter* %55, i32 0, i32 3
  %56 = load i32* %flags42, align 4
  %or43 = or i32 %56, 8
  store i32 %or43, i32* %flags42, align 4
  %57 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues44 = getelementptr inbounds %struct.igb_adapter* %57, i32 0, i32 14
  store i32 1, i32* %num_rx_queues44, align 4
  %58 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues45 = getelementptr inbounds %struct.igb_adapter* %58, i32 0, i32 12
  store i32 1, i32* %num_tx_queues45, align 4
  %59 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors46 = getelementptr inbounds %struct.igb_adapter* %59, i32 0, i32 4
  store i32 1, i32* %num_q_vectors46, align 4
  %60 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev47 = getelementptr inbounds %struct.igb_adapter* %60, i32 0, i32 32
  %61 = load %struct.pci_dev** %pdev47, align 8
  %call48 = call i32 @pci_enable_msi_exact(%struct.pci_dev* %61, i32 1) noredzone
  %tobool49 = icmp ne i32 %call48, 0
  br i1 %tobool49, label %if.end53, label %if.then50

if.then50:                                        ; preds = %if.end39
  %62 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags51 = getelementptr inbounds %struct.igb_adapter* %62, i32 0, i32 3
  %63 = load i32* %flags51, align 4
  %or52 = or i32 %63, 1
  store i32 %or52, i32* %flags51, align 4
  br label %if.end53

if.end53:                                         ; preds = %if.then17, %if.then50, %if.end39
  ret void
}

define internal i32 @igb_alloc_q_vectors(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %q_vectors = alloca i32, align 4
  %rxr_remaining = alloca i32, align 4
  %txr_remaining = alloca i32, align 4
  %rxr_idx = alloca i32, align 4
  %txr_idx = alloca i32, align 4
  %v_idx = alloca i32, align 4
  %err = alloca i32, align 4
  %rqpv = alloca i32, align 4
  %tqpv = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 4
  %1 = load i32* %num_q_vectors, align 4
  store i32 %1, i32* %q_vectors, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 14
  %3 = load i32* %num_rx_queues, align 4
  store i32 %3, i32* %rxr_remaining, align 4
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 12
  %5 = load i32* %num_tx_queues, align 4
  store i32 %5, i32* %txr_remaining, align 4
  store i32 0, i32* %rxr_idx, align 4
  store i32 0, i32* %txr_idx, align 4
  store i32 0, i32* %v_idx, align 4
  %6 = load i32* %q_vectors, align 4
  %7 = load i32* %rxr_remaining, align 4
  %8 = load i32* %txr_remaining, align 4
  %add = add i32 %7, %8
  %cmp = icmp sge i32 %6, %add
  br i1 %cmp, label %if.then, label %if.end4

if.then:                                          ; preds = %entry
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %9 = load i32* %rxr_remaining, align 4
  %tobool = icmp ne i32 %9, 0
  br i1 %tobool, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %11 = load i32* %q_vectors, align 4
  %12 = load i32* %v_idx, align 4
  %13 = load i32* %rxr_idx, align 4
  %call = call i32 @igb_alloc_q_vector(%struct.igb_adapter* %10, i32 %11, i32 %12, i32 0, i32 0, i32 1, i32 %13) noredzone
  store i32 %call, i32* %err, align 4
  %14 = load i32* %err, align 4
  %tobool1 = icmp ne i32 %14, 0
  br i1 %tobool1, label %if.then2, label %if.end

if.then2:                                         ; preds = %for.body
  br label %err_out

if.end:                                           ; preds = %for.body
  %15 = load i32* %rxr_remaining, align 4
  %dec = add i32 %15, -1
  store i32 %dec, i32* %rxr_remaining, align 4
  %16 = load i32* %rxr_idx, align 4
  %inc = add i32 %16, 1
  store i32 %inc, i32* %rxr_idx, align 4
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %17 = load i32* %v_idx, align 4
  %inc3 = add i32 %17, 1
  store i32 %inc3, i32* %v_idx, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end4

if.end4:                                          ; preds = %for.end, %entry
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc24, %if.end4
  %18 = load i32* %v_idx, align 4
  %19 = load i32* %q_vectors, align 4
  %cmp6 = icmp slt i32 %18, %19
  br i1 %cmp6, label %for.body7, label %for.end26

for.body7:                                        ; preds = %for.cond5
  %20 = load i32* %rxr_remaining, align 4
  %21 = load i32* %q_vectors, align 4
  %22 = load i32* %v_idx, align 4
  %sub = sub i32 %21, %22
  %add8 = add i32 %20, %sub
  %sub9 = sub i32 %add8, 1
  %23 = load i32* %q_vectors, align 4
  %24 = load i32* %v_idx, align 4
  %sub10 = sub i32 %23, %24
  %div = sdiv i32 %sub9, %sub10
  store i32 %div, i32* %rqpv, align 4
  %25 = load i32* %txr_remaining, align 4
  %26 = load i32* %q_vectors, align 4
  %27 = load i32* %v_idx, align 4
  %sub11 = sub i32 %26, %27
  %add12 = add i32 %25, %sub11
  %sub13 = sub i32 %add12, 1
  %28 = load i32* %q_vectors, align 4
  %29 = load i32* %v_idx, align 4
  %sub14 = sub i32 %28, %29
  %div15 = sdiv i32 %sub13, %sub14
  store i32 %div15, i32* %tqpv, align 4
  %30 = load %struct.igb_adapter** %adapter.addr, align 8
  %31 = load i32* %q_vectors, align 4
  %32 = load i32* %v_idx, align 4
  %33 = load i32* %tqpv, align 4
  %34 = load i32* %txr_idx, align 4
  %35 = load i32* %rqpv, align 4
  %36 = load i32* %rxr_idx, align 4
  %call16 = call i32 @igb_alloc_q_vector(%struct.igb_adapter* %30, i32 %31, i32 %32, i32 %33, i32 %34, i32 %35, i32 %36) noredzone
  store i32 %call16, i32* %err, align 4
  %37 = load i32* %err, align 4
  %tobool17 = icmp ne i32 %37, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %for.body7
  br label %err_out

if.end19:                                         ; preds = %for.body7
  %38 = load i32* %rqpv, align 4
  %39 = load i32* %rxr_remaining, align 4
  %sub20 = sub i32 %39, %38
  store i32 %sub20, i32* %rxr_remaining, align 4
  %40 = load i32* %tqpv, align 4
  %41 = load i32* %txr_remaining, align 4
  %sub21 = sub i32 %41, %40
  store i32 %sub21, i32* %txr_remaining, align 4
  %42 = load i32* %rxr_idx, align 4
  %inc22 = add i32 %42, 1
  store i32 %inc22, i32* %rxr_idx, align 4
  %43 = load i32* %txr_idx, align 4
  %inc23 = add i32 %43, 1
  store i32 %inc23, i32* %txr_idx, align 4
  br label %for.inc24

for.inc24:                                        ; preds = %if.end19
  %44 = load i32* %v_idx, align 4
  %inc25 = add i32 %44, 1
  store i32 %inc25, i32* %v_idx, align 4
  br label %for.cond5

for.end26:                                        ; preds = %for.cond5
  store i32 0, i32* %retval
  br label %return

err_out:                                          ; preds = %if.then18, %if.then2
  %45 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues27 = getelementptr inbounds %struct.igb_adapter* %45, i32 0, i32 12
  store i32 0, i32* %num_tx_queues27, align 4
  %46 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues28 = getelementptr inbounds %struct.igb_adapter* %46, i32 0, i32 14
  store i32 0, i32* %num_rx_queues28, align 4
  %47 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_q_vectors29 = getelementptr inbounds %struct.igb_adapter* %47, i32 0, i32 4
  store i32 0, i32* %num_q_vectors29, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %err_out
  %48 = load i32* %v_idx, align 4
  %dec30 = add i32 %48, -1
  store i32 %dec30, i32* %v_idx, align 4
  %tobool31 = icmp ne i32 %48, 0
  br i1 %tobool31, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %49 = load %struct.igb_adapter** %adapter.addr, align 8
  %50 = load i32* %v_idx, align 4
  call void @igb_free_q_vector(%struct.igb_adapter* %49, i32 %50) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  store i32 -12, i32* %retval
  br label %return

return:                                           ; preds = %while.end, %for.end26
  %51 = load i32* %retval
  ret i32 %51
}

define internal void @igb_cache_ring_register(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  %j = alloca i32, align 4
  %rbase_offset = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %i, align 4
  store i32 0, i32* %j, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 49
  %1 = load i32* %vfs_allocated_count, align 4
  store i32 %1, i32* %rbase_offset, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %3 = load i32* %type, align 4
  switch i32 %3, label %sw.default [
    i32 2, label %sw.bb
    i32 1, label %sw.bb3
    i32 3, label %sw.bb3
    i32 4, label %sw.bb3
    i32 5, label %sw.bb3
    i32 6, label %sw.bb3
    i32 7, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count1 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 49
  %5 = load i32* %vfs_allocated_count1, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.then
  %6 = load i32* %i, align 4
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 52
  %8 = load i32* %rss_queues, align 4
  %cmp = icmp ult i32 %6, %8
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %9 = load i32* %rbase_offset, align 4
  %10 = load i32* %i, align 4
  %and = and i32 %10, 1
  %shl = shl i32 %and, 3
  %11 = load i32* %i, align 4
  %shr = ashr i32 %11, 1
  %add = add i32 %shl, %shr
  %add2 = add i32 %9, %add
  %conv = trunc i32 %add2 to i8
  %12 = load i32* %i, align 4
  %idxprom = sext i32 %12 to i64
  %13 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %14 = load %struct.igb_ring** %arrayidx, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 11
  store i8 %conv, i8* %reg_idx, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %15 = load i32* %i, align 4
  %inc = add i32 %15, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %if.end

if.end:                                           ; preds = %for.end, %sw.bb
  br label %sw.bb3

sw.bb3:                                           ; preds = %entry, %entry, %entry, %entry, %entry, %entry, %if.end
  br label %sw.default

sw.default:                                       ; preds = %entry, %sw.bb3
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc14, %sw.default
  %16 = load i32* %i, align 4
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 14
  %18 = load i32* %num_rx_queues, align 4
  %cmp5 = icmp slt i32 %16, %18
  br i1 %cmp5, label %for.body7, label %for.end16

for.body7:                                        ; preds = %for.cond4
  %19 = load i32* %rbase_offset, align 4
  %20 = load i32* %i, align 4
  %add8 = add i32 %19, %20
  %conv9 = trunc i32 %add8 to i8
  %21 = load i32* %i, align 4
  %idxprom10 = sext i32 %21 to i64
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring11 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 15
  %arrayidx12 = getelementptr [16 x %struct.igb_ring*]* %rx_ring11, i32 0, i64 %idxprom10
  %23 = load %struct.igb_ring** %arrayidx12, align 8
  %reg_idx13 = getelementptr inbounds %struct.igb_ring* %23, i32 0, i32 11
  store i8 %conv9, i8* %reg_idx13, align 1
  br label %for.inc14

for.inc14:                                        ; preds = %for.body7
  %24 = load i32* %i, align 4
  %inc15 = add i32 %24, 1
  store i32 %inc15, i32* %i, align 4
  br label %for.cond4

for.end16:                                        ; preds = %for.cond4
  br label %for.cond17

for.cond17:                                       ; preds = %for.inc26, %for.end16
  %25 = load i32* %j, align 4
  %26 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %26, i32 0, i32 12
  %27 = load i32* %num_tx_queues, align 4
  %cmp18 = icmp slt i32 %25, %27
  br i1 %cmp18, label %for.body20, label %for.end28

for.body20:                                       ; preds = %for.cond17
  %28 = load i32* %rbase_offset, align 4
  %29 = load i32* %j, align 4
  %add21 = add i32 %28, %29
  %conv22 = trunc i32 %add21 to i8
  %30 = load i32* %j, align 4
  %idxprom23 = sext i32 %30 to i64
  %31 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %31, i32 0, i32 13
  %arrayidx24 = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom23
  %32 = load %struct.igb_ring** %arrayidx24, align 8
  %reg_idx25 = getelementptr inbounds %struct.igb_ring* %32, i32 0, i32 11
  store i8 %conv22, i8* %reg_idx25, align 1
  br label %for.inc26

for.inc26:                                        ; preds = %for.body20
  %33 = load i32* %j, align 4
  %inc27 = add i32 %33, 1
  store i32 %inc27, i32* %j, align 4
  br label %for.cond17

for.end28:                                        ; preds = %for.cond17
  br label %sw.epilog

sw.epilog:                                        ; preds = %for.end28
  ret void
}

define internal i32 @igb_alloc_q_vector(%struct.igb_adapter* %adapter, i32 %v_count, i32 %v_idx, i32 %txr_count, i32 %txr_idx, i32 %rxr_count, i32 %rxr_idx) nounwind noredzone {
entry:
  %nr.addr.i91 = alloca i64, align 8
  %addr.addr.i92 = alloca i64*, align 8
  %nr.addr.i89 = alloca i64, align 8
  %addr.addr.i90 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %v_count.addr = alloca i32, align 4
  %v_idx.addr = alloca i32, align 4
  %txr_count.addr = alloca i32, align 4
  %txr_idx.addr = alloca i32, align 4
  %rxr_count.addr = alloca i32, align 4
  %rxr_idx.addr = alloca i32, align 4
  %q_vector = alloca %struct.igb_q_vector*, align 8
  %ring = alloca %struct.igb_ring*, align 8
  %ring_count = alloca i32, align 4
  %size = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %v_count, i32* %v_count.addr, align 4
  store i32 %v_idx, i32* %v_idx.addr, align 4
  store i32 %txr_count, i32* %txr_count.addr, align 4
  store i32 %txr_idx, i32* %txr_idx.addr, align 4
  store i32 %rxr_count, i32* %rxr_count.addr, align 4
  store i32 %rxr_idx, i32* %rxr_idx.addr, align 4
  %0 = load i32* %txr_count.addr, align 4
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32* %rxr_count.addr, align 4
  %cmp1 = icmp sgt i32 %1, 1
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -12, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %2 = load i32* %txr_count.addr, align 4
  %3 = load i32* %rxr_count.addr, align 4
  %add = add i32 %2, %3
  store i32 %add, i32* %ring_count, align 4
  %4 = load i32* %ring_count, align 4
  %conv = sext i32 %4 to i64
  %mul = mul i64 128, %conv
  %add2 = add i64 256, %mul
  %conv3 = trunc i64 %add2 to i32
  store i32 %conv3, i32* %size, align 4
  %5 = load i32* %v_idx.addr, align 4
  %idxprom = sext i32 %5 to i64
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector4 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector4, i32 0, i64 %idxprom
  %7 = load %struct.igb_q_vector** %arrayidx, align 8
  store %struct.igb_q_vector* %7, %struct.igb_q_vector** %q_vector, align 8
  %8 = load %struct.igb_q_vector** %q_vector, align 8
  %tobool = icmp ne %struct.igb_q_vector* %8, null
  br i1 %tobool, label %if.end7, label %if.then5

if.then5:                                         ; preds = %if.end
  %9 = load i32* %size, align 4
  %conv6 = sext i32 %9 to i64
  %call = call i8* @kzalloc(i64 %conv6, i32 208) noredzone
  %10 = bitcast i8* %call to %struct.igb_q_vector*
  store %struct.igb_q_vector* %10, %struct.igb_q_vector** %q_vector, align 8
  br label %if.end7

if.end7:                                          ; preds = %if.then5, %if.end
  %11 = load %struct.igb_q_vector** %q_vector, align 8
  %tobool8 = icmp ne %struct.igb_q_vector* %11, null
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %if.end7
  store i32 -12, i32* %retval
  br label %return

if.end10:                                         ; preds = %if.end7
  %12 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 1
  %13 = load %struct.net_device** %netdev, align 8
  %14 = load %struct.igb_q_vector** %q_vector, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %14, i32 0, i32 8
  call void @netif_napi_add(%struct.net_device* %13, %struct.napi_struct* %napi, i32 (%struct.napi_struct*, i32)* @igb_poll, i32 64) noredzone
  %15 = load %struct.igb_q_vector** %q_vector, align 8
  %16 = load i32* %v_idx.addr, align 4
  %idxprom11 = sext i32 %16 to i64
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %q_vector12 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 44
  %arrayidx13 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector12, i32 0, i64 %idxprom11
  store %struct.igb_q_vector* %15, %struct.igb_q_vector** %arrayidx13, align 8
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %19 = load %struct.igb_q_vector** %q_vector, align 8
  %adapter14 = getelementptr inbounds %struct.igb_q_vector* %19, i32 0, i32 0
  store %struct.igb_adapter* %18, %struct.igb_adapter** %adapter14, align 8
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_work_limit = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 10
  %21 = load i16* %tx_work_limit, align 2
  %22 = load %struct.igb_q_vector** %q_vector, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %22, i32 0, i32 7
  %work_limit = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 3
  store i16 %21, i16* %work_limit, align 2
  %23 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 35
  %hw_addr = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 1
  %24 = load i8** %hw_addr, align 8
  %add.ptr = getelementptr i8* %24, i64 5760
  %25 = load %struct.igb_q_vector** %q_vector, align 8
  %itr_register = getelementptr inbounds %struct.igb_q_vector* %25, i32 0, i32 5
  store i8* %add.ptr, i8** %itr_register, align 8
  %26 = load %struct.igb_q_vector** %q_vector, align 8
  %itr_val = getelementptr inbounds %struct.igb_q_vector* %26, i32 0, i32 3
  store i16 648, i16* %itr_val, align 2
  %27 = load %struct.igb_q_vector** %q_vector, align 8
  %ring15 = getelementptr inbounds %struct.igb_q_vector* %27, i32 0, i32 12
  %arraydecay = getelementptr inbounds [0 x %struct.igb_ring]* %ring15, i32 0, i32 0
  store %struct.igb_ring* %arraydecay, %struct.igb_ring** %ring, align 8
  %28 = load i32* %rxr_count.addr, align 4
  %tobool16 = icmp ne i32 %28, 0
  br i1 %tobool16, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end10
  %29 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_itr_setting = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 6
  %30 = load i32* %rx_itr_setting, align 4
  %tobool18 = icmp ne i32 %30, 0
  br i1 %tobool18, label %lor.lhs.false19, label %if.then23

lor.lhs.false19:                                  ; preds = %if.then17
  %31 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_itr_setting20 = getelementptr inbounds %struct.igb_adapter* %31, i32 0, i32 6
  %32 = load i32* %rx_itr_setting20, align 4
  %cmp21 = icmp ugt i32 %32, 3
  br i1 %cmp21, label %if.then23, label %if.end27

if.then23:                                        ; preds = %lor.lhs.false19, %if.then17
  %33 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_itr_setting24 = getelementptr inbounds %struct.igb_adapter* %33, i32 0, i32 6
  %34 = load i32* %rx_itr_setting24, align 4
  %conv25 = trunc i32 %34 to i16
  %35 = load %struct.igb_q_vector** %q_vector, align 8
  %itr_val26 = getelementptr inbounds %struct.igb_q_vector* %35, i32 0, i32 3
  store i16 %conv25, i16* %itr_val26, align 2
  br label %if.end27

if.end27:                                         ; preds = %if.then23, %lor.lhs.false19
  br label %if.end38

if.else:                                          ; preds = %if.end10
  %36 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_itr_setting = getelementptr inbounds %struct.igb_adapter* %36, i32 0, i32 7
  %37 = load i32* %tx_itr_setting, align 4
  %tobool28 = icmp ne i32 %37, 0
  br i1 %tobool28, label %lor.lhs.false29, label %if.then33

lor.lhs.false29:                                  ; preds = %if.else
  %38 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_itr_setting30 = getelementptr inbounds %struct.igb_adapter* %38, i32 0, i32 7
  %39 = load i32* %tx_itr_setting30, align 4
  %cmp31 = icmp ugt i32 %39, 3
  br i1 %cmp31, label %if.then33, label %if.end37

if.then33:                                        ; preds = %lor.lhs.false29, %if.else
  %40 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_itr_setting34 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 7
  %41 = load i32* %tx_itr_setting34, align 4
  %conv35 = trunc i32 %41 to i16
  %42 = load %struct.igb_q_vector** %q_vector, align 8
  %itr_val36 = getelementptr inbounds %struct.igb_q_vector* %42, i32 0, i32 3
  store i16 %conv35, i16* %itr_val36, align 2
  br label %if.end37

if.end37:                                         ; preds = %if.then33, %lor.lhs.false29
  br label %if.end38

if.end38:                                         ; preds = %if.end37, %if.end27
  %43 = load i32* %txr_count.addr, align 4
  %tobool39 = icmp ne i32 %43, 0
  br i1 %tobool39, label %if.then40, label %if.end56

if.then40:                                        ; preds = %if.end38
  %44 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %44, i32 0, i32 32
  %45 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %45, i32 0, i32 33
  %46 = load %struct.igb_ring** %ring, align 8
  %dev41 = getelementptr inbounds %struct.igb_ring* %46, i32 0, i32 2
  store %struct.device* %dev, %struct.device** %dev41, align 8
  %47 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev42 = getelementptr inbounds %struct.igb_adapter* %47, i32 0, i32 1
  %48 = load %struct.net_device** %netdev42, align 8
  %49 = load %struct.igb_ring** %ring, align 8
  %netdev43 = getelementptr inbounds %struct.igb_ring* %49, i32 0, i32 1
  store %struct.net_device* %48, %struct.net_device** %netdev43, align 8
  %50 = load %struct.igb_q_vector** %q_vector, align 8
  %51 = load %struct.igb_ring** %ring, align 8
  %q_vector44 = getelementptr inbounds %struct.igb_ring* %51, i32 0, i32 0
  store %struct.igb_q_vector* %50, %struct.igb_q_vector** %q_vector44, align 8
  %52 = load %struct.igb_ring** %ring, align 8
  %53 = load %struct.igb_q_vector** %q_vector, align 8
  %tx45 = getelementptr inbounds %struct.igb_q_vector* %53, i32 0, i32 7
  call void @igb_add_ring(%struct.igb_ring* %52, %struct.igb_ring_container* %tx45) noredzone
  %54 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw46 = getelementptr inbounds %struct.igb_adapter* %54, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw46, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %55 = load i32* %type, align 4
  %cmp47 = icmp eq i32 %55, 1
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %if.then40
  %56 = load %struct.igb_ring** %ring, align 8
  %flags = getelementptr inbounds %struct.igb_ring* %56, i32 0, i32 5
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %57 = load i64** %addr.addr.i, align 8
  %58 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %57, i64 %58, i64* %57) nounwind, !srcloc !6
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %if.then40
  %59 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring_count = getelementptr inbounds %struct.igb_adapter* %59, i32 0, i32 47
  %60 = load i16* %tx_ring_count, align 2
  %61 = load %struct.igb_ring** %ring, align 8
  %count = getelementptr inbounds %struct.igb_ring* %61, i32 0, i32 9
  store i16 %60, i16* %count, align 2
  %62 = load i32* %txr_idx.addr, align 4
  %conv51 = trunc i32 %62 to i8
  %63 = load %struct.igb_ring** %ring, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %63, i32 0, i32 10
  store i8 %conv51, i8* %queue_index, align 1
  br label %do.body

do.body:                                          ; preds = %if.end50
  br label %do.end

do.end:                                           ; preds = %do.body
  br label %do.body52

do.body52:                                        ; preds = %do.end
  br label %do.end53

do.end53:                                         ; preds = %do.body52
  %64 = load %struct.igb_ring** %ring, align 8
  %65 = load i32* %txr_idx.addr, align 4
  %idxprom54 = sext i32 %65 to i64
  %66 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %66, i32 0, i32 13
  %arrayidx55 = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom54
  store %struct.igb_ring* %64, %struct.igb_ring** %arrayidx55, align 8
  %67 = load %struct.igb_ring** %ring, align 8
  %incdec.ptr = getelementptr %struct.igb_ring* %67, i32 1
  store %struct.igb_ring* %incdec.ptr, %struct.igb_ring** %ring, align 8
  br label %if.end56

if.end56:                                         ; preds = %do.end53, %if.end38
  %68 = load i32* %rxr_count.addr, align 4
  %tobool57 = icmp ne i32 %68, 0
  br i1 %tobool57, label %if.then58, label %if.end88

if.then58:                                        ; preds = %if.end56
  %69 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev59 = getelementptr inbounds %struct.igb_adapter* %69, i32 0, i32 32
  %70 = load %struct.pci_dev** %pdev59, align 8
  %dev60 = getelementptr inbounds %struct.pci_dev* %70, i32 0, i32 33
  %71 = load %struct.igb_ring** %ring, align 8
  %dev61 = getelementptr inbounds %struct.igb_ring* %71, i32 0, i32 2
  store %struct.device* %dev60, %struct.device** %dev61, align 8
  %72 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev62 = getelementptr inbounds %struct.igb_adapter* %72, i32 0, i32 1
  %73 = load %struct.net_device** %netdev62, align 8
  %74 = load %struct.igb_ring** %ring, align 8
  %netdev63 = getelementptr inbounds %struct.igb_ring* %74, i32 0, i32 1
  store %struct.net_device* %73, %struct.net_device** %netdev63, align 8
  %75 = load %struct.igb_q_vector** %q_vector, align 8
  %76 = load %struct.igb_ring** %ring, align 8
  %q_vector64 = getelementptr inbounds %struct.igb_ring* %76, i32 0, i32 0
  store %struct.igb_q_vector* %75, %struct.igb_q_vector** %q_vector64, align 8
  %77 = load %struct.igb_ring** %ring, align 8
  %78 = load %struct.igb_q_vector** %q_vector, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %78, i32 0, i32 6
  call void @igb_add_ring(%struct.igb_ring* %77, %struct.igb_ring_container* %rx) noredzone
  %79 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw65 = getelementptr inbounds %struct.igb_adapter* %79, i32 0, i32 35
  %mac66 = getelementptr inbounds %struct.e1000_hw* %hw65, i32 0, i32 4
  %type67 = getelementptr inbounds %struct.e1000_mac_info* %mac66, i32 0, i32 3
  %80 = load i32* %type67, align 4
  %cmp68 = icmp uge i32 %80, 2
  br i1 %cmp68, label %if.then70, label %if.end72

if.then70:                                        ; preds = %if.then58
  %81 = load %struct.igb_ring** %ring, align 8
  %flags71 = getelementptr inbounds %struct.igb_ring* %81, i32 0, i32 5
  store i64 0, i64* %nr.addr.i89, align 8
  store i64* %flags71, i64** %addr.addr.i90, align 8
  %82 = load i64** %addr.addr.i90, align 8
  %83 = load i64* %nr.addr.i89, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %82, i64 %83, i64* %82) nounwind, !srcloc !6
  br label %if.end72

if.end72:                                         ; preds = %if.then70, %if.then58
  %84 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw73 = getelementptr inbounds %struct.igb_adapter* %84, i32 0, i32 35
  %mac74 = getelementptr inbounds %struct.e1000_hw* %hw73, i32 0, i32 4
  %type75 = getelementptr inbounds %struct.e1000_mac_info* %mac74, i32 0, i32 3
  %85 = load i32* %type75, align 4
  %cmp76 = icmp uge i32 %85, 4
  br i1 %cmp76, label %if.then78, label %if.end80

if.then78:                                        ; preds = %if.end72
  %86 = load %struct.igb_ring** %ring, align 8
  %flags79 = getelementptr inbounds %struct.igb_ring* %86, i32 0, i32 5
  store i64 1, i64* %nr.addr.i91, align 8
  store i64* %flags79, i64** %addr.addr.i92, align 8
  %87 = load i64** %addr.addr.i92, align 8
  %88 = load i64* %nr.addr.i91, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %87, i64 %88, i64* %87) nounwind, !srcloc !6
  br label %if.end80

if.end80:                                         ; preds = %if.then78, %if.end72
  %89 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring_count = getelementptr inbounds %struct.igb_adapter* %89, i32 0, i32 48
  %90 = load i16* %rx_ring_count, align 2
  %91 = load %struct.igb_ring** %ring, align 8
  %count81 = getelementptr inbounds %struct.igb_ring* %91, i32 0, i32 9
  store i16 %90, i16* %count81, align 2
  %92 = load i32* %rxr_idx.addr, align 4
  %conv82 = trunc i32 %92 to i8
  %93 = load %struct.igb_ring** %ring, align 8
  %queue_index83 = getelementptr inbounds %struct.igb_ring* %93, i32 0, i32 10
  store i8 %conv82, i8* %queue_index83, align 1
  br label %do.body84

do.body84:                                        ; preds = %if.end80
  br label %do.end85

do.end85:                                         ; preds = %do.body84
  %94 = load %struct.igb_ring** %ring, align 8
  %95 = load i32* %rxr_idx.addr, align 4
  %idxprom86 = sext i32 %95 to i64
  %96 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %96, i32 0, i32 15
  %arrayidx87 = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom86
  store %struct.igb_ring* %94, %struct.igb_ring** %arrayidx87, align 8
  br label %if.end88

if.end88:                                         ; preds = %do.end85, %if.end56
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end88, %if.then9, %if.then
  %97 = load i32* %retval
  ret i32 %97
}

declare void @netif_napi_add(%struct.net_device*, %struct.napi_struct*, i32 (%struct.napi_struct*, i32)*, i32) noredzone

define internal i32 @igb_poll(%struct.napi_struct* %napi, i32 %budget) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %napi.addr = alloca %struct.napi_struct*, align 8
  %budget.addr = alloca i32, align 4
  %q_vector = alloca %struct.igb_q_vector*, align 8
  %__mptr = alloca %struct.napi_struct*, align 8
  %clean_complete = alloca i8, align 1
  store %struct.napi_struct* %napi, %struct.napi_struct** %napi.addr, align 8
  store i32 %budget, i32* %budget.addr, align 4
  %0 = load %struct.napi_struct** %napi.addr, align 8
  store %struct.napi_struct* %0, %struct.napi_struct** %__mptr, align 8
  %1 = load %struct.napi_struct** %__mptr, align 8
  %2 = bitcast %struct.napi_struct* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -80
  %3 = bitcast i8* %add.ptr to %struct.igb_q_vector*
  store %struct.igb_q_vector* %3, %struct.igb_q_vector** %q_vector, align 8
  store i8 1, i8* %clean_complete, align 1
  %4 = load %struct.igb_q_vector** %q_vector, align 8
  %adapter = getelementptr inbounds %struct.igb_q_vector* %4, i32 0, i32 0
  %5 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 3
  %6 = load i32* %flags, align 4
  %and = and i32 %6, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.igb_q_vector** %q_vector, align 8
  call void @igb_update_dca(%struct.igb_q_vector* %7) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.igb_q_vector** %q_vector, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %8, i32 0, i32 7
  %ring = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 0
  %9 = load %struct.igb_ring** %ring, align 8
  %tobool1 = icmp ne %struct.igb_ring* %9, null
  br i1 %tobool1, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  %10 = load %struct.igb_q_vector** %q_vector, align 8
  %call = call zeroext i1 @igb_clean_tx_irq(%struct.igb_q_vector* %10) noredzone
  %frombool = zext i1 %call to i8
  store i8 %frombool, i8* %clean_complete, align 1
  br label %if.end3

if.end3:                                          ; preds = %if.then2, %if.end
  %11 = load %struct.igb_q_vector** %q_vector, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %11, i32 0, i32 6
  %ring4 = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %12 = load %struct.igb_ring** %ring4, align 8
  %tobool5 = icmp ne %struct.igb_ring* %12, null
  br i1 %tobool5, label %if.then6, label %if.end13

if.then6:                                         ; preds = %if.end3
  %13 = load %struct.igb_q_vector** %q_vector, align 8
  %14 = load i32* %budget.addr, align 4
  %call7 = call zeroext i1 @igb_clean_rx_irq(%struct.igb_q_vector* %13, i32 %14) noredzone
  %conv = zext i1 %call7 to i32
  %15 = load i8* %clean_complete, align 1
  %tobool8 = trunc i8 %15 to i1
  %conv9 = zext i1 %tobool8 to i32
  %and10 = and i32 %conv9, %conv
  %tobool11 = icmp ne i32 %and10, 0
  %frombool12 = zext i1 %tobool11 to i8
  store i8 %frombool12, i8* %clean_complete, align 1
  br label %if.end13

if.end13:                                         ; preds = %if.then6, %if.end3
  %16 = load i8* %clean_complete, align 1
  %tobool14 = trunc i8 %16 to i1
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %if.end13
  %17 = load i32* %budget.addr, align 4
  store i32 %17, i32* %retval
  br label %return

if.end16:                                         ; preds = %if.end13
  %18 = load %struct.napi_struct** %napi.addr, align 8
  call void @napi_complete(%struct.napi_struct* %18) noredzone
  %19 = load %struct.igb_q_vector** %q_vector, align 8
  call void @igb_ring_irq_enable(%struct.igb_q_vector* %19) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end16, %if.then15
  %20 = load i32* %retval
  ret i32 %20
}

define internal void @igb_add_ring(%struct.igb_ring* %ring, %struct.igb_ring_container* %head) nounwind noredzone {
entry:
  %ring.addr = alloca %struct.igb_ring*, align 8
  %head.addr = alloca %struct.igb_ring_container*, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  store %struct.igb_ring_container* %head, %struct.igb_ring_container** %head.addr, align 8
  %0 = load %struct.igb_ring** %ring.addr, align 8
  %1 = load %struct.igb_ring_container** %head.addr, align 8
  %ring1 = getelementptr inbounds %struct.igb_ring_container* %1, i32 0, i32 0
  store %struct.igb_ring* %0, %struct.igb_ring** %ring1, align 8
  %2 = load %struct.igb_ring_container** %head.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring_container* %2, i32 0, i32 4
  %3 = load i8* %count, align 1
  %inc = add i8 %3, 1
  store i8 %inc, i8* %count, align 1
  ret void
}

define internal void @igb_update_dca(%struct.igb_q_vector* %q_vector) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %cpu = alloca i32, align 4
  %pscr_ret__ = alloca i32, align 4
  %__vpp_verify = alloca i8*, align 8
  %pfo_ret__ = alloca i32, align 4
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 0
  %1 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !15
  br label %do.body

do.body:                                          ; preds = %entry
  store i8* null, i8** %__vpp_verify, align 8
  %2 = load i8** %__vpp_verify, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %3 = call i32 asm "movl %gs:${1:P},$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @cpu_number) nounwind, !srcloc !16
  store i32 %3, i32* %pfo_ret__, align 4
  %4 = load i32* %pfo_ret__, align 4
  store i32 %4, i32* %pscr_ret__, align 4
  %5 = load i32* %pscr_ret__, align 4
  store i32 %5, i32* %cpu, align 4
  %6 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %cpu2 = getelementptr inbounds %struct.igb_q_vector* %6, i32 0, i32 1
  %7 = load i32* %cpu2, align 4
  %8 = load i32* %cpu, align 4
  %cmp = icmp eq i32 %7, %8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %do.end
  br label %out_no_update

if.end:                                           ; preds = %do.end
  %9 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %9, i32 0, i32 7
  %ring = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 0
  %10 = load %struct.igb_ring** %ring, align 8
  %tobool = icmp ne %struct.igb_ring* %10, null
  br i1 %tobool, label %if.then3, label %if.end6

if.then3:                                         ; preds = %if.end
  %11 = load %struct.igb_adapter** %adapter, align 8
  %12 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx4 = getelementptr inbounds %struct.igb_q_vector* %12, i32 0, i32 7
  %ring5 = getelementptr inbounds %struct.igb_ring_container* %tx4, i32 0, i32 0
  %13 = load %struct.igb_ring** %ring5, align 8
  %14 = load i32* %cpu, align 4
  call void @igb_update_tx_dca(%struct.igb_adapter* %11, %struct.igb_ring* %13, i32 %14) noredzone
  br label %if.end6

if.end6:                                          ; preds = %if.then3, %if.end
  %15 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %15, i32 0, i32 6
  %ring7 = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %16 = load %struct.igb_ring** %ring7, align 8
  %tobool8 = icmp ne %struct.igb_ring* %16, null
  br i1 %tobool8, label %if.then9, label %if.end12

if.then9:                                         ; preds = %if.end6
  %17 = load %struct.igb_adapter** %adapter, align 8
  %18 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx10 = getelementptr inbounds %struct.igb_q_vector* %18, i32 0, i32 6
  %ring11 = getelementptr inbounds %struct.igb_ring_container* %rx10, i32 0, i32 0
  %19 = load %struct.igb_ring** %ring11, align 8
  %20 = load i32* %cpu, align 4
  call void @igb_update_rx_dca(%struct.igb_adapter* %17, %struct.igb_ring* %19, i32 %20) noredzone
  br label %if.end12

if.end12:                                         ; preds = %if.then9, %if.end6
  %21 = load i32* %cpu, align 4
  %22 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %cpu13 = getelementptr inbounds %struct.igb_q_vector* %22, i32 0, i32 1
  store i32 %21, i32* %cpu13, align 4
  br label %out_no_update

out_no_update:                                    ; preds = %if.end12, %if.then
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !17
  ret void
}

define internal zeroext i1 @igb_clean_tx_irq(%struct.igb_q_vector* %q_vector) nounwind noredzone {
entry:
  %nr.addr.i213 = alloca i64, align 8
  %addr.addr.i214 = alloca i64*, align 8
  %nr.addr.i211 = alloca i64, align 8
  %addr.addr.i212 = alloca i64*, align 8
  %nr.addr.i202 = alloca i64, align 8
  %addr.addr.i203 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i1, align 1
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %tx_ring = alloca %struct.igb_ring*, align 8
  %tx_buffer = alloca %struct.igb_tx_buffer*, align 8
  %tx_desc = alloca %union.e1000_adv_tx_desc*, align 8
  %total_bytes = alloca i32, align 4
  %total_packets = alloca i32, align 4
  %budget = alloca i32, align 4
  %i = alloca i32, align 4
  %eop_desc = alloca %union.e1000_adv_tx_desc*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy110 = alloca i64, align 8
  %__dummy2111 = alloca i64, align 8
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 0
  %1 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %2, i32 0, i32 7
  %ring = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 0
  %3 = load %struct.igb_ring** %ring, align 8
  store %struct.igb_ring* %3, %struct.igb_ring** %tx_ring, align 8
  store i32 0, i32* %total_bytes, align 4
  store i32 0, i32* %total_packets, align 4
  %4 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx2 = getelementptr inbounds %struct.igb_q_vector* %4, i32 0, i32 7
  %work_limit = getelementptr inbounds %struct.igb_ring_container* %tx2, i32 0, i32 3
  %5 = load i16* %work_limit, align 2
  %conv = zext i16 %5 to i32
  store i32 %conv, i32* %budget, align 4
  %6 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 12
  %7 = load i16* %next_to_clean, align 2
  %conv3 = zext i16 %7 to i32
  store i32 %conv3, i32* %i, align 4
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %8 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %9 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %9, 63
  %shl.i = shl i64 1, %and.i
  %10 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %10, 6
  %11 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %11, i64 %shr.i
  %12 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %12
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false:                                       ; preds = %entry
  %13 = load %struct.igb_adapter** %adapter, align 8
  %state4 = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 2
  %call5 = call i32 @variable_test_bit(i64 2, i64* %state4) noredzone
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true
  %14 = load i32* %i, align 4
  %idxprom = zext i32 %14 to i64
  %15 = load %struct.igb_ring** %tx_ring, align 8
  %16 = getelementptr inbounds %struct.igb_ring* %15, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %16 to %struct.igb_tx_buffer**
  %17 = load %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %arrayidx = getelementptr %struct.igb_tx_buffer* %17, i64 %idxprom
  store %struct.igb_tx_buffer* %arrayidx, %struct.igb_tx_buffer** %tx_buffer, align 8
  %18 = load i32* %i, align 4
  %idxprom7 = zext i32 %18 to i64
  %19 = load %struct.igb_ring** %tx_ring, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %19, i32 0, i32 4
  %20 = load i8** %desc, align 8
  %21 = bitcast i8* %20 to %union.e1000_adv_tx_desc*
  %arrayidx8 = getelementptr %union.e1000_adv_tx_desc* %21, i64 %idxprom7
  store %union.e1000_adv_tx_desc* %arrayidx8, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %22 = load %struct.igb_ring** %tx_ring, align 8
  %count = getelementptr inbounds %struct.igb_ring* %22, i32 0, i32 9
  %23 = load i16* %count, align 2
  %conv9 = zext i16 %23 to i32
  %24 = load i32* %i, align 4
  %sub = sub i32 %24, %conv9
  store i32 %sub, i32* %i, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %if.end
  %25 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %next_to_watch = getelementptr inbounds %struct.igb_tx_buffer* %25, i32 0, i32 0
  %26 = load %union.e1000_adv_tx_desc** %next_to_watch, align 8
  store %union.e1000_adv_tx_desc* %26, %union.e1000_adv_tx_desc** %eop_desc, align 8
  %27 = load %union.e1000_adv_tx_desc** %eop_desc, align 8
  %tobool10 = icmp ne %union.e1000_adv_tx_desc* %27, null
  br i1 %tobool10, label %if.end12, label %if.then11

if.then11:                                        ; preds = %do.body
  br label %do.end76

if.end12:                                         ; preds = %do.body
  br label %do.body13

do.body13:                                        ; preds = %if.end12
  br label %do.end

do.end:                                           ; preds = %do.body13
  %28 = load %union.e1000_adv_tx_desc** %eop_desc, align 8
  %wb = bitcast %union.e1000_adv_tx_desc* %28 to %struct.anon.89*
  %status = getelementptr inbounds %struct.anon.89* %wb, i32 0, i32 2
  %29 = load i32* %status, align 4
  %and = and i32 %29, 1
  %tobool14 = icmp ne i32 %and, 0
  br i1 %tobool14, label %if.end16, label %if.then15

if.then15:                                        ; preds = %do.end
  br label %do.end76

if.end16:                                         ; preds = %do.end
  %30 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %next_to_watch17 = getelementptr inbounds %struct.igb_tx_buffer* %30, i32 0, i32 0
  store %union.e1000_adv_tx_desc* null, %union.e1000_adv_tx_desc** %next_to_watch17, align 8
  %31 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %bytecount = getelementptr inbounds %struct.igb_tx_buffer* %31, i32 0, i32 3
  %32 = load i32* %bytecount, align 4
  %33 = load i32* %total_bytes, align 4
  %add = add i32 %33, %32
  store i32 %add, i32* %total_bytes, align 4
  %34 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %gso_segs = getelementptr inbounds %struct.igb_tx_buffer* %34, i32 0, i32 4
  %35 = load i16* %gso_segs, align 2
  %conv18 = zext i16 %35 to i32
  %36 = load i32* %total_packets, align 4
  %add19 = add i32 %36, %conv18
  store i32 %add19, i32* %total_packets, align 4
  %37 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %skb = getelementptr inbounds %struct.igb_tx_buffer* %37, i32 0, i32 2
  %38 = load %struct.sk_buff** %skb, align 8
  call void @dev_kfree_skb_any(%struct.sk_buff* %38) noredzone
  %39 = load %struct.igb_ring** %tx_ring, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %39, i32 0, i32 2
  %40 = load %struct.device** %dev, align 8
  %41 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %dma = getelementptr inbounds %struct.igb_tx_buffer* %41, i32 0, i32 6
  %42 = load i64* %dma, align 8
  %43 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %len = getelementptr inbounds %struct.igb_tx_buffer* %43, i32 0, i32 7
  %44 = load i32* %len, align 4
  %conv20 = zext i32 %44 to i64
  call void @dma_unmap_single_attrs(%struct.device* %40, i64 %42, i64 %conv20, i32 1, %struct.dma_attrs* null) noredzone
  %45 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %skb21 = getelementptr inbounds %struct.igb_tx_buffer* %45, i32 0, i32 2
  store %struct.sk_buff* null, %struct.sk_buff** %skb21, align 8
  %46 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %len22 = getelementptr inbounds %struct.igb_tx_buffer* %46, i32 0, i32 7
  store i32 0, i32* %len22, align 4
  br label %while.cond

while.cond:                                       ; preds = %if.end46, %if.end16
  %47 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %48 = load %union.e1000_adv_tx_desc** %eop_desc, align 8
  %cmp = icmp ne %union.e1000_adv_tx_desc* %47, %48
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %49 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %incdec.ptr = getelementptr %struct.igb_tx_buffer* %49, i32 1
  store %struct.igb_tx_buffer* %incdec.ptr, %struct.igb_tx_buffer** %tx_buffer, align 8
  %50 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %incdec.ptr24 = getelementptr %union.e1000_adv_tx_desc* %50, i32 1
  store %union.e1000_adv_tx_desc* %incdec.ptr24, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %51 = load i32* %i, align 4
  %inc = add i32 %51, 1
  store i32 %inc, i32* %i, align 4
  %52 = load i32* %i, align 4
  %tobool25 = icmp ne i32 %52, 0
  %lnot = xor i1 %tobool25, true
  %lnot26 = xor i1 %lnot, true
  %lnot27 = xor i1 %lnot26, true
  %lnot.ext = zext i1 %lnot27 to i32
  %conv28 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv28, i64 0)
  %tobool29 = icmp ne i64 %expval, 0
  br i1 %tobool29, label %if.then30, label %if.end37

if.then30:                                        ; preds = %while.body
  %53 = load %struct.igb_ring** %tx_ring, align 8
  %count31 = getelementptr inbounds %struct.igb_ring* %53, i32 0, i32 9
  %54 = load i16* %count31, align 2
  %conv32 = zext i16 %54 to i32
  %55 = load i32* %i, align 4
  %sub33 = sub i32 %55, %conv32
  store i32 %sub33, i32* %i, align 4
  %56 = load %struct.igb_ring** %tx_ring, align 8
  %57 = getelementptr inbounds %struct.igb_ring* %56, i32 0, i32 3
  %tx_buffer_info34 = bitcast %union.anon.87* %57 to %struct.igb_tx_buffer**
  %58 = load %struct.igb_tx_buffer** %tx_buffer_info34, align 8
  store %struct.igb_tx_buffer* %58, %struct.igb_tx_buffer** %tx_buffer, align 8
  %59 = load %struct.igb_ring** %tx_ring, align 8
  %desc35 = getelementptr inbounds %struct.igb_ring* %59, i32 0, i32 4
  %60 = load i8** %desc35, align 8
  %61 = bitcast i8* %60 to %union.e1000_adv_tx_desc*
  %arrayidx36 = getelementptr %union.e1000_adv_tx_desc* %61, i64 0
  store %union.e1000_adv_tx_desc* %arrayidx36, %union.e1000_adv_tx_desc** %tx_desc, align 8
  br label %if.end37

if.end37:                                         ; preds = %if.then30, %while.body
  %62 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %len38 = getelementptr inbounds %struct.igb_tx_buffer* %62, i32 0, i32 7
  %63 = load i32* %len38, align 4
  %tobool39 = icmp ne i32 %63, 0
  br i1 %tobool39, label %if.then40, label %if.end46

if.then40:                                        ; preds = %if.end37
  %64 = load %struct.igb_ring** %tx_ring, align 8
  %dev41 = getelementptr inbounds %struct.igb_ring* %64, i32 0, i32 2
  %65 = load %struct.device** %dev41, align 8
  %66 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %dma42 = getelementptr inbounds %struct.igb_tx_buffer* %66, i32 0, i32 6
  %67 = load i64* %dma42, align 8
  %68 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %len43 = getelementptr inbounds %struct.igb_tx_buffer* %68, i32 0, i32 7
  %69 = load i32* %len43, align 4
  %conv44 = zext i32 %69 to i64
  call void @dma_unmap_page(%struct.device* %65, i64 %67, i64 %conv44, i32 1) noredzone
  %70 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %len45 = getelementptr inbounds %struct.igb_tx_buffer* %70, i32 0, i32 7
  store i32 0, i32* %len45, align 4
  br label %if.end46

if.end46:                                         ; preds = %if.then40, %if.end37
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %71 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %incdec.ptr47 = getelementptr %struct.igb_tx_buffer* %71, i32 1
  store %struct.igb_tx_buffer* %incdec.ptr47, %struct.igb_tx_buffer** %tx_buffer, align 8
  %72 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %incdec.ptr48 = getelementptr %union.e1000_adv_tx_desc* %72, i32 1
  store %union.e1000_adv_tx_desc* %incdec.ptr48, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %73 = load i32* %i, align 4
  %inc49 = add i32 %73, 1
  store i32 %inc49, i32* %i, align 4
  %74 = load i32* %i, align 4
  %tobool50 = icmp ne i32 %74, 0
  %lnot51 = xor i1 %tobool50, true
  %lnot53 = xor i1 %lnot51, true
  %lnot55 = xor i1 %lnot53, true
  %lnot.ext56 = zext i1 %lnot55 to i32
  %conv57 = sext i32 %lnot.ext56 to i64
  %expval58 = call i64 @llvm.expect.i64(i64 %conv57, i64 0)
  %tobool59 = icmp ne i64 %expval58, 0
  br i1 %tobool59, label %if.then60, label %if.end67

if.then60:                                        ; preds = %while.end
  %75 = load %struct.igb_ring** %tx_ring, align 8
  %count61 = getelementptr inbounds %struct.igb_ring* %75, i32 0, i32 9
  %76 = load i16* %count61, align 2
  %conv62 = zext i16 %76 to i32
  %77 = load i32* %i, align 4
  %sub63 = sub i32 %77, %conv62
  store i32 %sub63, i32* %i, align 4
  %78 = load %struct.igb_ring** %tx_ring, align 8
  %79 = getelementptr inbounds %struct.igb_ring* %78, i32 0, i32 3
  %tx_buffer_info64 = bitcast %union.anon.87* %79 to %struct.igb_tx_buffer**
  %80 = load %struct.igb_tx_buffer** %tx_buffer_info64, align 8
  store %struct.igb_tx_buffer* %80, %struct.igb_tx_buffer** %tx_buffer, align 8
  %81 = load %struct.igb_ring** %tx_ring, align 8
  %desc65 = getelementptr inbounds %struct.igb_ring* %81, i32 0, i32 4
  %82 = load i8** %desc65, align 8
  %83 = bitcast i8* %82 to %union.e1000_adv_tx_desc*
  %arrayidx66 = getelementptr %union.e1000_adv_tx_desc* %83, i64 0
  store %union.e1000_adv_tx_desc* %arrayidx66, %union.e1000_adv_tx_desc** %tx_desc, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.then60, %while.end
  %84 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %85 = bitcast %union.e1000_adv_tx_desc* %84 to i8*
  call void @llvm.prefetch(i8* %85, i32 0, i32 3, i32 1)
  %86 = load i32* %budget, align 4
  %dec = add i32 %86, -1
  store i32 %dec, i32* %budget, align 4
  br label %do.cond

do.cond:                                          ; preds = %if.end67
  %87 = load i32* %budget, align 4
  %tobool68 = icmp ne i32 %87, 0
  %lnot69 = xor i1 %tobool68, true
  %lnot71 = xor i1 %lnot69, true
  %lnot.ext72 = zext i1 %lnot71 to i32
  %conv73 = sext i32 %lnot.ext72 to i64
  %expval74 = call i64 @llvm.expect.i64(i64 %conv73, i64 1)
  %tobool75 = icmp ne i64 %expval74, 0
  br i1 %tobool75, label %do.body, label %do.end76

do.end76:                                         ; preds = %do.cond, %if.then15, %if.then11
  %88 = load %struct.igb_ring** %tx_ring, align 8
  %call77 = call %struct.netdev_queue* @txring_txq(%struct.igb_ring* %88) noredzone
  %89 = load i32* %total_packets, align 4
  %90 = load i32* %total_bytes, align 4
  call void @netdev_tx_completed_queue(%struct.netdev_queue* %call77, i32 %89, i32 %90) noredzone
  %91 = load %struct.igb_ring** %tx_ring, align 8
  %count78 = getelementptr inbounds %struct.igb_ring* %91, i32 0, i32 9
  %92 = load i16* %count78, align 2
  %conv79 = zext i16 %92 to i32
  %93 = load i32* %i, align 4
  %add80 = add i32 %93, %conv79
  store i32 %add80, i32* %i, align 4
  %94 = load i32* %i, align 4
  %conv81 = trunc i32 %94 to i16
  %95 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean82 = getelementptr inbounds %struct.igb_ring* %95, i32 0, i32 12
  store i16 %conv81, i16* %next_to_clean82, align 2
  %96 = load %struct.igb_ring** %tx_ring, align 8
  %97 = getelementptr inbounds %struct.igb_ring* %96, i32 0, i32 15
  %98 = bitcast %union.anon.90* %97 to %struct.anon.91*
  %tx_syncp = getelementptr inbounds %struct.anon.91* %98, i32 0, i32 1
  call void @u64_stats_update_begin(%struct.u64_stats_sync* %tx_syncp) noredzone
  %99 = load i32* %total_bytes, align 4
  %conv83 = zext i32 %99 to i64
  %100 = load %struct.igb_ring** %tx_ring, align 8
  %101 = getelementptr inbounds %struct.igb_ring* %100, i32 0, i32 15
  %102 = bitcast %union.anon.90* %101 to %struct.anon.91*
  %tx_stats = getelementptr inbounds %struct.anon.91* %102, i32 0, i32 0
  %bytes = getelementptr inbounds %struct.igb_tx_queue_stats* %tx_stats, i32 0, i32 1
  %103 = load i64* %bytes, align 8
  %add84 = add i64 %103, %conv83
  store i64 %add84, i64* %bytes, align 8
  %104 = load i32* %total_packets, align 4
  %conv85 = zext i32 %104 to i64
  %105 = load %struct.igb_ring** %tx_ring, align 8
  %106 = getelementptr inbounds %struct.igb_ring* %105, i32 0, i32 15
  %107 = bitcast %union.anon.90* %106 to %struct.anon.91*
  %tx_stats86 = getelementptr inbounds %struct.anon.91* %107, i32 0, i32 0
  %packets = getelementptr inbounds %struct.igb_tx_queue_stats* %tx_stats86, i32 0, i32 0
  %108 = load i64* %packets, align 8
  %add87 = add i64 %108, %conv85
  store i64 %add87, i64* %packets, align 8
  %109 = load %struct.igb_ring** %tx_ring, align 8
  %110 = getelementptr inbounds %struct.igb_ring* %109, i32 0, i32 15
  %111 = bitcast %union.anon.90* %110 to %struct.anon.91*
  %tx_syncp88 = getelementptr inbounds %struct.anon.91* %111, i32 0, i32 1
  call void @u64_stats_update_end(%struct.u64_stats_sync* %tx_syncp88) noredzone
  %112 = load i32* %total_bytes, align 4
  %113 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx89 = getelementptr inbounds %struct.igb_q_vector* %113, i32 0, i32 7
  %total_bytes90 = getelementptr inbounds %struct.igb_ring_container* %tx89, i32 0, i32 1
  %114 = load i32* %total_bytes90, align 4
  %add91 = add i32 %114, %112
  store i32 %add91, i32* %total_bytes90, align 4
  %115 = load i32* %total_packets, align 4
  %116 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx92 = getelementptr inbounds %struct.igb_q_vector* %116, i32 0, i32 7
  %total_packets93 = getelementptr inbounds %struct.igb_ring_container* %tx92, i32 0, i32 2
  %117 = load i32* %total_packets93, align 4
  %add94 = add i32 %117, %115
  store i32 %add94, i32* %total_packets93, align 4
  br i1 true, label %cond.true95, label %cond.false98

cond.true95:                                      ; preds = %do.end76
  %118 = load %struct.igb_ring** %tx_ring, align 8
  %flags = getelementptr inbounds %struct.igb_ring* %118, i32 0, i32 5
  store i64 3, i64* %nr.addr.i202, align 8
  store i64* %flags, i64** %addr.addr.i203, align 8
  %119 = load i64* %nr.addr.i202, align 8
  %and.i204 = and i64 %119, 63
  %shl.i205 = shl i64 1, %and.i204
  %120 = load i64* %nr.addr.i202, align 8
  %shr.i206 = ashr i64 %120, 6
  %121 = load i64** %addr.addr.i203, align 8
  %arrayidx.i207 = getelementptr i64* %121, i64 %shr.i206
  %122 = load volatile i64* %arrayidx.i207, align 8
  %and1.i208 = and i64 %shl.i205, %122
  %cmp.i209 = icmp ne i64 %and1.i208, 0
  %conv.i210 = zext i1 %cmp.i209 to i32
  %tobool97 = icmp ne i32 %conv.i210, 0
  br i1 %tobool97, label %if.then102, label %if.end155

cond.false98:                                     ; preds = %do.end76
  %123 = load %struct.igb_ring** %tx_ring, align 8
  %flags99 = getelementptr inbounds %struct.igb_ring* %123, i32 0, i32 5
  %call100 = call i32 @variable_test_bit(i64 3, i64* %flags99) noredzone
  %tobool101 = icmp ne i32 %call100, 0
  br i1 %tobool101, label %if.then102, label %if.end155

if.then102:                                       ; preds = %cond.false98, %cond.true95
  %124 = load %struct.igb_adapter** %adapter, align 8
  %hw103 = getelementptr inbounds %struct.igb_adapter* %124, i32 0, i32 35
  store %struct.e1000_hw* %hw103, %struct.e1000_hw** %hw, align 8
  %125 = load %struct.igb_ring** %tx_ring, align 8
  %flags104 = getelementptr inbounds %struct.igb_ring* %125, i32 0, i32 5
  store i64 3, i64* %nr.addr.i211, align 8
  store i64* %flags104, i64** %addr.addr.i212, align 8
  %126 = load i64** %addr.addr.i212, align 8
  %127 = load i64* %nr.addr.i211, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %126, i64 %127, i64* %126) nounwind, !srcloc !1
  %128 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %next_to_watch105 = getelementptr inbounds %struct.igb_tx_buffer* %128, i32 0, i32 0
  %129 = load %union.e1000_adv_tx_desc** %next_to_watch105, align 8
  %tobool106 = icmp ne %union.e1000_adv_tx_desc* %129, null
  br i1 %tobool106, label %land.lhs.true, label %if.end154

land.lhs.true:                                    ; preds = %if.then102
  %cmp107 = icmp eq i64* %__dummy, %__dummy2
  %conv108 = zext i1 %cmp107 to i32
  br i1 true, label %land.lhs.true109, label %if.end154

land.lhs.true109:                                 ; preds = %land.lhs.true
  %cmp112 = icmp eq i64* %__dummy110, %__dummy2111
  %conv113 = zext i1 %cmp112 to i32
  br i1 true, label %land.lhs.true114, label %if.end154

land.lhs.true114:                                 ; preds = %land.lhs.true109
  %130 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %time_stamp = getelementptr inbounds %struct.igb_tx_buffer* %130, i32 0, i32 1
  %131 = load i64* %time_stamp, align 8
  %132 = load %struct.igb_adapter** %adapter, align 8
  %tx_timeout_factor = getelementptr inbounds %struct.igb_adapter* %132, i32 0, i32 29
  %133 = load i8* %tx_timeout_factor, align 1
  %conv115 = zext i8 %133 to i32
  %mul = mul i32 %conv115, 250
  %conv116 = sext i32 %mul to i64
  %add117 = add i64 %131, %conv116
  %134 = load volatile i64* @jiffies, align 8
  %sub118 = sub i64 %add117, %134
  %cmp119 = icmp slt i64 %sub118, 0
  br i1 %cmp119, label %land.lhs.true121, label %if.end154

land.lhs.true121:                                 ; preds = %land.lhs.true114
  %135 = load %struct.e1000_hw** %hw, align 8
  %call122 = call i32 @igb_rd32(%struct.e1000_hw* %135, i32 8) noredzone
  %and123 = and i32 %call122, 16
  %tobool124 = icmp ne i32 %and123, 0
  br i1 %tobool124, label %if.end154, label %if.then125

if.then125:                                       ; preds = %land.lhs.true121
  %136 = load %struct.igb_ring** %tx_ring, align 8
  %dev126 = getelementptr inbounds %struct.igb_ring* %136, i32 0, i32 2
  %137 = load %struct.device** %dev126, align 8
  %138 = load %struct.igb_ring** %tx_ring, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %138, i32 0, i32 10
  %139 = load i8* %queue_index, align 1
  %conv127 = zext i8 %139 to i32
  %140 = load %struct.e1000_hw** %hw, align 8
  %141 = load %struct.igb_ring** %tx_ring, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %141, i32 0, i32 11
  %142 = load i8* %reg_idx, align 1
  %conv128 = zext i8 %142 to i32
  %cmp129 = icmp slt i32 %conv128, 4
  br i1 %cmp129, label %cond.true131, label %cond.false136

cond.true131:                                     ; preds = %if.then125
  %143 = load %struct.igb_ring** %tx_ring, align 8
  %reg_idx132 = getelementptr inbounds %struct.igb_ring* %143, i32 0, i32 11
  %144 = load i8* %reg_idx132, align 1
  %conv133 = zext i8 %144 to i32
  %mul134 = mul i32 %conv133, 256
  %add135 = add i32 14352, %mul134
  br label %cond.end

cond.false136:                                    ; preds = %if.then125
  %145 = load %struct.igb_ring** %tx_ring, align 8
  %reg_idx137 = getelementptr inbounds %struct.igb_ring* %145, i32 0, i32 11
  %146 = load i8* %reg_idx137, align 1
  %conv138 = zext i8 %146 to i32
  %mul139 = mul i32 %conv138, 64
  %add140 = add i32 57360, %mul139
  br label %cond.end

cond.end:                                         ; preds = %cond.false136, %cond.true131
  %cond = phi i32 [ %add135, %cond.true131 ], [ %add140, %cond.false136 ]
  %call141 = call i32 @igb_rd32(%struct.e1000_hw* %140, i32 %cond) noredzone
  %147 = load %struct.igb_ring** %tx_ring, align 8
  %tail = getelementptr inbounds %struct.igb_ring* %147, i32 0, i32 6
  %148 = load i8** %tail, align 8
  %call142 = call i32 @readl(i8* %148) noredzone
  %149 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %149, i32 0, i32 13
  %150 = load i16* %next_to_use, align 2
  %conv143 = zext i16 %150 to i32
  %151 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean144 = getelementptr inbounds %struct.igb_ring* %151, i32 0, i32 12
  %152 = load i16* %next_to_clean144, align 2
  %conv145 = zext i16 %152 to i32
  %153 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %time_stamp146 = getelementptr inbounds %struct.igb_tx_buffer* %153, i32 0, i32 1
  %154 = load i64* %time_stamp146, align 8
  %155 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %next_to_watch147 = getelementptr inbounds %struct.igb_tx_buffer* %155, i32 0, i32 0
  %156 = load %union.e1000_adv_tx_desc** %next_to_watch147, align 8
  %157 = load volatile i64* @jiffies, align 8
  %158 = load %struct.igb_tx_buffer** %tx_buffer, align 8
  %next_to_watch148 = getelementptr inbounds %struct.igb_tx_buffer* %158, i32 0, i32 0
  %159 = load %union.e1000_adv_tx_desc** %next_to_watch148, align 8
  %wb149 = bitcast %union.e1000_adv_tx_desc* %159 to %struct.anon.89*
  %status150 = getelementptr inbounds %struct.anon.89* %wb149, i32 0, i32 2
  %160 = load i32* %status150, align 4
  %call151 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %137, i8* getelementptr inbounds ([304 x i8]* @.str29, i32 0, i32 0), i32 %conv127, i32 %call141, i32 %call142, i32 %conv143, i32 %conv145, i64 %154, %union.e1000_adv_tx_desc* %156, i64 %157, i32 %160) noredzone
  %161 = load %struct.igb_ring** %tx_ring, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %161, i32 0, i32 1
  %162 = load %struct.net_device** %netdev, align 8
  %163 = load %struct.igb_ring** %tx_ring, align 8
  %queue_index152 = getelementptr inbounds %struct.igb_ring* %163, i32 0, i32 10
  %164 = load i8* %queue_index152, align 1
  %conv153 = zext i8 %164 to i16
  call void @netif_stop_subqueue(%struct.net_device* %162, i16 zeroext %conv153) noredzone
  store i1 true, i1* %retval
  br label %return

if.end154:                                        ; preds = %land.lhs.true121, %land.lhs.true114, %land.lhs.true109, %land.lhs.true, %if.then102
  br label %if.end155

if.end155:                                        ; preds = %if.end154, %cond.false98, %cond.true95
  %165 = load i32* %total_packets, align 4
  %tobool156 = icmp ne i32 %165, 0
  br i1 %tobool156, label %land.lhs.true157, label %land.end

land.lhs.true157:                                 ; preds = %if.end155
  %166 = load %struct.igb_ring** %tx_ring, align 8
  %netdev158 = getelementptr inbounds %struct.igb_ring* %166, i32 0, i32 1
  %167 = load %struct.net_device** %netdev158, align 8
  %call159 = call zeroext i1 @netif_carrier_ok(%struct.net_device* %167) noredzone
  br i1 %call159, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %land.lhs.true157
  %168 = load %struct.igb_ring** %tx_ring, align 8
  %call161 = call i32 @igb_desc_unused(%struct.igb_ring* %168) noredzone
  %conv162 = sext i32 %call161 to i64
  %cmp163 = icmp uge i64 %conv162, 42
  br label %land.end

land.end:                                         ; preds = %land.rhs, %land.lhs.true157, %if.end155
  %169 = phi i1 [ false, %land.lhs.true157 ], [ false, %if.end155 ], [ %cmp163, %land.rhs ]
  %lnot165 = xor i1 %169, true
  %lnot167 = xor i1 %lnot165, true
  %lnot.ext168 = zext i1 %lnot167 to i32
  %conv169 = sext i32 %lnot.ext168 to i64
  %expval170 = call i64 @llvm.expect.i64(i64 %conv169, i64 0)
  %tobool171 = icmp ne i64 %expval170, 0
  br i1 %tobool171, label %if.then172, label %if.end196

if.then172:                                       ; preds = %land.end
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !18
  %170 = load %struct.igb_ring** %tx_ring, align 8
  %netdev173 = getelementptr inbounds %struct.igb_ring* %170, i32 0, i32 1
  %171 = load %struct.net_device** %netdev173, align 8
  %172 = load %struct.igb_ring** %tx_ring, align 8
  %queue_index174 = getelementptr inbounds %struct.igb_ring* %172, i32 0, i32 10
  %173 = load i8* %queue_index174, align 1
  %conv175 = zext i8 %173 to i16
  %call176 = call zeroext i1 @__netif_subqueue_stopped(%struct.net_device* %171, i16 zeroext %conv175) noredzone
  br i1 %call176, label %land.lhs.true178, label %if.end195

land.lhs.true178:                                 ; preds = %if.then172
  br i1 true, label %cond.true179, label %cond.false183

cond.true179:                                     ; preds = %land.lhs.true178
  %174 = load %struct.igb_adapter** %adapter, align 8
  %state180 = getelementptr inbounds %struct.igb_adapter* %174, i32 0, i32 2
  store i64 2, i64* %nr.addr.i213, align 8
  store i64* %state180, i64** %addr.addr.i214, align 8
  %175 = load i64* %nr.addr.i213, align 8
  %and.i215 = and i64 %175, 63
  %shl.i216 = shl i64 1, %and.i215
  %176 = load i64* %nr.addr.i213, align 8
  %shr.i217 = ashr i64 %176, 6
  %177 = load i64** %addr.addr.i214, align 8
  %arrayidx.i218 = getelementptr i64* %177, i64 %shr.i217
  %178 = load volatile i64* %arrayidx.i218, align 8
  %and1.i219 = and i64 %shl.i216, %178
  %cmp.i220 = icmp ne i64 %and1.i219, 0
  %conv.i221 = zext i1 %cmp.i220 to i32
  %tobool182 = icmp ne i32 %conv.i221, 0
  br i1 %tobool182, label %if.end195, label %if.then187

cond.false183:                                    ; preds = %land.lhs.true178
  %179 = load %struct.igb_adapter** %adapter, align 8
  %state184 = getelementptr inbounds %struct.igb_adapter* %179, i32 0, i32 2
  %call185 = call i32 @variable_test_bit(i64 2, i64* %state184) noredzone
  %tobool186 = icmp ne i32 %call185, 0
  br i1 %tobool186, label %if.end195, label %if.then187

if.then187:                                       ; preds = %cond.false183, %cond.true179
  %180 = load %struct.igb_ring** %tx_ring, align 8
  %netdev188 = getelementptr inbounds %struct.igb_ring* %180, i32 0, i32 1
  %181 = load %struct.net_device** %netdev188, align 8
  %182 = load %struct.igb_ring** %tx_ring, align 8
  %queue_index189 = getelementptr inbounds %struct.igb_ring* %182, i32 0, i32 10
  %183 = load i8* %queue_index189, align 1
  %conv190 = zext i8 %183 to i16
  call void @netif_wake_subqueue(%struct.net_device* %181, i16 zeroext %conv190) noredzone
  %184 = load %struct.igb_ring** %tx_ring, align 8
  %185 = getelementptr inbounds %struct.igb_ring* %184, i32 0, i32 15
  %186 = bitcast %union.anon.90* %185 to %struct.anon.91*
  %tx_syncp191 = getelementptr inbounds %struct.anon.91* %186, i32 0, i32 1
  call void @u64_stats_update_begin(%struct.u64_stats_sync* %tx_syncp191) noredzone
  %187 = load %struct.igb_ring** %tx_ring, align 8
  %188 = getelementptr inbounds %struct.igb_ring* %187, i32 0, i32 15
  %189 = bitcast %union.anon.90* %188 to %struct.anon.91*
  %tx_stats192 = getelementptr inbounds %struct.anon.91* %189, i32 0, i32 0
  %restart_queue = getelementptr inbounds %struct.igb_tx_queue_stats* %tx_stats192, i32 0, i32 2
  %190 = load i64* %restart_queue, align 8
  %inc193 = add i64 %190, 1
  store i64 %inc193, i64* %restart_queue, align 8
  %191 = load %struct.igb_ring** %tx_ring, align 8
  %192 = getelementptr inbounds %struct.igb_ring* %191, i32 0, i32 15
  %193 = bitcast %union.anon.90* %192 to %struct.anon.91*
  %tx_syncp194 = getelementptr inbounds %struct.anon.91* %193, i32 0, i32 1
  call void @u64_stats_update_end(%struct.u64_stats_sync* %tx_syncp194) noredzone
  br label %if.end195

if.end195:                                        ; preds = %if.then187, %cond.false183, %cond.true179, %if.then172
  br label %if.end196

if.end196:                                        ; preds = %if.end195, %land.end
  %194 = load i32* %budget, align 4
  %tobool197 = icmp ne i32 %194, 0
  %lnot198 = xor i1 %tobool197, true
  %lnot200 = xor i1 %lnot198, true
  store i1 %lnot200, i1* %retval
  br label %return

return:                                           ; preds = %if.end196, %cond.end, %if.then
  %195 = load i1* %retval
  ret i1 %195
}

define internal zeroext i1 @igb_clean_rx_irq(%struct.igb_q_vector* %q_vector, i32 %budget) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %budget.addr = alloca i32, align 4
  %rx_ring = alloca %struct.igb_ring*, align 8
  %skb = alloca %struct.sk_buff*, align 8
  %total_bytes = alloca i32, align 4
  %total_packets = alloca i32, align 4
  %cleaned_count = alloca i16, align 2
  %rx_desc = alloca %union.e1000_adv_rx_desc*, align 8
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  store i32 %budget, i32* %budget.addr, align 4
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 6
  %ring = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %1 = load %struct.igb_ring** %ring, align 8
  store %struct.igb_ring* %1, %struct.igb_ring** %rx_ring, align 8
  %2 = load %struct.igb_ring** %rx_ring, align 8
  %3 = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 15
  %4 = bitcast %union.anon.90* %3 to %struct.anon.92*
  %skb1 = getelementptr inbounds %struct.anon.92* %4, i32 0, i32 0
  %5 = load %struct.sk_buff** %skb1, align 8
  store %struct.sk_buff* %5, %struct.sk_buff** %skb, align 8
  store i32 0, i32* %total_bytes, align 4
  store i32 0, i32* %total_packets, align 4
  %6 = load %struct.igb_ring** %rx_ring, align 8
  %call = call i32 @igb_desc_unused(%struct.igb_ring* %6) noredzone
  %conv = trunc i32 %call to i16
  store i16 %conv, i16* %cleaned_count, align 2
  br label %while.cond

while.cond:                                       ; preds = %if.end21, %if.then20, %if.then17, %entry
  %7 = load i32* %total_packets, align 4
  %8 = load i32* %budget.addr, align 4
  %cmp = icmp ult i32 %7, %8
  %lnot = xor i1 %cmp, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %9 = load i16* %cleaned_count, align 2
  %conv5 = zext i16 %9 to i32
  %cmp6 = icmp sge i32 %conv5, 16
  br i1 %cmp6, label %if.then, label %if.end

if.then:                                          ; preds = %while.body
  %10 = load %struct.igb_ring** %rx_ring, align 8
  %11 = load i16* %cleaned_count, align 2
  call void @igb_alloc_rx_buffers(%struct.igb_ring* %10, i16 zeroext %11) noredzone
  store i16 0, i16* %cleaned_count, align 2
  br label %if.end

if.end:                                           ; preds = %if.then, %while.body
  %12 = load %struct.igb_ring** %rx_ring, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %12, i32 0, i32 12
  %13 = load i16* %next_to_clean, align 2
  %idxprom = zext i16 %13 to i64
  %14 = load %struct.igb_ring** %rx_ring, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 4
  %15 = load i8** %desc, align 8
  %16 = bitcast i8* %15 to %union.e1000_adv_rx_desc*
  %arrayidx = getelementptr %union.e1000_adv_rx_desc* %16, i64 %idxprom
  store %union.e1000_adv_rx_desc* %arrayidx, %union.e1000_adv_rx_desc** %rx_desc, align 8
  %17 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %call8 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %17, i32 1) noredzone
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %if.end
  br label %while.end

if.end11:                                         ; preds = %if.end
  call void asm sideeffect "lfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !19
  %18 = load %struct.igb_ring** %rx_ring, align 8
  %19 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %20 = load %struct.sk_buff** %skb, align 8
  %call12 = call %struct.sk_buff* @igb_fetch_rx_buffer(%struct.igb_ring* %18, %union.e1000_adv_rx_desc* %19, %struct.sk_buff* %20) noredzone
  store %struct.sk_buff* %call12, %struct.sk_buff** %skb, align 8
  %21 = load %struct.sk_buff** %skb, align 8
  %tobool13 = icmp ne %struct.sk_buff* %21, null
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %if.end11
  br label %while.end

if.end15:                                         ; preds = %if.end11
  %22 = load i16* %cleaned_count, align 2
  %inc = add i16 %22, 1
  store i16 %inc, i16* %cleaned_count, align 2
  %23 = load %struct.igb_ring** %rx_ring, align 8
  %24 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %call16 = call zeroext i1 @igb_is_non_eop(%struct.igb_ring* %23, %union.e1000_adv_rx_desc* %24) noredzone
  br i1 %call16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end15
  br label %while.cond

if.end18:                                         ; preds = %if.end15
  %25 = load %struct.igb_ring** %rx_ring, align 8
  %26 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %27 = load %struct.sk_buff** %skb, align 8
  %call19 = call zeroext i1 @igb_cleanup_headers(%struct.igb_ring* %25, %union.e1000_adv_rx_desc* %26, %struct.sk_buff* %27) noredzone
  br i1 %call19, label %if.then20, label %if.end21

if.then20:                                        ; preds = %if.end18
  store %struct.sk_buff* null, %struct.sk_buff** %skb, align 8
  br label %while.cond

if.end21:                                         ; preds = %if.end18
  %28 = load %struct.sk_buff** %skb, align 8
  %len = getelementptr inbounds %struct.sk_buff* %28, i32 0, i32 8
  %29 = load i32* %len, align 4
  %30 = load i32* %total_bytes, align 4
  %add = add i32 %30, %29
  store i32 %add, i32* %total_bytes, align 4
  %31 = load %struct.igb_ring** %rx_ring, align 8
  %32 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %33 = load %struct.sk_buff** %skb, align 8
  call void @igb_process_skb_fields(%struct.igb_ring* %31, %union.e1000_adv_rx_desc* %32, %struct.sk_buff* %33) noredzone
  %34 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %34, i32 0, i32 8
  %35 = load %struct.sk_buff** %skb, align 8
  %call22 = call i32 @napi_gro_receive(%struct.napi_struct* %napi, %struct.sk_buff* %35) noredzone
  store %struct.sk_buff* null, %struct.sk_buff** %skb, align 8
  %36 = load i32* %total_packets, align 4
  %inc23 = add i32 %36, 1
  store i32 %inc23, i32* %total_packets, align 4
  br label %while.cond

while.end:                                        ; preds = %if.then14, %if.then10, %while.cond
  %37 = load %struct.sk_buff** %skb, align 8
  %38 = load %struct.igb_ring** %rx_ring, align 8
  %39 = getelementptr inbounds %struct.igb_ring* %38, i32 0, i32 15
  %40 = bitcast %union.anon.90* %39 to %struct.anon.92*
  %skb24 = getelementptr inbounds %struct.anon.92* %40, i32 0, i32 0
  store %struct.sk_buff* %37, %struct.sk_buff** %skb24, align 8
  %41 = load %struct.igb_ring** %rx_ring, align 8
  %42 = getelementptr inbounds %struct.igb_ring* %41, i32 0, i32 15
  %43 = bitcast %union.anon.90* %42 to %struct.anon.92*
  %rx_syncp = getelementptr inbounds %struct.anon.92* %43, i32 0, i32 2
  call void @u64_stats_update_begin(%struct.u64_stats_sync* %rx_syncp) noredzone
  %44 = load i32* %total_packets, align 4
  %conv25 = zext i32 %44 to i64
  %45 = load %struct.igb_ring** %rx_ring, align 8
  %46 = getelementptr inbounds %struct.igb_ring* %45, i32 0, i32 15
  %47 = bitcast %union.anon.90* %46 to %struct.anon.92*
  %rx_stats = getelementptr inbounds %struct.anon.92* %47, i32 0, i32 1
  %packets = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats, i32 0, i32 0
  %48 = load i64* %packets, align 8
  %add26 = add i64 %48, %conv25
  store i64 %add26, i64* %packets, align 8
  %49 = load i32* %total_bytes, align 4
  %conv27 = zext i32 %49 to i64
  %50 = load %struct.igb_ring** %rx_ring, align 8
  %51 = getelementptr inbounds %struct.igb_ring* %50, i32 0, i32 15
  %52 = bitcast %union.anon.90* %51 to %struct.anon.92*
  %rx_stats28 = getelementptr inbounds %struct.anon.92* %52, i32 0, i32 1
  %bytes = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats28, i32 0, i32 1
  %53 = load i64* %bytes, align 8
  %add29 = add i64 %53, %conv27
  store i64 %add29, i64* %bytes, align 8
  %54 = load %struct.igb_ring** %rx_ring, align 8
  %55 = getelementptr inbounds %struct.igb_ring* %54, i32 0, i32 15
  %56 = bitcast %union.anon.90* %55 to %struct.anon.92*
  %rx_syncp30 = getelementptr inbounds %struct.anon.92* %56, i32 0, i32 2
  call void @u64_stats_update_end(%struct.u64_stats_sync* %rx_syncp30) noredzone
  %57 = load i32* %total_packets, align 4
  %58 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx31 = getelementptr inbounds %struct.igb_q_vector* %58, i32 0, i32 6
  %total_packets32 = getelementptr inbounds %struct.igb_ring_container* %rx31, i32 0, i32 2
  %59 = load i32* %total_packets32, align 4
  %add33 = add i32 %59, %57
  store i32 %add33, i32* %total_packets32, align 4
  %60 = load i32* %total_bytes, align 4
  %61 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx34 = getelementptr inbounds %struct.igb_q_vector* %61, i32 0, i32 6
  %total_bytes35 = getelementptr inbounds %struct.igb_ring_container* %rx34, i32 0, i32 1
  %62 = load i32* %total_bytes35, align 4
  %add36 = add i32 %62, %60
  store i32 %add36, i32* %total_bytes35, align 4
  %63 = load i16* %cleaned_count, align 2
  %tobool37 = icmp ne i16 %63, 0
  br i1 %tobool37, label %if.then38, label %if.end39

if.then38:                                        ; preds = %while.end
  %64 = load %struct.igb_ring** %rx_ring, align 8
  %65 = load i16* %cleaned_count, align 2
  call void @igb_alloc_rx_buffers(%struct.igb_ring* %64, i16 zeroext %65) noredzone
  br label %if.end39

if.end39:                                         ; preds = %if.then38, %while.end
  %66 = load i32* %total_packets, align 4
  %67 = load i32* %budget.addr, align 4
  %cmp40 = icmp ult i32 %66, %67
  ret i1 %cmp40
}

declare void @napi_complete(%struct.napi_struct*) noredzone

define internal void @igb_ring_irq_enable(%struct.igb_q_vector* %q_vector) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 0
  %1 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %3, i32 0, i32 6
  %ring = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 0
  %4 = load %struct.igb_ring** %ring, align 8
  %tobool = icmp ne %struct.igb_ring* %4, null
  br i1 %tobool, label %land.lhs.true, label %lor.lhs.false

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.igb_adapter** %adapter, align 8
  %rx_itr_setting = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 6
  %6 = load i32* %rx_itr_setting, align 4
  %and = and i32 %6, 3
  %tobool3 = icmp ne i32 %and, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true, %entry
  %7 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx4 = getelementptr inbounds %struct.igb_q_vector* %7, i32 0, i32 6
  %ring5 = getelementptr inbounds %struct.igb_ring_container* %rx4, i32 0, i32 0
  %8 = load %struct.igb_ring** %ring5, align 8
  %tobool6 = icmp ne %struct.igb_ring* %8, null
  br i1 %tobool6, label %if.end13, label %land.lhs.true7

land.lhs.true7:                                   ; preds = %lor.lhs.false
  %9 = load %struct.igb_adapter** %adapter, align 8
  %tx_itr_setting = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 7
  %10 = load i32* %tx_itr_setting, align 4
  %and8 = and i32 %10, 3
  %tobool9 = icmp ne i32 %and8, 0
  br i1 %tobool9, label %if.then, label %if.end13

if.then:                                          ; preds = %land.lhs.true7, %land.lhs.true
  %11 = load %struct.igb_adapter** %adapter, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 4
  %12 = load i32* %num_q_vectors, align 4
  %cmp = icmp eq i32 %12, 1
  br i1 %cmp, label %land.lhs.true10, label %if.else

land.lhs.true10:                                  ; preds = %if.then
  %13 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 50
  %14 = load %struct.vf_data_storage** %vf_data, align 8
  %tobool11 = icmp ne %struct.vf_data_storage* %14, null
  br i1 %tobool11, label %if.else, label %if.then12

if.then12:                                        ; preds = %land.lhs.true10
  %15 = load %struct.igb_q_vector** %q_vector.addr, align 8
  call void @igb_set_itr(%struct.igb_q_vector* %15) noredzone
  br label %if.end

if.else:                                          ; preds = %land.lhs.true10, %if.then
  %16 = load %struct.igb_q_vector** %q_vector.addr, align 8
  call void @igb_update_ring_itr(%struct.igb_q_vector* %16) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then12
  br label %if.end13

if.end13:                                         ; preds = %if.end, %land.lhs.true7, %lor.lhs.false
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end13
  %17 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %18 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %18, 63
  %shl.i = shl i64 1, %and.i
  %19 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %19, 6
  %20 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %20, i64 %shr.i
  %21 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %21
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool14 = icmp ne i32 %conv.i, 0
  br i1 %tobool14, label %if.end31, label %if.then18

cond.false:                                       ; preds = %if.end13
  %22 = load %struct.igb_adapter** %adapter, align 8
  %state15 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 2
  %call16 = call i32 @variable_test_bit(i64 2, i64* %state15) noredzone
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.end31, label %if.then18

if.then18:                                        ; preds = %cond.false, %cond.true
  %23 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 3
  %24 = load i32* %flags, align 4
  %and19 = and i32 %24, 8192
  %tobool20 = icmp ne i32 %and19, 0
  br i1 %tobool20, label %if.then21, label %if.else29

if.then21:                                        ; preds = %if.then18
  br label %do.body

do.body:                                          ; preds = %if.then21
  %25 = load %struct.e1000_hw** %hw, align 8
  %hw_addr22 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 1
  %26 = load volatile i8** %hw_addr22, align 8
  store i8* %26, i8** %hw_addr, align 8
  %27 = load i8** %hw_addr, align 8
  %tobool23 = icmp ne i8* %27, null
  %lnot = xor i1 %tobool23, true
  %lnot24 = xor i1 %lnot, true
  %lnot25 = xor i1 %lnot24, true
  %lnot.ext = zext i1 %lnot25 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool26 = icmp ne i64 %expval, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %do.body
  %28 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %eims_value = getelementptr inbounds %struct.igb_q_vector* %28, i32 0, i32 2
  %29 = load i32* %eims_value, align 4
  %30 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %30, i64 5412
  call void @writel(i32 %29, i8* %arrayidx) noredzone
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end28
  br label %if.end30

if.else29:                                        ; preds = %if.then18
  %31 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_irq_enable(%struct.igb_adapter* %31) noredzone
  br label %if.end30

if.end30:                                         ; preds = %if.else29, %do.end
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %cond.false, %cond.true
  ret void
}

define internal void @igb_set_itr(%struct.igb_q_vector* %q_vector) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %new_itr = alloca i32, align 4
  %current_itr = alloca i8, align 1
  %_max1 = alloca i8, align 1
  %_max2 = alloca i8, align 1
  %_max144 = alloca i32, align 4
  %_max249 = alloca i32, align 4
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 0
  %1 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val = getelementptr inbounds %struct.igb_q_vector* %2, i32 0, i32 3
  %3 = load i16* %itr_val, align 2
  %conv = zext i16 %3 to i32
  store i32 %conv, i32* %new_itr, align 4
  store i8 0, i8* %current_itr, align 1
  %4 = load %struct.igb_adapter** %adapter, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 24
  %5 = load i16* %link_speed, align 2
  %conv2 = zext i16 %5 to i32
  %cmp = icmp ne i32 %conv2, 1000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i8 0, i8* %current_itr, align 1
  store i32 980, i32* %new_itr, align 4
  br label %set_itr_now

if.end:                                           ; preds = %entry
  %6 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %7 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %7, i32 0, i32 7
  call void @igb_update_itr(%struct.igb_q_vector* %6, %struct.igb_ring_container* %tx) noredzone
  %8 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %9 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %9, i32 0, i32 6
  call void @igb_update_itr(%struct.igb_q_vector* %8, %struct.igb_ring_container* %rx) noredzone
  %10 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx4 = getelementptr inbounds %struct.igb_q_vector* %10, i32 0, i32 6
  %itr = getelementptr inbounds %struct.igb_ring_container* %rx4, i32 0, i32 5
  %11 = load i8* %itr, align 1
  store i8 %11, i8* %_max1, align 1
  %12 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx5 = getelementptr inbounds %struct.igb_q_vector* %12, i32 0, i32 7
  %itr6 = getelementptr inbounds %struct.igb_ring_container* %tx5, i32 0, i32 5
  %13 = load i8* %itr6, align 1
  store i8 %13, i8* %_max2, align 1
  %cmp7 = icmp eq i8* %_max1, %_max2
  %conv8 = zext i1 %cmp7 to i32
  %14 = load i8* %_max1, align 1
  %conv9 = zext i8 %14 to i32
  %15 = load i8* %_max2, align 1
  %conv10 = zext i8 %15 to i32
  %cmp11 = icmp sgt i32 %conv9, %conv10
  br i1 %cmp11, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %16 = load i8* %_max1, align 1
  %conv13 = zext i8 %16 to i32
  br label %cond.end

cond.false:                                       ; preds = %if.end
  %17 = load i8* %_max2, align 1
  %conv14 = zext i8 %17 to i32
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv13, %cond.true ], [ %conv14, %cond.false ]
  %conv15 = trunc i32 %cond to i8
  store i8 %conv15, i8* %current_itr, align 1
  %18 = load i8* %current_itr, align 1
  %conv16 = zext i8 %18 to i32
  %cmp17 = icmp eq i32 %conv16, 0
  br i1 %cmp17, label %land.lhs.true, label %if.end30

land.lhs.true:                                    ; preds = %cond.end
  %19 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx19 = getelementptr inbounds %struct.igb_q_vector* %19, i32 0, i32 6
  %ring = getelementptr inbounds %struct.igb_ring_container* %rx19, i32 0, i32 0
  %20 = load %struct.igb_ring** %ring, align 8
  %tobool = icmp ne %struct.igb_ring* %20, null
  br i1 %tobool, label %land.lhs.true20, label %lor.lhs.false

land.lhs.true20:                                  ; preds = %land.lhs.true
  %21 = load %struct.igb_adapter** %adapter, align 8
  %rx_itr_setting = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 6
  %22 = load i32* %rx_itr_setting, align 4
  %cmp21 = icmp eq i32 %22, 3
  br i1 %cmp21, label %if.then29, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true20, %land.lhs.true
  %23 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx23 = getelementptr inbounds %struct.igb_q_vector* %23, i32 0, i32 6
  %ring24 = getelementptr inbounds %struct.igb_ring_container* %rx23, i32 0, i32 0
  %24 = load %struct.igb_ring** %ring24, align 8
  %tobool25 = icmp ne %struct.igb_ring* %24, null
  br i1 %tobool25, label %if.end30, label %land.lhs.true26

land.lhs.true26:                                  ; preds = %lor.lhs.false
  %25 = load %struct.igb_adapter** %adapter, align 8
  %tx_itr_setting = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 7
  %26 = load i32* %tx_itr_setting, align 4
  %cmp27 = icmp eq i32 %26, 3
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %land.lhs.true26, %land.lhs.true20
  store i8 1, i8* %current_itr, align 1
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %land.lhs.true26, %lor.lhs.false, %cond.end
  %27 = load i8* %current_itr, align 1
  %conv31 = zext i8 %27 to i32
  switch i32 %conv31, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb32
    i32 2, label %sw.bb33
  ]

sw.bb:                                            ; preds = %if.end30
  store i32 56, i32* %new_itr, align 4
  br label %sw.epilog

sw.bb32:                                          ; preds = %if.end30
  store i32 196, i32* %new_itr, align 4
  br label %sw.epilog

sw.bb33:                                          ; preds = %if.end30
  store i32 980, i32* %new_itr, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end30
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb33, %sw.bb32, %sw.bb
  br label %set_itr_now

set_itr_now:                                      ; preds = %sw.epilog, %if.then
  %28 = load i32* %new_itr, align 4
  %29 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val34 = getelementptr inbounds %struct.igb_q_vector* %29, i32 0, i32 3
  %30 = load i16* %itr_val34, align 2
  %conv35 = zext i16 %30 to i32
  %cmp36 = icmp ne i32 %28, %conv35
  br i1 %cmp36, label %if.then38, label %if.end63

if.then38:                                        ; preds = %set_itr_now
  %31 = load i32* %new_itr, align 4
  %32 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val39 = getelementptr inbounds %struct.igb_q_vector* %32, i32 0, i32 3
  %33 = load i16* %itr_val39, align 2
  %conv40 = zext i16 %33 to i32
  %cmp41 = icmp ugt i32 %31, %conv40
  br i1 %cmp41, label %cond.true43, label %cond.false58

cond.true43:                                      ; preds = %if.then38
  %34 = load i32* %new_itr, align 4
  %35 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val45 = getelementptr inbounds %struct.igb_q_vector* %35, i32 0, i32 3
  %36 = load i16* %itr_val45, align 2
  %conv46 = zext i16 %36 to i32
  %mul = mul i32 %34, %conv46
  %37 = load i32* %new_itr, align 4
  %38 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val47 = getelementptr inbounds %struct.igb_q_vector* %38, i32 0, i32 3
  %39 = load i16* %itr_val47, align 2
  %conv48 = zext i16 %39 to i32
  %shr = ashr i32 %conv48, 2
  %add = add i32 %37, %shr
  %div = udiv i32 %mul, %add
  store i32 %div, i32* %_max144, align 4
  %40 = load i32* %new_itr, align 4
  store i32 %40, i32* %_max249, align 4
  %cmp50 = icmp eq i32* %_max144, %_max249
  %conv51 = zext i1 %cmp50 to i32
  %41 = load i32* %_max144, align 4
  %42 = load i32* %_max249, align 4
  %cmp52 = icmp ugt i32 %41, %42
  br i1 %cmp52, label %cond.true54, label %cond.false55

cond.true54:                                      ; preds = %cond.true43
  %43 = load i32* %_max144, align 4
  br label %cond.end56

cond.false55:                                     ; preds = %cond.true43
  %44 = load i32* %_max249, align 4
  br label %cond.end56

cond.end56:                                       ; preds = %cond.false55, %cond.true54
  %cond57 = phi i32 [ %43, %cond.true54 ], [ %44, %cond.false55 ]
  br label %cond.end59

cond.false58:                                     ; preds = %if.then38
  %45 = load i32* %new_itr, align 4
  br label %cond.end59

cond.end59:                                       ; preds = %cond.false58, %cond.end56
  %cond60 = phi i32 [ %cond57, %cond.end56 ], [ %45, %cond.false58 ]
  store i32 %cond60, i32* %new_itr, align 4
  %46 = load i32* %new_itr, align 4
  %conv61 = trunc i32 %46 to i16
  %47 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val62 = getelementptr inbounds %struct.igb_q_vector* %47, i32 0, i32 3
  store i16 %conv61, i16* %itr_val62, align 2
  %48 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %set_itr = getelementptr inbounds %struct.igb_q_vector* %48, i32 0, i32 4
  store i8 1, i8* %set_itr, align 1
  br label %if.end63

if.end63:                                         ; preds = %cond.end59, %set_itr_now
  ret void
}

define internal void @igb_update_ring_itr(%struct.igb_q_vector* %q_vector) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %new_val = alloca i32, align 4
  %avg_wire_size = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %packets = alloca i32, align 4
  %__max1 = alloca i32, align 4
  %__max2 = alloca i32, align 4
  %_min1 = alloca i32, align 4
  %_min2 = alloca i32, align 4
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  %0 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val = getelementptr inbounds %struct.igb_q_vector* %0, i32 0, i32 3
  %1 = load i16* %itr_val, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %new_val, align 4
  store i32 0, i32* %avg_wire_size, align 4
  %2 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %adapter1 = getelementptr inbounds %struct.igb_q_vector* %2, i32 0, i32 0
  %3 = load %struct.igb_adapter** %adapter1, align 8
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 24
  %5 = load i16* %link_speed, align 2
  %conv2 = zext i16 %5 to i32
  %cmp = icmp ne i32 %conv2, 1000
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 980, i32* %new_val, align 4
  br label %set_itr_val

if.end:                                           ; preds = %entry
  %6 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx = getelementptr inbounds %struct.igb_q_vector* %6, i32 0, i32 6
  %total_packets = getelementptr inbounds %struct.igb_ring_container* %rx, i32 0, i32 2
  %7 = load i32* %total_packets, align 4
  store i32 %7, i32* %packets, align 4
  %8 = load i32* %packets, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then4, label %if.end6

if.then4:                                         ; preds = %if.end
  %9 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx5 = getelementptr inbounds %struct.igb_q_vector* %9, i32 0, i32 6
  %total_bytes = getelementptr inbounds %struct.igb_ring_container* %rx5, i32 0, i32 1
  %10 = load i32* %total_bytes, align 4
  %11 = load i32* %packets, align 4
  %div = udiv i32 %10, %11
  store i32 %div, i32* %avg_wire_size, align 4
  br label %if.end6

if.end6:                                          ; preds = %if.then4, %if.end
  %12 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx = getelementptr inbounds %struct.igb_q_vector* %12, i32 0, i32 7
  %total_packets7 = getelementptr inbounds %struct.igb_ring_container* %tx, i32 0, i32 2
  %13 = load i32* %total_packets7, align 4
  store i32 %13, i32* %packets, align 4
  %14 = load i32* %packets, align 4
  %tobool8 = icmp ne i32 %14, 0
  br i1 %tobool8, label %if.then9, label %if.end15

if.then9:                                         ; preds = %if.end6
  %15 = load i32* %avg_wire_size, align 4
  store i32 %15, i32* %__max1, align 4
  %16 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx10 = getelementptr inbounds %struct.igb_q_vector* %16, i32 0, i32 7
  %total_bytes11 = getelementptr inbounds %struct.igb_ring_container* %tx10, i32 0, i32 1
  %17 = load i32* %total_bytes11, align 4
  %18 = load i32* %packets, align 4
  %div12 = udiv i32 %17, %18
  store i32 %div12, i32* %__max2, align 4
  %19 = load i32* %__max1, align 4
  %20 = load i32* %__max2, align 4
  %cmp13 = icmp ugt i32 %19, %20
  br i1 %cmp13, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then9
  %21 = load i32* %__max1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then9
  %22 = load i32* %__max2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %21, %cond.true ], [ %22, %cond.false ]
  store i32 %cond, i32* %avg_wire_size, align 4
  br label %if.end15

if.end15:                                         ; preds = %cond.end, %if.end6
  %23 = load i32* %avg_wire_size, align 4
  %tobool16 = icmp ne i32 %23, 0
  br i1 %tobool16, label %if.end18, label %if.then17

if.then17:                                        ; preds = %if.end15
  br label %clear_counts

if.end18:                                         ; preds = %if.end15
  %24 = load i32* %avg_wire_size, align 4
  %add = add i32 %24, 24
  store i32 %add, i32* %avg_wire_size, align 4
  %25 = load i32* %avg_wire_size, align 4
  store i32 %25, i32* %_min1, align 4
  store i32 3000, i32* %_min2, align 4
  %cmp19 = icmp eq i32* %_min1, %_min2
  %conv20 = zext i1 %cmp19 to i32
  %26 = load i32* %_min1, align 4
  %27 = load i32* %_min2, align 4
  %cmp21 = icmp slt i32 %26, %27
  br i1 %cmp21, label %cond.true23, label %cond.false24

cond.true23:                                      ; preds = %if.end18
  %28 = load i32* %_min1, align 4
  br label %cond.end25

cond.false24:                                     ; preds = %if.end18
  %29 = load i32* %_min2, align 4
  br label %cond.end25

cond.end25:                                       ; preds = %cond.false24, %cond.true23
  %cond26 = phi i32 [ %28, %cond.true23 ], [ %29, %cond.false24 ]
  store i32 %cond26, i32* %avg_wire_size, align 4
  %30 = load i32* %avg_wire_size, align 4
  %cmp27 = icmp sgt i32 %30, 300
  br i1 %cmp27, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %cond.end25
  %31 = load i32* %avg_wire_size, align 4
  %cmp29 = icmp slt i32 %31, 1200
  br i1 %cmp29, label %if.then31, label %if.else

if.then31:                                        ; preds = %land.lhs.true
  %32 = load i32* %avg_wire_size, align 4
  %div32 = sdiv i32 %32, 3
  store i32 %div32, i32* %new_val, align 4
  br label %if.end34

if.else:                                          ; preds = %land.lhs.true, %cond.end25
  %33 = load i32* %avg_wire_size, align 4
  %div33 = sdiv i32 %33, 2
  store i32 %div33, i32* %new_val, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.else, %if.then31
  %34 = load i32* %new_val, align 4
  %cmp35 = icmp slt i32 %34, 196
  br i1 %cmp35, label %land.lhs.true37, label %if.end50

land.lhs.true37:                                  ; preds = %if.end34
  %35 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx38 = getelementptr inbounds %struct.igb_q_vector* %35, i32 0, i32 6
  %ring = getelementptr inbounds %struct.igb_ring_container* %rx38, i32 0, i32 0
  %36 = load %struct.igb_ring** %ring, align 8
  %tobool39 = icmp ne %struct.igb_ring* %36, null
  br i1 %tobool39, label %land.lhs.true40, label %lor.lhs.false

land.lhs.true40:                                  ; preds = %land.lhs.true37
  %37 = load %struct.igb_adapter** %adapter, align 8
  %rx_itr_setting = getelementptr inbounds %struct.igb_adapter* %37, i32 0, i32 6
  %38 = load i32* %rx_itr_setting, align 4
  %cmp41 = icmp eq i32 %38, 3
  br i1 %cmp41, label %if.then49, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %land.lhs.true40, %land.lhs.true37
  %39 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx43 = getelementptr inbounds %struct.igb_q_vector* %39, i32 0, i32 6
  %ring44 = getelementptr inbounds %struct.igb_ring_container* %rx43, i32 0, i32 0
  %40 = load %struct.igb_ring** %ring44, align 8
  %tobool45 = icmp ne %struct.igb_ring* %40, null
  br i1 %tobool45, label %if.end50, label %land.lhs.true46

land.lhs.true46:                                  ; preds = %lor.lhs.false
  %41 = load %struct.igb_adapter** %adapter, align 8
  %tx_itr_setting = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 7
  %42 = load i32* %tx_itr_setting, align 4
  %cmp47 = icmp eq i32 %42, 3
  br i1 %cmp47, label %if.then49, label %if.end50

if.then49:                                        ; preds = %land.lhs.true46, %land.lhs.true40
  store i32 196, i32* %new_val, align 4
  br label %if.end50

if.end50:                                         ; preds = %if.then49, %land.lhs.true46, %lor.lhs.false, %if.end34
  br label %set_itr_val

set_itr_val:                                      ; preds = %if.end50, %if.then
  %43 = load i32* %new_val, align 4
  %44 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val51 = getelementptr inbounds %struct.igb_q_vector* %44, i32 0, i32 3
  %45 = load i16* %itr_val51, align 2
  %conv52 = zext i16 %45 to i32
  %cmp53 = icmp ne i32 %43, %conv52
  br i1 %cmp53, label %if.then55, label %if.end58

if.then55:                                        ; preds = %set_itr_val
  %46 = load i32* %new_val, align 4
  %conv56 = trunc i32 %46 to i16
  %47 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %itr_val57 = getelementptr inbounds %struct.igb_q_vector* %47, i32 0, i32 3
  store i16 %conv56, i16* %itr_val57, align 2
  %48 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %set_itr = getelementptr inbounds %struct.igb_q_vector* %48, i32 0, i32 4
  store i8 1, i8* %set_itr, align 1
  br label %if.end58

if.end58:                                         ; preds = %if.then55, %set_itr_val
  br label %clear_counts

clear_counts:                                     ; preds = %if.end58, %if.then17
  %49 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx59 = getelementptr inbounds %struct.igb_q_vector* %49, i32 0, i32 6
  %total_bytes60 = getelementptr inbounds %struct.igb_ring_container* %rx59, i32 0, i32 1
  store i32 0, i32* %total_bytes60, align 4
  %50 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %rx61 = getelementptr inbounds %struct.igb_q_vector* %50, i32 0, i32 6
  %total_packets62 = getelementptr inbounds %struct.igb_ring_container* %rx61, i32 0, i32 2
  store i32 0, i32* %total_packets62, align 4
  %51 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx63 = getelementptr inbounds %struct.igb_q_vector* %51, i32 0, i32 7
  %total_bytes64 = getelementptr inbounds %struct.igb_ring_container* %tx63, i32 0, i32 1
  store i32 0, i32* %total_bytes64, align 4
  %52 = load %struct.igb_q_vector** %q_vector.addr, align 8
  %tx65 = getelementptr inbounds %struct.igb_q_vector* %52, i32 0, i32 7
  %total_packets66 = getelementptr inbounds %struct.igb_ring_container* %tx65, i32 0, i32 2
  store i32 0, i32* %total_packets66, align 4
  ret void
}

define internal void @igb_update_itr(%struct.igb_q_vector* %q_vector, %struct.igb_ring_container* %ring_container) nounwind noredzone {
entry:
  %q_vector.addr = alloca %struct.igb_q_vector*, align 8
  %ring_container.addr = alloca %struct.igb_ring_container*, align 8
  %packets = alloca i32, align 4
  %bytes = alloca i32, align 4
  %itrval = alloca i8, align 1
  store %struct.igb_q_vector* %q_vector, %struct.igb_q_vector** %q_vector.addr, align 8
  store %struct.igb_ring_container* %ring_container, %struct.igb_ring_container** %ring_container.addr, align 8
  %0 = load %struct.igb_ring_container** %ring_container.addr, align 8
  %total_packets = getelementptr inbounds %struct.igb_ring_container* %0, i32 0, i32 2
  %1 = load i32* %total_packets, align 4
  store i32 %1, i32* %packets, align 4
  %2 = load %struct.igb_ring_container** %ring_container.addr, align 8
  %total_bytes = getelementptr inbounds %struct.igb_ring_container* %2, i32 0, i32 1
  %3 = load i32* %total_bytes, align 4
  store i32 %3, i32* %bytes, align 4
  %4 = load %struct.igb_ring_container** %ring_container.addr, align 8
  %itr = getelementptr inbounds %struct.igb_ring_container* %4, i32 0, i32 5
  %5 = load i8* %itr, align 1
  store i8 %5, i8* %itrval, align 1
  %6 = load i32* %packets, align 4
  %cmp = icmp eq i32 %6, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i8* %itrval, align 1
  %conv = zext i8 %7 to i32
  switch i32 %conv, label %sw.epilog [
    i32 0, label %sw.bb
    i32 1, label %sw.bb11
    i32 2, label %sw.bb48
  ]

sw.bb:                                            ; preds = %if.end
  %8 = load i32* %bytes, align 4
  %9 = load i32* %packets, align 4
  %div = udiv i32 %8, %9
  %cmp1 = icmp ugt i32 %div, 8000
  br i1 %cmp1, label %if.then3, label %if.else

if.then3:                                         ; preds = %sw.bb
  store i8 2, i8* %itrval, align 1
  br label %if.end10

if.else:                                          ; preds = %sw.bb
  %10 = load i32* %packets, align 4
  %cmp4 = icmp ult i32 %10, 5
  br i1 %cmp4, label %land.lhs.true, label %if.end9

land.lhs.true:                                    ; preds = %if.else
  %11 = load i32* %bytes, align 4
  %cmp6 = icmp ugt i32 %11, 512
  br i1 %cmp6, label %if.then8, label %if.end9

if.then8:                                         ; preds = %land.lhs.true
  store i8 1, i8* %itrval, align 1
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %land.lhs.true, %if.else
  br label %if.end10

if.end10:                                         ; preds = %if.end9, %if.then3
  br label %sw.epilog

sw.bb11:                                          ; preds = %if.end
  %12 = load i32* %bytes, align 4
  %cmp12 = icmp ugt i32 %12, 10000
  br i1 %cmp12, label %if.then14, label %if.else33

if.then14:                                        ; preds = %sw.bb11
  %13 = load i32* %bytes, align 4
  %14 = load i32* %packets, align 4
  %div15 = udiv i32 %13, %14
  %cmp16 = icmp ugt i32 %div15, 8000
  br i1 %cmp16, label %if.then18, label %if.else19

if.then18:                                        ; preds = %if.then14
  store i8 2, i8* %itrval, align 1
  br label %if.end32

if.else19:                                        ; preds = %if.then14
  %15 = load i32* %packets, align 4
  %cmp20 = icmp ult i32 %15, 10
  br i1 %cmp20, label %if.then25, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.else19
  %16 = load i32* %bytes, align 4
  %17 = load i32* %packets, align 4
  %div22 = udiv i32 %16, %17
  %cmp23 = icmp ugt i32 %div22, 1200
  br i1 %cmp23, label %if.then25, label %if.else26

if.then25:                                        ; preds = %lor.lhs.false, %if.else19
  store i8 2, i8* %itrval, align 1
  br label %if.end31

if.else26:                                        ; preds = %lor.lhs.false
  %18 = load i32* %packets, align 4
  %cmp27 = icmp ugt i32 %18, 35
  br i1 %cmp27, label %if.then29, label %if.end30

if.then29:                                        ; preds = %if.else26
  store i8 0, i8* %itrval, align 1
  br label %if.end30

if.end30:                                         ; preds = %if.then29, %if.else26
  br label %if.end31

if.end31:                                         ; preds = %if.end30, %if.then25
  br label %if.end32

if.end32:                                         ; preds = %if.end31, %if.then18
  br label %if.end47

if.else33:                                        ; preds = %sw.bb11
  %19 = load i32* %bytes, align 4
  %20 = load i32* %packets, align 4
  %div34 = udiv i32 %19, %20
  %cmp35 = icmp ugt i32 %div34, 2000
  br i1 %cmp35, label %if.then37, label %if.else38

if.then37:                                        ; preds = %if.else33
  store i8 2, i8* %itrval, align 1
  br label %if.end46

if.else38:                                        ; preds = %if.else33
  %21 = load i32* %packets, align 4
  %cmp39 = icmp ule i32 %21, 2
  br i1 %cmp39, label %land.lhs.true41, label %if.end45

land.lhs.true41:                                  ; preds = %if.else38
  %22 = load i32* %bytes, align 4
  %cmp42 = icmp ult i32 %22, 512
  br i1 %cmp42, label %if.then44, label %if.end45

if.then44:                                        ; preds = %land.lhs.true41
  store i8 0, i8* %itrval, align 1
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %land.lhs.true41, %if.else38
  br label %if.end46

if.end46:                                         ; preds = %if.end45, %if.then37
  br label %if.end47

if.end47:                                         ; preds = %if.end46, %if.end32
  br label %sw.epilog

sw.bb48:                                          ; preds = %if.end
  %23 = load i32* %bytes, align 4
  %cmp49 = icmp ugt i32 %23, 25000
  br i1 %cmp49, label %if.then51, label %if.else56

if.then51:                                        ; preds = %sw.bb48
  %24 = load i32* %packets, align 4
  %cmp52 = icmp ugt i32 %24, 35
  br i1 %cmp52, label %if.then54, label %if.end55

if.then54:                                        ; preds = %if.then51
  store i8 1, i8* %itrval, align 1
  br label %if.end55

if.end55:                                         ; preds = %if.then54, %if.then51
  br label %if.end61

if.else56:                                        ; preds = %sw.bb48
  %25 = load i32* %bytes, align 4
  %cmp57 = icmp ult i32 %25, 1500
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.else56
  store i8 1, i8* %itrval, align 1
  br label %if.end60

if.end60:                                         ; preds = %if.then59, %if.else56
  br label %if.end61

if.end61:                                         ; preds = %if.end60, %if.end55
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end, %if.end61, %if.end47, %if.end10
  %26 = load %struct.igb_ring_container** %ring_container.addr, align 8
  %total_bytes62 = getelementptr inbounds %struct.igb_ring_container* %26, i32 0, i32 1
  store i32 0, i32* %total_bytes62, align 4
  %27 = load %struct.igb_ring_container** %ring_container.addr, align 8
  %total_packets63 = getelementptr inbounds %struct.igb_ring_container* %27, i32 0, i32 2
  store i32 0, i32* %total_packets63, align 4
  %28 = load i8* %itrval, align 1
  %29 = load %struct.igb_ring_container** %ring_container.addr, align 8
  %itr64 = getelementptr inbounds %struct.igb_ring_container* %29, i32 0, i32 5
  store i8 %28, i8* %itr64, align 1
  br label %return

return:                                           ; preds = %sw.epilog, %if.then
  ret void
}

define internal i32 @igb_desc_unused(%struct.igb_ring* %ring) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %ring.addr = alloca %struct.igb_ring*, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  %0 = load %struct.igb_ring** %ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 12
  %1 = load i16* %next_to_clean, align 2
  %conv = zext i16 %1 to i32
  %2 = load %struct.igb_ring** %ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 13
  %3 = load i16* %next_to_use, align 2
  %conv1 = zext i16 %3 to i32
  %cmp = icmp sgt i32 %conv, %conv1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.igb_ring** %ring.addr, align 8
  %next_to_clean3 = getelementptr inbounds %struct.igb_ring* %4, i32 0, i32 12
  %5 = load i16* %next_to_clean3, align 2
  %conv4 = zext i16 %5 to i32
  %6 = load %struct.igb_ring** %ring.addr, align 8
  %next_to_use5 = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 13
  %7 = load i16* %next_to_use5, align 2
  %conv6 = zext i16 %7 to i32
  %sub = sub i32 %conv4, %conv6
  %sub7 = sub i32 %sub, 1
  store i32 %sub7, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %8 = load %struct.igb_ring** %ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 9
  %9 = load i16* %count, align 2
  %conv8 = zext i16 %9 to i32
  %10 = load %struct.igb_ring** %ring.addr, align 8
  %next_to_clean9 = getelementptr inbounds %struct.igb_ring* %10, i32 0, i32 12
  %11 = load i16* %next_to_clean9, align 2
  %conv10 = zext i16 %11 to i32
  %add = add i32 %conv8, %conv10
  %12 = load %struct.igb_ring** %ring.addr, align 8
  %next_to_use11 = getelementptr inbounds %struct.igb_ring* %12, i32 0, i32 13
  %13 = load i16* %next_to_use11, align 2
  %conv12 = zext i16 %13 to i32
  %sub13 = sub i32 %add, %conv12
  %sub14 = sub i32 %sub13, 1
  store i32 %sub14, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i32* %retval
  ret i32 %14
}

define internal i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %rx_desc, i32 %stat_err_bits) nounwind inlinehint noredzone {
entry:
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %stat_err_bits.addr = alloca i32, align 4
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store i32 %stat_err_bits, i32* %stat_err_bits.addr, align 4
  %0 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %wb = bitcast %union.e1000_adv_rx_desc* %0 to %struct.anon.97*
  %upper = getelementptr inbounds %struct.anon.97* %wb, i32 0, i32 1
  %status_error = getelementptr inbounds %struct.anon.102* %upper, i32 0, i32 0
  %1 = load i32* %status_error, align 4
  %2 = load i32* %stat_err_bits.addr, align 4
  %and = and i32 %1, %2
  ret i32 %and
}

define internal %struct.sk_buff* @igb_fetch_rx_buffer(%struct.igb_ring* %rx_ring, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind noredzone {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %retval = alloca %struct.sk_buff*, align 8
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %rx_buffer = alloca %struct.igb_rx_buffer*, align 8
  %page = alloca %struct.page*, align 8
  %page_addr = alloca i8*, align 8
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 12
  %1 = load i16* %next_to_clean, align 2
  %idxprom = zext i16 %1 to i64
  %2 = load %struct.igb_ring** %rx_ring.addr, align 8
  %3 = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %3 to %struct.igb_rx_buffer**
  %4 = load %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %arrayidx = getelementptr %struct.igb_rx_buffer* %4, i64 %idxprom
  store %struct.igb_rx_buffer* %arrayidx, %struct.igb_rx_buffer** %rx_buffer, align 8
  %5 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %page1 = getelementptr inbounds %struct.igb_rx_buffer* %5, i32 0, i32 1
  %6 = load %struct.page** %page1, align 8
  store %struct.page* %6, %struct.page** %page, align 8
  %7 = load %struct.page** %page, align 8
  %8 = bitcast %struct.page* %7 to i8*
  call void @prefetchw(i8* %8) noredzone
  %9 = load %struct.sk_buff** %skb.addr, align 8
  %tobool = icmp ne %struct.sk_buff* %9, null
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end18

if.then:                                          ; preds = %entry
  %10 = load %struct.page** %page, align 8
  store %struct.page* %10, %struct.page** %page.addr.i, align 8
  %11 = load %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %11 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %12 = inttoptr i64 %add.i to i8*
  %13 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %13, i32 0, i32 2
  %14 = load i32* %page_offset, align 4
  %idx.ext = zext i32 %14 to i64
  %add.ptr = getelementptr i8* %12, i64 %idx.ext
  store i8* %add.ptr, i8** %page_addr, align 8
  %15 = load i8** %page_addr, align 8
  call void @llvm.prefetch(i8* %15, i32 0, i32 3, i32 1)
  %16 = load i8** %page_addr, align 8
  %add.ptr5 = getelementptr i8* %16, i64 64
  call void @llvm.prefetch(i8* %add.ptr5, i32 0, i32 3, i32 1)
  %17 = load %struct.igb_ring** %rx_ring.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 1
  %18 = load %struct.net_device** %netdev, align 8
  %call6 = call %struct.sk_buff* @netdev_alloc_skb_ip_align(%struct.net_device* %18, i32 256) noredzone
  store %struct.sk_buff* %call6, %struct.sk_buff** %skb.addr, align 8
  %19 = load %struct.sk_buff** %skb.addr, align 8
  %tobool7 = icmp ne %struct.sk_buff* %19, null
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %if.then17, label %if.end

if.then17:                                        ; preds = %if.then
  %20 = load %struct.igb_ring** %rx_ring.addr, align 8
  %21 = getelementptr inbounds %struct.igb_ring* %20, i32 0, i32 15
  %22 = bitcast %union.anon.90* %21 to %struct.anon.92*
  %rx_stats = getelementptr inbounds %struct.anon.92* %22, i32 0, i32 1
  %alloc_failed = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats, i32 0, i32 4
  %23 = load i64* %alloc_failed, align 8
  %inc = add i64 %23, 1
  store i64 %inc, i64* %alloc_failed, align 8
  store %struct.sk_buff* null, %struct.sk_buff** %retval
  br label %return

if.end:                                           ; preds = %if.then
  %24 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %24, i32 0, i32 42
  %25 = load i8** %data, align 8
  call void @prefetchw(i8* %25) noredzone
  br label %if.end18

if.end18:                                         ; preds = %if.end, %entry
  %26 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %26, i32 0, i32 2
  %27 = load %struct.device** %dev, align 8
  %28 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %dma = getelementptr inbounds %struct.igb_rx_buffer* %28, i32 0, i32 0
  %29 = load i64* %dma, align 8
  %30 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %page_offset19 = getelementptr inbounds %struct.igb_rx_buffer* %30, i32 0, i32 2
  %31 = load i32* %page_offset19, align 4
  %conv20 = zext i32 %31 to i64
  call void @dma_sync_single_range_for_cpu(%struct.device* %27, i64 %29, i64 %conv20, i64 2048, i32 2) noredzone
  %32 = load %struct.igb_ring** %rx_ring.addr, align 8
  %33 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %34 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %35 = load %struct.sk_buff** %skb.addr, align 8
  %call21 = call zeroext i1 @igb_add_rx_frag(%struct.igb_ring* %32, %struct.igb_rx_buffer* %33, %union.e1000_adv_rx_desc* %34, %struct.sk_buff* %35) noredzone
  br i1 %call21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end18
  %36 = load %struct.igb_ring** %rx_ring.addr, align 8
  %37 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  call void @igb_reuse_rx_page(%struct.igb_ring* %36, %struct.igb_rx_buffer* %37) noredzone
  br label %if.end25

if.else:                                          ; preds = %if.end18
  %38 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev23 = getelementptr inbounds %struct.igb_ring* %38, i32 0, i32 2
  %39 = load %struct.device** %dev23, align 8
  %40 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %dma24 = getelementptr inbounds %struct.igb_rx_buffer* %40, i32 0, i32 0
  %41 = load i64* %dma24, align 8
  call void @dma_unmap_page(%struct.device* %39, i64 %41, i64 4096, i32 2) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.else, %if.then22
  %42 = load %struct.igb_rx_buffer** %rx_buffer, align 8
  %page26 = getelementptr inbounds %struct.igb_rx_buffer* %42, i32 0, i32 1
  store %struct.page* null, %struct.page** %page26, align 8
  %43 = load %struct.sk_buff** %skb.addr, align 8
  store %struct.sk_buff* %43, %struct.sk_buff** %retval
  br label %return

return:                                           ; preds = %if.end25, %if.then17
  %44 = load %struct.sk_buff** %retval
  ret %struct.sk_buff* %44
}

define internal zeroext i1 @igb_is_non_eop(%struct.igb_ring* %rx_ring, %union.e1000_adv_rx_desc* %rx_desc) nounwind noredzone {
entry:
  %retval = alloca i1, align 1
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %ntc = alloca i32, align 4
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 12
  %1 = load i16* %next_to_clean, align 2
  %conv = zext i16 %1 to i32
  %add = add i32 %conv, 1
  store i32 %add, i32* %ntc, align 4
  %2 = load i32* %ntc, align 4
  %3 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %3, i32 0, i32 9
  %4 = load i16* %count, align 2
  %conv1 = zext i16 %4 to i32
  %cmp = icmp ult i32 %2, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %5 = load i32* %ntc, align 4
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %5, %cond.true ], [ 0, %cond.false ]
  store i32 %cond, i32* %ntc, align 4
  %6 = load i32* %ntc, align 4
  %conv3 = trunc i32 %6 to i16
  %7 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_clean4 = getelementptr inbounds %struct.igb_ring* %7, i32 0, i32 12
  store i16 %conv3, i16* %next_to_clean4, align 2
  %8 = load i32* %ntc, align 4
  %idxprom = zext i32 %8 to i64
  %9 = load %struct.igb_ring** %rx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %9, i32 0, i32 4
  %10 = load i8** %desc, align 8
  %11 = bitcast i8* %10 to %union.e1000_adv_rx_desc*
  %arrayidx = getelementptr %union.e1000_adv_rx_desc* %11, i64 %idxprom
  %12 = bitcast %union.e1000_adv_rx_desc* %arrayidx to i8*
  call void @llvm.prefetch(i8* %12, i32 0, i32 3, i32 1)
  %13 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %13, i32 2) noredzone
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot5 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 1)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %cond.end
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %14 = load i1* %retval
  ret i1 %14
}

define internal zeroext i1 @igb_cleanup_headers(%struct.igb_ring* %rx_ring, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind noredzone {
entry:
  %retval = alloca i1, align 1
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %pad_len = alloca i32, align 4
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %0, i32 -1761607680) noredzone
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %1 = load %struct.igb_ring** %rx_ring.addr, align 8
  %netdev3 = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 1
  %2 = load %struct.net_device** %netdev3, align 8
  store %struct.net_device* %2, %struct.net_device** %netdev, align 8
  %3 = load %struct.net_device** %netdev, align 8
  %features = getelementptr inbounds %struct.net_device* %3, i32 0, i32 14
  %4 = load i64* %features, align 8
  %and = and i64 %4, 274877906944
  %tobool4 = icmp ne i64 %and, 0
  br i1 %tobool4, label %if.end, label %if.then5

if.then5:                                         ; preds = %if.then
  %5 = load %struct.sk_buff** %skb.addr, align 8
  call void @dev_kfree_skb_any(%struct.sk_buff* %5) noredzone
  store i1 true, i1* %retval
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  %6 = load %struct.sk_buff** %skb.addr, align 8
  %call7 = call zeroext i1 @skb_is_nonlinear(%struct.sk_buff* %6) noredzone
  br i1 %call7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end6
  %7 = load %struct.igb_ring** %rx_ring.addr, align 8
  %8 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %9 = load %struct.sk_buff** %skb.addr, align 8
  call void @igb_pull_tail(%struct.igb_ring* %7, %union.e1000_adv_rx_desc* %8, %struct.sk_buff* %9) noredzone
  br label %if.end9

if.end9:                                          ; preds = %if.then8, %if.end6
  %10 = load %struct.sk_buff** %skb.addr, align 8
  %len = getelementptr inbounds %struct.sk_buff* %10, i32 0, i32 8
  %11 = load i32* %len, align 4
  %cmp = icmp ult i32 %11, 60
  %lnot11 = xor i1 %cmp, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %tobool17 = icmp ne i64 %expval16, 0
  br i1 %tobool17, label %if.then18, label %if.end25

if.then18:                                        ; preds = %if.end9
  %12 = load %struct.sk_buff** %skb.addr, align 8
  %len19 = getelementptr inbounds %struct.sk_buff* %12, i32 0, i32 8
  %13 = load i32* %len19, align 4
  %sub = sub i32 60, %13
  store i32 %sub, i32* %pad_len, align 4
  %14 = load %struct.sk_buff** %skb.addr, align 8
  %15 = load i32* %pad_len, align 4
  %call20 = call i32 @skb_pad(%struct.sk_buff* %14, i32 %15) noredzone
  %tobool21 = icmp ne i32 %call20, 0
  br i1 %tobool21, label %if.then22, label %if.end23

if.then22:                                        ; preds = %if.then18
  store i1 true, i1* %retval
  br label %return

if.end23:                                         ; preds = %if.then18
  %16 = load %struct.sk_buff** %skb.addr, align 8
  %17 = load i32* %pad_len, align 4
  %call24 = call i8* @__skb_put(%struct.sk_buff* %16, i32 %17) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.end23, %if.end9
  store i1 false, i1* %retval
  br label %return

return:                                           ; preds = %if.end25, %if.then22, %if.then5
  %18 = load i1* %retval
  ret i1 %18
}

define internal void @igb_process_skb_fields(%struct.igb_ring* %rx_ring, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %dev = alloca %struct.net_device*, align 8
  %vid = alloca i16, align 2
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev, align 8
  store %struct.net_device* %1, %struct.net_device** %dev, align 8
  %2 = load %struct.igb_ring** %rx_ring.addr, align 8
  %3 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %4 = load %struct.sk_buff** %skb.addr, align 8
  call void @igb_rx_hash(%struct.igb_ring* %2, %union.e1000_adv_rx_desc* %3, %struct.sk_buff* %4) noredzone
  %5 = load %struct.igb_ring** %rx_ring.addr, align 8
  %6 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %7 = load %struct.sk_buff** %skb.addr, align 8
  call void @igb_rx_checksum(%struct.igb_ring* %5, %union.e1000_adv_rx_desc* %6, %struct.sk_buff* %7) noredzone
  %8 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %8, i32 65536) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %9 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call1 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %9, i32 32768) noredzone
  %tobool2 = icmp ne i32 %call1, 0
  br i1 %tobool2, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %10 = load %struct.igb_ring** %rx_ring.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_ring* %10, i32 0, i32 0
  %11 = load %struct.igb_q_vector** %q_vector, align 8
  %12 = load %struct.sk_buff** %skb.addr, align 8
  call void @igb_ptp_rx_rgtstamp(%struct.igb_q_vector* %11, %struct.sk_buff* %12) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  %13 = load %struct.net_device** %dev, align 8
  %features = getelementptr inbounds %struct.net_device* %13, i32 0, i32 14
  %14 = load i64* %features, align 8
  %and = and i64 %14, 256
  %tobool3 = icmp ne i64 %and, 0
  br i1 %tobool3, label %land.lhs.true4, label %if.end24

land.lhs.true4:                                   ; preds = %if.end
  %15 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call5 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %15, i32 8) noredzone
  %tobool6 = icmp ne i32 %call5, 0
  br i1 %tobool6, label %if.then7, label %if.end24

if.then7:                                         ; preds = %land.lhs.true4
  %16 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call8 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %16, i32 262144) noredzone
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %land.lhs.true10, label %if.else

land.lhs.true10:                                  ; preds = %if.then7
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true10
  %17 = load %struct.igb_ring** %rx_ring.addr, align 8
  %flags = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 5
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %18 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %18, 63
  %shl.i = shl i64 1, %and.i
  %19 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %19, 6
  %20 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %20, i64 %shr.i
  %21 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %21
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool12 = icmp ne i32 %conv.i, 0
  br i1 %tobool12, label %if.then16, label %if.else

cond.false:                                       ; preds = %land.lhs.true10
  %22 = load %struct.igb_ring** %rx_ring.addr, align 8
  %flags13 = getelementptr inbounds %struct.igb_ring* %22, i32 0, i32 5
  %call14 = call i32 @variable_test_bit(i64 1, i64* %flags13) noredzone
  %tobool15 = icmp ne i32 %call14, 0
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %cond.false, %cond.true
  %23 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %wb = bitcast %union.e1000_adv_rx_desc* %23 to %struct.anon.97*
  %upper = getelementptr inbounds %struct.anon.97* %wb, i32 0, i32 1
  %vlan = getelementptr inbounds %struct.anon.102* %upper, i32 0, i32 2
  %24 = load i16* %vlan, align 2
  %call17 = call zeroext i16 @__fswab16(i16 zeroext %24) nounwind readnone noredzone
  %conv = zext i16 %call17 to i32
  %conv18 = trunc i32 %conv to i16
  store i16 %conv18, i16* %vid, align 2
  br label %if.end22

if.else:                                          ; preds = %cond.false, %cond.true, %if.then7
  %25 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %wb19 = bitcast %union.e1000_adv_rx_desc* %25 to %struct.anon.97*
  %upper20 = getelementptr inbounds %struct.anon.97* %wb19, i32 0, i32 1
  %vlan21 = getelementptr inbounds %struct.anon.102* %upper20, i32 0, i32 2
  %26 = load i16* %vlan21, align 2
  store i16 %26, i16* %vid, align 2
  br label %if.end22

if.end22:                                         ; preds = %if.else, %if.then16
  %27 = load %struct.sk_buff** %skb.addr, align 8
  %28 = load i16* %vid, align 2
  %call23 = call %struct.sk_buff* @__vlan_hwaccel_put_tag(%struct.sk_buff* %27, i16 zeroext 129, i16 zeroext %28) noredzone
  br label %if.end24

if.end24:                                         ; preds = %if.end22, %land.lhs.true4, %if.end
  %29 = load %struct.sk_buff** %skb.addr, align 8
  %30 = load %struct.igb_ring** %rx_ring.addr, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %30, i32 0, i32 10
  %31 = load i8* %queue_index, align 1
  %conv25 = zext i8 %31 to i16
  call void @skb_record_rx_queue(%struct.sk_buff* %29, i16 zeroext %conv25) noredzone
  %32 = load %struct.sk_buff** %skb.addr, align 8
  %33 = load %struct.igb_ring** %rx_ring.addr, align 8
  %netdev26 = getelementptr inbounds %struct.igb_ring* %33, i32 0, i32 1
  %34 = load %struct.net_device** %netdev26, align 8
  %call27 = call zeroext i16 @eth_type_trans(%struct.sk_buff* %32, %struct.net_device* %34) noredzone
  %35 = load %struct.sk_buff** %skb.addr, align 8
  %protocol = getelementptr inbounds %struct.sk_buff* %35, i32 0, i32 16
  store i16 %call27, i16* %protocol, align 2
  ret void
}

declare i32 @napi_gro_receive(%struct.napi_struct*, %struct.sk_buff*) noredzone

define internal void @u64_stats_update_begin(%struct.u64_stats_sync* %syncp) nounwind inlinehint noredzone {
entry:
  %syncp.addr = alloca %struct.u64_stats_sync*, align 8
  store %struct.u64_stats_sync* %syncp, %struct.u64_stats_sync** %syncp.addr, align 8
  ret void
}

define internal void @u64_stats_update_end(%struct.u64_stats_sync* %syncp) nounwind inlinehint noredzone {
entry:
  %syncp.addr = alloca %struct.u64_stats_sync*, align 8
  store %struct.u64_stats_sync* %syncp, %struct.u64_stats_sync** %syncp.addr, align 8
  ret void
}

define internal void @igb_rx_hash(%struct.igb_ring* %ring, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.igb_ring** %ring.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev, align 8
  %features = getelementptr inbounds %struct.net_device* %1, i32 0, i32 14
  %2 = load i64* %features, align 8
  %and = and i64 %2, 8589934592
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.sk_buff** %skb.addr, align 8
  %4 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %wb = bitcast %union.e1000_adv_rx_desc* %4 to %struct.anon.97*
  %lower = getelementptr inbounds %struct.anon.97* %wb, i32 0, i32 0
  %hi_dword = getelementptr inbounds %struct.anon.98* %lower, i32 0, i32 1
  %rss = bitcast %union.anon.100* %hi_dword to i32*
  %5 = load i32* %rss, align 4
  call void @skb_set_hash(%struct.sk_buff* %3, i32 %5, i32 2) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define internal void @igb_rx_checksum(%struct.igb_ring* %ring, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.igb_ring* %ring, %struct.igb_ring** %ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  call void @skb_checksum_none_assert(%struct.sk_buff* %0) noredzone
  %1 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %1, i32 4) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end19

if.end:                                           ; preds = %entry
  %2 = load %struct.igb_ring** %ring.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 1
  %3 = load %struct.net_device** %netdev, align 8
  %features = getelementptr inbounds %struct.net_device* %3, i32 0, i32 14
  %4 = load i64* %features, align 8
  %and = and i64 %4, 17179869184
  %tobool1 = icmp ne i64 %and, 0
  br i1 %tobool1, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %if.end19

if.end3:                                          ; preds = %if.end
  %5 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call4 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %5, i32 1610612736) noredzone
  %tobool5 = icmp ne i32 %call4, 0
  br i1 %tobool5, label %if.then6, label %if.end15

if.then6:                                         ; preds = %if.end3
  %6 = load %struct.sk_buff** %skb.addr, align 8
  %len = getelementptr inbounds %struct.sk_buff* %6, i32 0, i32 8
  %7 = load i32* %len, align 4
  %cmp = icmp eq i32 %7, 60
  br i1 %cmp, label %land.lhs.true, label %if.then12

land.lhs.true:                                    ; preds = %if.then6
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true
  %8 = load %struct.igb_ring** %ring.addr, align 8
  %flags = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 5
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %9 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %9, 63
  %shl.i = shl i64 1, %and.i
  %10 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %10, 6
  %11 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %11, i64 %shr.i
  %12 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %12
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool8 = icmp ne i32 %conv.i, 0
  br i1 %tobool8, label %if.end14, label %if.then12

cond.false:                                       ; preds = %land.lhs.true
  %13 = load %struct.igb_ring** %ring.addr, align 8
  %flags9 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 5
  %call10 = call i32 @variable_test_bit(i64 0, i64* %flags9) noredzone
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.end14, label %if.then12

if.then12:                                        ; preds = %cond.false, %cond.true, %if.then6
  %14 = load %struct.igb_ring** %ring.addr, align 8
  %15 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 15
  %16 = bitcast %union.anon.90* %15 to %struct.anon.92*
  %rx_syncp = getelementptr inbounds %struct.anon.92* %16, i32 0, i32 2
  call void @u64_stats_update_begin(%struct.u64_stats_sync* %rx_syncp) noredzone
  %17 = load %struct.igb_ring** %ring.addr, align 8
  %18 = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 15
  %19 = bitcast %union.anon.90* %18 to %struct.anon.92*
  %rx_stats = getelementptr inbounds %struct.anon.92* %19, i32 0, i32 1
  %csum_err = getelementptr inbounds %struct.igb_rx_queue_stats* %rx_stats, i32 0, i32 3
  %20 = load i64* %csum_err, align 8
  %inc = add i64 %20, 1
  store i64 %inc, i64* %csum_err, align 8
  %21 = load %struct.igb_ring** %ring.addr, align 8
  %22 = getelementptr inbounds %struct.igb_ring* %21, i32 0, i32 15
  %23 = bitcast %union.anon.90* %22 to %struct.anon.92*
  %rx_syncp13 = getelementptr inbounds %struct.anon.92* %23, i32 0, i32 2
  call void @u64_stats_update_end(%struct.u64_stats_sync* %rx_syncp13) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %cond.false, %cond.true
  br label %if.end19

if.end15:                                         ; preds = %if.end3
  %24 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call16 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %24, i32 48) noredzone
  %tobool17 = icmp ne i32 %call16, 0
  br i1 %tobool17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %if.end15
  %25 = load %struct.sk_buff** %skb.addr, align 8
  %26 = bitcast %struct.sk_buff* %25 to i8*
  %bf.field.offs = getelementptr i8* %26, i32 124
  %27 = load i8* %bf.field.offs, align 4
  %28 = and i8 %27, -13
  %29 = or i8 %28, 4
  store i8 %29, i8* %bf.field.offs, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then, %if.then2, %if.end14, %if.then18, %if.end15
  ret void
}

declare void @igb_ptp_rx_rgtstamp(%struct.igb_q_vector*, %struct.sk_buff*) noredzone

define internal zeroext i16 @__fswab16(i16 zeroext %val) nounwind readnone inlinehint noredzone {
entry:
  %val.addr = alloca i16, align 2
  store i16 %val, i16* %val.addr, align 2
  %0 = load i16* %val.addr, align 2
  %conv = zext i16 %0 to i32
  %and = and i32 %conv, 255
  %shl = shl i32 %and, 8
  %1 = load i16* %val.addr, align 2
  %conv1 = zext i16 %1 to i32
  %and2 = and i32 %conv1, 65280
  %shr = ashr i32 %and2, 8
  %or = or i32 %shl, %shr
  %conv3 = trunc i32 %or to i16
  ret i16 %conv3
}

define internal %struct.sk_buff* @__vlan_hwaccel_put_tag(%struct.sk_buff* %skb, i16 zeroext %vlan_proto, i16 zeroext %vlan_tci) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %vlan_proto.addr = alloca i16, align 2
  %vlan_tci.addr = alloca i16, align 2
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i16 %vlan_proto, i16* %vlan_proto.addr, align 2
  store i16 %vlan_tci, i16* %vlan_tci.addr, align 2
  %0 = load i16* %vlan_proto.addr, align 2
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %vlan_proto1 = getelementptr inbounds %struct.sk_buff* %1, i32 0, i32 22
  store i16 %0, i16* %vlan_proto1, align 2
  %2 = load i16* %vlan_tci.addr, align 2
  %conv = zext i16 %2 to i32
  %or = or i32 4096, %conv
  %conv2 = trunc i32 %or to i16
  %3 = load %struct.sk_buff** %skb.addr, align 8
  %vlan_tci3 = getelementptr inbounds %struct.sk_buff* %3, i32 0, i32 23
  store i16 %conv2, i16* %vlan_tci3, align 2
  %4 = load %struct.sk_buff** %skb.addr, align 8
  ret %struct.sk_buff* %4
}

define internal void @skb_record_rx_queue(%struct.sk_buff* %skb, i16 zeroext %rx_queue) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %rx_queue.addr = alloca i16, align 2
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i16 %rx_queue, i16* %rx_queue.addr, align 2
  %0 = load i16* %rx_queue.addr, align 2
  %conv = zext i16 %0 to i32
  %add = add i32 %conv, 1
  %conv1 = trunc i32 %add to i16
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %queue_mapping = getelementptr inbounds %struct.sk_buff* %1, i32 0, i32 26
  store i16 %conv1, i16* %queue_mapping, align 2
  ret void
}

declare zeroext i16 @eth_type_trans(%struct.sk_buff*, %struct.net_device*) noredzone

define internal void @skb_checksum_none_assert(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  ret void
}

define internal void @skb_set_hash(%struct.sk_buff* %skb, i32 %hash, i32 %type) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %hash.addr = alloca i32, align 4
  %type.addr = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %hash, i32* %hash.addr, align 4
  store i32 %type, i32* %type.addr, align 4
  %0 = load i32* %type.addr, align 4
  %cmp = icmp eq i32 %0, 3
  %conv = zext i1 %cmp to i32
  %conv1 = trunc i32 %conv to i8
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %bf.value = and i8 %conv1, 1
  %2 = bitcast %struct.sk_buff* %1 to i8*
  %bf.field.offs = getelementptr i8* %2, i32 170
  %3 = and i8 %bf.value, 1
  %4 = shl i8 %3, 4
  %5 = load i8* %bf.field.offs, align 2
  %6 = and i8 %5, -17
  %7 = or i8 %6, %4
  store i8 %7, i8* %bf.field.offs, align 2
  %8 = load %struct.sk_buff** %skb.addr, align 8
  %9 = bitcast %struct.sk_buff* %8 to i8*
  %bf.field.offs2 = getelementptr i8* %9, i32 170
  %10 = load i8* %bf.field.offs2, align 2
  %11 = and i8 %10, -33
  store i8 %11, i8* %bf.field.offs2, align 2
  %12 = load i32* %hash.addr, align 4
  %13 = load %struct.sk_buff** %skb.addr, align 8
  %hash3 = getelementptr inbounds %struct.sk_buff* %13, i32 0, i32 21
  store i32 %12, i32* %hash3, align 4
  ret void
}

define internal zeroext i1 @skb_is_nonlinear(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %data_len = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 9
  %1 = load i32* %data_len, align 4
  %tobool = icmp ne i32 %1, 0
  ret i1 %tobool
}

define internal void @igb_pull_tail(%struct.igb_ring* %rx_ring, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind noredzone {
entry:
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %frag = alloca %struct.skb_frag_struct*, align 8
  %va = alloca i8*, align 8
  %pull_len = alloca i32, align 4
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_end_pointer(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.skb_shared_info*
  %frags = getelementptr inbounds %struct.skb_shared_info* %1, i32 0, i32 11
  %arrayidx = getelementptr [17 x %struct.skb_frag_struct]* %frags, i32 0, i64 0
  store %struct.skb_frag_struct* %arrayidx, %struct.skb_frag_struct** %frag, align 8
  %2 = load %struct.skb_frag_struct** %frag, align 8
  %call1 = call i8* @skb_frag_address(%struct.skb_frag_struct* %2) noredzone
  store i8* %call1, i8** %va, align 8
  %3 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call2 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %3, i32 32768) noredzone
  %tobool = icmp ne i32 %call2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.igb_ring** %rx_ring.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_ring* %4, i32 0, i32 0
  %5 = load %struct.igb_q_vector** %q_vector, align 8
  %6 = load i8** %va, align 8
  %7 = load %struct.sk_buff** %skb.addr, align 8
  call void @igb_ptp_rx_pktstamp(%struct.igb_q_vector* %5, i8* %6, %struct.sk_buff* %7) noredzone
  %8 = load %struct.skb_frag_struct** %frag, align 8
  call void @skb_frag_size_sub(%struct.skb_frag_struct* %8, i32 16) noredzone
  %9 = load %struct.skb_frag_struct** %frag, align 8
  %page_offset = getelementptr inbounds %struct.skb_frag_struct* %9, i32 0, i32 1
  %10 = load i32* %page_offset, align 4
  %add = add i32 %10, 16
  store i32 %add, i32* %page_offset, align 4
  %11 = load %struct.sk_buff** %skb.addr, align 8
  %data_len = getelementptr inbounds %struct.sk_buff* %11, i32 0, i32 9
  %12 = load i32* %data_len, align 4
  %sub = sub i32 %12, 16
  store i32 %sub, i32* %data_len, align 4
  %13 = load %struct.sk_buff** %skb.addr, align 8
  %len = getelementptr inbounds %struct.sk_buff* %13, i32 0, i32 8
  %14 = load i32* %len, align 4
  %sub3 = sub i32 %14, 16
  store i32 %sub3, i32* %len, align 4
  %15 = load i8** %va, align 8
  %add.ptr = getelementptr i8* %15, i64 16
  store i8* %add.ptr, i8** %va, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %16 = load i8** %va, align 8
  %call4 = call i32 @igb_get_headlen(i8* %16, i32 256) noredzone
  store i32 %call4, i32* %pull_len, align 4
  %17 = load %struct.sk_buff** %skb.addr, align 8
  %18 = load i8** %va, align 8
  %19 = load i32* %pull_len, align 4
  %add5 = add i32 %19, 7
  %and = and i32 %add5, -8
  call void @skb_copy_to_linear_data(%struct.sk_buff* %17, i8* %18, i32 %and) noredzone
  %20 = load %struct.skb_frag_struct** %frag, align 8
  %21 = load i32* %pull_len, align 4
  call void @skb_frag_size_sub(%struct.skb_frag_struct* %20, i32 %21) noredzone
  %22 = load i32* %pull_len, align 4
  %23 = load %struct.skb_frag_struct** %frag, align 8
  %page_offset6 = getelementptr inbounds %struct.skb_frag_struct* %23, i32 0, i32 1
  %24 = load i32* %page_offset6, align 4
  %add7 = add i32 %24, %22
  store i32 %add7, i32* %page_offset6, align 4
  %25 = load i32* %pull_len, align 4
  %26 = load %struct.sk_buff** %skb.addr, align 8
  %data_len8 = getelementptr inbounds %struct.sk_buff* %26, i32 0, i32 9
  %27 = load i32* %data_len8, align 4
  %sub9 = sub i32 %27, %25
  store i32 %sub9, i32* %data_len8, align 4
  %28 = load i32* %pull_len, align 4
  %29 = load %struct.sk_buff** %skb.addr, align 8
  %tail = getelementptr inbounds %struct.sk_buff* %29, i32 0, i32 39
  %30 = load i32* %tail, align 4
  %add10 = add i32 %30, %28
  store i32 %add10, i32* %tail, align 4
  ret void
}

declare i32 @skb_pad(%struct.sk_buff*, i32) noredzone

define internal i8* @__skb_put(%struct.sk_buff* %skb, i32 %len) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %len.addr = alloca i32, align 4
  %tmp = alloca i8*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_tail_pointer(%struct.sk_buff* %0) noredzone
  store i8* %call, i8** %tmp, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %call1 = call zeroext i1 @skb_is_nonlinear(%struct.sk_buff* %1) noredzone
  %lnot = xor i1 %call1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body3

do.body3:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([23 x i8]* @.str27, i32 0, i32 0), i32 1575, i64 12) nounwind, !srcloc !20
  br label %do.body4

do.body4:                                         ; preds = %do.cond, %do.body3
  br label %do.cond

do.cond:                                          ; preds = %do.body4
  br i1 true, label %do.body4, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end6

do.end6:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end6, %do.body
  br label %do.end8

do.end8:                                          ; preds = %if.end
  %2 = load i32* %len.addr, align 4
  %3 = load %struct.sk_buff** %skb.addr, align 8
  %tail = getelementptr inbounds %struct.sk_buff* %3, i32 0, i32 39
  %4 = load i32* %tail, align 4
  %add = add i32 %4, %2
  store i32 %add, i32* %tail, align 4
  %5 = load i32* %len.addr, align 4
  %6 = load %struct.sk_buff** %skb.addr, align 8
  %len9 = getelementptr inbounds %struct.sk_buff* %6, i32 0, i32 8
  %7 = load i32* %len9, align 4
  %add10 = add i32 %7, %5
  store i32 %add10, i32* %len9, align 4
  %8 = load i8** %tmp, align 8
  ret i8* %8
}

define internal i8* @skb_tail_pointer(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %head = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 41
  %1 = load i8** %head, align 8
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %tail = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 39
  %3 = load i32* %tail, align 4
  %idx.ext = zext i32 %3 to i64
  %add.ptr = getelementptr i8* %1, i64 %idx.ext
  ret i8* %add.ptr
}

define internal i8* @skb_frag_address(%struct.skb_frag_struct* %frag) nounwind inlinehint noredzone {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %frag.addr = alloca %struct.skb_frag_struct*, align 8
  store %struct.skb_frag_struct* %frag, %struct.skb_frag_struct** %frag.addr, align 8
  %0 = load %struct.skb_frag_struct** %frag.addr, align 8
  %call = call %struct.page* @skb_frag_page(%struct.skb_frag_struct* %0) noredzone
  store %struct.page* %call, %struct.page** %page.addr.i, align 8
  %1 = load %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %1 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %2 = inttoptr i64 %add.i to i8*
  %3 = load %struct.skb_frag_struct** %frag.addr, align 8
  %page_offset = getelementptr inbounds %struct.skb_frag_struct* %3, i32 0, i32 1
  %4 = load i32* %page_offset, align 4
  %idx.ext = zext i32 %4 to i64
  %add.ptr = getelementptr i8* %2, i64 %idx.ext
  ret i8* %add.ptr
}

declare void @igb_ptp_rx_pktstamp(%struct.igb_q_vector*, i8*, %struct.sk_buff*) noredzone

define internal void @skb_frag_size_sub(%struct.skb_frag_struct* %frag, i32 %delta) nounwind inlinehint noredzone {
entry:
  %frag.addr = alloca %struct.skb_frag_struct*, align 8
  %delta.addr = alloca i32, align 4
  store %struct.skb_frag_struct* %frag, %struct.skb_frag_struct** %frag.addr, align 8
  store i32 %delta, i32* %delta.addr, align 4
  %0 = load i32* %delta.addr, align 4
  %1 = load %struct.skb_frag_struct** %frag.addr, align 8
  %size = getelementptr inbounds %struct.skb_frag_struct* %1, i32 0, i32 2
  %2 = load i32* %size, align 4
  %sub = sub i32 %2, %0
  store i32 %sub, i32* %size, align 4
  ret void
}

define internal i32 @igb_get_headlen(i8* %data, i32 %max_len) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %data.addr = alloca i8*, align 8
  %max_len.addr = alloca i32, align 4
  %hdr = alloca %union.anon.103, align 8
  %protocol = alloca i16, align 2
  %nexthdr = alloca i8, align 1
  %hlen = alloca i8, align 1
  store i8* %data, i8** %data.addr, align 8
  store i32 %max_len, i32* %max_len.addr, align 4
  store i8 0, i8* %nexthdr, align 1
  %0 = load i32* %max_len.addr, align 4
  %cmp = icmp ult i32 %0, 14
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i32* %max_len.addr, align 4
  store i32 %1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i8** %data.addr, align 8
  %network = bitcast %union.anon.103* %hdr to i8**
  store i8* %2, i8** %network, align 8
  %eth = bitcast %union.anon.103* %hdr to %struct.ethhdr**
  %3 = load %struct.ethhdr** %eth, align 8
  %h_proto = getelementptr inbounds %struct.ethhdr* %3, i32 0, i32 2
  %4 = load i16* %h_proto, align 1
  store i16 %4, i16* %protocol, align 2
  %network1 = bitcast %union.anon.103* %hdr to i8**
  %5 = load i8** %network1, align 8
  %add.ptr = getelementptr i8* %5, i64 14
  store i8* %add.ptr, i8** %network1, align 8
  %6 = load i16* %protocol, align 2
  %conv = zext i16 %6 to i32
  %cmp2 = icmp eq i32 %conv, 129
  br i1 %cmp2, label %if.then4, label %if.end13

if.then4:                                         ; preds = %if.end
  %network5 = bitcast %union.anon.103* %hdr to i8**
  %7 = load i8** %network5, align 8
  %8 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %7 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %8 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %9 = load i32* %max_len.addr, align 4
  %sub = sub i32 %9, 4
  %conv6 = zext i32 %sub to i64
  %cmp7 = icmp sgt i64 %sub.ptr.sub, %conv6
  br i1 %cmp7, label %if.then9, label %if.end10

if.then9:                                         ; preds = %if.then4
  %10 = load i32* %max_len.addr, align 4
  store i32 %10, i32* %retval
  br label %return

if.end10:                                         ; preds = %if.then4
  %vlan = bitcast %union.anon.103* %hdr to %struct.vlan_hdr**
  %11 = load %struct.vlan_hdr** %vlan, align 8
  %h_vlan_encapsulated_proto = getelementptr inbounds %struct.vlan_hdr* %11, i32 0, i32 1
  %12 = load i16* %h_vlan_encapsulated_proto, align 2
  store i16 %12, i16* %protocol, align 2
  %network11 = bitcast %union.anon.103* %hdr to i8**
  %13 = load i8** %network11, align 8
  %add.ptr12 = getelementptr i8* %13, i64 4
  store i8* %add.ptr12, i8** %network11, align 8
  br label %if.end13

if.end13:                                         ; preds = %if.end10, %if.end
  %14 = load i16* %protocol, align 2
  %conv14 = zext i16 %14 to i32
  %cmp15 = icmp eq i32 %conv14, 8
  br i1 %cmp15, label %if.then17, label %if.else

if.then17:                                        ; preds = %if.end13
  %network18 = bitcast %union.anon.103* %hdr to i8**
  %15 = load i8** %network18, align 8
  %16 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast19 = ptrtoint i8* %15 to i64
  %sub.ptr.rhs.cast20 = ptrtoint i8* %16 to i64
  %sub.ptr.sub21 = sub i64 %sub.ptr.lhs.cast19, %sub.ptr.rhs.cast20
  %17 = load i32* %max_len.addr, align 4
  %conv22 = zext i32 %17 to i64
  %sub23 = sub i64 %conv22, 20
  %cmp24 = icmp ugt i64 %sub.ptr.sub21, %sub23
  br i1 %cmp24, label %if.then26, label %if.end27

if.then26:                                        ; preds = %if.then17
  %18 = load i32* %max_len.addr, align 4
  store i32 %18, i32* %retval
  br label %return

if.end27:                                         ; preds = %if.then17
  %network28 = bitcast %union.anon.103* %hdr to i8**
  %19 = load i8** %network28, align 8
  %arrayidx = getelementptr i8* %19, i64 0
  %20 = load i8* %arrayidx, align 1
  %conv29 = zext i8 %20 to i32
  %and = and i32 %conv29, 15
  %shl = shl i32 %and, 2
  %conv30 = trunc i32 %shl to i8
  store i8 %conv30, i8* %hlen, align 1
  %21 = load i8* %hlen, align 1
  %conv31 = zext i8 %21 to i64
  %cmp32 = icmp ult i64 %conv31, 20
  br i1 %cmp32, label %if.then34, label %if.end40

if.then34:                                        ; preds = %if.end27
  %network35 = bitcast %union.anon.103* %hdr to i8**
  %22 = load i8** %network35, align 8
  %23 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast36 = ptrtoint i8* %22 to i64
  %sub.ptr.rhs.cast37 = ptrtoint i8* %23 to i64
  %sub.ptr.sub38 = sub i64 %sub.ptr.lhs.cast36, %sub.ptr.rhs.cast37
  %conv39 = trunc i64 %sub.ptr.sub38 to i32
  store i32 %conv39, i32* %retval
  br label %return

if.end40:                                         ; preds = %if.end27
  %ipv4 = bitcast %union.anon.103* %hdr to %struct.iphdr**
  %24 = load %struct.iphdr** %ipv4, align 8
  %frag_off = getelementptr inbounds %struct.iphdr* %24, i32 0, i32 4
  %25 = load i16* %frag_off, align 2
  %conv41 = zext i16 %25 to i32
  %and42 = and i32 %conv41, 65311
  %tobool = icmp ne i32 %and42, 0
  br i1 %tobool, label %if.end46, label %if.then43

if.then43:                                        ; preds = %if.end40
  %ipv444 = bitcast %union.anon.103* %hdr to %struct.iphdr**
  %26 = load %struct.iphdr** %ipv444, align 8
  %protocol45 = getelementptr inbounds %struct.iphdr* %26, i32 0, i32 6
  %27 = load i8* %protocol45, align 1
  store i8 %27, i8* %nexthdr, align 1
  br label %if.end46

if.end46:                                         ; preds = %if.then43, %if.end40
  br label %if.end69

if.else:                                          ; preds = %if.end13
  %28 = load i16* %protocol, align 2
  %conv47 = zext i16 %28 to i32
  %cmp48 = icmp eq i32 %conv47, 56710
  br i1 %cmp48, label %if.then50, label %if.else62

if.then50:                                        ; preds = %if.else
  %network51 = bitcast %union.anon.103* %hdr to i8**
  %29 = load i8** %network51, align 8
  %30 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast52 = ptrtoint i8* %29 to i64
  %sub.ptr.rhs.cast53 = ptrtoint i8* %30 to i64
  %sub.ptr.sub54 = sub i64 %sub.ptr.lhs.cast52, %sub.ptr.rhs.cast53
  %31 = load i32* %max_len.addr, align 4
  %conv55 = zext i32 %31 to i64
  %sub56 = sub i64 %conv55, 40
  %cmp57 = icmp ugt i64 %sub.ptr.sub54, %sub56
  br i1 %cmp57, label %if.then59, label %if.end60

if.then59:                                        ; preds = %if.then50
  %32 = load i32* %max_len.addr, align 4
  store i32 %32, i32* %retval
  br label %return

if.end60:                                         ; preds = %if.then50
  %ipv6 = bitcast %union.anon.103* %hdr to %struct.ipv6hdr**
  %33 = load %struct.ipv6hdr** %ipv6, align 8
  %nexthdr61 = getelementptr inbounds %struct.ipv6hdr* %33, i32 0, i32 3
  %34 = load i8* %nexthdr61, align 1
  store i8 %34, i8* %nexthdr, align 1
  store i8 40, i8* %hlen, align 1
  br label %if.end68

if.else62:                                        ; preds = %if.else
  %network63 = bitcast %union.anon.103* %hdr to i8**
  %35 = load i8** %network63, align 8
  %36 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast64 = ptrtoint i8* %35 to i64
  %sub.ptr.rhs.cast65 = ptrtoint i8* %36 to i64
  %sub.ptr.sub66 = sub i64 %sub.ptr.lhs.cast64, %sub.ptr.rhs.cast65
  %conv67 = trunc i64 %sub.ptr.sub66 to i32
  store i32 %conv67, i32* %retval
  br label %return

if.end68:                                         ; preds = %if.end60
  br label %if.end69

if.end69:                                         ; preds = %if.end68, %if.end46
  %37 = load i8* %hlen, align 1
  %conv70 = zext i8 %37 to i32
  %network71 = bitcast %union.anon.103* %hdr to i8**
  %38 = load i8** %network71, align 8
  %idx.ext = sext i32 %conv70 to i64
  %add.ptr72 = getelementptr i8* %38, i64 %idx.ext
  store i8* %add.ptr72, i8** %network71, align 8
  %39 = load i8* %nexthdr, align 1
  %conv73 = zext i8 %39 to i32
  %cmp74 = icmp eq i32 %conv73, 6
  br i1 %cmp74, label %if.then76, label %if.else106

if.then76:                                        ; preds = %if.end69
  %network77 = bitcast %union.anon.103* %hdr to i8**
  %40 = load i8** %network77, align 8
  %41 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast78 = ptrtoint i8* %40 to i64
  %sub.ptr.rhs.cast79 = ptrtoint i8* %41 to i64
  %sub.ptr.sub80 = sub i64 %sub.ptr.lhs.cast78, %sub.ptr.rhs.cast79
  %42 = load i32* %max_len.addr, align 4
  %conv81 = zext i32 %42 to i64
  %sub82 = sub i64 %conv81, 20
  %cmp83 = icmp ugt i64 %sub.ptr.sub80, %sub82
  br i1 %cmp83, label %if.then85, label %if.end86

if.then85:                                        ; preds = %if.then76
  %43 = load i32* %max_len.addr, align 4
  store i32 %43, i32* %retval
  br label %return

if.end86:                                         ; preds = %if.then76
  %network87 = bitcast %union.anon.103* %hdr to i8**
  %44 = load i8** %network87, align 8
  %arrayidx88 = getelementptr i8* %44, i64 12
  %45 = load i8* %arrayidx88, align 1
  %conv89 = zext i8 %45 to i32
  %and90 = and i32 %conv89, 240
  %shr = ashr i32 %and90, 2
  %conv91 = trunc i32 %shr to i8
  store i8 %conv91, i8* %hlen, align 1
  %46 = load i8* %hlen, align 1
  %conv92 = zext i8 %46 to i64
  %cmp93 = icmp ult i64 %conv92, 20
  br i1 %cmp93, label %if.then95, label %if.end101

if.then95:                                        ; preds = %if.end86
  %network96 = bitcast %union.anon.103* %hdr to i8**
  %47 = load i8** %network96, align 8
  %48 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast97 = ptrtoint i8* %47 to i64
  %sub.ptr.rhs.cast98 = ptrtoint i8* %48 to i64
  %sub.ptr.sub99 = sub i64 %sub.ptr.lhs.cast97, %sub.ptr.rhs.cast98
  %conv100 = trunc i64 %sub.ptr.sub99 to i32
  store i32 %conv100, i32* %retval
  br label %return

if.end101:                                        ; preds = %if.end86
  %49 = load i8* %hlen, align 1
  %conv102 = zext i8 %49 to i32
  %network103 = bitcast %union.anon.103* %hdr to i8**
  %50 = load i8** %network103, align 8
  %idx.ext104 = sext i32 %conv102 to i64
  %add.ptr105 = getelementptr i8* %50, i64 %idx.ext104
  store i8* %add.ptr105, i8** %network103, align 8
  br label %if.end124

if.else106:                                       ; preds = %if.end69
  %51 = load i8* %nexthdr, align 1
  %conv107 = zext i8 %51 to i32
  %cmp108 = icmp eq i32 %conv107, 17
  br i1 %cmp108, label %if.then110, label %if.end123

if.then110:                                       ; preds = %if.else106
  %network111 = bitcast %union.anon.103* %hdr to i8**
  %52 = load i8** %network111, align 8
  %53 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast112 = ptrtoint i8* %52 to i64
  %sub.ptr.rhs.cast113 = ptrtoint i8* %53 to i64
  %sub.ptr.sub114 = sub i64 %sub.ptr.lhs.cast112, %sub.ptr.rhs.cast113
  %54 = load i32* %max_len.addr, align 4
  %conv115 = zext i32 %54 to i64
  %sub116 = sub i64 %conv115, 8
  %cmp117 = icmp ugt i64 %sub.ptr.sub114, %sub116
  br i1 %cmp117, label %if.then119, label %if.end120

if.then119:                                       ; preds = %if.then110
  %55 = load i32* %max_len.addr, align 4
  store i32 %55, i32* %retval
  br label %return

if.end120:                                        ; preds = %if.then110
  %network121 = bitcast %union.anon.103* %hdr to i8**
  %56 = load i8** %network121, align 8
  %add.ptr122 = getelementptr i8* %56, i64 8
  store i8* %add.ptr122, i8** %network121, align 8
  br label %if.end123

if.end123:                                        ; preds = %if.end120, %if.else106
  br label %if.end124

if.end124:                                        ; preds = %if.end123, %if.end101
  %network125 = bitcast %union.anon.103* %hdr to i8**
  %57 = load i8** %network125, align 8
  %58 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast126 = ptrtoint i8* %57 to i64
  %sub.ptr.rhs.cast127 = ptrtoint i8* %58 to i64
  %sub.ptr.sub128 = sub i64 %sub.ptr.lhs.cast126, %sub.ptr.rhs.cast127
  %59 = load i32* %max_len.addr, align 4
  %conv129 = zext i32 %59 to i64
  %cmp130 = icmp slt i64 %sub.ptr.sub128, %conv129
  br i1 %cmp130, label %if.then132, label %if.else138

if.then132:                                       ; preds = %if.end124
  %network133 = bitcast %union.anon.103* %hdr to i8**
  %60 = load i8** %network133, align 8
  %61 = load i8** %data.addr, align 8
  %sub.ptr.lhs.cast134 = ptrtoint i8* %60 to i64
  %sub.ptr.rhs.cast135 = ptrtoint i8* %61 to i64
  %sub.ptr.sub136 = sub i64 %sub.ptr.lhs.cast134, %sub.ptr.rhs.cast135
  %conv137 = trunc i64 %sub.ptr.sub136 to i32
  store i32 %conv137, i32* %retval
  br label %return

if.else138:                                       ; preds = %if.end124
  %62 = load i32* %max_len.addr, align 4
  store i32 %62, i32* %retval
  br label %return

return:                                           ; preds = %if.else138, %if.then132, %if.then119, %if.then95, %if.then85, %if.else62, %if.then59, %if.then34, %if.then26, %if.then9, %if.then
  %63 = load i32* %retval
  ret i32 %63
}

define internal void @skb_copy_to_linear_data(%struct.sk_buff* %skb, i8* %from, i32 %len) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %from.addr = alloca i8*, align 8
  %len.addr = alloca i32, align 4
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i8* %from, i8** %from.addr, align 8
  store i32 %len, i32* %len.addr, align 4
  %0 = load i32* %len.addr, align 4
  %conv = zext i32 %0 to i64
  store i64 %conv, i64* %__len, align 8
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %1, i32 0, i32 42
  %2 = load i8** %data, align 8
  %3 = load i8** %from.addr, align 8
  %4 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %2, i8* %3, i64 %4, i32 1, i1 false)
  store i8* %2, i8** %__ret, align 8
  %5 = load i8** %__ret, align 8
  ret void
}

define internal %struct.page* @skb_frag_page(%struct.skb_frag_struct* %frag) nounwind inlinehint noredzone {
entry:
  %frag.addr = alloca %struct.skb_frag_struct*, align 8
  store %struct.skb_frag_struct* %frag, %struct.skb_frag_struct** %frag.addr, align 8
  %0 = load %struct.skb_frag_struct** %frag.addr, align 8
  %page = getelementptr inbounds %struct.skb_frag_struct* %0, i32 0, i32 0
  %p = getelementptr inbounds %struct.anon.95* %page, i32 0, i32 0
  %1 = load %struct.page** %p, align 8
  ret %struct.page* %1
}

declare void @llvm.prefetch(i8* nocapture, i32, i32, i32) nounwind

define internal void @prefetchw(i8* %x) nounwind inlinehint noredzone {
entry:
  %x.addr = alloca i8*, align 8
  store i8* %x, i8** %x.addr, align 8
  %0 = load i8** %x.addr, align 8
  call void asm sideeffect "661:\0A\09prefetcht0 ($1)\0A662:\0A.pushsection .altinstructions,\22a\22\0A .long 661b - .\0A .long 6631f - .\0A .word ( 1*32+31)\0A .byte 662b-661b\0A .byte 6641f-6631f\0A.popsection\0A.pushsection .discard,\22aw\22,@progbits\0A .byte 0xff + (6641f-6631f) - (662b-661b)\0A.popsection\0A.pushsection .altinstr_replacement, \22ax\22\0A6631:\0A\09prefetchw ($1)\0A6641:\0A\09.popsection", "i,r,~{dirflag},~{fpsr},~{flags}"(i32 0, i8* %0) nounwind, !srcloc !21
  ret void
}

define internal %struct.sk_buff* @netdev_alloc_skb_ip_align(%struct.net_device* %dev, i32 %length) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %length.addr = alloca i32, align 4
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i32 %length, i32* %length.addr, align 4
  %0 = load %struct.net_device** %dev.addr, align 8
  %1 = load i32* %length.addr, align 4
  %call = call %struct.sk_buff* @__netdev_alloc_skb_ip_align(%struct.net_device* %0, i32 %1, i32 32) noredzone
  ret %struct.sk_buff* %call
}

define internal void @dma_sync_single_range_for_cpu(%struct.device* %dev, i64 %addr, i64 %offset, i64 %size, i32 %dir) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %addr.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %ops = alloca %struct.dma_map_ops*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32* %dir.addr, align 4
  %call1 = call i32 @valid_dma_direction(i32 %1) noredzone
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8]* @.str28, i32 0, i32 0), i32 129, i64 12) nounwind, !srcloc !22
  br label %do.body6

do.body6:                                         ; preds = %do.cond, %do.body5
  br label %do.cond

do.cond:                                          ; preds = %do.body6
  br i1 true, label %do.body6, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %do.body
  br label %do.end10

do.end10:                                         ; preds = %if.end
  %2 = load %struct.dma_map_ops** %ops, align 8
  %sync_single_for_cpu = getelementptr inbounds %struct.dma_map_ops* %2, i32 0, i32 8
  %3 = load void (%struct.device*, i64, i64, i32)** %sync_single_for_cpu, align 8
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32)* %3, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %4 = load %struct.dma_map_ops** %ops, align 8
  %sync_single_for_cpu13 = getelementptr inbounds %struct.dma_map_ops* %4, i32 0, i32 8
  %5 = load void (%struct.device*, i64, i64, i32)** %sync_single_for_cpu13, align 8
  %6 = load %struct.device** %dev.addr, align 8
  %7 = load i64* %addr.addr, align 8
  %8 = load i64* %offset.addr, align 8
  %add = add i64 %7, %8
  %9 = load i64* %size.addr, align 8
  %10 = load i32* %dir.addr, align 4
  call void %5(%struct.device* %6, i64 %add, i64 %9, i32 %10) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  %11 = load %struct.device** %dev.addr, align 8
  %12 = load i64* %addr.addr, align 8
  %13 = load i64* %offset.addr, align 8
  %14 = load i64* %size.addr, align 8
  %15 = load i32* %dir.addr, align 4
  call void @debug_dma_sync_single_range_for_cpu(%struct.device* %11, i64 %12, i64 %13, i64 %14, i32 %15) noredzone
  ret void
}

define internal zeroext i1 @igb_add_rx_frag(%struct.igb_ring* %rx_ring, %struct.igb_rx_buffer* %rx_buffer, %union.e1000_adv_rx_desc* %rx_desc, %struct.sk_buff* %skb) nounwind noredzone {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %retval = alloca i1, align 1
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %rx_buffer.addr = alloca %struct.igb_rx_buffer*, align 8
  %rx_desc.addr = alloca %union.e1000_adv_rx_desc*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %page = alloca %struct.page*, align 8
  %size = alloca i32, align 4
  %truesize = alloca i32, align 4
  %va = alloca i8*, align 8
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %struct.igb_rx_buffer* %rx_buffer, %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  store %union.e1000_adv_rx_desc* %rx_desc, %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  %page1 = getelementptr inbounds %struct.igb_rx_buffer* %0, i32 0, i32 1
  %1 = load %struct.page** %page1, align 8
  store %struct.page* %1, %struct.page** %page, align 8
  %2 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %wb = bitcast %union.e1000_adv_rx_desc* %2 to %struct.anon.97*
  %upper = getelementptr inbounds %struct.anon.97* %wb, i32 0, i32 1
  %length = getelementptr inbounds %struct.anon.102* %upper, i32 0, i32 1
  %3 = load i16* %length, align 2
  %conv = zext i16 %3 to i32
  store i32 %conv, i32* %size, align 4
  store i32 2048, i32* %truesize, align 4
  %4 = load i32* %size, align 4
  %cmp = icmp ule i32 %4, 256
  br i1 %cmp, label %land.lhs.true, label %if.end18

land.lhs.true:                                    ; preds = %entry
  %5 = load %struct.sk_buff** %skb.addr, align 8
  %call = call zeroext i1 @skb_is_nonlinear(%struct.sk_buff* %5) noredzone
  br i1 %call, label %if.end18, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.page** %page, align 8
  store %struct.page* %6, %struct.page** %page.addr.i, align 8
  %7 = load %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %7 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %8 = inttoptr i64 %add.i to i8*
  %9 = load %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %9, i32 0, i32 2
  %10 = load i32* %page_offset, align 4
  %idx.ext = zext i32 %10 to i64
  %add.ptr = getelementptr i8* %8, i64 %idx.ext
  store i8* %add.ptr, i8** %va, align 8
  %11 = load %union.e1000_adv_rx_desc** %rx_desc.addr, align 8
  %call4 = call i32 @igb_test_staterr(%union.e1000_adv_rx_desc* %11, i32 32768) noredzone
  %tobool = icmp ne i32 %call4, 0
  br i1 %tobool, label %if.then5, label %if.end

if.then5:                                         ; preds = %if.then
  %12 = load %struct.igb_ring** %rx_ring.addr, align 8
  %q_vector = getelementptr inbounds %struct.igb_ring* %12, i32 0, i32 0
  %13 = load %struct.igb_q_vector** %q_vector, align 8
  %14 = load i8** %va, align 8
  %15 = load %struct.sk_buff** %skb.addr, align 8
  call void @igb_ptp_rx_pktstamp(%struct.igb_q_vector* %13, i8* %14, %struct.sk_buff* %15) noredzone
  %16 = load i8** %va, align 8
  %add.ptr6 = getelementptr i8* %16, i64 16
  store i8* %add.ptr6, i8** %va, align 8
  %17 = load i32* %size, align 4
  %sub = sub i32 %17, 16
  store i32 %sub, i32* %size, align 4
  br label %if.end

if.end:                                           ; preds = %if.then5, %if.then
  %18 = load i32* %size, align 4
  %add = add i32 %18, 7
  %and = and i32 %add, -8
  %conv7 = zext i32 %and to i64
  store i64 %conv7, i64* %__len, align 8
  %19 = load %struct.sk_buff** %skb.addr, align 8
  %20 = load i32* %size, align 4
  %call8 = call i8* @__skb_put(%struct.sk_buff* %19, i32 %20) noredzone
  %21 = load i8** %va, align 8
  %22 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %call8, i8* %21, i64 %22, i32 1, i1 false)
  store i8* %call8, i8** %__ret, align 8
  %23 = load i8** %__ret, align 8
  %24 = load %struct.page** %page, align 8
  %call9 = call i32 @page_to_nid(%struct.page* %24) noredzone
  %call10 = call i32 @numa_node_id() noredzone
  %cmp11 = icmp eq i32 %call9, %call10
  %lnot = xor i1 %cmp11, true
  %lnot13 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot13 to i32
  %conv14 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv14, i64 1)
  %tobool15 = icmp ne i64 %expval, 0
  br i1 %tobool15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %if.end
  store i1 true, i1* %retval
  br label %return

if.end17:                                         ; preds = %if.end
  %25 = load %struct.page** %page, align 8
  call void @put_page(%struct.page* %25) noredzone
  store i1 false, i1* %retval
  br label %return

if.end18:                                         ; preds = %land.lhs.true, %entry
  %26 = load %struct.sk_buff** %skb.addr, align 8
  %27 = load %struct.sk_buff** %skb.addr, align 8
  %call19 = call i8* @skb_end_pointer(%struct.sk_buff* %27) noredzone
  %28 = bitcast i8* %call19 to %struct.skb_shared_info*
  %nr_frags = getelementptr inbounds %struct.skb_shared_info* %28, i32 0, i32 0
  %29 = load i8* %nr_frags, align 1
  %conv20 = zext i8 %29 to i32
  %30 = load %struct.page** %page, align 8
  %31 = load %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  %page_offset21 = getelementptr inbounds %struct.igb_rx_buffer* %31, i32 0, i32 2
  %32 = load i32* %page_offset21, align 4
  %33 = load i32* %size, align 4
  %34 = load i32* %truesize, align 4
  call void @skb_add_rx_frag(%struct.sk_buff* %26, i32 %conv20, %struct.page* %30, i32 %32, i32 %33, i32 %34) noredzone
  %35 = load %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  %36 = load %struct.page** %page, align 8
  %37 = load i32* %truesize, align 4
  %call22 = call zeroext i1 @igb_can_reuse_rx_page(%struct.igb_rx_buffer* %35, %struct.page* %36, i32 %37) noredzone
  store i1 %call22, i1* %retval
  br label %return

return:                                           ; preds = %if.end18, %if.end17, %if.then16
  %38 = load i1* %retval
  ret i1 %38
}

define internal void @igb_reuse_rx_page(%struct.igb_ring* %rx_ring, %struct.igb_rx_buffer* %old_buff) nounwind noredzone {
entry:
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %old_buff.addr = alloca %struct.igb_rx_buffer*, align 8
  %new_buff = alloca %struct.igb_rx_buffer*, align 8
  %nta = alloca i16, align 2
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store %struct.igb_rx_buffer* %old_buff, %struct.igb_rx_buffer** %old_buff.addr, align 8
  %0 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_alloc = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 14
  %1 = load i16* %next_to_alloc, align 2
  store i16 %1, i16* %nta, align 2
  %2 = load i16* %nta, align 2
  %idxprom = zext i16 %2 to i64
  %3 = load %struct.igb_ring** %rx_ring.addr, align 8
  %4 = getelementptr inbounds %struct.igb_ring* %3, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %4 to %struct.igb_rx_buffer**
  %5 = load %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %arrayidx = getelementptr %struct.igb_rx_buffer* %5, i64 %idxprom
  store %struct.igb_rx_buffer* %arrayidx, %struct.igb_rx_buffer** %new_buff, align 8
  %6 = load i16* %nta, align 2
  %inc = add i16 %6, 1
  store i16 %inc, i16* %nta, align 2
  %7 = load i16* %nta, align 2
  %conv = zext i16 %7 to i32
  %8 = load %struct.igb_ring** %rx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 9
  %9 = load i16* %count, align 2
  %conv1 = zext i16 %9 to i32
  %cmp = icmp slt i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load i16* %nta, align 2
  %conv3 = zext i16 %10 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv3, %cond.true ], [ 0, %cond.false ]
  %conv4 = trunc i32 %cond to i16
  %11 = load %struct.igb_ring** %rx_ring.addr, align 8
  %next_to_alloc5 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 14
  store i16 %conv4, i16* %next_to_alloc5, align 2
  %12 = load %struct.igb_rx_buffer** %new_buff, align 8
  %13 = load %struct.igb_rx_buffer** %old_buff.addr, align 8
  %14 = bitcast %struct.igb_rx_buffer* %12 to i8*
  %15 = bitcast %struct.igb_rx_buffer* %13 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %14, i8* %15, i64 24, i32 8, i1 false)
  %16 = load %struct.igb_ring** %rx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %16, i32 0, i32 2
  %17 = load %struct.device** %dev, align 8
  %18 = load %struct.igb_rx_buffer** %old_buff.addr, align 8
  %dma = getelementptr inbounds %struct.igb_rx_buffer* %18, i32 0, i32 0
  %19 = load i64* %dma, align 8
  %20 = load %struct.igb_rx_buffer** %old_buff.addr, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %20, i32 0, i32 2
  %21 = load i32* %page_offset, align 4
  %conv6 = zext i32 %21 to i64
  call void @dma_sync_single_range_for_device(%struct.device* %17, i64 %19, i64 %conv6, i64 2048, i32 2) noredzone
  ret void
}

define internal void @dma_sync_single_range_for_device(%struct.device* %dev, i64 %addr, i64 %offset, i64 %size, i32 %dir) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %addr.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %ops = alloca %struct.dma_map_ops*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %1 = load i32* %dir.addr, align 4
  %call1 = call i32 @valid_dma_direction(i32 %1) noredzone
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool4 = icmp ne i64 %expval, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body5

do.body5:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8]* @.str28, i32 0, i32 0), i32 143, i64 12) nounwind, !srcloc !23
  br label %do.body6

do.body6:                                         ; preds = %do.cond, %do.body5
  br label %do.cond

do.cond:                                          ; preds = %do.body6
  br i1 true, label %do.body6, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end8

do.end8:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end8, %do.body
  br label %do.end10

do.end10:                                         ; preds = %if.end
  %2 = load %struct.dma_map_ops** %ops, align 8
  %sync_single_for_device = getelementptr inbounds %struct.dma_map_ops* %2, i32 0, i32 9
  %3 = load void (%struct.device*, i64, i64, i32)** %sync_single_for_device, align 8
  %tobool11 = icmp ne void (%struct.device*, i64, i64, i32)* %3, null
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %do.end10
  %4 = load %struct.dma_map_ops** %ops, align 8
  %sync_single_for_device13 = getelementptr inbounds %struct.dma_map_ops* %4, i32 0, i32 9
  %5 = load void (%struct.device*, i64, i64, i32)** %sync_single_for_device13, align 8
  %6 = load %struct.device** %dev.addr, align 8
  %7 = load i64* %addr.addr, align 8
  %8 = load i64* %offset.addr, align 8
  %add = add i64 %7, %8
  %9 = load i64* %size.addr, align 8
  %10 = load i32* %dir.addr, align 4
  call void %5(%struct.device* %6, i64 %add, i64 %9, i32 %10) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %do.end10
  %11 = load %struct.device** %dev.addr, align 8
  %12 = load i64* %addr.addr, align 8
  %13 = load i64* %offset.addr, align 8
  %14 = load i64* %size.addr, align 8
  %15 = load i32* %dir.addr, align 4
  call void @debug_dma_sync_single_range_for_device(%struct.device* %11, i64 %12, i64 %13, i64 %14, i32 %15) noredzone
  ret void
}

define internal %struct.dma_map_ops* @get_dma_ops(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %retval = alloca %struct.dma_map_ops*, align 8
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %tobool = icmp ne %struct.device* %0, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load %struct.device** %dev.addr, align 8
  %archdata = getelementptr inbounds %struct.device* %1, i32 0, i32 19
  %dma_ops = getelementptr inbounds %struct.dev_archdata* %archdata, i32 0, i32 0
  %2 = load %struct.dma_map_ops** %dma_ops, align 8
  %tobool4 = icmp ne %struct.dma_map_ops* %2, null
  br i1 %tobool4, label %if.else, label %if.then

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load %struct.dma_map_ops** @dma_ops, align 8
  store %struct.dma_map_ops* %3, %struct.dma_map_ops** %retval
  br label %return

if.else:                                          ; preds = %lor.lhs.false
  %4 = load %struct.device** %dev.addr, align 8
  %archdata5 = getelementptr inbounds %struct.device* %4, i32 0, i32 19
  %dma_ops6 = getelementptr inbounds %struct.dev_archdata* %archdata5, i32 0, i32 0
  %5 = load %struct.dma_map_ops** %dma_ops6, align 8
  store %struct.dma_map_ops* %5, %struct.dma_map_ops** %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %6 = load %struct.dma_map_ops** %retval
  ret %struct.dma_map_ops* %6
}

define internal i32 @valid_dma_direction(i32 %dma_direction) nounwind inlinehint noredzone {
entry:
  %dma_direction.addr = alloca i32, align 4
  store i32 %dma_direction, i32* %dma_direction.addr, align 4
  %0 = load i32* %dma_direction.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %lor.end, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32* %dma_direction.addr, align 4
  %cmp1 = icmp eq i32 %1, 1
  br i1 %cmp1, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %lor.lhs.false
  %2 = load i32* %dma_direction.addr, align 4
  %cmp2 = icmp eq i32 %2, 2
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %lor.lhs.false, %entry
  %3 = phi i1 [ true, %lor.lhs.false ], [ true, %entry ], [ %cmp2, %lor.rhs ]
  %lor.ext = zext i1 %3 to i32
  ret i32 %lor.ext
}

define internal void @debug_dma_sync_single_range_for_device(%struct.device* %dev, i64 %dma_handle, i64 %offset, i64 %size, i32 %direction) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %dma_handle.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %direction.addr = alloca i32, align 4
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %dma_handle, i64* %dma_handle.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %direction, i32* %direction.addr, align 4
  ret void
}

define internal i32 @page_to_nid(%struct.page* %page) nounwind inlinehint noredzone {
entry:
  %page.addr = alloca %struct.page*, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  %0 = load %struct.page** %page.addr, align 8
  %flags = getelementptr inbounds %struct.page* %0, i32 0, i32 0
  %1 = load i64* %flags, align 8
  %shr = lshr i64 %1, 58
  %and = and i64 %shr, 63
  %conv = trunc i64 %and to i32
  ret i32 %conv
}

define internal i32 @numa_node_id() nounwind inlinehint noredzone {
entry:
  %pscr_ret__ = alloca i32, align 4
  %__vpp_verify = alloca i8*, align 8
  %pfo_ret__ = alloca i32, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  store i8* null, i8** %__vpp_verify, align 8
  %0 = load i8** %__vpp_verify, align 8
  br label %do.end

do.end:                                           ; preds = %do.body
  %1 = call i32 asm "movl %gs:${1:P},$0", "=r,*m,~{dirflag},~{fpsr},~{flags}"(i32* @numa_node) nounwind, !srcloc !24
  store i32 %1, i32* %pfo_ret__, align 4
  %2 = load i32* %pfo_ret__, align 4
  store i32 %2, i32* %pscr_ret__, align 4
  %3 = load i32* %pscr_ret__, align 4
  ret i32 %3
}

declare void @put_page(%struct.page*) noredzone

declare void @skb_add_rx_frag(%struct.sk_buff*, i32, %struct.page*, i32, i32, i32) noredzone

define internal zeroext i1 @igb_can_reuse_rx_page(%struct.igb_rx_buffer* %rx_buffer, %struct.page* %page, i32 %truesize) nounwind noredzone {
entry:
  %retval = alloca i1, align 1
  %rx_buffer.addr = alloca %struct.igb_rx_buffer*, align 8
  %page.addr = alloca %struct.page*, align 8
  %truesize.addr = alloca i32, align 4
  store %struct.igb_rx_buffer* %rx_buffer, %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  store i32 %truesize, i32* %truesize.addr, align 4
  %0 = load %struct.page** %page.addr, align 8
  %call = call i32 @page_to_nid(%struct.page* %0) noredzone
  %call1 = call i32 @numa_node_id() noredzone
  %cmp = icmp ne i32 %call, %call1
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i1 false, i1* %retval
  br label %return

if.end:                                           ; preds = %entry
  %1 = load %struct.page** %page.addr, align 8
  %call3 = call i32 @page_count(%struct.page* %1) noredzone
  %cmp4 = icmp ne i32 %call3, 1
  %lnot6 = xor i1 %cmp4, true
  %lnot8 = xor i1 %lnot6, true
  %lnot.ext9 = zext i1 %lnot8 to i32
  %conv10 = sext i32 %lnot.ext9 to i64
  %expval11 = call i64 @llvm.expect.i64(i64 %conv10, i64 0)
  %tobool12 = icmp ne i64 %expval11, 0
  br i1 %tobool12, label %if.then13, label %if.end14

if.then13:                                        ; preds = %if.end
  store i1 false, i1* %retval
  br label %return

if.end14:                                         ; preds = %if.end
  %2 = load %struct.igb_rx_buffer** %rx_buffer.addr, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %2, i32 0, i32 2
  %3 = load i32* %page_offset, align 4
  %xor = xor i32 %3, 2048
  store i32 %xor, i32* %page_offset, align 4
  %4 = load %struct.page** %page.addr, align 8
  %5 = getelementptr inbounds %struct.page* %4, i32 0, i32 2
  %6 = getelementptr inbounds %struct.anon.25* %5, i32 0, i32 1
  %7 = bitcast %union.anon.27* %6 to %struct.anon.28*
  %_count = getelementptr inbounds %struct.anon.28* %7, i32 0, i32 1
  call void @atomic_set(%struct.atomic_t* %_count, i32 2) noredzone
  store i1 true, i1* %retval
  br label %return

return:                                           ; preds = %if.end14, %if.then13, %if.then
  %8 = load i1* %retval
  ret i1 %8
}

define internal i32 @page_count(%struct.page* %page) nounwind inlinehint noredzone {
entry:
  %page.addr = alloca %struct.page*, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  %0 = load %struct.page** %page.addr, align 8
  %call = call %struct.page* @compound_head(%struct.page* %0) noredzone
  %1 = getelementptr inbounds %struct.page* %call, i32 0, i32 2
  %2 = getelementptr inbounds %struct.anon.25* %1, i32 0, i32 1
  %3 = bitcast %union.anon.27* %2 to %struct.anon.28*
  %_count = getelementptr inbounds %struct.anon.28* %3, i32 0, i32 1
  %call1 = call i32 @atomic_read(%struct.atomic_t* %_count) noredzone
  ret i32 %call1
}

define internal void @atomic_set(%struct.atomic_t* %v, i32 %i) nounwind inlinehint noredzone {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  %i.addr = alloca i32, align 4
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  store i32 %i, i32* %i.addr, align 4
  %0 = load i32* %i.addr, align 4
  %1 = load %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t* %1, i32 0, i32 0
  store i32 %0, i32* %counter, align 4
  ret void
}

define internal i32 @atomic_read(%struct.atomic_t* %v) nounwind inlinehint noredzone {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t* %0, i32 0, i32 0
  %1 = load volatile i32* %counter, align 4
  ret i32 %1
}

define internal %struct.page* @compound_head(%struct.page* %page) nounwind inlinehint noredzone {
entry:
  %retval = alloca %struct.page*, align 8
  %page.addr = alloca %struct.page*, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  %0 = load %struct.page** %page.addr, align 8
  %call = call i32 @PageTail(%struct.page* %0) noredzone
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load %struct.page** %page.addr, align 8
  %call3 = call %struct.page* @compound_head_by_tail(%struct.page* %1) noredzone
  store %struct.page* %call3, %struct.page** %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.page** %page.addr, align 8
  store %struct.page* %2, %struct.page** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %3 = load %struct.page** %retval
  ret %struct.page* %3
}

define internal i32 @PageTail(%struct.page* %page) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %page.addr = alloca %struct.page*, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  %0 = load %struct.page** %page.addr, align 8
  %flags = getelementptr inbounds %struct.page* %0, i32 0, i32 0
  store i64 15, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  ret i32 %conv.i
}

define internal %struct.page* @compound_head_by_tail(%struct.page* %tail) nounwind inlinehint noredzone {
entry:
  %retval = alloca %struct.page*, align 8
  %tail.addr = alloca %struct.page*, align 8
  %head = alloca %struct.page*, align 8
  store %struct.page* %tail, %struct.page** %tail.addr, align 8
  %0 = load %struct.page** %tail.addr, align 8
  %1 = getelementptr inbounds %struct.page* %0, i32 0, i32 4
  %first_page = bitcast %union.anon.33* %1 to %struct.page**
  %2 = load %struct.page** %first_page, align 8
  store %struct.page* %2, %struct.page** %head, align 8
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !25
  %3 = load %struct.page** %tail.addr, align 8
  %call = call i32 @PageTail(%struct.page* %3) noredzone
  %tobool = icmp ne i32 %call, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.page** %head, align 8
  store %struct.page* %4, %struct.page** %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.page** %tail.addr, align 8
  store %struct.page* %5, %struct.page** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load %struct.page** %retval
  ret %struct.page* %6
}

define internal void @debug_dma_sync_single_range_for_cpu(%struct.device* %dev, i64 %dma_handle, i64 %offset, i64 %size, i32 %direction) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %dma_handle.addr = alloca i64, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %direction.addr = alloca i32, align 4
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %dma_handle, i64* %dma_handle.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %direction, i32* %direction.addr, align 4
  ret void
}

define internal %struct.sk_buff* @__netdev_alloc_skb_ip_align(%struct.net_device* %dev, i32 %length, i32 %gfp) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %length.addr = alloca i32, align 4
  %gfp.addr = alloca i32, align 4
  %skb = alloca %struct.sk_buff*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i32 %length, i32* %length.addr, align 4
  store i32 %gfp, i32* %gfp.addr, align 4
  %0 = load %struct.net_device** %dev.addr, align 8
  %1 = load i32* %length.addr, align 4
  %add = add i32 %1, 0
  %2 = load i32* %gfp.addr, align 4
  %call = call %struct.sk_buff* @__netdev_alloc_skb(%struct.net_device* %0, i32 %add, i32 %2) noredzone
  store %struct.sk_buff* %call, %struct.sk_buff** %skb, align 8
  %3 = load %struct.sk_buff** %skb, align 8
  ret %struct.sk_buff* %3
}

declare %struct.sk_buff* @__netdev_alloc_skb(%struct.net_device*, i32, i32) noredzone

define internal void @netdev_tx_completed_queue(%struct.netdev_queue* %dev_queue, i32 %pkts, i32 %bytes) nounwind inlinehint noredzone {
entry:
  %dev_queue.addr = alloca %struct.netdev_queue*, align 8
  %pkts.addr = alloca i32, align 4
  %bytes.addr = alloca i32, align 4
  store %struct.netdev_queue* %dev_queue, %struct.netdev_queue** %dev_queue.addr, align 8
  store i32 %pkts, i32* %pkts.addr, align 4
  store i32 %bytes, i32* %bytes.addr, align 4
  %0 = load i32* %bytes.addr, align 4
  %tobool = icmp ne i32 %0, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end11

if.end:                                           ; preds = %entry
  %1 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %dql = getelementptr inbounds %struct.netdev_queue* %1, i32 0, i32 12
  %2 = load i32* %bytes.addr, align 4
  call void @dql_completed(%struct.dql* %dql, i32 %2) noredzone
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !26
  %3 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %dql4 = getelementptr inbounds %struct.netdev_queue* %3, i32 0, i32 12
  %call = call i32 @dql_avail(%struct.dql* %dql4) noredzone
  %cmp = icmp slt i32 %call, 0
  br i1 %cmp, label %if.then6, label %if.end7

if.then6:                                         ; preds = %if.end
  br label %if.end11

if.end7:                                          ; preds = %if.end
  %4 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %4, i32 0, i32 10
  %call8 = call i32 @test_and_clear_bit(i64 1, i64* %state) noredzone
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end11

if.then10:                                        ; preds = %if.end7
  %5 = load %struct.netdev_queue** %dev_queue.addr, align 8
  call void @netif_schedule_queue(%struct.netdev_queue* %5) noredzone
  br label %if.end11

if.end11:                                         ; preds = %if.then, %if.then6, %if.then10, %if.end7
  ret void
}

define internal %struct.netdev_queue* @txring_txq(%struct.igb_ring* %tx_ring) nounwind inlinehint noredzone {
entry:
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_ring** %tx_ring.addr, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %2, i32 0, i32 10
  %3 = load i8* %queue_index, align 1
  %conv = zext i8 %3 to i32
  %call = call %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %1, i32 %conv) noredzone
  ret %struct.netdev_queue* %call
}

define internal void @netif_stop_subqueue(%struct.net_device* %dev, i16 zeroext %queue_index) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %queue_index.addr = alloca i16, align 2
  %txq = alloca %struct.netdev_queue*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i16 %queue_index, i16* %queue_index.addr, align 2
  %0 = load %struct.net_device** %dev.addr, align 8
  %1 = load i16* %queue_index.addr, align 2
  %conv = zext i16 %1 to i32
  %call = call %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %0, i32 %conv) noredzone
  store %struct.netdev_queue* %call, %struct.netdev_queue** %txq, align 8
  %2 = load %struct.netdev_queue** %txq, align 8
  call void @netif_tx_stop_queue(%struct.netdev_queue* %2) noredzone
  ret void
}

define internal zeroext i1 @__netif_subqueue_stopped(%struct.net_device* %dev, i16 zeroext %queue_index) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %queue_index.addr = alloca i16, align 2
  %txq = alloca %struct.netdev_queue*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i16 %queue_index, i16* %queue_index.addr, align 2
  %0 = load %struct.net_device** %dev.addr, align 8
  %1 = load i16* %queue_index.addr, align 2
  %conv = zext i16 %1 to i32
  %call = call %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %0, i32 %conv) noredzone
  store %struct.netdev_queue* %call, %struct.netdev_queue** %txq, align 8
  %2 = load %struct.netdev_queue** %txq, align 8
  %call1 = call zeroext i1 @netif_tx_queue_stopped(%struct.netdev_queue* %2) noredzone
  ret i1 %call1
}

define internal void @netif_wake_subqueue(%struct.net_device* %dev, i16 zeroext %queue_index) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %queue_index.addr = alloca i16, align 2
  %txq = alloca %struct.netdev_queue*, align 8
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i16 %queue_index, i16* %queue_index.addr, align 2
  %0 = load %struct.net_device** %dev.addr, align 8
  %1 = load i16* %queue_index.addr, align 2
  %conv = zext i16 %1 to i32
  %call = call %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %0, i32 %conv) noredzone
  store %struct.netdev_queue* %call, %struct.netdev_queue** %txq, align 8
  %2 = load %struct.netdev_queue** %txq, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %2, i32 0, i32 10
  %call1 = call i32 @test_and_clear_bit(i64 0, i64* %state) noredzone
  %tobool = icmp ne i32 %call1, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.netdev_queue** %txq, align 8
  %qdisc = getelementptr inbounds %struct.netdev_queue* %3, i32 0, i32 1
  %4 = load %struct.Qdisc** %qdisc, align 8
  call void @__netif_schedule(%struct.Qdisc* %4) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define internal %struct.netdev_queue* @netdev_get_tx_queue(%struct.net_device* %dev, i32 %index) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.net_device*, align 8
  %index.addr = alloca i32, align 4
  store %struct.net_device* %dev, %struct.net_device** %dev.addr, align 8
  store i32 %index, i32* %index.addr, align 4
  %0 = load i32* %index.addr, align 4
  %idxprom = zext i32 %0 to i64
  %1 = load %struct.net_device** %dev.addr, align 8
  %_tx = getelementptr inbounds %struct.net_device* %1, i32 0, i32 79
  %2 = load %struct.netdev_queue** %_tx, align 64
  %arrayidx = getelementptr %struct.netdev_queue* %2, i64 %idxprom
  ret %struct.netdev_queue* %arrayidx
}

define internal i32 @test_and_clear_bit(i64 %nr, i64* %addr) nounwind inlinehint noredzone {
entry:
  %nr.addr = alloca i64, align 8
  %addr.addr = alloca i64*, align 8
  %c = alloca i8, align 1
  store i64 %nr, i64* %nr.addr, align 8
  store i64* %addr, i64** %addr.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i64** %addr.addr, align 8
  %1 = load i64* %nr.addr, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $2, $0; setc $1", "=*m,=*qm,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %0, i8* %c, i64 %1, i64* %0) nounwind, !srcloc !27
  %2 = load i8* %c, align 1
  %conv = sext i8 %2 to i32
  %cmp = icmp ne i32 %conv, 0
  %conv1 = zext i1 %cmp to i32
  br label %do.end

do.end:                                           ; preds = %do.body
  ret i32 %conv1
}

declare void @__netif_schedule(%struct.Qdisc*) noredzone

define internal zeroext i1 @netif_tx_queue_stopped(%struct.netdev_queue* %dev_queue) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %dev_queue.addr = alloca %struct.netdev_queue*, align 8
  store %struct.netdev_queue* %dev_queue, %struct.netdev_queue** %dev_queue.addr, align 8
  %0 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %0, i32 0, i32 10
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %1, 63
  %shl.i = shl i64 1, %and.i
  %2 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %2, 6
  %3 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %3, i64 %shr.i
  %4 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %4
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  ret i1 %tobool
}

define internal void @netif_tx_stop_queue(%struct.netdev_queue* %dev_queue) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %dev_queue.addr = alloca %struct.netdev_queue*, align 8
  %__ret_warn_on = alloca i32, align 4
  store %struct.netdev_queue* %dev_queue, %struct.netdev_queue** %dev_queue.addr, align 8
  %0 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %tobool = icmp ne %struct.netdev_queue* %0, null
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot2 = xor i1 %lnot1, true
  %lnot.ext = zext i1 %lnot2 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %1 = load i32* %__ret_warn_on, align 4
  %tobool3 = icmp ne i32 %1, 0
  %lnot4 = xor i1 %tobool3, true
  %lnot6 = xor i1 %lnot4, true
  %lnot.ext7 = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext7 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([26 x i8]* @.str30, i32 0, i32 0), i32 2335) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %2 = load i32* %__ret_warn_on, align 4
  %tobool9 = icmp ne i32 %2, 0
  %lnot10 = xor i1 %tobool9, true
  %lnot12 = xor i1 %lnot10, true
  %lnot.ext13 = zext i1 %lnot12 to i32
  %conv14 = sext i32 %lnot.ext13 to i64
  %expval15 = call i64 @llvm.expect.i64(i64 %conv14, i64 0)
  %tobool16 = icmp ne i64 %expval15, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end
  %call = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([69 x i8]* @.str31, i32 0, i32 0)) noredzone
  br label %return

if.end18:                                         ; preds = %if.end
  %3 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %3, i32 0, i32 10
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %4 = load i64** %addr.addr.i, align 8
  %5 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %4, i64 %5, i64* %4) nounwind, !srcloc !6
  br label %return

return:                                           ; preds = %if.end18, %if.then17
  ret void
}

declare i32 @printk(i8*, ...) noredzone

declare void @dql_completed(%struct.dql*, i32) noredzone

define internal i32 @dql_avail(%struct.dql* %dql) nounwind inlinehint noredzone {
entry:
  %dql.addr = alloca %struct.dql*, align 8
  store %struct.dql* %dql, %struct.dql** %dql.addr, align 8
  %0 = load %struct.dql** %dql.addr, align 8
  %adj_limit = getelementptr inbounds %struct.dql* %0, i32 0, i32 1
  %1 = load i32* %adj_limit, align 4
  %2 = load %struct.dql** %dql.addr, align 8
  %num_queued = getelementptr inbounds %struct.dql* %2, i32 0, i32 0
  %3 = load i32* %num_queued, align 4
  %sub = sub i32 %1, %3
  ret i32 %sub
}

define internal void @netif_schedule_queue(%struct.netdev_queue* %txq) nounwind inlinehint noredzone {
entry:
  %txq.addr = alloca %struct.netdev_queue*, align 8
  store %struct.netdev_queue* %txq, %struct.netdev_queue** %txq.addr, align 8
  %0 = load %struct.netdev_queue** %txq.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %0, i32 0, i32 10
  %1 = load i64* %state, align 8
  %and = and i64 %1, 3
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.netdev_queue** %txq.addr, align 8
  %qdisc = getelementptr inbounds %struct.netdev_queue* %2, i32 0, i32 1
  %3 = load %struct.Qdisc** %qdisc, align 8
  call void @__netif_schedule(%struct.Qdisc* %3) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define internal void @igb_update_tx_dca(%struct.igb_adapter* %adapter, %struct.igb_ring* %tx_ring, i32 %cpu) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %cpu.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %txctrl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store i32 %cpu, i32* %cpu.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_ring** %tx_ring.addr, align 8
  %dev = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 2
  %2 = load %struct.device** %dev, align 8
  %3 = load i32* %cpu.addr, align 4
  %call = call zeroext i8 @dca3_get_tag(%struct.device* %2, i32 %3) noredzone
  %conv = zext i8 %call to i32
  store i32 %conv, i32* %txctrl, align 4
  %4 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %5 = load i32* %type, align 4
  %cmp = icmp ne i32 %5, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32* %txctrl, align 4
  %shl = shl i32 %6, 24
  store i32 %shl, i32* %txctrl, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32* %txctrl, align 4
  %or = or i32 %7, 8736
  store i32 %or, i32* %txctrl, align 4
  br label %do.body

do.body:                                          ; preds = %if.end
  %8 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr3, align 8
  store i8* %9, i8** %hw_addr, align 8
  %10 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %10, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.end18, label %if.then8

if.then8:                                         ; preds = %do.body
  %11 = load i32* %txctrl, align 4
  %12 = load %struct.igb_ring** %tx_ring.addr, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %12, i32 0, i32 11
  %13 = load i8* %reg_idx, align 1
  %conv9 = zext i8 %13 to i32
  %cmp10 = icmp slt i32 %conv9, 4
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then8
  %14 = load %struct.igb_ring** %tx_ring.addr, align 8
  %reg_idx12 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 11
  %15 = load i8* %reg_idx12, align 1
  %conv13 = zext i8 %15 to i32
  %mul = mul i32 %conv13, 256
  %add = add i32 14356, %mul
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  %16 = load %struct.igb_ring** %tx_ring.addr, align 8
  %reg_idx14 = getelementptr inbounds %struct.igb_ring* %16, i32 0, i32 11
  %17 = load i8* %reg_idx14, align 1
  %conv15 = zext i8 %17 to i32
  %mul16 = mul i32 %conv15, 64
  %add17 = add i32 57364, %mul16
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ %add17, %cond.false ]
  %idxprom = sext i32 %cond to i64
  %18 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %18, i64 %idxprom
  call void @writel(i32 %11, i8* %arrayidx) noredzone
  br label %if.end18

if.end18:                                         ; preds = %cond.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end18
  ret void
}

define internal void @igb_update_rx_dca(%struct.igb_adapter* %adapter, %struct.igb_ring* %rx_ring, i32 %cpu) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %rx_ring.addr = alloca %struct.igb_ring*, align 8
  %cpu.addr = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %rxctrl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store %struct.igb_ring* %rx_ring, %struct.igb_ring** %rx_ring.addr, align 8
  store i32 %cpu, i32* %cpu.addr, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 32
  %2 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %2, i32 0, i32 33
  %3 = load i32* %cpu.addr, align 4
  %call = call zeroext i8 @dca3_get_tag(%struct.device* %dev, i32 %3) noredzone
  %conv = zext i8 %call to i32
  store i32 %conv, i32* %rxctrl, align 4
  %4 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %5 = load i32* %type, align 4
  %cmp = icmp ne i32 %5, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32* %rxctrl, align 4
  %shl = shl i32 %6, 24
  store i32 %shl, i32* %rxctrl, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %7 = load i32* %rxctrl, align 4
  %or = or i32 %7, 544
  store i32 %or, i32* %rxctrl, align 4
  br label %do.body

do.body:                                          ; preds = %if.end
  %8 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr3, align 8
  store i8* %9, i8** %hw_addr, align 8
  %10 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %10, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv6 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv6, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.end18, label %if.then8

if.then8:                                         ; preds = %do.body
  %11 = load i32* %rxctrl, align 4
  %12 = load %struct.igb_ring** %rx_ring.addr, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %12, i32 0, i32 11
  %13 = load i8* %reg_idx, align 1
  %conv9 = zext i8 %13 to i32
  %cmp10 = icmp slt i32 %conv9, 4
  br i1 %cmp10, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then8
  %14 = load %struct.igb_ring** %rx_ring.addr, align 8
  %reg_idx12 = getelementptr inbounds %struct.igb_ring* %14, i32 0, i32 11
  %15 = load i8* %reg_idx12, align 1
  %conv13 = zext i8 %15 to i32
  %mul = mul i32 %conv13, 256
  %add = add i32 10260, %mul
  br label %cond.end

cond.false:                                       ; preds = %if.then8
  %16 = load %struct.igb_ring** %rx_ring.addr, align 8
  %reg_idx14 = getelementptr inbounds %struct.igb_ring* %16, i32 0, i32 11
  %17 = load i8* %reg_idx14, align 1
  %conv15 = zext i8 %17 to i32
  %mul16 = mul i32 %conv15, 64
  %add17 = add i32 49172, %mul16
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ %add17, %cond.false ]
  %idxprom = sext i32 %cond to i64
  %18 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %18, i64 %idxprom
  call void @writel(i32 %11, i8* %arrayidx) noredzone
  br label %if.end18

if.end18:                                         ; preds = %cond.end, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end18
  ret void
}

declare zeroext i8 @dca3_get_tag(%struct.device*, i32) noredzone

declare i32 @pci_enable_msix_range(%struct.pci_dev*, %struct.msix_entry*, i32, i32) noredzone

declare void @pci_disable_sriov(%struct.pci_dev*) noredzone

declare void @msleep(i32) noredzone

define internal i32 @pci_enable_msi_exact(%struct.pci_dev* %dev, i32 %nvec) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.pci_dev*, align 8
  %nvec.addr = alloca i32, align 4
  %rc = alloca i32, align 4
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  store i32 %nvec, i32* %nvec.addr, align 4
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %1 = load i32* %nvec.addr, align 4
  %2 = load i32* %nvec.addr, align 4
  %call = call i32 @pci_enable_msi_range(%struct.pci_dev* %0, i32 %1, i32 %2) noredzone
  store i32 %call, i32* %rc, align 4
  %3 = load i32* %rc, align 4
  %cmp = icmp slt i32 %3, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load i32* %rc, align 4
  store i32 %4, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i32* %retval
  ret i32 %5
}

declare i32 @pci_enable_msi_range(%struct.pci_dev*, i32, i32) noredzone

declare void @pci_disable_msix(%struct.pci_dev*) noredzone

declare void @pci_disable_msi(%struct.pci_dev*) noredzone

define internal i32 @__igb_close(%struct.net_device* %netdev, i1 zeroext %suspending) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %netdev.addr = alloca %struct.net_device*, align 8
  %suspending.addr = alloca i8, align 1
  %adapter = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %__ret_warn_on = alloca i32, align 4
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %frombool = zext i1 %suspending to i8
  store i8 %frombool, i8* %suspending.addr, align 1
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 32
  %3 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 2
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %5 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %5, 63
  %shl.i = shl i64 1, %and.i
  %6 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %6, 6
  %7 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %7, i64 %shr.i
  %8 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %8
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot3 to i32
  store i32 %lnot.ext, i32* %__ret_warn_on, align 4
  %9 = load i32* %__ret_warn_on, align 4
  %tobool4 = icmp ne i32 %9, 0
  %lnot5 = xor i1 %tobool4, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext8 to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  call void @warn_slowpath_null(i8* getelementptr inbounds ([56 x i8]* @.str1, i32 0, i32 0), i32 3138) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load i32* %__ret_warn_on, align 4
  %tobool10 = icmp ne i32 %10, 0
  %lnot11 = xor i1 %tobool10, true
  %lnot13 = xor i1 %lnot11, true
  %lnot.ext14 = zext i1 %lnot13 to i32
  %conv15 = sext i32 %lnot.ext14 to i64
  %expval16 = call i64 @llvm.expect.i64(i64 %conv15, i64 0)
  %11 = load i8* %suspending.addr, align 1
  %tobool17 = trunc i8 %11 to i1
  br i1 %tobool17, label %if.end20, label %if.then18

if.then18:                                        ; preds = %if.end
  %12 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %12, i32 0, i32 33
  %call19 = call i32 @pm_runtime_get_sync(%struct.device* %dev) noredzone
  br label %if.end20

if.end20:                                         ; preds = %if.then18, %if.end
  %13 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_down(%struct.igb_adapter* %13) noredzone
  %14 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_free_irq(%struct.igb_adapter* %14) noredzone
  %15 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_free_all_tx_resources(%struct.igb_adapter* %15) noredzone
  %16 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_free_all_rx_resources(%struct.igb_adapter* %16) noredzone
  %17 = load i8* %suspending.addr, align 1
  %tobool21 = trunc i8 %17 to i1
  br i1 %tobool21, label %if.end25, label %if.then22

if.then22:                                        ; preds = %if.end20
  %18 = load %struct.pci_dev** %pdev, align 8
  %dev23 = getelementptr inbounds %struct.pci_dev* %18, i32 0, i32 33
  %call24 = call i32 @pm_runtime_put_sync(%struct.device* %dev23) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.then22, %if.end20
  ret i32 0
}

define internal i32 @pm_runtime_put_sync(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call i32 @__pm_runtime_idle(%struct.device* %0, i32 4) noredzone
  ret i32 %call
}

declare i32 @pci_bus_write_config_word(%struct.pci_bus*, i32, i32, i16 zeroext) noredzone

declare i32 @pci_bus_read_config_word(%struct.pci_bus*, i32, i32, i16*) noredzone

define internal %struct.page* @__skb_alloc_page(i32 %gfp_mask, %struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %gfp_mask.addr = alloca i32, align 4
  %skb.addr = alloca %struct.sk_buff*, align 8
  store i32 %gfp_mask, i32* %gfp_mask.addr, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load i32* %gfp_mask.addr, align 4
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %call = call %struct.page* @__skb_alloc_pages(i32 %0, %struct.sk_buff* %1, i32 0) noredzone
  ret %struct.page* %call
}

define internal i64 @dma_map_page(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %dir) nounwind inlinehint noredzone {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %dev.addr = alloca %struct.device*, align 8
  %page.addr = alloca %struct.page*, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %ops = alloca %struct.dma_map_ops*, align 8
  %addr = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  %1 = load %struct.page** %page.addr, align 8
  store %struct.page* %1, %struct.page** %page.addr.i, align 8
  %2 = load %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %2 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %3 = inttoptr i64 %add.i to i8*
  %4 = load i64* %offset.addr, align 8
  %add.ptr = getelementptr i8* %3, i64 %4
  %5 = load i64* %size.addr, align 8
  %conv = trunc i64 %5 to i32
  call void @kmemcheck_mark_initialized(i8* %add.ptr, i32 %conv) noredzone
  br label %do.body

do.body:                                          ; preds = %entry
  %6 = load i32* %dir.addr, align 4
  %call2 = call i32 @valid_dma_direction(i32 %6) noredzone
  %tobool = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv5 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv5, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body7

do.body7:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8]* @.str28, i32 0, i32 0), i32 79, i64 12) nounwind, !srcloc !28
  br label %do.body8

do.body8:                                         ; preds = %do.cond, %do.body7
  br label %do.cond

do.cond:                                          ; preds = %do.body8
  br i1 true, label %do.body8, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end10

do.end10:                                         ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end10, %do.body
  br label %do.end12

do.end12:                                         ; preds = %if.end
  %7 = load %struct.dma_map_ops** %ops, align 8
  %map_page = getelementptr inbounds %struct.dma_map_ops* %7, i32 0, i32 4
  %8 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)** %map_page, align 8
  %9 = load %struct.device** %dev.addr, align 8
  %10 = load %struct.page** %page.addr, align 8
  %11 = load i64* %offset.addr, align 8
  %12 = load i64* %size.addr, align 8
  %13 = load i32* %dir.addr, align 4
  %call13 = call i64 %8(%struct.device* %9, %struct.page* %10, i64 %11, i64 %12, i32 %13, %struct.dma_attrs* null) noredzone
  store i64 %call13, i64* %addr, align 8
  %14 = load %struct.device** %dev.addr, align 8
  %15 = load %struct.page** %page.addr, align 8
  %16 = load i64* %offset.addr, align 8
  %17 = load i64* %size.addr, align 8
  %18 = load i32* %dir.addr, align 4
  %19 = load i64* %addr, align 8
  call void @debug_dma_map_page(%struct.device* %14, %struct.page* %15, i64 %16, i64 %17, i32 %18, i64 %19, i1 zeroext false) noredzone
  %20 = load i64* %addr, align 8
  ret i64 %20
}

define internal i32 @dma_mapping_error(%struct.device* %dev, i64 %dma_addr) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.device*, align 8
  %dma_addr.addr = alloca i64, align 8
  %ops = alloca %struct.dma_map_ops*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %dma_addr, i64* %dma_addr.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  %1 = load %struct.device** %dev.addr, align 8
  %2 = load i64* %dma_addr.addr, align 8
  call void @debug_dma_mapping_error(%struct.device* %1, i64 %2) noredzone
  %3 = load %struct.dma_map_ops** %ops, align 8
  %mapping_error = getelementptr inbounds %struct.dma_map_ops* %3, i32 0, i32 12
  %4 = load i32 (%struct.device*, i64)** %mapping_error, align 8
  %tobool = icmp ne i32 (%struct.device*, i64)* %4, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load %struct.dma_map_ops** %ops, align 8
  %mapping_error1 = getelementptr inbounds %struct.dma_map_ops* %5, i32 0, i32 12
  %6 = load i32 (%struct.device*, i64)** %mapping_error1, align 8
  %7 = load %struct.device** %dev.addr, align 8
  %8 = load i64* %dma_addr.addr, align 8
  %call2 = call i32 %6(%struct.device* %7, i64 %8) noredzone
  store i32 %call2, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %9 = load i64* %dma_addr.addr, align 8
  %cmp = icmp eq i64 %9, 0
  %conv = zext i1 %cmp to i32
  store i32 %conv, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %10 = load i32* %retval
  ret i32 %10
}

declare void @__free_pages(%struct.page*, i32) noredzone

define internal void @debug_dma_mapping_error(%struct.device* %dev, i64 %dma_addr) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %dma_addr.addr = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %dma_addr, i64* %dma_addr.addr, align 8
  ret void
}

define internal void @kmemcheck_mark_initialized(i8* %address, i32 %n) nounwind inlinehint noredzone {
entry:
  %address.addr = alloca i8*, align 8
  %n.addr = alloca i32, align 4
  store i8* %address, i8** %address.addr, align 8
  store i32 %n, i32* %n.addr, align 4
  ret void
}

define internal void @debug_dma_map_page(%struct.device* %dev, %struct.page* %page, i64 %offset, i64 %size, i32 %direction, i64 %dma_addr, i1 zeroext %map_single) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %page.addr = alloca %struct.page*, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %direction.addr = alloca i32, align 4
  %dma_addr.addr = alloca i64, align 8
  %map_single.addr = alloca i8, align 1
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store %struct.page* %page, %struct.page** %page.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %direction, i32* %direction.addr, align 4
  store i64 %dma_addr, i64* %dma_addr.addr, align 8
  %frombool = zext i1 %map_single to i8
  store i8 %frombool, i8* %map_single.addr, align 1
  ret void
}

define internal %struct.page* @__skb_alloc_pages(i32 %gfp_mask, %struct.sk_buff* %skb, i32 %order) nounwind inlinehint noredzone {
entry:
  %gfp_mask.addr = alloca i32, align 4
  %skb.addr = alloca %struct.sk_buff*, align 8
  %order.addr = alloca i32, align 4
  %page = alloca %struct.page*, align 8
  store i32 %gfp_mask, i32* %gfp_mask.addr, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %order, i32* %order.addr, align 4
  %0 = load i32* %gfp_mask.addr, align 4
  %or = or i32 %0, 256
  store i32 %or, i32* %gfp_mask.addr, align 4
  %1 = load i32* %gfp_mask.addr, align 4
  %and = and i32 %1, 65536
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32* %gfp_mask.addr, align 4
  %or1 = or i32 %2, 8192
  store i32 %or1, i32* %gfp_mask.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32* %gfp_mask.addr, align 4
  %4 = load i32* %order.addr, align 4
  %call = call %struct.page* @alloc_pages_node(i32 -1, i32 %3, i32 %4) noredzone
  store %struct.page* %call, %struct.page** %page, align 8
  %5 = load %struct.sk_buff** %skb.addr, align 8
  %tobool2 = icmp ne %struct.sk_buff* %5, null
  br i1 %tobool2, label %land.lhs.true, label %if.end7

land.lhs.true:                                    ; preds = %if.end
  %6 = load %struct.page** %page, align 8
  %tobool3 = icmp ne %struct.page* %6, null
  br i1 %tobool3, label %land.lhs.true4, label %if.end7

land.lhs.true4:                                   ; preds = %land.lhs.true
  %7 = load %struct.page** %page, align 8
  %8 = getelementptr inbounds %struct.page* %7, i32 0, i32 2
  %9 = getelementptr inbounds %struct.anon.25* %8, i32 0, i32 0
  %pfmemalloc = bitcast %union.anon.26* %9 to i8*
  %10 = load i8* %pfmemalloc, align 1
  %tobool5 = trunc i8 %10 to i1
  br i1 %tobool5, label %if.then6, label %if.end7

if.then6:                                         ; preds = %land.lhs.true4
  %11 = load %struct.sk_buff** %skb.addr, align 8
  %12 = bitcast %struct.sk_buff* %11 to i8*
  %bf.field.offs = getelementptr i8* %12, i32 170
  %13 = load i8* %bf.field.offs, align 2
  %14 = and i8 %13, -5
  %15 = or i8 %14, 4
  store i8 %15, i8* %bf.field.offs, align 2
  br label %if.end7

if.end7:                                          ; preds = %if.then6, %land.lhs.true4, %land.lhs.true, %if.end
  %16 = load %struct.page** %page, align 8
  ret %struct.page* %16
}

define internal %struct.page* @alloc_pages_node(i32 %nid, i32 %gfp_mask, i32 %order) nounwind inlinehint noredzone {
entry:
  %nid.addr = alloca i32, align 4
  %gfp_mask.addr = alloca i32, align 4
  %order.addr = alloca i32, align 4
  store i32 %nid, i32* %nid.addr, align 4
  store i32 %gfp_mask, i32* %gfp_mask.addr, align 4
  store i32 %order, i32* %order.addr, align 4
  %0 = load i32* %nid.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %call = call i32 @numa_node_id() noredzone
  store i32 %call, i32* %nid.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %1 = load i32* %gfp_mask.addr, align 4
  %2 = load i32* %order.addr, align 4
  %3 = load i32* %nid.addr, align 4
  %4 = load i32* %gfp_mask.addr, align 4
  %call1 = call %struct.zonelist* @node_zonelist(i32 %3, i32 %4) noredzone
  %call2 = call %struct.page* @__alloc_pages(i32 %1, i32 %2, %struct.zonelist* %call1) noredzone
  ret %struct.page* %call2
}

define internal %struct.page* @__alloc_pages(i32 %gfp_mask, i32 %order, %struct.zonelist* %zonelist) nounwind inlinehint noredzone {
entry:
  %gfp_mask.addr = alloca i32, align 4
  %order.addr = alloca i32, align 4
  %zonelist.addr = alloca %struct.zonelist*, align 8
  store i32 %gfp_mask, i32* %gfp_mask.addr, align 4
  store i32 %order, i32* %order.addr, align 4
  store %struct.zonelist* %zonelist, %struct.zonelist** %zonelist.addr, align 8
  %0 = load i32* %gfp_mask.addr, align 4
  %1 = load i32* %order.addr, align 4
  %2 = load %struct.zonelist** %zonelist.addr, align 8
  %call = call %struct.page* @__alloc_pages_nodemask(i32 %0, i32 %1, %struct.zonelist* %2, %struct.nodemask_t* null) noredzone
  ret %struct.page* %call
}

define internal %struct.zonelist* @node_zonelist(i32 %nid, i32 %flags) nounwind inlinehint noredzone {
entry:
  %nid.addr = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %nid, i32* %nid.addr, align 4
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i32* %nid.addr, align 4
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr [0 x %struct.pglist_data*]* @node_data, i32 0, i64 %idxprom
  %1 = load %struct.pglist_data** %arrayidx, align 1
  %node_zonelists = getelementptr inbounds %struct.pglist_data* %1, i32 0, i32 1
  %arraydecay = getelementptr inbounds [2 x %struct.zonelist]* %node_zonelists, i32 0, i32 0
  %2 = load i32* %flags.addr, align 4
  %call = call i32 @gfp_zonelist(i32 %2) noredzone
  %idx.ext = sext i32 %call to i64
  %add.ptr = getelementptr %struct.zonelist* %arraydecay, i64 %idx.ext
  ret %struct.zonelist* %add.ptr
}

define internal i32 @gfp_zonelist(i32 %flags) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %flags.addr = alloca i32, align 4
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i32* %flags.addr, align 4
  %and = and i32 %0, 262144
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool2 = icmp ne i64 %expval, 0
  br i1 %tobool2, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 1, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %1 = load i32* %retval
  ret i32 %1
}

declare %struct.page* @__alloc_pages_nodemask(i32, i32, %struct.zonelist*, %struct.nodemask_t*) noredzone

define internal void @__rcu_read_unlock() nounwind inlinehint noredzone {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !29
  ret void
}

define internal void @__rcu_read_lock() nounwind inlinehint noredzone {
entry:
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !30
  ret void
}

define internal i32 @igb_tx_cmd_type(%struct.sk_buff* %skb, i32 %tx_flags) nounwind noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %tx_flags.addr = alloca i32, align 4
  %cmd_type = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %tx_flags, i32* %tx_flags.addr, align 4
  store i32 573571072, i32* %cmd_type, align 4
  %0 = load i32* %tx_flags.addr, align 4
  %and = and i32 %0, 1
  %mul = mul i32 %and, 1073741824
  %1 = load i32* %cmd_type, align 4
  %or = or i32 %1, %mul
  store i32 %or, i32* %cmd_type, align 4
  %2 = load i32* %tx_flags.addr, align 4
  %and1 = and i32 %2, 2
  %mul2 = mul i32 %and1, 1073741824
  %3 = load i32* %cmd_type, align 4
  %or3 = or i32 %3, %mul2
  store i32 %or3, i32* %cmd_type, align 4
  %4 = load i32* %tx_flags.addr, align 4
  %and4 = and i32 %4, 4
  %mul5 = mul i32 %and4, 131072
  %5 = load i32* %cmd_type, align 4
  %or6 = or i32 %5, %mul5
  store i32 %or6, i32* %cmd_type, align 4
  %6 = load %struct.sk_buff** %skb.addr, align 8
  %7 = bitcast %struct.sk_buff* %6 to i8*
  %bf.field.offs = getelementptr i8* %7, i32 171
  %8 = load i8* %bf.field.offs, align 1
  %bf.clear = and i8 %8, 1
  %conv = zext i8 %bf.clear to i32
  %and7 = and i32 %conv, 1
  %mul8 = mul i32 %and7, 33554432
  %9 = load i32* %cmd_type, align 4
  %xor = xor i32 %9, %mul8
  store i32 %xor, i32* %cmd_type, align 4
  %10 = load i32* %cmd_type, align 4
  ret i32 %10
}

define internal void @igb_tx_olinfo_status(%struct.igb_ring* %tx_ring, %union.e1000_adv_tx_desc* %tx_desc, i32 %tx_flags, i32 %paylen) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %tx_desc.addr = alloca %union.e1000_adv_tx_desc*, align 8
  %tx_flags.addr = alloca i32, align 4
  %paylen.addr = alloca i32, align 4
  %olinfo_status = alloca i32, align 4
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store %union.e1000_adv_tx_desc* %tx_desc, %union.e1000_adv_tx_desc** %tx_desc.addr, align 8
  store i32 %tx_flags, i32* %tx_flags.addr, align 4
  store i32 %paylen, i32* %paylen.addr, align 4
  %0 = load i32* %paylen.addr, align 4
  %shl = shl i32 %0, 14
  store i32 %shl, i32* %olinfo_status, align 4
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %1 = load %struct.igb_ring** %tx_ring.addr, align 8
  %flags = getelementptr inbounds %struct.igb_ring* %1, i32 0, i32 5
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %2 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %2, 63
  %shl.i = shl i64 1, %and.i
  %3 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %3, 6
  %4 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %4, i64 %shr.i
  %5 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %5
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false:                                       ; preds = %entry
  %6 = load %struct.igb_ring** %tx_ring.addr, align 8
  %flags1 = getelementptr inbounds %struct.igb_ring* %6, i32 0, i32 5
  %call2 = call i32 @variable_test_bit(i64 2, i64* %flags1) noredzone
  %tobool3 = icmp ne i32 %call2, 0
  br i1 %tobool3, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %7 = load %struct.igb_ring** %tx_ring.addr, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %7, i32 0, i32 11
  %8 = load i8* %reg_idx, align 1
  %conv = zext i8 %8 to i32
  %shl4 = shl i32 %conv, 4
  %9 = load i32* %olinfo_status, align 4
  %or = or i32 %9, %shl4
  store i32 %or, i32* %olinfo_status, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false, %cond.true
  %10 = load i32* %tx_flags.addr, align 4
  %and = and i32 %10, 32
  %mul = mul i32 %and, 16
  %11 = load i32* %olinfo_status, align 4
  %or5 = or i32 %11, %mul
  store i32 %or5, i32* %olinfo_status, align 4
  %12 = load i32* %tx_flags.addr, align 4
  %and6 = and i32 %12, 16
  %mul7 = mul i32 %and6, 16
  %13 = load i32* %olinfo_status, align 4
  %or8 = or i32 %13, %mul7
  store i32 %or8, i32* %olinfo_status, align 4
  %14 = load i32* %olinfo_status, align 4
  %15 = load %union.e1000_adv_tx_desc** %tx_desc.addr, align 8
  %read = bitcast %union.e1000_adv_tx_desc* %15 to %struct.anon.88*
  %olinfo_status9 = getelementptr inbounds %struct.anon.88* %read, i32 0, i32 2
  store i32 %14, i32* %olinfo_status9, align 4
  ret void
}

define internal i64 @dma_map_single_attrs(%struct.device* %dev, i8* %ptr, i64 %size, i32 %dir, %struct.dma_attrs* %attrs) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %ptr.addr = alloca i8*, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  %attrs.addr = alloca %struct.dma_attrs*, align 8
  %ops = alloca %struct.dma_map_ops*, align 8
  %addr = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i8* %ptr, i8** %ptr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  store %struct.dma_attrs* %attrs, %struct.dma_attrs** %attrs.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call %struct.dma_map_ops* @get_dma_ops(%struct.device* %0) noredzone
  store %struct.dma_map_ops* %call, %struct.dma_map_ops** %ops, align 8
  %1 = load i8** %ptr.addr, align 8
  %2 = load i64* %size.addr, align 8
  %conv = trunc i64 %2 to i32
  call void @kmemcheck_mark_initialized(i8* %1, i32 %conv) noredzone
  br label %do.body

do.body:                                          ; preds = %entry
  %3 = load i32* %dir.addr, align 4
  %call1 = call i32 @valid_dma_direction(i32 %3) noredzone
  %tobool = icmp ne i32 %call1, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot3 = xor i1 %lnot2, true
  %lnot.ext = zext i1 %lnot3 to i32
  %conv4 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv4, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body6

do.body6:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([41 x i8]* @.str28, i32 0, i32 0), i32 19, i64 12) nounwind, !srcloc !31
  br label %do.body7

do.body7:                                         ; preds = %do.cond, %do.body6
  br label %do.cond

do.cond:                                          ; preds = %do.body7
  br i1 true, label %do.body7, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end9

do.end9:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end9, %do.body
  br label %do.end11

do.end11:                                         ; preds = %if.end
  %4 = load %struct.dma_map_ops** %ops, align 8
  %map_page = getelementptr inbounds %struct.dma_map_ops* %4, i32 0, i32 4
  %5 = load i64 (%struct.device*, %struct.page*, i64, i64, i32, %struct.dma_attrs*)** %map_page, align 8
  %6 = load %struct.device** %dev.addr, align 8
  %7 = load i8** %ptr.addr, align 8
  %8 = ptrtoint i8* %7 to i64
  %call12 = call i64 @__phys_addr_nodebug(i64 %8) noredzone
  %shr = lshr i64 %call12, 12
  %add.ptr = getelementptr %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr
  %9 = load i8** %ptr.addr, align 8
  %10 = ptrtoint i8* %9 to i64
  %and = and i64 %10, 4095
  %11 = load i64* %size.addr, align 8
  %12 = load i32* %dir.addr, align 4
  %13 = load %struct.dma_attrs** %attrs.addr, align 8
  %call13 = call i64 %5(%struct.device* %6, %struct.page* %add.ptr, i64 %and, i64 %11, i32 %12, %struct.dma_attrs* %13) noredzone
  store i64 %call13, i64* %addr, align 8
  %14 = load %struct.device** %dev.addr, align 8
  %15 = load i8** %ptr.addr, align 8
  %16 = ptrtoint i8* %15 to i64
  %call14 = call i64 @__phys_addr_nodebug(i64 %16) noredzone
  %shr15 = lshr i64 %call14, 12
  %add.ptr16 = getelementptr %struct.page* inttoptr (i64 -24189255811072 to %struct.page*), i64 %shr15
  %17 = load i8** %ptr.addr, align 8
  %18 = ptrtoint i8* %17 to i64
  %and17 = and i64 %18, 4095
  %19 = load i64* %size.addr, align 8
  %20 = load i32* %dir.addr, align 4
  %21 = load i64* %addr, align 8
  call void @debug_dma_map_page(%struct.device* %14, %struct.page* %add.ptr16, i64 %and17, i64 %19, i32 %20, i64 %21, i1 zeroext true) noredzone
  %22 = load i64* %addr, align 8
  ret i64 %22
}

define internal i32 @skb_frag_size(%struct.skb_frag_struct* %frag) nounwind inlinehint noredzone {
entry:
  %frag.addr = alloca %struct.skb_frag_struct*, align 8
  store %struct.skb_frag_struct* %frag, %struct.skb_frag_struct** %frag.addr, align 8
  %0 = load %struct.skb_frag_struct** %frag.addr, align 8
  %size = getelementptr inbounds %struct.skb_frag_struct* %0, i32 0, i32 2
  %1 = load i32* %size, align 4
  ret i32 %1
}

define internal i64 @skb_frag_dma_map(%struct.device* %dev, %struct.skb_frag_struct* %frag, i64 %offset, i64 %size, i32 %dir) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %frag.addr = alloca %struct.skb_frag_struct*, align 8
  %offset.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %dir.addr = alloca i32, align 4
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store %struct.skb_frag_struct* %frag, %struct.skb_frag_struct** %frag.addr, align 8
  store i64 %offset, i64* %offset.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %dir, i32* %dir.addr, align 4
  %0 = load %struct.device** %dev.addr, align 8
  %1 = load %struct.skb_frag_struct** %frag.addr, align 8
  %call = call %struct.page* @skb_frag_page(%struct.skb_frag_struct* %1) noredzone
  %2 = load %struct.skb_frag_struct** %frag.addr, align 8
  %page_offset = getelementptr inbounds %struct.skb_frag_struct* %2, i32 0, i32 1
  %3 = load i32* %page_offset, align 4
  %conv = zext i32 %3 to i64
  %4 = load i64* %offset.addr, align 8
  %add = add i64 %conv, %4
  %5 = load i64* %size.addr, align 8
  %6 = load i32* %dir.addr, align 4
  %call1 = call i64 @dma_map_page(%struct.device* %0, %struct.page* %call, i64 %add, i64 %5, i32 %6) noredzone
  ret i64 %call1
}

define internal void @netdev_tx_sent_queue(%struct.netdev_queue* %dev_queue, i32 %bytes) nounwind inlinehint noredzone {
entry:
  %nr.addr.i17 = alloca i64, align 8
  %addr.addr.i18 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %dev_queue.addr = alloca %struct.netdev_queue*, align 8
  %bytes.addr = alloca i32, align 4
  store %struct.netdev_queue* %dev_queue, %struct.netdev_queue** %dev_queue.addr, align 8
  store i32 %bytes, i32* %bytes.addr, align 4
  %0 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %dql = getelementptr inbounds %struct.netdev_queue* %0, i32 0, i32 12
  %1 = load i32* %bytes.addr, align 4
  call void @dql_queued(%struct.dql* %dql, i32 %1) noredzone
  %2 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %dql1 = getelementptr inbounds %struct.netdev_queue* %2, i32 0, i32 12
  %call = call i32 @dql_avail(%struct.dql* %dql1) noredzone
  %cmp = icmp sge i32 %call, 0
  %lnot = xor i1 %cmp, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 1)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %if.end16

if.end:                                           ; preds = %entry
  %3 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %3, i32 0, i32 10
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %4 = load i64** %addr.addr.i, align 8
  %5 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %4, i64 %5, i64* %4) nounwind, !srcloc !6
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !32
  %6 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %dql3 = getelementptr inbounds %struct.netdev_queue* %6, i32 0, i32 12
  %call4 = call i32 @dql_avail(%struct.dql* %dql3) noredzone
  %cmp5 = icmp sge i32 %call4, 0
  %lnot7 = xor i1 %cmp5, true
  %lnot9 = xor i1 %lnot7, true
  %lnot.ext10 = zext i1 %lnot9 to i32
  %conv11 = sext i32 %lnot.ext10 to i64
  %expval12 = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool13 = icmp ne i64 %expval12, 0
  br i1 %tobool13, label %if.then14, label %if.end16

if.then14:                                        ; preds = %if.end
  %7 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %state15 = getelementptr inbounds %struct.netdev_queue* %7, i32 0, i32 10
  store i64 1, i64* %nr.addr.i17, align 8
  store i64* %state15, i64** %addr.addr.i18, align 8
  %8 = load i64** %addr.addr.i18, align 8
  %9 = load i64* %nr.addr.i17, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %8, i64 %9, i64* %8) nounwind, !srcloc !1
  br label %if.end16

if.end16:                                         ; preds = %if.then, %if.then14, %if.end
  ret void
}

define internal void @dql_queued(%struct.dql* %dql, i32 %count) nounwind inlinehint noredzone {
entry:
  %dql.addr = alloca %struct.dql*, align 8
  %count.addr = alloca i32, align 4
  store %struct.dql* %dql, %struct.dql** %dql.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %0 = load i32* %count.addr, align 4
  %cmp = icmp ugt i32 %0, 268435455
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %do.body
  br label %do.body2

do.body2:                                         ; preds = %if.then
  call void asm sideeffect "1:\09ud2\0A.pushsection __bug_table,\22a\22\0A2:\09.long 1b - 2b, ${0:c} - 2b\0A\09.word ${1:c}, 0\0A\09.org 2b+${2:c}\0A.popsection", "i,i,i,~{dirflag},~{fpsr},~{flags}"(i8* getelementptr inbounds ([37 x i8]* @.str34, i32 0, i32 0), i32 74, i64 12) nounwind, !srcloc !33
  br label %do.body3

do.body3:                                         ; preds = %do.cond, %do.body2
  br label %do.cond

do.cond:                                          ; preds = %do.body3
  br i1 true, label %do.body3, label %do.end

do.end:                                           ; preds = %do.cond
  br label %do.end5

do.end5:                                          ; preds = %do.end
  br label %if.end

if.end:                                           ; preds = %do.end5, %do.body
  br label %do.end7

do.end7:                                          ; preds = %if.end
  %1 = load i32* %count.addr, align 4
  %2 = load %struct.dql** %dql.addr, align 8
  %num_queued = getelementptr inbounds %struct.dql* %2, i32 0, i32 0
  %3 = load i32* %num_queued, align 4
  %add = add i32 %3, %1
  store i32 %add, i32* %num_queued, align 4
  %4 = load i32* %count.addr, align 4
  %5 = load %struct.dql** %dql.addr, align 8
  %last_obj_cnt = getelementptr inbounds %struct.dql* %5, i32 0, i32 2
  store i32 %4, i32* %last_obj_cnt, align 4
  ret void
}

define internal i64 @__phys_addr_nodebug(i64 %x) nounwind inlinehint noredzone {
entry:
  %x.addr = alloca i64, align 8
  %y = alloca i64, align 8
  store i64 %x, i64* %x.addr, align 8
  %0 = load i64* %x.addr, align 8
  %sub = sub i64 %0, -2147483648
  store i64 %sub, i64* %y, align 8
  %1 = load i64* %y, align 8
  %2 = load i64* %x.addr, align 8
  %3 = load i64* %y, align 8
  %cmp = icmp ugt i64 %2, %3
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %4 = load i64* @phys_base, align 8
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i64 [ %4, %cond.true ], [ 131939247849472, %cond.false ]
  %add = add i64 %1, %cond
  store i64 %add, i64* %x.addr, align 8
  %5 = load i64* %x.addr, align 8
  ret i64 %5
}

define internal i32 @skb_network_header_len(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %transport_header = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 36
  %1 = load i16* %transport_header, align 2
  %conv = zext i16 %1 to i32
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %network_header = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 37
  %3 = load i16* %network_header, align 2
  %conv1 = zext i16 %3 to i32
  %sub = sub i32 %conv, %conv1
  ret i32 %sub
}

define internal %struct.iphdr* @ip_hdr(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_network_header(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.iphdr*
  ret %struct.iphdr* %1
}

define internal %struct.ipv6hdr* @ipv6_hdr(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_network_header(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.ipv6hdr*
  ret %struct.ipv6hdr* %1
}

declare i32 @net_ratelimit() noredzone

define internal i32 @tcp_hdrlen(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call %struct.tcphdr* @tcp_hdr(%struct.sk_buff* %0) noredzone
  %1 = bitcast %struct.tcphdr* %call to i8*
  %bf.field.offs = getelementptr i8* %1, i32 12
  %2 = bitcast i8* %bf.field.offs to i16*
  %3 = load i16* %2, align 4
  %4 = lshr i16 %3, 4
  %bf.clear = and i16 %4, 15
  %conv = zext i16 %bf.clear to i32
  %mul = mul i32 %conv, 4
  ret i32 %mul
}

define internal i32 @skb_network_offset(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_network_header(%struct.sk_buff* %0) noredzone
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %1, i32 0, i32 42
  %2 = load i8** %data, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %call to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv
}

define internal void @igb_tx_ctxtdesc(%struct.igb_ring* %tx_ring, i32 %vlan_macip_lens, i32 %type_tucmd, i32 %mss_l4len_idx) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %vlan_macip_lens.addr = alloca i32, align 4
  %type_tucmd.addr = alloca i32, align 4
  %mss_l4len_idx.addr = alloca i32, align 4
  %context_desc = alloca %struct.e1000_adv_tx_context_desc*, align 8
  %i = alloca i16, align 2
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store i32 %vlan_macip_lens, i32* %vlan_macip_lens.addr, align 4
  store i32 %type_tucmd, i32* %type_tucmd.addr, align 4
  store i32 %mss_l4len_idx, i32* %mss_l4len_idx.addr, align 4
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 13
  %1 = load i16* %next_to_use, align 2
  store i16 %1, i16* %i, align 2
  %2 = load i16* %i, align 2
  %idxprom = zext i16 %2 to i64
  %3 = load %struct.igb_ring** %tx_ring.addr, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %3, i32 0, i32 4
  %4 = load i8** %desc, align 8
  %5 = bitcast i8* %4 to %struct.e1000_adv_tx_context_desc*
  %arrayidx = getelementptr %struct.e1000_adv_tx_context_desc* %5, i64 %idxprom
  store %struct.e1000_adv_tx_context_desc* %arrayidx, %struct.e1000_adv_tx_context_desc** %context_desc, align 8
  %6 = load i16* %i, align 2
  %inc = add i16 %6, 1
  store i16 %inc, i16* %i, align 2
  %7 = load i16* %i, align 2
  %conv = zext i16 %7 to i32
  %8 = load %struct.igb_ring** %tx_ring.addr, align 8
  %count = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 9
  %9 = load i16* %count, align 2
  %conv1 = zext i16 %9 to i32
  %cmp = icmp slt i32 %conv, %conv1
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %10 = load i16* %i, align 2
  %conv3 = zext i16 %10 to i32
  br label %cond.end

cond.false:                                       ; preds = %entry
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %conv3, %cond.true ], [ 0, %cond.false ]
  %conv4 = trunc i32 %cond to i16
  %11 = load %struct.igb_ring** %tx_ring.addr, align 8
  %next_to_use5 = getelementptr inbounds %struct.igb_ring* %11, i32 0, i32 13
  store i16 %conv4, i16* %next_to_use5, align 2
  %12 = load i32* %type_tucmd.addr, align 4
  %or = or i32 %12, 538968064
  store i32 %or, i32* %type_tucmd.addr, align 4
  br i1 true, label %cond.true6, label %cond.false7

cond.true6:                                       ; preds = %cond.end
  %13 = load %struct.igb_ring** %tx_ring.addr, align 8
  %flags = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 5
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %flags, i64** %addr.addr.i, align 8
  %14 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %14, 63
  %shl.i = shl i64 1, %and.i
  %15 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %15, 6
  %16 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %16, i64 %shr.i
  %17 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %17
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false7:                                      ; preds = %cond.end
  %18 = load %struct.igb_ring** %tx_ring.addr, align 8
  %flags8 = getelementptr inbounds %struct.igb_ring* %18, i32 0, i32 5
  %call9 = call i32 @variable_test_bit(i64 2, i64* %flags8) noredzone
  %tobool10 = icmp ne i32 %call9, 0
  br i1 %tobool10, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false7, %cond.true6
  %19 = load %struct.igb_ring** %tx_ring.addr, align 8
  %reg_idx = getelementptr inbounds %struct.igb_ring* %19, i32 0, i32 11
  %20 = load i8* %reg_idx, align 1
  %conv11 = zext i8 %20 to i32
  %shl = shl i32 %conv11, 4
  %21 = load i32* %mss_l4len_idx.addr, align 4
  %or12 = or i32 %21, %shl
  store i32 %or12, i32* %mss_l4len_idx.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.false7, %cond.true6
  %22 = load i32* %vlan_macip_lens.addr, align 4
  %23 = load %struct.e1000_adv_tx_context_desc** %context_desc, align 8
  %vlan_macip_lens13 = getelementptr inbounds %struct.e1000_adv_tx_context_desc* %23, i32 0, i32 0
  store i32 %22, i32* %vlan_macip_lens13, align 4
  %24 = load %struct.e1000_adv_tx_context_desc** %context_desc, align 8
  %seqnum_seed = getelementptr inbounds %struct.e1000_adv_tx_context_desc* %24, i32 0, i32 1
  store i32 0, i32* %seqnum_seed, align 4
  %25 = load i32* %type_tucmd.addr, align 4
  %26 = load %struct.e1000_adv_tx_context_desc** %context_desc, align 8
  %type_tucmd_mlhl = getelementptr inbounds %struct.e1000_adv_tx_context_desc* %26, i32 0, i32 2
  store i32 %25, i32* %type_tucmd_mlhl, align 4
  %27 = load i32* %mss_l4len_idx.addr, align 4
  %28 = load %struct.e1000_adv_tx_context_desc** %context_desc, align 8
  %mss_l4len_idx14 = getelementptr inbounds %struct.e1000_adv_tx_context_desc* %28, i32 0, i32 3
  store i32 %27, i32* %mss_l4len_idx14, align 4
  ret void
}

define internal i8* @skb_network_header(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %head = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 41
  %1 = load i8** %head, align 8
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %network_header = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 37
  %3 = load i16* %network_header, align 2
  %conv = zext i16 %3 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8* %1, i64 %idx.ext
  ret i8* %add.ptr
}

define internal %struct.tcphdr* @tcp_hdr(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_transport_header(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.tcphdr*
  ret %struct.tcphdr* %1
}

define internal i8* @skb_transport_header(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %head = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 41
  %1 = load i8** %head, align 8
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %transport_header = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 36
  %3 = load i16* %transport_header, align 2
  %conv = zext i16 %3 to i32
  %idx.ext = sext i32 %conv to i64
  %add.ptr = getelementptr i8* %1, i64 %idx.ext
  ret i8* %add.ptr
}

define internal zeroext i1 @skb_is_gso(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_end_pointer(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.skb_shared_info*
  %gso_size = getelementptr inbounds %struct.skb_shared_info* %1, i32 0, i32 2
  %2 = load i16* %gso_size, align 2
  %tobool = icmp ne i16 %2, 0
  ret i1 %tobool
}

define internal i32 @skb_cow_head(%struct.sk_buff* %skb, i32 %headroom) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %headroom.addr = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %headroom, i32* %headroom.addr, align 4
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %1 = load i32* %headroom.addr, align 4
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i32 @skb_header_cloned(%struct.sk_buff* %2) noredzone
  %call1 = call i32 @__skb_cow(%struct.sk_buff* %0, i32 %1, i32 %call) noredzone
  ret i32 %call1
}

define internal zeroext i16 @csum_tcpudp_magic(i32 %saddr, i32 %daddr, i16 zeroext %len, i16 zeroext %proto, i32 %sum) nounwind inlinehint noredzone {
entry:
  %saddr.addr = alloca i32, align 4
  %daddr.addr = alloca i32, align 4
  %len.addr = alloca i16, align 2
  %proto.addr = alloca i16, align 2
  %sum.addr = alloca i32, align 4
  store i32 %saddr, i32* %saddr.addr, align 4
  store i32 %daddr, i32* %daddr.addr, align 4
  store i16 %len, i16* %len.addr, align 2
  store i16 %proto, i16* %proto.addr, align 2
  store i32 %sum, i32* %sum.addr, align 4
  %0 = load i32* %saddr.addr, align 4
  %1 = load i32* %daddr.addr, align 4
  %2 = load i16* %len.addr, align 2
  %3 = load i16* %proto.addr, align 2
  %4 = load i32* %sum.addr, align 4
  %call = call i32 @csum_tcpudp_nofold(i32 %0, i32 %1, i16 zeroext %2, i16 zeroext %3, i32 %4) noredzone
  %call1 = call zeroext i16 @csum_fold(i32 %call) noredzone
  ret i16 %call1
}

define internal zeroext i1 @skb_is_gso_v6(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_end_pointer(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.skb_shared_info*
  %gso_type = getelementptr inbounds %struct.skb_shared_info* %1, i32 0, i32 4
  %2 = load i16* %gso_type, align 2
  %conv = zext i16 %2 to i32
  %and = and i32 %conv, 16
  %tobool = icmp ne i32 %and, 0
  ret i1 %tobool
}

declare zeroext i16 @csum_ipv6_magic(%struct.in6_addr*, %struct.in6_addr*, i32, i16 zeroext, i32) noredzone

define internal i32 @skb_transport_offset(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_transport_header(%struct.sk_buff* %0) noredzone
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %1, i32 0, i32 42
  %2 = load i8** %data, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %call to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %2 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv
}

define internal zeroext i16 @csum_fold(i32 %sum) nounwind inlinehint noredzone {
entry:
  %sum.addr = alloca i32, align 4
  store i32 %sum, i32* %sum.addr, align 4
  %0 = load i32* %sum.addr, align 4
  %shl = shl i32 %0, 16
  %1 = load i32* %sum.addr, align 4
  %and = and i32 %1, -65536
  %2 = call i32 asm "  addl $1,$0\0A  adcl $$0xffff,$0", "=r,r,0,~{dirflag},~{fpsr},~{flags}"(i32 %shl, i32 %and) nounwind, !srcloc !34
  store i32 %2, i32* %sum.addr, align 4
  %3 = load i32* %sum.addr, align 4
  %neg = xor i32 %3, -1
  %shr = lshr i32 %neg, 16
  %conv = trunc i32 %shr to i16
  ret i16 %conv
}

define internal i32 @csum_tcpudp_nofold(i32 %saddr, i32 %daddr, i16 zeroext %len, i16 zeroext %proto, i32 %sum) nounwind inlinehint noredzone {
entry:
  %saddr.addr = alloca i32, align 4
  %daddr.addr = alloca i32, align 4
  %len.addr = alloca i16, align 2
  %proto.addr = alloca i16, align 2
  %sum.addr = alloca i32, align 4
  store i32 %saddr, i32* %saddr.addr, align 4
  store i32 %daddr, i32* %daddr.addr, align 4
  store i16 %len, i16* %len.addr, align 2
  store i16 %proto, i16* %proto.addr, align 2
  store i32 %sum, i32* %sum.addr, align 4
  %0 = load i32* %daddr.addr, align 4
  %1 = load i32* %saddr.addr, align 4
  %2 = load i16* %len.addr, align 2
  %conv = zext i16 %2 to i32
  %3 = load i16* %proto.addr, align 2
  %conv1 = zext i16 %3 to i32
  %add = add i32 %conv, %conv1
  %shl = shl i32 %add, 8
  %4 = load i32* %sum.addr, align 4
  %5 = call i32 asm "  addl $1, $0\0A  adcl $2, $0\0A  adcl $3, $0\0A  adcl $$0, $0\0A", "=r,imr,imr,imr,0,~{dirflag},~{fpsr},~{flags}"(i32 %0, i32 %1, i32 %shl, i32 %4) nounwind, !srcloc !35
  store i32 %5, i32* %sum.addr, align 4
  %6 = load i32* %sum.addr, align 4
  ret i32 %6
}

define internal i32 @__skb_cow(%struct.sk_buff* %skb, i32 %headroom, i32 %cloned) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %skb.addr = alloca %struct.sk_buff*, align 8
  %headroom.addr = alloca i32, align 4
  %cloned.addr = alloca i32, align 4
  %delta = alloca i32, align 4
  %_max1 = alloca i32, align 4
  %_max2 = alloca i32, align 4
  %_max18 = alloca i32, align 4
  %_max29 = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %headroom, i32* %headroom.addr, align 4
  store i32 %cloned, i32* %cloned.addr, align 4
  store i32 0, i32* %delta, align 4
  %0 = load i32* %headroom.addr, align 4
  %1 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i32 @skb_headroom(%struct.sk_buff* %1) noredzone
  %cmp = icmp ugt i32 %0, %call
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load i32* %headroom.addr, align 4
  %3 = load %struct.sk_buff** %skb.addr, align 8
  %call1 = call i32 @skb_headroom(%struct.sk_buff* %3) noredzone
  %sub = sub i32 %2, %call1
  store i32 %sub, i32* %delta, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i32* %delta, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then3, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end
  %5 = load i32* %cloned.addr, align 4
  %tobool2 = icmp ne i32 %5, 0
  br i1 %tobool2, label %if.then3, label %if.end20

if.then3:                                         ; preds = %lor.lhs.false, %if.end
  %6 = load %struct.sk_buff** %skb.addr, align 8
  %7 = load i32* %delta, align 4
  store i32 32, i32* %_max1, align 4
  store i32 64, i32* %_max2, align 4
  %cmp4 = icmp eq i32* %_max1, %_max2
  %conv = zext i1 %cmp4 to i32
  %8 = load i32* %_max1, align 4
  %9 = load i32* %_max2, align 4
  %cmp5 = icmp sgt i32 %8, %9
  br i1 %cmp5, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then3
  %10 = load i32* %_max1, align 4
  br label %cond.end

cond.false:                                       ; preds = %if.then3
  %11 = load i32* %_max2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %10, %cond.true ], [ %11, %cond.false ]
  %sub7 = sub i32 %cond, 1
  %add = add i32 %7, %sub7
  store i32 32, i32* %_max18, align 4
  store i32 64, i32* %_max29, align 4
  %cmp10 = icmp eq i32* %_max18, %_max29
  %conv11 = zext i1 %cmp10 to i32
  %12 = load i32* %_max18, align 4
  %13 = load i32* %_max29, align 4
  %cmp12 = icmp sgt i32 %12, %13
  br i1 %cmp12, label %cond.true14, label %cond.false15

cond.true14:                                      ; preds = %cond.end
  %14 = load i32* %_max18, align 4
  br label %cond.end16

cond.false15:                                     ; preds = %cond.end
  %15 = load i32* %_max29, align 4
  br label %cond.end16

cond.end16:                                       ; preds = %cond.false15, %cond.true14
  %cond17 = phi i32 [ %14, %cond.true14 ], [ %15, %cond.false15 ]
  %sub18 = sub i32 %cond17, 1
  %neg = xor i32 %sub18, -1
  %and = and i32 %add, %neg
  %call19 = call i32 @pskb_expand_head(%struct.sk_buff* %6, i32 %and, i32 0, i32 32) noredzone
  store i32 %call19, i32* %retval
  br label %return

if.end20:                                         ; preds = %lor.lhs.false
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end20, %cond.end16
  %16 = load i32* %retval
  ret i32 %16
}

define internal i32 @skb_header_cloned(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %skb.addr = alloca %struct.sk_buff*, align 8
  %dataref = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %1 = bitcast %struct.sk_buff* %0 to i8*
  %bf.field.offs = getelementptr i8* %1, i32 124
  %2 = load i8* %bf.field.offs, align 4
  %3 = lshr i8 %2, 1
  %bf.clear = and i8 %3, 1
  %tobool = icmp ne i8 %bf.clear, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_end_pointer(%struct.sk_buff* %4) noredzone
  %5 = bitcast i8* %call to %struct.skb_shared_info*
  %dataref1 = getelementptr inbounds %struct.skb_shared_info* %5, i32 0, i32 9
  %call2 = call i32 @atomic_read(%struct.atomic_t* %dataref1) noredzone
  store i32 %call2, i32* %dataref, align 4
  %6 = load i32* %dataref, align 4
  %and = and i32 %6, 65535
  %7 = load i32* %dataref, align 4
  %shr = ashr i32 %7, 16
  %sub = sub i32 %and, %shr
  store i32 %sub, i32* %dataref, align 4
  %8 = load i32* %dataref, align 4
  %cmp = icmp ne i32 %8, 1
  %conv = zext i1 %cmp to i32
  store i32 %conv, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %9 = load i32* %retval
  ret i32 %9
}

define internal i32 @skb_headroom(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 42
  %1 = load i8** %data, align 8
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %head = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 41
  %3 = load i8** %head, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  ret i32 %conv
}

declare i32 @pskb_expand_head(%struct.sk_buff*, i32, i32, i32) noredzone

define internal void @skb_clone_tx_timestamp(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  ret void
}

define internal void @sw_tx_timestamp(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i8* @skb_end_pointer(%struct.sk_buff* %0) noredzone
  %1 = bitcast i8* %call to %struct.skb_shared_info*
  %tx_flags = getelementptr inbounds %struct.skb_shared_info* %1, i32 0, i32 1
  %2 = load i8* %tx_flags, align 1
  %conv = zext i8 %2 to i32
  %and = and i32 %conv, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %3 = load %struct.sk_buff** %skb.addr, align 8
  %call1 = call i8* @skb_end_pointer(%struct.sk_buff* %3) noredzone
  %4 = bitcast i8* %call1 to %struct.skb_shared_info*
  %tx_flags2 = getelementptr inbounds %struct.skb_shared_info* %4, i32 0, i32 1
  %5 = load i8* %tx_flags2, align 1
  %conv3 = zext i8 %5 to i32
  %and4 = and i32 %conv3, 4
  %tobool5 = icmp ne i32 %and4, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %land.lhs.true
  %6 = load %struct.sk_buff** %skb.addr, align 8
  call void @skb_tstamp_tx(%struct.sk_buff* %6, %struct.skb_shared_hwtstamps* null) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %land.lhs.true, %entry
  ret void
}

declare void @skb_tstamp_tx(%struct.sk_buff*, %struct.skb_shared_hwtstamps*) noredzone

define internal void @atomic_inc(%struct.atomic_t* %v) nounwind inlinehint noredzone {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  %0 = load %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t* %0, i32 0, i32 0
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; incl $0", "=*m,*m,~{dirflag},~{fpsr},~{flags}"(i32* %counter, i32* %counter) nounwind, !srcloc !36
  ret void
}

define internal i32 @__igb_maybe_stop_tx(%struct.igb_ring* %tx_ring, i16 zeroext %size) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %tx_ring.addr = alloca %struct.igb_ring*, align 8
  %size.addr = alloca i16, align 2
  %netdev = alloca %struct.net_device*, align 8
  store %struct.igb_ring* %tx_ring, %struct.igb_ring** %tx_ring.addr, align 8
  store i16 %size, i16* %size.addr, align 2
  %0 = load %struct.igb_ring** %tx_ring.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_ring* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %3 = load %struct.igb_ring** %tx_ring.addr, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %3, i32 0, i32 10
  %4 = load i8* %queue_index, align 1
  %conv = zext i8 %4 to i16
  call void @netif_stop_subqueue(%struct.net_device* %2, i16 zeroext %conv) noredzone
  call void asm sideeffect "mfence", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !37
  %5 = load %struct.igb_ring** %tx_ring.addr, align 8
  %call = call i32 @igb_desc_unused(%struct.igb_ring* %5) noredzone
  %6 = load i16* %size.addr, align 2
  %conv2 = zext i16 %6 to i32
  %cmp = icmp slt i32 %call, %conv2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -16, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.net_device** %netdev, align 8
  %8 = load %struct.igb_ring** %tx_ring.addr, align 8
  %queue_index4 = getelementptr inbounds %struct.igb_ring* %8, i32 0, i32 10
  %9 = load i8* %queue_index4, align 1
  %conv5 = zext i8 %9 to i16
  call void @netif_wake_subqueue(%struct.net_device* %7, i16 zeroext %conv5) noredzone
  %10 = load %struct.igb_ring** %tx_ring.addr, align 8
  %11 = getelementptr inbounds %struct.igb_ring* %10, i32 0, i32 15
  %12 = bitcast %union.anon.90* %11 to %struct.anon.91*
  %tx_syncp2 = getelementptr inbounds %struct.anon.91* %12, i32 0, i32 2
  call void @u64_stats_update_begin(%struct.u64_stats_sync* %tx_syncp2) noredzone
  %13 = load %struct.igb_ring** %tx_ring.addr, align 8
  %14 = getelementptr inbounds %struct.igb_ring* %13, i32 0, i32 15
  %15 = bitcast %union.anon.90* %14 to %struct.anon.91*
  %tx_stats = getelementptr inbounds %struct.anon.91* %15, i32 0, i32 0
  %restart_queue2 = getelementptr inbounds %struct.igb_tx_queue_stats* %tx_stats, i32 0, i32 3
  %16 = load i64* %restart_queue2, align 8
  %inc = add i64 %16, 1
  store i64 %inc, i64* %restart_queue2, align 8
  %17 = load %struct.igb_ring** %tx_ring.addr, align 8
  %18 = getelementptr inbounds %struct.igb_ring* %17, i32 0, i32 15
  %19 = bitcast %union.anon.90* %18 to %struct.anon.91*
  %tx_syncp26 = getelementptr inbounds %struct.anon.91* %19, i32 0, i32 2
  call void @u64_stats_update_end(%struct.u64_stats_sync* %tx_syncp26) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %20 = load i32* %retval
  ret i32 %20
}

define internal i8* @skb_header_pointer(%struct.sk_buff* %skb, i32 %offset, i32 %len, i8* %buffer) nounwind inlinehint noredzone {
entry:
  %retval = alloca i8*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %offset.addr = alloca i32, align 4
  %len.addr = alloca i32, align 4
  %buffer.addr = alloca i8*, align 8
  %hlen = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %offset, i32* %offset.addr, align 4
  store i32 %len, i32* %len.addr, align 4
  store i8* %buffer, i8** %buffer.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %call = call i32 @skb_headlen(%struct.sk_buff* %0) noredzone
  store i32 %call, i32* %hlen, align 4
  %1 = load i32* %hlen, align 4
  %2 = load i32* %offset.addr, align 4
  %sub = sub i32 %1, %2
  %3 = load i32* %len.addr, align 4
  %cmp = icmp sge i32 %sub, %3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %4 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %4, i32 0, i32 42
  %5 = load i8** %data, align 8
  %6 = load i32* %offset.addr, align 4
  %idx.ext = sext i32 %6 to i64
  %add.ptr = getelementptr i8* %5, i64 %idx.ext
  store i8* %add.ptr, i8** %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load %struct.sk_buff** %skb.addr, align 8
  %8 = load i32* %offset.addr, align 4
  %9 = load i8** %buffer.addr, align 8
  %10 = load i32* %len.addr, align 4
  %call1 = call i32 @skb_copy_bits(%struct.sk_buff* %7, i32 %8, i8* %9, i32 %10) noredzone
  %cmp2 = icmp slt i32 %call1, 0
  br i1 %cmp2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i8* null, i8** %retval
  br label %return

if.end4:                                          ; preds = %if.end
  %11 = load i8** %buffer.addr, align 8
  store i8* %11, i8** %retval
  br label %return

return:                                           ; preds = %if.end4, %if.then3, %if.then
  %12 = load i8** %retval
  ret i8* %12
}

declare i32 @skb_copy_bits(%struct.sk_buff*, i32, i8*, i32) noredzone

declare void @consume_skb(%struct.sk_buff*) noredzone

define internal void @netdev_tx_reset_queue(%struct.netdev_queue* %q) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %q.addr = alloca %struct.netdev_queue*, align 8
  store %struct.netdev_queue* %q, %struct.netdev_queue** %q.addr, align 8
  %0 = load %struct.netdev_queue** %q.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %0, i32 0, i32 10
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64** %addr.addr.i, align 8
  %2 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %1, i64 %2, i64* %1) nounwind, !srcloc !1
  %3 = load %struct.netdev_queue** %q.addr, align 8
  %dql = getelementptr inbounds %struct.netdev_queue* %3, i32 0, i32 12
  call void @dql_reset(%struct.dql* %dql) noredzone
  ret void
}

declare void @dql_reset(%struct.dql*) noredzone

define internal void @debug_dma_unmap_page(%struct.device* %dev, i64 %addr, i64 %size, i32 %direction, i1 zeroext %map_single) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %addr.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %direction.addr = alloca i32, align 4
  %map_single.addr = alloca i8, align 1
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %addr, i64* %addr.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %direction, i32* %direction.addr, align 4
  %frombool = zext i1 %map_single to i8
  store i8 %frombool, i8* %map_single.addr, align 1
  ret void
}

declare void @__dev_kfree_skb_any(%struct.sk_buff*, i32) noredzone

define internal i64 @arch_local_save_flags() nounwind inlinehint noredzone {
entry:
  %call = call i64 @native_save_fl() noredzone
  ret i64 %call
}

define internal i32 @arch_irqs_disabled_flags(i64 %flags) nounwind inlinehint noredzone {
entry:
  %flags.addr = alloca i64, align 8
  store i64 %flags, i64* %flags.addr, align 8
  %0 = load i64* %flags.addr, align 8
  %and = and i64 %0, 512
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot.ext = zext i1 %lnot to i32
  ret i32 %lnot.ext
}

define internal void @debug_dma_free_coherent(%struct.device* %dev, i64 %size, i8* %virt, i64 %addr) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %size.addr = alloca i64, align 8
  %virt.addr = alloca i8*, align 8
  %addr.addr = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i8* %virt, i8** %virt.addr, align 8
  store i64 %addr, i64* %addr.addr, align 8
  ret void
}

define internal i64 @native_save_fl() nounwind inlinehint noredzone {
entry:
  %flags = alloca i64, align 8
  call void asm sideeffect "# __raw_save_flags\0A\09pushf ; pop $0", "=*rm,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %flags) nounwind, !srcloc !38
  %0 = load i64* %flags, align 8
  ret i64 %0
}

define internal i32 @is_device_dma_capable(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %dma_mask = getelementptr inbounds %struct.device* %0, i32 0, i32 13
  %1 = load i64** %dma_mask, align 8
  %cmp = icmp ne i64* %1, null
  br i1 %cmp, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %entry
  %2 = load %struct.device** %dev.addr, align 8
  %dma_mask1 = getelementptr inbounds %struct.device* %2, i32 0, i32 13
  %3 = load i64** %dma_mask1, align 8
  %4 = load i64* %3, align 8
  %cmp2 = icmp ne i64 %4, 0
  br label %land.end

land.end:                                         ; preds = %land.rhs, %entry
  %5 = phi i1 [ false, %entry ], [ %cmp2, %land.rhs ]
  %land.ext = zext i1 %5 to i32
  ret i32 %land.ext
}

define internal i32 @dma_alloc_coherent_gfp_flags(%struct.device* %dev, i32 %gfp) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %gfp.addr = alloca i32, align 4
  %dma_mask = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i32 %gfp, i32* %gfp.addr, align 4
  %0 = load %struct.device** %dev.addr, align 8
  %1 = load i32* %gfp.addr, align 4
  %call = call i64 @dma_alloc_coherent_mask(%struct.device* %0, i32 %1) noredzone
  store i64 %call, i64* %dma_mask, align 8
  %2 = load i64* %dma_mask, align 8
  %cmp = icmp ule i64 %2, 16777215
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load i32* %gfp.addr, align 4
  %or = or i32 %3, 1
  store i32 %or, i32* %gfp.addr, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i64* %dma_mask, align 8
  %cmp1 = icmp ule i64 %4, 4294967295
  br i1 %cmp1, label %land.lhs.true, label %if.end4

land.lhs.true:                                    ; preds = %if.end
  %5 = load i32* %gfp.addr, align 4
  %and = and i32 %5, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end4, label %if.then2

if.then2:                                         ; preds = %land.lhs.true
  %6 = load i32* %gfp.addr, align 4
  %or3 = or i32 %6, 4
  store i32 %or3, i32* %gfp.addr, align 4
  br label %if.end4

if.end4:                                          ; preds = %if.then2, %land.lhs.true, %if.end
  %7 = load i32* %gfp.addr, align 4
  ret i32 %7
}

define internal void @debug_dma_alloc_coherent(%struct.device* %dev, i64 %size, i64 %dma_addr, i8* %virt) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %size.addr = alloca i64, align 8
  %dma_addr.addr = alloca i64, align 8
  %virt.addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i64 %dma_addr, i64* %dma_addr.addr, align 8
  store i8* %virt, i8** %virt.addr, align 8
  ret void
}

define internal i64 @dma_alloc_coherent_mask(%struct.device* %dev, i32 %gfp) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %gfp.addr = alloca i32, align 4
  %dma_mask = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i32 %gfp, i32* %gfp.addr, align 4
  store i64 0, i64* %dma_mask, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %coherent_dma_mask = getelementptr inbounds %struct.device* %0, i32 0, i32 14
  %1 = load i64* %coherent_dma_mask, align 8
  store i64 %1, i64* %dma_mask, align 8
  %2 = load i64* %dma_mask, align 8
  %tobool = icmp ne i64 %2, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %3 = load i32* %gfp.addr, align 4
  %and = and i32 %3, 1
  %tobool1 = icmp ne i32 %and, 0
  %cond = select i1 %tobool1, i64 16777215, i64 4294967295
  store i64 %cond, i64* %dma_mask, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %4 = load i64* %dma_mask, align 8
  ret i64 %4
}

declare void @igb_power_down_phy_copper_82575(%struct.e1000_hw*) noredzone

declare void @igb_shutdown_serdes_link_82575(%struct.e1000_hw*) noredzone

declare i32 @netdev_info(%struct.net_device*, i8*, ...) noredzone

define internal void @__raw_spin_unlock(%struct.raw_spinlock* %lock) nounwind inlinehint noredzone {
entry:
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  br label %do.body

do.body:                                          ; preds = %entry
  br label %do.end

do.end:                                           ; preds = %do.body
  %0 = load %struct.raw_spinlock** %lock.addr, align 8
  call void @do_raw_spin_unlock(%struct.raw_spinlock* %0) noredzone
  call void asm sideeffect "", "~{memory},~{dirflag},~{fpsr},~{flags}"() nounwind, !srcloc !39
  ret void
}

define internal void @do_raw_spin_unlock(%struct.raw_spinlock* %lock) nounwind inlinehint noredzone {
entry:
  %lock.addr.i = alloca %struct.arch_spinlock*, align 8
  %__ret.i = alloca i16, align 2
  %lock.addr = alloca %struct.raw_spinlock*, align 8
  store %struct.raw_spinlock* %lock, %struct.raw_spinlock** %lock.addr, align 8
  %0 = load %struct.raw_spinlock** %lock.addr, align 8
  %raw_lock = getelementptr inbounds %struct.raw_spinlock* %0, i32 0, i32 0
  store %struct.arch_spinlock* %raw_lock, %struct.arch_spinlock** %lock.addr.i, align 8
  store i16 1, i16* %__ret.i, align 2
  %1 = load %struct.arch_spinlock** %lock.addr.i, align 8
  %2 = getelementptr inbounds %struct.arch_spinlock* %1, i32 0, i32 0
  %tickets.i = bitcast %union.anon.4* %2 to %struct.__raw_tickets*
  %head.i = getelementptr inbounds %struct.__raw_tickets* %tickets.i, i32 0, i32 0
  call void asm sideeffect "addw ${1:w}, $0\0A", "=*m,ri,*m,~{memory},~{cc},~{dirflag},~{fpsr},~{flags}"(i16* %head.i, i16 1, i16* %head.i) nounwind, !srcloc !40
  %3 = load i16* %__ret.i, align 2
  ret void
}

declare void @_raw_spin_lock(%struct.raw_spinlock*) noredzone section ".spinlock.text"

declare i32 @_cond_resched() noredzone

declare void @synchronize_irq(i32) noredzone

define internal zeroext i1 @queue_work(%struct.workqueue_struct* %wq, %struct.work_struct* %work) nounwind inlinehint noredzone {
entry:
  %wq.addr = alloca %struct.workqueue_struct*, align 8
  %work.addr = alloca %struct.work_struct*, align 8
  store %struct.workqueue_struct* %wq, %struct.workqueue_struct** %wq.addr, align 8
  store %struct.work_struct* %work, %struct.work_struct** %work.addr, align 8
  %0 = load %struct.workqueue_struct** %wq.addr, align 8
  %1 = load %struct.work_struct** %work.addr, align 8
  %call = call zeroext i1 @queue_work_on(i32 256, %struct.workqueue_struct* %0, %struct.work_struct* %1) noredzone
  ret i1 %call
}

declare zeroext i1 @queue_work_on(i32, %struct.workqueue_struct*, %struct.work_struct*) noredzone

define internal void @netif_tx_start_queue(%struct.netdev_queue* %dev_queue) nounwind inlinehint noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %dev_queue.addr = alloca %struct.netdev_queue*, align 8
  store %struct.netdev_queue* %dev_queue, %struct.netdev_queue** %dev_queue.addr, align 8
  %0 = load %struct.netdev_queue** %dev_queue.addr, align 8
  %state = getelementptr inbounds %struct.netdev_queue* %0, i32 0, i32 10
  store i64 0, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %1 = load i64** %addr.addr.i, align 8
  %2 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %1, i64 %2, i64* %1) nounwind, !srcloc !1
  ret void
}

define internal void @igb_write_ivar(%struct.e1000_hw* %hw, i32 %msix_vector, i32 %index, i32 %offset) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %msix_vector.addr = alloca i32, align 4
  %index.addr = alloca i32, align 4
  %offset.addr = alloca i32, align 4
  %ivar = alloca i32, align 4
  %hw_addr5 = alloca i8*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %msix_vector, i32* %msix_vector.addr, align 4
  store i32 %index, i32* %index.addr, align 4
  store i32 %offset, i32* %offset.addr, align 4
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 1
  %1 = load i8** %hw_addr, align 8
  %add.ptr = getelementptr i8* %1, i64 5888
  %2 = load i32* %index.addr, align 4
  %shl = shl i32 %2, 2
  %idx.ext = sext i32 %shl to i64
  %add.ptr1 = getelementptr i8* %add.ptr, i64 %idx.ext
  %call = call i32 @readl(i8* %add.ptr1) noredzone
  store i32 %call, i32* %ivar, align 4
  %3 = load i32* %offset.addr, align 4
  %shl2 = shl i32 255, %3
  %neg = xor i32 %shl2, -1
  %4 = load i32* %ivar, align 4
  %and = and i32 %4, %neg
  store i32 %and, i32* %ivar, align 4
  %5 = load i32* %msix_vector.addr, align 4
  %or = or i32 %5, 128
  %6 = load i32* %offset.addr, align 4
  %shl3 = shl i32 %or, %6
  %7 = load i32* %ivar, align 4
  %or4 = or i32 %7, %shl3
  store i32 %or4, i32* %ivar, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %8 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr6 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr6, align 8
  store i8* %9, i8** %hw_addr5, align 8
  %10 = load i8** %hw_addr5, align 8
  %tobool = icmp ne i8* %10, null
  %lnot = xor i1 %tobool, true
  %lnot7 = xor i1 %lnot, true
  %lnot8 = xor i1 %lnot7, true
  %lnot.ext = zext i1 %lnot8 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %11 = load i32* %ivar, align 4
  %12 = load i32* %index.addr, align 4
  %shl10 = shl i32 %12, 2
  %add = add i32 5888, %shl10
  %idxprom = sext i32 %add to i64
  %13 = load i8** %hw_addr5, align 8
  %arrayidx = getelementptr i8* %13, i64 %idxprom
  call void @writel(i32 %11, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  ret void
}

define internal void @igb_get_hw_control(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ctrl_ext = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 24) noredzone
  store i32 %call, i32* %ctrl_ext, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %2 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 1
  %3 = load volatile i8** %hw_addr2, align 8
  store i8* %3, i8** %hw_addr, align 8
  %4 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %4, null
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %5 = load i32* %ctrl_ext, align 4
  %or = or i32 %5, 268435456
  %6 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %6, i64 24
  call void @writel(i32 %or, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  ret void
}

define internal void @igb_restore_vlan(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vid = alloca i16, align 2
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 1
  %3 = load %struct.net_device** %netdev1, align 8
  %features = getelementptr inbounds %struct.net_device* %3, i32 0, i32 14
  %4 = load i64* %features, align 8
  call void @igb_vlan_mode(%struct.net_device* %1, i64 %4) noredzone
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %active_vlans = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64]* %active_vlans, i32 0, i32 0
  %call = call i64 @find_first_bit(i64* %arraydecay, i64 4096) noredzone
  %conv = trunc i64 %call to i16
  store i16 %conv, i16* %vid, align 2
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %6 = load i16* %vid, align 2
  %conv2 = zext i16 %6 to i32
  %cmp = icmp slt i32 %conv2, 4096
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev4 = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 1
  %8 = load %struct.net_device** %netdev4, align 8
  %9 = load i16* %vid, align 2
  %call5 = call i32 @igb_vlan_rx_add_vid(%struct.net_device* %8, i16 zeroext 129, i16 zeroext %9) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %active_vlans6 = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 0
  %arraydecay7 = getelementptr inbounds [64 x i64]* %active_vlans6, i32 0, i32 0
  %11 = load i16* %vid, align 2
  %conv8 = zext i16 %11 to i32
  %add = add i32 %conv8, 1
  %conv9 = sext i32 %add to i64
  %call10 = call i64 @find_next_bit(i64* %arraydecay7, i64 4096, i64 %conv9) noredzone
  %conv11 = trunc i64 %call10 to i16
  store i16 %conv11, i16* %vid, align 2
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal void @igb_setup_mrqc(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %mrqc = alloca i32, align 4
  %rxcsum = alloca i32, align 4
  %j = alloca i32, align 4
  %num_rx_queues = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr36 = alloca i8*, align 8
  %vtctl = alloca i32, align 4
  %hw_addr75 = alloca i8*, align 8
  %hw_addr109 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32* %j, align 4
  %cmp = icmp ult i32 %1, 10
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %2 = load %struct.e1000_hw** %hw, align 8
  %hw_addr2 = getelementptr inbounds %struct.e1000_hw* %2, i32 0, i32 1
  %3 = load volatile i8** %hw_addr2, align 8
  store i8* %3, i8** %hw_addr, align 8
  %4 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %4, null
  %lnot = xor i1 %tobool, true
  %lnot3 = xor i1 %lnot, true
  %lnot4 = xor i1 %lnot3, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %5 = load i32* %j, align 4
  %idxprom = zext i32 %5 to i64
  %arrayidx = getelementptr [10 x i32]* @igb_setup_mrqc.rsskey, i32 0, i64 %idxprom
  %6 = load i32* %arrayidx, align 4
  %7 = load i32* %j, align 4
  %mul = mul i32 %7, 4
  %add = add i32 23680, %mul
  %idxprom6 = zext i32 %add to i64
  %8 = load i8** %hw_addr, align 8
  %arrayidx7 = getelementptr i8* %8, i64 %idxprom6
  call void @writel(i32 %6, i8* %arrayidx7) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %9 = load i32* %j, align 4
  %inc = add i32 %9, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 52
  %11 = load i32* %rss_queues, align 4
  store i32 %11, i32* %num_rx_queues, align 4
  %12 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %13 = load i32* %type, align 4
  switch i32 %13, label %sw.default [
    i32 2, label %sw.bb
  ]

sw.bb:                                            ; preds = %for.end
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 49
  %15 = load i32* %vfs_allocated_count, align 4
  %tobool8 = icmp ne i32 %15, 0
  br i1 %tobool8, label %if.then9, label %if.end10

if.then9:                                         ; preds = %sw.bb
  store i32 2, i32* %num_rx_queues, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %sw.bb
  br label %sw.epilog

sw.default:                                       ; preds = %for.end
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end10
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_indir_tbl_init = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 75
  %17 = load i32* %rss_indir_tbl_init, align 4
  %18 = load i32* %num_rx_queues, align 4
  %cmp11 = icmp ne i32 %17, %18
  br i1 %cmp11, label %if.then13, label %if.end26

if.then13:                                        ; preds = %sw.epilog
  store i32 0, i32* %j, align 4
  br label %for.cond14

for.cond14:                                       ; preds = %for.inc22, %if.then13
  %19 = load i32* %j, align 4
  %cmp15 = icmp ult i32 %19, 128
  br i1 %cmp15, label %for.body17, label %for.end24

for.body17:                                       ; preds = %for.cond14
  %20 = load i32* %j, align 4
  %21 = load i32* %num_rx_queues, align 4
  %mul18 = mul i32 %20, %21
  %div = udiv i32 %mul18, 128
  %conv19 = trunc i32 %div to i8
  %22 = load i32* %j, align 4
  %idxprom20 = zext i32 %22 to i64
  %23 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_indir_tbl = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 76
  %arrayidx21 = getelementptr [128 x i8]* %rss_indir_tbl, i32 0, i64 %idxprom20
  store i8 %conv19, i8* %arrayidx21, align 1
  br label %for.inc22

for.inc22:                                        ; preds = %for.body17
  %24 = load i32* %j, align 4
  %inc23 = add i32 %24, 1
  store i32 %inc23, i32* %j, align 4
  br label %for.cond14

for.end24:                                        ; preds = %for.cond14
  %25 = load i32* %num_rx_queues, align 4
  %26 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_indir_tbl_init25 = getelementptr inbounds %struct.igb_adapter* %26, i32 0, i32 75
  store i32 %25, i32* %rss_indir_tbl_init25, align 4
  br label %if.end26

if.end26:                                         ; preds = %for.end24, %sw.epilog
  %27 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_write_rss_indir_tbl(%struct.igb_adapter* %27) noredzone
  %28 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %28, i32 20480) noredzone
  store i32 %call, i32* %rxcsum, align 4
  %29 = load i32* %rxcsum, align 4
  %or = or i32 %29, 8192
  store i32 %or, i32* %rxcsum, align 4
  %30 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw27 = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 35
  %mac28 = getelementptr inbounds %struct.e1000_hw* %hw27, i32 0, i32 4
  %type29 = getelementptr inbounds %struct.e1000_mac_info* %mac28, i32 0, i32 3
  %31 = load i32* %type29, align 4
  %cmp30 = icmp uge i32 %31, 2
  br i1 %cmp30, label %if.then32, label %if.end34

if.then32:                                        ; preds = %if.end26
  %32 = load i32* %rxcsum, align 4
  %or33 = or i32 %32, 2048
  store i32 %or33, i32* %rxcsum, align 4
  br label %if.end34

if.end34:                                         ; preds = %if.then32, %if.end26
  br label %do.body35

do.body35:                                        ; preds = %if.end34
  %33 = load %struct.e1000_hw** %hw, align 8
  %hw_addr37 = getelementptr inbounds %struct.e1000_hw* %33, i32 0, i32 1
  %34 = load volatile i8** %hw_addr37, align 8
  store i8* %34, i8** %hw_addr36, align 8
  %35 = load i8** %hw_addr36, align 8
  %tobool38 = icmp ne i8* %35, null
  %lnot39 = xor i1 %tobool38, true
  %lnot41 = xor i1 %lnot39, true
  %lnot43 = xor i1 %lnot41, true
  %lnot.ext44 = zext i1 %lnot43 to i32
  %conv45 = sext i32 %lnot.ext44 to i64
  %expval46 = call i64 @llvm.expect.i64(i64 %conv45, i64 0)
  %tobool47 = icmp ne i64 %expval46, 0
  br i1 %tobool47, label %if.end50, label %if.then48

if.then48:                                        ; preds = %do.body35
  %36 = load i32* %rxcsum, align 4
  %37 = load i8** %hw_addr36, align 8
  %arrayidx49 = getelementptr i8* %37, i64 20480
  call void @writel(i32 %36, i8* %arrayidx49) noredzone
  br label %if.end50

if.end50:                                         ; preds = %if.then48, %do.body35
  br label %do.end51

do.end51:                                         ; preds = %if.end50
  store i32 3604480, i32* %mrqc, align 4
  %38 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %38, i32 0, i32 3
  %39 = load i32* %flags, align 4
  %and = and i32 %39, 64
  %tobool52 = icmp ne i32 %and, 0
  br i1 %tobool52, label %if.then53, label %if.end55

if.then53:                                        ; preds = %do.end51
  %40 = load i32* %mrqc, align 4
  %or54 = or i32 %40, 4194304
  store i32 %or54, i32* %mrqc, align 4
  br label %if.end55

if.end55:                                         ; preds = %if.then53, %do.end51
  %41 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags56 = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 3
  %42 = load i32* %flags56, align 4
  %and57 = and i32 %42, 128
  %tobool58 = icmp ne i32 %and57, 0
  br i1 %tobool58, label %if.then59, label %if.end61

if.then59:                                        ; preds = %if.end55
  %43 = load i32* %mrqc, align 4
  %or60 = or i32 %43, 8388608
  store i32 %or60, i32* %mrqc, align 4
  br label %if.end61

if.end61:                                         ; preds = %if.then59, %if.end55
  %44 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count62 = getelementptr inbounds %struct.igb_adapter* %44, i32 0, i32 49
  %45 = load i32* %vfs_allocated_count62, align 4
  %tobool63 = icmp ne i32 %45, 0
  br i1 %tobool63, label %if.then64, label %if.else99

if.then64:                                        ; preds = %if.end61
  %46 = load %struct.e1000_hw** %hw, align 8
  %mac65 = getelementptr inbounds %struct.e1000_hw* %46, i32 0, i32 4
  %type66 = getelementptr inbounds %struct.e1000_mac_info* %mac65, i32 0, i32 3
  %47 = load i32* %type66, align 4
  %cmp67 = icmp ugt i32 %47, 1
  br i1 %cmp67, label %if.then69, label %if.end91

if.then69:                                        ; preds = %if.then64
  %48 = load %struct.e1000_hw** %hw, align 8
  %call70 = call i32 @igb_rd32(%struct.e1000_hw* %48, i32 22556) noredzone
  store i32 %call70, i32* %vtctl, align 4
  %49 = load i32* %vtctl, align 4
  %and71 = and i32 %49, -536871809
  store i32 %and71, i32* %vtctl, align 4
  %50 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count72 = getelementptr inbounds %struct.igb_adapter* %50, i32 0, i32 49
  %51 = load i32* %vfs_allocated_count72, align 4
  %shl = shl i32 %51, 7
  %52 = load i32* %vtctl, align 4
  %or73 = or i32 %52, %shl
  store i32 %or73, i32* %vtctl, align 4
  br label %do.body74

do.body74:                                        ; preds = %if.then69
  %53 = load %struct.e1000_hw** %hw, align 8
  %hw_addr76 = getelementptr inbounds %struct.e1000_hw* %53, i32 0, i32 1
  %54 = load volatile i8** %hw_addr76, align 8
  store i8* %54, i8** %hw_addr75, align 8
  %55 = load i8** %hw_addr75, align 8
  %tobool77 = icmp ne i8* %55, null
  %lnot78 = xor i1 %tobool77, true
  %lnot80 = xor i1 %lnot78, true
  %lnot82 = xor i1 %lnot80, true
  %lnot.ext83 = zext i1 %lnot82 to i32
  %conv84 = sext i32 %lnot.ext83 to i64
  %expval85 = call i64 @llvm.expect.i64(i64 %conv84, i64 0)
  %tobool86 = icmp ne i64 %expval85, 0
  br i1 %tobool86, label %if.end89, label %if.then87

if.then87:                                        ; preds = %do.body74
  %56 = load i32* %vtctl, align 4
  %57 = load i8** %hw_addr75, align 8
  %arrayidx88 = getelementptr i8* %57, i64 22556
  call void @writel(i32 %56, i8* %arrayidx88) noredzone
  br label %if.end89

if.end89:                                         ; preds = %if.then87, %do.body74
  br label %do.end90

do.end90:                                         ; preds = %if.end89
  br label %if.end91

if.end91:                                         ; preds = %do.end90, %if.then64
  %58 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues92 = getelementptr inbounds %struct.igb_adapter* %58, i32 0, i32 52
  %59 = load i32* %rss_queues92, align 4
  %cmp93 = icmp ugt i32 %59, 1
  br i1 %cmp93, label %if.then95, label %if.else

if.then95:                                        ; preds = %if.end91
  %60 = load i32* %mrqc, align 4
  %or96 = or i32 %60, 5
  store i32 %or96, i32* %mrqc, align 4
  br label %if.end98

if.else:                                          ; preds = %if.end91
  %61 = load i32* %mrqc, align 4
  %or97 = or i32 %61, 3
  store i32 %or97, i32* %mrqc, align 4
  br label %if.end98

if.end98:                                         ; preds = %if.else, %if.then95
  br label %if.end107

if.else99:                                        ; preds = %if.end61
  %62 = load %struct.e1000_hw** %hw, align 8
  %mac100 = getelementptr inbounds %struct.e1000_hw* %62, i32 0, i32 4
  %type101 = getelementptr inbounds %struct.e1000_mac_info* %mac100, i32 0, i32 3
  %63 = load i32* %type101, align 4
  %cmp102 = icmp ne i32 %63, 7
  br i1 %cmp102, label %if.then104, label %if.end106

if.then104:                                       ; preds = %if.else99
  %64 = load i32* %mrqc, align 4
  %or105 = or i32 %64, 2
  store i32 %or105, i32* %mrqc, align 4
  br label %if.end106

if.end106:                                        ; preds = %if.then104, %if.else99
  br label %if.end107

if.end107:                                        ; preds = %if.end106, %if.end98
  %65 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_vmm_control(%struct.igb_adapter* %65) noredzone
  br label %do.body108

do.body108:                                       ; preds = %if.end107
  %66 = load %struct.e1000_hw** %hw, align 8
  %hw_addr110 = getelementptr inbounds %struct.e1000_hw* %66, i32 0, i32 1
  %67 = load volatile i8** %hw_addr110, align 8
  store i8* %67, i8** %hw_addr109, align 8
  %68 = load i8** %hw_addr109, align 8
  %tobool111 = icmp ne i8* %68, null
  %lnot112 = xor i1 %tobool111, true
  %lnot114 = xor i1 %lnot112, true
  %lnot116 = xor i1 %lnot114, true
  %lnot.ext117 = zext i1 %lnot116 to i32
  %conv118 = sext i32 %lnot.ext117 to i64
  %expval119 = call i64 @llvm.expect.i64(i64 %conv118, i64 0)
  %tobool120 = icmp ne i64 %expval119, 0
  br i1 %tobool120, label %if.end123, label %if.then121

if.then121:                                       ; preds = %do.body108
  %69 = load i32* %mrqc, align 4
  %70 = load i8** %hw_addr109, align 8
  %arrayidx122 = getelementptr i8* %70, i64 22552
  call void @writel(i32 %69, i8* %arrayidx122) noredzone
  br label %if.end123

if.end123:                                        ; preds = %if.then121, %do.body108
  br label %do.end124

do.end124:                                        ; preds = %if.end123
  ret void
}

define internal void @igb_configure_tx(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32* %i, align 4
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 12
  %2 = load i32* %num_tx_queues, align 4
  %cmp = icmp slt i32 %0, %2
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %4 = load i32* %i, align 4
  %idxprom = sext i32 %4 to i64
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom
  %6 = load %struct.igb_ring** %arrayidx, align 8
  call void @igb_configure_tx_ring(%struct.igb_adapter* %3, %struct.igb_ring* %6) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %7 = load i32* %i, align 4
  %inc = add i32 %7, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal void @igb_configure_rx(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %i = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_set_uta(%struct.igb_adapter* %0) noredzone
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  %addr = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 1
  %arraydecay = getelementptr inbounds [6 x i8]* %addr, i32 0, i32 0
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %conv = trunc i32 %4 to i8
  call void @igb_rar_set_qsel(%struct.igb_adapter* %1, i8* %arraydecay, i32 0, i8 zeroext %conv) noredzone
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %5 = load i32* %i, align 4
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 14
  %7 = load i32* %num_rx_queues, align 4
  %cmp = icmp slt i32 %5, %7
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %9 = load i32* %i, align 4
  %idxprom = sext i32 %9 to i64
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 15
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %rx_ring, i32 0, i64 %idxprom
  %11 = load %struct.igb_ring** %arrayidx, align 8
  call void @igb_configure_rx_ring(%struct.igb_adapter* %8, %struct.igb_ring* %11) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %12 = load i32* %i, align 4
  %inc = add i32 %12, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

declare void @igb_rx_fifo_flush_82575(%struct.e1000_hw*) noredzone

define internal void @igb_set_uta(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  %cmp = icmp ult i32 %2, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end3, label %if.then2

if.then2:                                         ; preds = %if.end
  br label %for.end

if.end3:                                          ; preds = %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end3
  %5 = load i32* %i, align 4
  %6 = load %struct.e1000_hw** %hw, align 8
  %mac4 = getelementptr inbounds %struct.e1000_hw* %6, i32 0, i32 4
  %uta_reg_count = getelementptr inbounds %struct.e1000_mac_info* %mac4, i32 0, i32 10
  %7 = load i16* %uta_reg_count, align 2
  %conv = zext i16 %7 to i32
  %cmp5 = icmp slt i32 %5, %conv
  br i1 %cmp5, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  br label %do.body

do.body:                                          ; preds = %for.body
  %8 = load %struct.e1000_hw** %hw, align 8
  %hw_addr7 = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 1
  %9 = load volatile i8** %hw_addr7, align 8
  store i8* %9, i8** %hw_addr, align 8
  %10 = load i8** %hw_addr, align 8
  %tobool8 = icmp ne i8* %10, null
  %lnot = xor i1 %tobool8, true
  %lnot9 = xor i1 %lnot, true
  %lnot10 = xor i1 %lnot9, true
  %lnot.ext = zext i1 %lnot10 to i32
  %conv11 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv11, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.end14, label %if.then13

if.then13:                                        ; preds = %do.body
  %11 = load i32* %i, align 4
  %shl = shl i32 %11, 2
  %add = add i32 40960, %shl
  %idxprom = sext i32 %add to i64
  %12 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %12, i64 %idxprom
  call void @writel(i32 -1, i8* %arrayidx) noredzone
  br label %if.end14

if.end14:                                         ; preds = %if.then13, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end14
  br label %for.inc

for.inc:                                          ; preds = %do.end
  %13 = load i32* %i, align 4
  %inc = add i32 %13, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %if.then2, %for.cond
  ret void
}

declare void @igb_write_rss_indir_tbl(%struct.igb_adapter*) noredzone

define internal void @igb_vmm_control(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %reg = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr11 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  switch i32 %2, label %sw.default [
    i32 1, label %sw.bb
    i32 6, label %sw.bb
    i32 7, label %sw.bb
    i32 5, label %sw.bb
    i32 2, label %sw.bb2
    i32 3, label %sw.bb7
    i32 4, label %sw.bb27
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry, %entry
  br label %sw.default

sw.default:                                       ; preds = %entry, %sw.bb
  br label %if.end31

sw.bb2:                                           ; preds = %entry
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 13712) noredzone
  store i32 %call, i32* %reg, align 4
  %4 = load i32* %reg, align 4
  %or = or i32 %4, 8
  store i32 %or, i32* %reg, align 4
  br label %do.body

do.body:                                          ; preds = %sw.bb2
  %5 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 1
  %6 = load volatile i8** %hw_addr3, align 8
  store i8* %6, i8** %hw_addr, align 8
  %7 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %7, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end, label %if.then

if.then:                                          ; preds = %do.body
  %8 = load i32* %reg, align 4
  %9 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %9, i64 13712
  call void @writel(i32 %8, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %sw.bb7

sw.bb7:                                           ; preds = %entry, %do.end
  %10 = load %struct.e1000_hw** %hw, align 8
  %call8 = call i32 @igb_rd32(%struct.e1000_hw* %10, i32 23280) noredzone
  store i32 %call8, i32* %reg, align 4
  %11 = load i32* %reg, align 4
  %or9 = or i32 %11, 1073741824
  store i32 %or9, i32* %reg, align 4
  br label %do.body10

do.body10:                                        ; preds = %sw.bb7
  %12 = load %struct.e1000_hw** %hw, align 8
  %hw_addr12 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 1
  %13 = load volatile i8** %hw_addr12, align 8
  store i8* %13, i8** %hw_addr11, align 8
  %14 = load i8** %hw_addr11, align 8
  %tobool13 = icmp ne i8* %14, null
  %lnot14 = xor i1 %tobool13, true
  %lnot16 = xor i1 %lnot14, true
  %lnot18 = xor i1 %lnot16, true
  %lnot.ext19 = zext i1 %lnot18 to i32
  %conv20 = sext i32 %lnot.ext19 to i64
  %expval21 = call i64 @llvm.expect.i64(i64 %conv20, i64 0)
  %tobool22 = icmp ne i64 %expval21, 0
  br i1 %tobool22, label %if.end25, label %if.then23

if.then23:                                        ; preds = %do.body10
  %15 = load i32* %reg, align 4
  %16 = load i8** %hw_addr11, align 8
  %arrayidx24 = getelementptr i8* %16, i64 23280
  call void @writel(i32 %15, i8* %arrayidx24) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %do.body10
  br label %do.end26

do.end26:                                         ; preds = %if.end25
  br label %sw.bb27

sw.bb27:                                          ; preds = %entry, %do.end26
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.bb27
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 49
  %18 = load i32* %vfs_allocated_count, align 4
  %tobool28 = icmp ne i32 %18, 0
  br i1 %tobool28, label %if.then29, label %if.else

if.then29:                                        ; preds = %sw.epilog
  %19 = load %struct.e1000_hw** %hw, align 8
  call void @igb_vmdq_set_loopback_pf(%struct.e1000_hw* %19, i1 zeroext true) noredzone
  %20 = load %struct.e1000_hw** %hw, align 8
  call void @igb_vmdq_set_replication_pf(%struct.e1000_hw* %20, i1 zeroext true) noredzone
  %21 = load %struct.e1000_hw** %hw, align 8
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count30 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 49
  %23 = load i32* %vfs_allocated_count30, align 4
  call void @igb_vmdq_set_anti_spoofing_pf(%struct.e1000_hw* %21, i1 zeroext true, i32 %23) noredzone
  br label %if.end31

if.else:                                          ; preds = %sw.epilog
  %24 = load %struct.e1000_hw** %hw, align 8
  call void @igb_vmdq_set_loopback_pf(%struct.e1000_hw* %24, i1 zeroext false) noredzone
  %25 = load %struct.e1000_hw** %hw, align 8
  call void @igb_vmdq_set_replication_pf(%struct.e1000_hw* %25, i1 zeroext false) noredzone
  br label %if.end31

if.end31:                                         ; preds = %sw.default, %if.else, %if.then29
  ret void
}

declare void @igb_vmdq_set_loopback_pf(%struct.e1000_hw*, i1 zeroext) noredzone

declare void @igb_vmdq_set_replication_pf(%struct.e1000_hw*, i1 zeroext) noredzone

declare void @igb_vmdq_set_anti_spoofing_pf(%struct.e1000_hw*, i1 zeroext, i32) noredzone

define internal void @igb_vlan_mode(%struct.net_device* %netdev, i64 %features) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  %features.addr = alloca i64, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ctrl = alloca i32, align 4
  %rctl = alloca i32, align 4
  %enable = alloca i8, align 1
  %hw_addr = alloca i8*, align 8
  %hw_addr15 = alloca i8*, align 8
  %hw_addr34 = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i64 %features, i64* %features.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load i64* %features.addr, align 8
  %and = and i64 %3, 256
  %tobool = icmp ne i64 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %frombool = zext i1 %lnot2 to i8
  store i8 %frombool, i8* %enable, align 1
  %4 = load i8* %enable, align 1
  %tobool3 = trunc i8 %4 to i1
  br i1 %tobool3, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load %struct.e1000_hw** %hw, align 8
  %call4 = call i32 @igb_rd32(%struct.e1000_hw* %5, i32 0) noredzone
  store i32 %call4, i32* %ctrl, align 4
  %6 = load i32* %ctrl, align 4
  %or = or i32 %6, 1073741824
  store i32 %or, i32* %ctrl, align 4
  br label %do.body

do.body:                                          ; preds = %if.then
  %7 = load %struct.e1000_hw** %hw, align 8
  %hw_addr5 = getelementptr inbounds %struct.e1000_hw* %7, i32 0, i32 1
  %8 = load volatile i8** %hw_addr5, align 8
  store i8* %8, i8** %hw_addr, align 8
  %9 = load i8** %hw_addr, align 8
  %tobool6 = icmp ne i8* %9, null
  %lnot7 = xor i1 %tobool6, true
  %lnot8 = xor i1 %lnot7, true
  %lnot9 = xor i1 %lnot8, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.end, label %if.then11

if.then11:                                        ; preds = %do.body
  %10 = load i32* %ctrl, align 4
  %11 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %11, i64 0
  call void @writel(i32 %10, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then11, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  %12 = load %struct.e1000_hw** %hw, align 8
  %call12 = call i32 @igb_rd32(%struct.e1000_hw* %12, i32 256) noredzone
  store i32 %call12, i32* %rctl, align 4
  %13 = load i32* %rctl, align 4
  %and13 = and i32 %13, -524289
  store i32 %and13, i32* %rctl, align 4
  br label %do.body14

do.body14:                                        ; preds = %do.end
  %14 = load %struct.e1000_hw** %hw, align 8
  %hw_addr16 = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 1
  %15 = load volatile i8** %hw_addr16, align 8
  store i8* %15, i8** %hw_addr15, align 8
  %16 = load i8** %hw_addr15, align 8
  %tobool17 = icmp ne i8* %16, null
  %lnot18 = xor i1 %tobool17, true
  %lnot20 = xor i1 %lnot18, true
  %lnot22 = xor i1 %lnot20, true
  %lnot.ext23 = zext i1 %lnot22 to i32
  %conv24 = sext i32 %lnot.ext23 to i64
  %expval25 = call i64 @llvm.expect.i64(i64 %conv24, i64 0)
  %tobool26 = icmp ne i64 %expval25, 0
  br i1 %tobool26, label %if.end29, label %if.then27

if.then27:                                        ; preds = %do.body14
  %17 = load i32* %rctl, align 4
  %18 = load i8** %hw_addr15, align 8
  %arrayidx28 = getelementptr i8* %18, i64 256
  call void @writel(i32 %17, i8* %arrayidx28) noredzone
  br label %if.end29

if.end29:                                         ; preds = %if.then27, %do.body14
  br label %do.end30

do.end30:                                         ; preds = %if.end29
  br label %if.end50

if.else:                                          ; preds = %entry
  %19 = load %struct.e1000_hw** %hw, align 8
  %call31 = call i32 @igb_rd32(%struct.e1000_hw* %19, i32 0) noredzone
  store i32 %call31, i32* %ctrl, align 4
  %20 = load i32* %ctrl, align 4
  %and32 = and i32 %20, -1073741825
  store i32 %and32, i32* %ctrl, align 4
  br label %do.body33

do.body33:                                        ; preds = %if.else
  %21 = load %struct.e1000_hw** %hw, align 8
  %hw_addr35 = getelementptr inbounds %struct.e1000_hw* %21, i32 0, i32 1
  %22 = load volatile i8** %hw_addr35, align 8
  store i8* %22, i8** %hw_addr34, align 8
  %23 = load i8** %hw_addr34, align 8
  %tobool36 = icmp ne i8* %23, null
  %lnot37 = xor i1 %tobool36, true
  %lnot39 = xor i1 %lnot37, true
  %lnot41 = xor i1 %lnot39, true
  %lnot.ext42 = zext i1 %lnot41 to i32
  %conv43 = sext i32 %lnot.ext42 to i64
  %expval44 = call i64 @llvm.expect.i64(i64 %conv43, i64 0)
  %tobool45 = icmp ne i64 %expval44, 0
  br i1 %tobool45, label %if.end48, label %if.then46

if.then46:                                        ; preds = %do.body33
  %24 = load i32* %ctrl, align 4
  %25 = load i8** %hw_addr34, align 8
  %arrayidx47 = getelementptr i8* %25, i64 0
  call void @writel(i32 %24, i8* %arrayidx47) noredzone
  br label %if.end48

if.end48:                                         ; preds = %if.then46, %do.body33
  br label %do.end49

do.end49:                                         ; preds = %if.end48
  br label %if.end50

if.end50:                                         ; preds = %do.end49, %do.end30
  %26 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_rlpml_set(%struct.igb_adapter* %26) noredzone
  ret void
}

declare i64 @find_first_bit(i64*, i64) noredzone

define internal i32 @igb_vlan_rx_add_vid(%struct.net_device* %netdev, i16 zeroext %proto, i16 zeroext %vid) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %netdev.addr = alloca %struct.net_device*, align 8
  %proto.addr = alloca i16, align 2
  %vid.addr = alloca i16, align 2
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %pf_id = alloca i32, align 4
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i16 %proto, i16* %proto.addr, align 2
  store i16 %vid, i16* %vid.addr, align 2
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  store i32 %4, i32* %pf_id, align 4
  %5 = load %struct.igb_adapter** %adapter, align 8
  %6 = load i16* %vid.addr, align 2
  %conv = zext i16 %6 to i32
  %7 = load i32* %pf_id, align 4
  %call2 = call i32 @igb_vlvf_set(%struct.igb_adapter* %5, i32 %conv, i1 zeroext true, i32 %7) noredzone
  %8 = load %struct.e1000_hw** %hw, align 8
  %9 = load i16* %vid.addr, align 2
  %conv3 = zext i16 %9 to i32
  %call4 = call i32 @igb_vfta_set(%struct.e1000_hw* %8, i32 %conv3, i1 zeroext true) noredzone
  %10 = load i16* %vid.addr, align 2
  %conv5 = zext i16 %10 to i64
  %11 = load %struct.igb_adapter** %adapter, align 8
  %active_vlans = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64]* %active_vlans, i32 0, i32 0
  store i64 %conv5, i64* %nr.addr.i, align 8
  store i64* %arraydecay, i64** %addr.addr.i, align 8
  %12 = load i64** %addr.addr.i, align 8
  %13 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %12, i64 %13, i64* %12) nounwind, !srcloc !6
  ret i32 0
}

declare i64 @find_next_bit(i64*, i64, i64) noredzone

define internal void @igb_rlpml_set(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %max_frame_size = alloca i32, align 4
  %hw = alloca %struct.e1000_hw*, align 8
  %pf_id = alloca i16, align 2
  %hw_addr = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 16
  %1 = load i32* %max_frame_size1, align 4
  store i32 %1, i32* %max_frame_size, align 4
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %conv = trunc i32 %4 to i16
  store i16 %conv, i16* %pf_id, align 2
  %5 = load i16* %pf_id, align 2
  %tobool = icmp ne i16 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %7 = load i32* %max_frame_size, align 4
  %8 = load i16* %pf_id, align 2
  %conv3 = zext i16 %8 to i32
  %call = call i32 @igb_set_vf_rlpml(%struct.igb_adapter* %6, i32 %7, i32 %conv3) noredzone
  store i32 16128, i32* %max_frame_size, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  br label %do.body

do.body:                                          ; preds = %if.end
  %9 = load %struct.e1000_hw** %hw, align 8
  %hw_addr4 = getelementptr inbounds %struct.e1000_hw* %9, i32 0, i32 1
  %10 = load volatile i8** %hw_addr4, align 8
  store i8* %10, i8** %hw_addr, align 8
  %11 = load i8** %hw_addr, align 8
  %tobool5 = icmp ne i8* %11, null
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv8 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv8, i64 0)
  %tobool9 = icmp ne i64 %expval, 0
  br i1 %tobool9, label %if.end11, label %if.then10

if.then10:                                        ; preds = %do.body
  %12 = load i32* %max_frame_size, align 4
  %13 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %13, i64 20484
  call void @writel(i32 %12, i8* %arrayidx) noredzone
  br label %if.end11

if.end11:                                         ; preds = %if.then10, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end11
  ret void
}

declare void @dca_unregister_notify(%struct.notifier_block*) noredzone

declare void @pci_unregister_driver(%struct.pci_driver*) noredzone

define internal i32 @igb_probe(%struct.pci_dev* %pdev, %struct.pci_device_id* %ent) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %ent.addr = alloca %struct.pci_device_id*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %eeprom_data = alloca i16, align 2
  %ret_val = alloca i32, align 4
  %ei = alloca %struct.e1000_info*, align 8
  %err = alloca i32, align 4
  %pci_using_dac = alloca i32, align 4
  %part_str = alloca [11 x i8], align 1
  %__ret_warn_on = alloca i32, align 4
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  %__len68 = alloca i64, align 8
  %__ret69 = alloca i8*, align 8
  %__len80 = alloca i64, align 8
  %__ret81 = alloca i8*, align 8
  %__len179 = alloca i64, align 8
  %__ret181 = alloca i8*, align 8
  %hw_addr194 = alloca i8*, align 8
  %hw_addr210 = alloca i8*, align 8
  %.compoundliteral = alloca %struct.atomic64_t, align 8
  %.compoundliteral250 = alloca %struct.atomic64_t, align 8
  %ets_word = alloca i16, align 2
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  store %struct.pci_device_id* %ent, %struct.pci_device_id** %ent.addr, align 8
  store i16 0, i16* %eeprom_data, align 2
  %0 = load %struct.pci_device_id** %ent.addr, align 8
  %driver_data = getelementptr inbounds %struct.pci_device_id* %0, i32 0, i32 6
  %1 = load i64* %driver_data, align 8
  %arrayidx = getelementptr [1 x %struct.e1000_info*]* @igb_info_tbl, i32 0, i64 %1
  %2 = load %struct.e1000_info** %arrayidx, align 8
  store %struct.e1000_info* %2, %struct.e1000_info** %ei, align 8
  %3 = load %struct.pci_dev** %pdev.addr, align 8
  %4 = bitcast %struct.pci_dev* %3 to i8*
  %bf.field.offs = getelementptr i8* %4, i32 1800
  %5 = bitcast i8* %bf.field.offs to i32*
  %6 = load i32* %5, align 8
  %7 = lshr i32 %6, 24
  %bf.clear = and i32 %7, 1
  %tobool = icmp ne i32 %bf.clear, 0
  br i1 %tobool, label %if.then, label %if.end14

if.then:                                          ; preds = %entry
  store i32 1, i32* %__ret_warn_on, align 4
  %8 = load i32* %__ret_warn_on, align 4
  %tobool1 = icmp ne i32 %8, 0
  %lnot = xor i1 %tobool1, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool3 = icmp ne i64 %expval, 0
  br i1 %tobool3, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %9 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_name(%struct.pci_dev* %9) noredzone
  %10 = load %struct.pci_dev** %pdev.addr, align 8
  %vendor = getelementptr inbounds %struct.pci_dev* %10, i32 0, i32 7
  %11 = load i16* %vendor, align 2
  %conv5 = zext i16 %11 to i32
  %12 = load %struct.pci_dev** %pdev.addr, align 8
  %device = getelementptr inbounds %struct.pci_dev* %12, i32 0, i32 8
  %13 = load i16* %device, align 2
  %conv6 = zext i16 %13 to i32
  call void (i8*, i32, i8*, ...)* @warn_slowpath_fmt(i8* getelementptr inbounds ([56 x i8]* @.str1, i32 0, i32 0), i32 2253, i8* getelementptr inbounds ([36 x i8]* @.str48, i32 0, i32 0), i8* %call, i32 %conv5, i32 %conv6) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then4, %if.then
  %14 = load i32* %__ret_warn_on, align 4
  %tobool7 = icmp ne i32 %14, 0
  %lnot8 = xor i1 %tobool7, true
  %lnot10 = xor i1 %lnot8, true
  %lnot.ext11 = zext i1 %lnot10 to i32
  %conv12 = sext i32 %lnot.ext11 to i64
  %expval13 = call i64 @llvm.expect.i64(i64 %conv12, i64 0)
  store i32 -22, i32* %retval
  br label %return

if.end14:                                         ; preds = %entry
  %15 = load %struct.pci_dev** %pdev.addr, align 8
  %call15 = call i32 @pci_enable_device_mem(%struct.pci_dev* %15) noredzone
  store i32 %call15, i32* %err, align 4
  %16 = load i32* %err, align 4
  %tobool16 = icmp ne i32 %16, 0
  br i1 %tobool16, label %if.then17, label %if.end18

if.then17:                                        ; preds = %if.end14
  %17 = load i32* %err, align 4
  store i32 %17, i32* %retval
  br label %return

if.end18:                                         ; preds = %if.end14
  store i32 0, i32* %pci_using_dac, align 4
  %18 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %18, i32 0, i32 33
  %call19 = call i32 @dma_set_mask_and_coherent(%struct.device* %dev, i64 -1) noredzone
  store i32 %call19, i32* %err, align 4
  %19 = load i32* %err, align 4
  %tobool20 = icmp ne i32 %19, 0
  br i1 %tobool20, label %if.else, label %if.then21

if.then21:                                        ; preds = %if.end18
  store i32 1, i32* %pci_using_dac, align 4
  br label %if.end29

if.else:                                          ; preds = %if.end18
  %20 = load %struct.pci_dev** %pdev.addr, align 8
  %dev22 = getelementptr inbounds %struct.pci_dev* %20, i32 0, i32 33
  %call23 = call i32 @dma_set_mask_and_coherent(%struct.device* %dev22, i64 4294967295) noredzone
  store i32 %call23, i32* %err, align 4
  %21 = load i32* %err, align 4
  %tobool24 = icmp ne i32 %21, 0
  br i1 %tobool24, label %if.then25, label %if.end28

if.then25:                                        ; preds = %if.else
  %22 = load %struct.pci_dev** %pdev.addr, align 8
  %dev26 = getelementptr inbounds %struct.pci_dev* %22, i32 0, i32 33
  %call27 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev26, i8* getelementptr inbounds ([39 x i8]* @.str49, i32 0, i32 0)) noredzone
  br label %err_dma

if.end28:                                         ; preds = %if.else
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then21
  %23 = load %struct.pci_dev** %pdev.addr, align 8
  %24 = load %struct.pci_dev** %pdev.addr, align 8
  %call30 = call i32 @pci_select_bars(%struct.pci_dev* %24, i64 512) noredzone
  %call31 = call i32 @pci_request_selected_regions(%struct.pci_dev* %23, i32 %call30, i8* getelementptr inbounds ([4 x i8]* @igb_driver_name, i32 0, i32 0)) noredzone
  store i32 %call31, i32* %err, align 4
  %25 = load i32* %err, align 4
  %tobool32 = icmp ne i32 %25, 0
  br i1 %tobool32, label %if.then33, label %if.end34

if.then33:                                        ; preds = %if.end29
  br label %err_pci_reg

if.end34:                                         ; preds = %if.end29
  %26 = load %struct.pci_dev** %pdev.addr, align 8
  %call35 = call i32 @pci_enable_pcie_error_reporting(%struct.pci_dev* %26) noredzone
  %27 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_set_master(%struct.pci_dev* %27) noredzone
  %28 = load %struct.pci_dev** %pdev.addr, align 8
  %call36 = call i32 @pci_save_state(%struct.pci_dev* %28) noredzone
  store i32 -12, i32* %err, align 4
  %call37 = call %struct.net_device* @alloc_etherdev_mqs(i32 5504, i32 8, i32 8) noredzone
  store %struct.net_device* %call37, %struct.net_device** %netdev, align 8
  %29 = load %struct.net_device** %netdev, align 8
  %tobool38 = icmp ne %struct.net_device* %29, null
  br i1 %tobool38, label %if.end40, label %if.then39

if.then39:                                        ; preds = %if.end34
  br label %err_alloc_etherdev

if.end40:                                         ; preds = %if.end34
  %30 = load %struct.pci_dev** %pdev.addr, align 8
  %dev41 = getelementptr inbounds %struct.pci_dev* %30, i32 0, i32 33
  %31 = load %struct.net_device** %netdev, align 8
  %dev42 = getelementptr inbounds %struct.net_device* %31, i32 0, i32 103
  %parent = getelementptr inbounds %struct.device* %dev42, i32 0, i32 0
  store %struct.device* %dev41, %struct.device** %parent, align 8
  %32 = load %struct.pci_dev** %pdev.addr, align 8
  %33 = load %struct.net_device** %netdev, align 8
  %34 = bitcast %struct.net_device* %33 to i8*
  call void @pci_set_drvdata(%struct.pci_dev* %32, i8* %34) noredzone
  %35 = load %struct.net_device** %netdev, align 8
  %call43 = call i8* @netdev_priv(%struct.net_device* %35) noredzone
  %36 = bitcast i8* %call43 to %struct.igb_adapter*
  store %struct.igb_adapter* %36, %struct.igb_adapter** %adapter, align 8
  %37 = load %struct.net_device** %netdev, align 8
  %38 = load %struct.igb_adapter** %adapter, align 8
  %netdev44 = getelementptr inbounds %struct.igb_adapter* %38, i32 0, i32 1
  store %struct.net_device* %37, %struct.net_device** %netdev44, align 8
  %39 = load %struct.pci_dev** %pdev.addr, align 8
  %40 = load %struct.igb_adapter** %adapter, align 8
  %pdev45 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 32
  store %struct.pci_dev* %39, %struct.pci_dev** %pdev45, align 8
  %41 = load %struct.igb_adapter** %adapter, align 8
  %hw46 = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 35
  store %struct.e1000_hw* %hw46, %struct.e1000_hw** %hw, align 8
  %42 = load %struct.igb_adapter** %adapter, align 8
  %43 = bitcast %struct.igb_adapter* %42 to i8*
  %44 = load %struct.e1000_hw** %hw, align 8
  %back = getelementptr inbounds %struct.e1000_hw* %44, i32 0, i32 0
  store i8* %43, i8** %back, align 8
  %45 = load i32* @debug, align 4
  %call47 = call i32 @netif_msg_init(i32 %45, i32 7) noredzone
  %46 = load %struct.igb_adapter** %adapter, align 8
  %msg_enable = getelementptr inbounds %struct.igb_adapter* %46, i32 0, i32 43
  store i32 %call47, i32* %msg_enable, align 4
  store i32 -5, i32* %err, align 4
  %47 = load %struct.pci_dev** %pdev.addr, align 8
  %call48 = call i8* @pci_iomap(%struct.pci_dev* %47, i32 0, i64 0) noredzone
  %48 = load %struct.e1000_hw** %hw, align 8
  %hw_addr = getelementptr inbounds %struct.e1000_hw* %48, i32 0, i32 1
  store i8* %call48, i8** %hw_addr, align 8
  %49 = load %struct.e1000_hw** %hw, align 8
  %hw_addr49 = getelementptr inbounds %struct.e1000_hw* %49, i32 0, i32 1
  %50 = load i8** %hw_addr49, align 8
  %tobool50 = icmp ne i8* %50, null
  br i1 %tobool50, label %if.end52, label %if.then51

if.then51:                                        ; preds = %if.end40
  br label %err_ioremap

if.end52:                                         ; preds = %if.end40
  %51 = load %struct.net_device** %netdev, align 8
  %netdev_ops = getelementptr inbounds %struct.net_device* %51, i32 0, i32 28
  store %struct.net_device_ops* @igb_netdev_ops, %struct.net_device_ops** %netdev_ops, align 8
  %52 = load %struct.net_device** %netdev, align 8
  call void @igb_set_ethtool_ops(%struct.net_device* %52) noredzone
  %53 = load %struct.net_device** %netdev, align 8
  %watchdog_timeo = getelementptr inbounds %struct.net_device* %53, i32 0, i32 88
  store i32 1250, i32* %watchdog_timeo, align 4
  %54 = load %struct.net_device** %netdev, align 8
  %name = getelementptr inbounds %struct.net_device* %54, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8]* %name, i32 0, i32 0
  %55 = load %struct.pci_dev** %pdev.addr, align 8
  %call53 = call i8* @pci_name(%struct.pci_dev* %55) noredzone
  %call54 = call i8* @strncpy(i8* %arraydecay, i8* %call53, i64 15) noredzone
  %56 = load %struct.pci_dev** %pdev.addr, align 8
  %resource = getelementptr inbounds %struct.pci_dev* %56, i32 0, i32 36
  %arrayidx55 = getelementptr [17 x %struct.resource]* %resource, i32 0, i64 0
  %start = getelementptr inbounds %struct.resource* %arrayidx55, i32 0, i32 0
  %57 = load i64* %start, align 8
  %58 = load %struct.net_device** %netdev, align 8
  %mem_start = getelementptr inbounds %struct.net_device* %58, i32 0, i32 4
  store i64 %57, i64* %mem_start, align 8
  %59 = load %struct.pci_dev** %pdev.addr, align 8
  %resource56 = getelementptr inbounds %struct.pci_dev* %59, i32 0, i32 36
  %arrayidx57 = getelementptr [17 x %struct.resource]* %resource56, i32 0, i64 0
  %end = getelementptr inbounds %struct.resource* %arrayidx57, i32 0, i32 1
  %60 = load i64* %end, align 8
  %61 = load %struct.net_device** %netdev, align 8
  %mem_end = getelementptr inbounds %struct.net_device* %61, i32 0, i32 3
  store i64 %60, i64* %mem_end, align 8
  %62 = load %struct.pci_dev** %pdev.addr, align 8
  %vendor58 = getelementptr inbounds %struct.pci_dev* %62, i32 0, i32 7
  %63 = load i16* %vendor58, align 2
  %64 = load %struct.e1000_hw** %hw, align 8
  %vendor_id = getelementptr inbounds %struct.e1000_hw* %64, i32 0, i32 15
  store i16 %63, i16* %vendor_id, align 2
  %65 = load %struct.pci_dev** %pdev.addr, align 8
  %device59 = getelementptr inbounds %struct.pci_dev* %65, i32 0, i32 8
  %66 = load i16* %device59, align 2
  %67 = load %struct.e1000_hw** %hw, align 8
  %device_id = getelementptr inbounds %struct.e1000_hw* %67, i32 0, i32 12
  store i16 %66, i16* %device_id, align 2
  %68 = load %struct.pci_dev** %pdev.addr, align 8
  %revision = getelementptr inbounds %struct.pci_dev* %68, i32 0, i32 12
  %69 = load i8* %revision, align 1
  %70 = load %struct.e1000_hw** %hw, align 8
  %revision_id = getelementptr inbounds %struct.e1000_hw* %70, i32 0, i32 16
  store i8 %69, i8* %revision_id, align 1
  %71 = load %struct.pci_dev** %pdev.addr, align 8
  %subsystem_vendor = getelementptr inbounds %struct.pci_dev* %71, i32 0, i32 9
  %72 = load i16* %subsystem_vendor, align 2
  %73 = load %struct.e1000_hw** %hw, align 8
  %subsystem_vendor_id = getelementptr inbounds %struct.e1000_hw* %73, i32 0, i32 13
  store i16 %72, i16* %subsystem_vendor_id, align 2
  %74 = load %struct.pci_dev** %pdev.addr, align 8
  %subsystem_device = getelementptr inbounds %struct.pci_dev* %74, i32 0, i32 10
  %75 = load i16* %subsystem_device, align 2
  %76 = load %struct.e1000_hw** %hw, align 8
  %subsystem_device_id = getelementptr inbounds %struct.e1000_hw* %76, i32 0, i32 14
  store i16 %75, i16* %subsystem_device_id, align 2
  store i64 96, i64* %__len, align 8
  %77 = load i64* %__len, align 8
  %cmp = icmp uge i64 %77, 64
  br i1 %cmp, label %if.then61, label %if.else63

if.then61:                                        ; preds = %if.end52
  %78 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %78, i32 0, i32 4
  %ops = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 0
  %79 = bitcast %struct.e1000_mac_operations* %ops to i8*
  %80 = load %struct.e1000_info** %ei, align 8
  %mac_ops = getelementptr inbounds %struct.e1000_info* %80, i32 0, i32 1
  %81 = load %struct.e1000_mac_operations** %mac_ops, align 8
  %82 = bitcast %struct.e1000_mac_operations* %81 to i8*
  %83 = load i64* %__len, align 8
  %call62 = call i8* @__memcpy(i8* %79, i8* %82, i64 %83) noredzone
  store i8* %call62, i8** %__ret, align 8
  br label %if.end67

if.else63:                                        ; preds = %if.end52
  %84 = load %struct.e1000_hw** %hw, align 8
  %mac64 = getelementptr inbounds %struct.e1000_hw* %84, i32 0, i32 4
  %ops65 = getelementptr inbounds %struct.e1000_mac_info* %mac64, i32 0, i32 0
  %85 = bitcast %struct.e1000_mac_operations* %ops65 to i8*
  %86 = load %struct.e1000_info** %ei, align 8
  %mac_ops66 = getelementptr inbounds %struct.e1000_info* %86, i32 0, i32 1
  %87 = load %struct.e1000_mac_operations** %mac_ops66, align 8
  %88 = bitcast %struct.e1000_mac_operations* %87 to i8*
  %89 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %85, i8* %88, i64 %89, i32 8, i1 false)
  store i8* %85, i8** %__ret, align 8
  br label %if.end67

if.end67:                                         ; preds = %if.else63, %if.then61
  %90 = load i8** %__ret, align 8
  store i64 120, i64* %__len68, align 8
  %91 = load i64* %__len68, align 8
  %cmp70 = icmp uge i64 %91, 64
  br i1 %cmp70, label %if.then72, label %if.else75

if.then72:                                        ; preds = %if.end67
  %92 = load %struct.e1000_hw** %hw, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %92, i32 0, i32 6
  %ops73 = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 0
  %93 = bitcast %struct.e1000_phy_operations* %ops73 to i8*
  %94 = load %struct.e1000_info** %ei, align 8
  %phy_ops = getelementptr inbounds %struct.e1000_info* %94, i32 0, i32 2
  %95 = load %struct.e1000_phy_operations** %phy_ops, align 8
  %96 = bitcast %struct.e1000_phy_operations* %95 to i8*
  %97 = load i64* %__len68, align 8
  %call74 = call i8* @__memcpy(i8* %93, i8* %96, i64 %97) noredzone
  store i8* %call74, i8** %__ret69, align 8
  br label %if.end79

if.else75:                                        ; preds = %if.end67
  %98 = load %struct.e1000_hw** %hw, align 8
  %phy76 = getelementptr inbounds %struct.e1000_hw* %98, i32 0, i32 6
  %ops77 = getelementptr inbounds %struct.e1000_phy_info* %phy76, i32 0, i32 0
  %99 = bitcast %struct.e1000_phy_operations* %ops77 to i8*
  %100 = load %struct.e1000_info** %ei, align 8
  %phy_ops78 = getelementptr inbounds %struct.e1000_info* %100, i32 0, i32 2
  %101 = load %struct.e1000_phy_operations** %phy_ops78, align 8
  %102 = bitcast %struct.e1000_phy_operations* %101 to i8*
  %103 = load i64* %__len68, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %99, i8* %102, i64 %103, i32 8, i1 false)
  store i8* %99, i8** %__ret69, align 8
  br label %if.end79

if.end79:                                         ; preds = %if.else75, %if.then72
  %104 = load i8** %__ret69, align 8
  store i64 56, i64* %__len80, align 8
  %105 = load i64* %__len80, align 8
  %cmp82 = icmp uge i64 %105, 64
  br i1 %cmp82, label %if.then84, label %if.else87

if.then84:                                        ; preds = %if.end79
  %106 = load %struct.e1000_hw** %hw, align 8
  %nvm = getelementptr inbounds %struct.e1000_hw* %106, i32 0, i32 7
  %ops85 = getelementptr inbounds %struct.e1000_nvm_info* %nvm, i32 0, i32 0
  %107 = bitcast %struct.e1000_nvm_operations* %ops85 to i8*
  %108 = load %struct.e1000_info** %ei, align 8
  %nvm_ops = getelementptr inbounds %struct.e1000_info* %108, i32 0, i32 3
  %109 = load %struct.e1000_nvm_operations** %nvm_ops, align 8
  %110 = bitcast %struct.e1000_nvm_operations* %109 to i8*
  %111 = load i64* %__len80, align 8
  %call86 = call i8* @__memcpy(i8* %107, i8* %110, i64 %111) noredzone
  store i8* %call86, i8** %__ret81, align 8
  br label %if.end91

if.else87:                                        ; preds = %if.end79
  %112 = load %struct.e1000_hw** %hw, align 8
  %nvm88 = getelementptr inbounds %struct.e1000_hw* %112, i32 0, i32 7
  %ops89 = getelementptr inbounds %struct.e1000_nvm_info* %nvm88, i32 0, i32 0
  %113 = bitcast %struct.e1000_nvm_operations* %ops89 to i8*
  %114 = load %struct.e1000_info** %ei, align 8
  %nvm_ops90 = getelementptr inbounds %struct.e1000_info* %114, i32 0, i32 3
  %115 = load %struct.e1000_nvm_operations** %nvm_ops90, align 8
  %116 = bitcast %struct.e1000_nvm_operations* %115 to i8*
  %117 = load i64* %__len80, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %113, i8* %116, i64 %117, i32 8, i1 false)
  store i8* %113, i8** %__ret81, align 8
  br label %if.end91

if.end91:                                         ; preds = %if.else87, %if.then84
  %118 = load i8** %__ret81, align 8
  %119 = load %struct.e1000_info** %ei, align 8
  %get_invariants = getelementptr inbounds %struct.e1000_info* %119, i32 0, i32 0
  %120 = load i32 (%struct.e1000_hw*)** %get_invariants, align 8
  %121 = load %struct.e1000_hw** %hw, align 8
  %call92 = call i32 %120(%struct.e1000_hw* %121) noredzone
  store i32 %call92, i32* %err, align 4
  %122 = load i32* %err, align 4
  %tobool93 = icmp ne i32 %122, 0
  br i1 %tobool93, label %if.then94, label %if.end95

if.then94:                                        ; preds = %if.end91
  br label %err_sw_init

if.end95:                                         ; preds = %if.end91
  %123 = load %struct.igb_adapter** %adapter, align 8
  %call96 = call i32 @igb_sw_init(%struct.igb_adapter* %123) noredzone
  store i32 %call96, i32* %err, align 4
  %124 = load i32* %err, align 4
  %tobool97 = icmp ne i32 %124, 0
  br i1 %tobool97, label %if.then98, label %if.end99

if.then98:                                        ; preds = %if.end95
  br label %err_sw_init

if.end99:                                         ; preds = %if.end95
  %125 = load %struct.e1000_hw** %hw, align 8
  %call100 = call i32 @igb_get_bus_info_pcie(%struct.e1000_hw* %125) noredzone
  %126 = load %struct.e1000_hw** %hw, align 8
  %phy101 = getelementptr inbounds %struct.e1000_hw* %126, i32 0, i32 6
  %autoneg_wait_to_complete = getelementptr inbounds %struct.e1000_phy_info* %phy101, i32 0, i32 24
  store i8 0, i8* %autoneg_wait_to_complete, align 1
  %127 = load %struct.e1000_hw** %hw, align 8
  %phy102 = getelementptr inbounds %struct.e1000_hw* %127, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy102, i32 0, i32 12
  %128 = load i32* %media_type, align 4
  %cmp103 = icmp eq i32 %128, 1
  br i1 %cmp103, label %if.then105, label %if.end109

if.then105:                                       ; preds = %if.end99
  %129 = load %struct.e1000_hw** %hw, align 8
  %phy106 = getelementptr inbounds %struct.e1000_hw* %129, i32 0, i32 6
  %mdix = getelementptr inbounds %struct.e1000_phy_info* %phy106, i32 0, i32 18
  store i8 0, i8* %mdix, align 1
  %130 = load %struct.e1000_hw** %hw, align 8
  %phy107 = getelementptr inbounds %struct.e1000_hw* %130, i32 0, i32 6
  %disable_polarity_correction = getelementptr inbounds %struct.e1000_phy_info* %phy107, i32 0, i32 19
  store i8 0, i8* %disable_polarity_correction, align 1
  %131 = load %struct.e1000_hw** %hw, align 8
  %phy108 = getelementptr inbounds %struct.e1000_hw* %131, i32 0, i32 6
  %ms_type = getelementptr inbounds %struct.e1000_phy_info* %phy108, i32 0, i32 4
  store i32 0, i32* %ms_type, align 4
  br label %if.end109

if.end109:                                        ; preds = %if.then105, %if.end99
  %132 = load %struct.e1000_hw** %hw, align 8
  %call110 = call i32 @igb_check_reset_block(%struct.e1000_hw* %132) noredzone
  %tobool111 = icmp ne i32 %call110, 0
  br i1 %tobool111, label %if.then112, label %if.end115

if.then112:                                       ; preds = %if.end109
  %133 = load %struct.pci_dev** %pdev.addr, align 8
  %dev113 = getelementptr inbounds %struct.pci_dev* %133, i32 0, i32 33
  %call114 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev113, i8* getelementptr inbounds ([47 x i8]* @.str50, i32 0, i32 0)) noredzone
  br label %if.end115

if.end115:                                        ; preds = %if.then112, %if.end109
  %134 = load %struct.net_device** %netdev, align 8
  %features = getelementptr inbounds %struct.net_device* %134, i32 0, i32 14
  %135 = load i64* %features, align 8
  %or = or i64 %135, 25770918291
  store i64 %or, i64* %features, align 8
  %136 = load %struct.net_device** %netdev, align 8
  %features116 = getelementptr inbounds %struct.net_device* %136, i32 0, i32 14
  %137 = load i64* %features116, align 8
  %138 = load %struct.net_device** %netdev, align 8
  %hw_features = getelementptr inbounds %struct.net_device* %138, i32 0, i32 15
  %139 = load i64* %hw_features, align 8
  %or117 = or i64 %139, %137
  store i64 %or117, i64* %hw_features, align 8
  %140 = load %struct.net_device** %netdev, align 8
  %hw_features118 = getelementptr inbounds %struct.net_device* %140, i32 0, i32 15
  %141 = load i64* %hw_features118, align 8
  %or119 = or i64 %141, 274877906944
  store i64 %or119, i64* %hw_features118, align 8
  %142 = load %struct.net_device** %netdev, align 8
  %features120 = getelementptr inbounds %struct.net_device* %142, i32 0, i32 14
  %143 = load i64* %features120, align 8
  %or121 = or i64 %143, 512
  store i64 %or121, i64* %features120, align 8
  %144 = load %struct.net_device** %netdev, align 8
  %vlan_features = getelementptr inbounds %struct.net_device* %144, i32 0, i32 17
  %145 = load i64* %vlan_features, align 8
  %or122 = or i64 %145, 1114131
  store i64 %or122, i64* %vlan_features, align 8
  %146 = load %struct.net_device** %netdev, align 8
  %priv_flags = getelementptr inbounds %struct.net_device* %146, i32 0, i32 33
  %147 = load i32* %priv_flags, align 4
  %or123 = or i32 %147, 524288
  store i32 %or123, i32* %priv_flags, align 4
  %148 = load i32* %pci_using_dac, align 4
  %tobool124 = icmp ne i32 %148, 0
  br i1 %tobool124, label %if.then125, label %if.end130

if.then125:                                       ; preds = %if.end115
  %149 = load %struct.net_device** %netdev, align 8
  %features126 = getelementptr inbounds %struct.net_device* %149, i32 0, i32 14
  %150 = load i64* %features126, align 8
  %or127 = or i64 %150, 32
  store i64 %or127, i64* %features126, align 8
  %151 = load %struct.net_device** %netdev, align 8
  %vlan_features128 = getelementptr inbounds %struct.net_device* %151, i32 0, i32 17
  %152 = load i64* %vlan_features128, align 8
  %or129 = or i64 %152, 32
  store i64 %or129, i64* %vlan_features128, align 8
  br label %if.end130

if.end130:                                        ; preds = %if.then125, %if.end115
  %153 = load %struct.e1000_hw** %hw, align 8
  %mac131 = getelementptr inbounds %struct.e1000_hw* %153, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac131, i32 0, i32 3
  %154 = load i32* %type, align 4
  %cmp132 = icmp uge i32 %154, 2
  br i1 %cmp132, label %if.then134, label %if.end139

if.then134:                                       ; preds = %if.end130
  %155 = load %struct.net_device** %netdev, align 8
  %hw_features135 = getelementptr inbounds %struct.net_device* %155, i32 0, i32 15
  %156 = load i64* %hw_features135, align 8
  %or136 = or i64 %156, 1073741824
  store i64 %or136, i64* %hw_features135, align 8
  %157 = load %struct.net_device** %netdev, align 8
  %features137 = getelementptr inbounds %struct.net_device* %157, i32 0, i32 14
  %158 = load i64* %features137, align 8
  %or138 = or i64 %158, 1073741824
  store i64 %or138, i64* %features137, align 8
  br label %if.end139

if.end139:                                        ; preds = %if.then134, %if.end130
  %159 = load %struct.net_device** %netdev, align 8
  %priv_flags140 = getelementptr inbounds %struct.net_device* %159, i32 0, i32 33
  %160 = load i32* %priv_flags140, align 4
  %or141 = or i32 %160, 131072
  store i32 %or141, i32* %priv_flags140, align 4
  %161 = load %struct.e1000_hw** %hw, align 8
  %call142 = call zeroext i1 @igb_enable_mng_pass_thru(%struct.e1000_hw* %161) noredzone
  %conv143 = zext i1 %call142 to i32
  %162 = load %struct.igb_adapter** %adapter, align 8
  %en_mng_pt = getelementptr inbounds %struct.igb_adapter* %162, i32 0, i32 23
  store i32 %conv143, i32* %en_mng_pt, align 4
  %163 = load %struct.e1000_hw** %hw, align 8
  %mac144 = getelementptr inbounds %struct.e1000_hw* %163, i32 0, i32 4
  %ops145 = getelementptr inbounds %struct.e1000_mac_info* %mac144, i32 0, i32 0
  %reset_hw = getelementptr inbounds %struct.e1000_mac_operations* %ops145, i32 0, i32 1
  %164 = load i32 (%struct.e1000_hw*)** %reset_hw, align 8
  %165 = load %struct.e1000_hw** %hw, align 8
  %call146 = call i32 %164(%struct.e1000_hw* %165) noredzone
  %166 = load %struct.e1000_hw** %hw, align 8
  %mac147 = getelementptr inbounds %struct.e1000_hw* %166, i32 0, i32 4
  %type148 = getelementptr inbounds %struct.e1000_mac_info* %mac147, i32 0, i32 3
  %167 = load i32* %type148, align 4
  switch i32 %167, label %sw.default [
    i32 6, label %sw.bb
    i32 7, label %sw.bb
  ]

sw.bb:                                            ; preds = %if.end139, %if.end139
  %168 = load %struct.e1000_hw** %hw, align 8
  %call149 = call zeroext i1 @igb_get_flash_presence_i210(%struct.e1000_hw* %168) noredzone
  br i1 %call149, label %if.then150, label %if.end160

if.then150:                                       ; preds = %sw.bb
  %169 = load %struct.e1000_hw** %hw, align 8
  %nvm151 = getelementptr inbounds %struct.e1000_hw* %169, i32 0, i32 7
  %ops152 = getelementptr inbounds %struct.e1000_nvm_info* %nvm151, i32 0, i32 0
  %validate = getelementptr inbounds %struct.e1000_nvm_operations* %ops152, i32 0, i32 5
  %170 = load i32 (%struct.e1000_hw*)** %validate, align 8
  %171 = load %struct.e1000_hw** %hw, align 8
  %call153 = call i32 %170(%struct.e1000_hw* %171) noredzone
  %cmp154 = icmp slt i32 %call153, 0
  br i1 %cmp154, label %if.then156, label %if.end159

if.then156:                                       ; preds = %if.then150
  %172 = load %struct.pci_dev** %pdev.addr, align 8
  %dev157 = getelementptr inbounds %struct.pci_dev* %172, i32 0, i32 33
  %call158 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev157, i8* getelementptr inbounds ([31 x i8]* @.str51, i32 0, i32 0)) noredzone
  store i32 -5, i32* %err, align 4
  br label %err_eeprom

if.end159:                                        ; preds = %if.then150
  br label %if.end160

if.end160:                                        ; preds = %if.end159, %sw.bb
  br label %sw.epilog

sw.default:                                       ; preds = %if.end139
  %173 = load %struct.e1000_hw** %hw, align 8
  %nvm161 = getelementptr inbounds %struct.e1000_hw* %173, i32 0, i32 7
  %ops162 = getelementptr inbounds %struct.e1000_nvm_info* %nvm161, i32 0, i32 0
  %validate163 = getelementptr inbounds %struct.e1000_nvm_operations* %ops162, i32 0, i32 5
  %174 = load i32 (%struct.e1000_hw*)** %validate163, align 8
  %175 = load %struct.e1000_hw** %hw, align 8
  %call164 = call i32 %174(%struct.e1000_hw* %175) noredzone
  %cmp165 = icmp slt i32 %call164, 0
  br i1 %cmp165, label %if.then167, label %if.end170

if.then167:                                       ; preds = %sw.default
  %176 = load %struct.pci_dev** %pdev.addr, align 8
  %dev168 = getelementptr inbounds %struct.pci_dev* %176, i32 0, i32 33
  %call169 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev168, i8* getelementptr inbounds ([31 x i8]* @.str51, i32 0, i32 0)) noredzone
  store i32 -5, i32* %err, align 4
  br label %err_eeprom

if.end170:                                        ; preds = %sw.default
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end170, %if.end160
  %177 = load %struct.e1000_hw** %hw, align 8
  %mac171 = getelementptr inbounds %struct.e1000_hw* %177, i32 0, i32 4
  %ops172 = getelementptr inbounds %struct.e1000_mac_info* %mac171, i32 0, i32 0
  %read_mac_addr = getelementptr inbounds %struct.e1000_mac_operations* %ops172, i32 0, i32 6
  %178 = load i32 (%struct.e1000_hw*)** %read_mac_addr, align 8
  %179 = load %struct.e1000_hw** %hw, align 8
  %call173 = call i32 %178(%struct.e1000_hw* %179) noredzone
  %tobool174 = icmp ne i32 %call173, 0
  br i1 %tobool174, label %if.then175, label %if.end178

if.then175:                                       ; preds = %sw.epilog
  %180 = load %struct.pci_dev** %pdev.addr, align 8
  %dev176 = getelementptr inbounds %struct.pci_dev* %180, i32 0, i32 33
  %call177 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev176, i8* getelementptr inbounds ([16 x i8]* @.str52, i32 0, i32 0)) noredzone
  br label %if.end178

if.end178:                                        ; preds = %if.then175, %sw.epilog
  %181 = load %struct.net_device** %netdev, align 8
  %addr_len = getelementptr inbounds %struct.net_device* %181, i32 0, i32 47
  %182 = load i8* %addr_len, align 1
  %conv180 = zext i8 %182 to i64
  store i64 %conv180, i64* %__len179, align 8
  %183 = load %struct.net_device** %netdev, align 8
  %dev_addr = getelementptr inbounds %struct.net_device* %183, i32 0, i32 70
  %184 = load i8** %dev_addr, align 8
  %185 = load %struct.e1000_hw** %hw, align 8
  %mac182 = getelementptr inbounds %struct.e1000_hw* %185, i32 0, i32 4
  %addr = getelementptr inbounds %struct.e1000_mac_info* %mac182, i32 0, i32 1
  %186 = bitcast [6 x i8]* %addr to i8*
  %187 = load i64* %__len179, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %184, i8* %186, i64 %187, i32 1, i1 false)
  store i8* %184, i8** %__ret181, align 8
  %188 = load i8** %__ret181, align 8
  %189 = load %struct.net_device** %netdev, align 8
  %dev_addr183 = getelementptr inbounds %struct.net_device* %189, i32 0, i32 70
  %190 = load i8** %dev_addr183, align 8
  %call184 = call zeroext i1 @is_valid_ether_addr(i8* %190) noredzone
  br i1 %call184, label %if.end188, label %if.then185

if.then185:                                       ; preds = %if.end178
  %191 = load %struct.pci_dev** %pdev.addr, align 8
  %dev186 = getelementptr inbounds %struct.pci_dev* %191, i32 0, i32 33
  %call187 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev186, i8* getelementptr inbounds ([21 x i8]* @.str53, i32 0, i32 0)) noredzone
  store i32 -5, i32* %err, align 4
  br label %err_eeprom

if.end188:                                        ; preds = %if.end178
  %192 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_set_fw_version(%struct.igb_adapter* %192) noredzone
  %193 = load %struct.e1000_hw** %hw, align 8
  %mac189 = getelementptr inbounds %struct.e1000_hw* %193, i32 0, i32 4
  %type190 = getelementptr inbounds %struct.e1000_mac_info* %mac189, i32 0, i32 3
  %194 = load i32* %type190, align 4
  %cmp191 = icmp eq i32 %194, 6
  br i1 %cmp191, label %if.then193, label %if.end226

if.then193:                                       ; preds = %if.end188
  br label %do.body

do.body:                                          ; preds = %if.then193
  %195 = load %struct.e1000_hw** %hw, align 8
  %hw_addr195 = getelementptr inbounds %struct.e1000_hw* %195, i32 0, i32 1
  %196 = load volatile i8** %hw_addr195, align 8
  store i8* %196, i8** %hw_addr194, align 8
  %197 = load i8** %hw_addr194, align 8
  %tobool196 = icmp ne i8* %197, null
  %lnot197 = xor i1 %tobool196, true
  %lnot199 = xor i1 %lnot197, true
  %lnot201 = xor i1 %lnot199, true
  %lnot.ext202 = zext i1 %lnot201 to i32
  %conv203 = sext i32 %lnot.ext202 to i64
  %expval204 = call i64 @llvm.expect.i64(i64 %conv203, i64 0)
  %tobool205 = icmp ne i64 %expval204, 0
  br i1 %tobool205, label %if.end208, label %if.then206

if.then206:                                       ; preds = %do.body
  %198 = load i8** %hw_addr194, align 8
  %arrayidx207 = getelementptr i8* %198, i64 9220
  call void @writel(i32 162, i8* %arrayidx207) noredzone
  br label %if.end208

if.end208:                                        ; preds = %if.then206, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end208
  br label %do.body209

do.body209:                                       ; preds = %do.end
  %199 = load %struct.e1000_hw** %hw, align 8
  %hw_addr211 = getelementptr inbounds %struct.e1000_hw* %199, i32 0, i32 1
  %200 = load volatile i8** %hw_addr211, align 8
  store i8* %200, i8** %hw_addr210, align 8
  %201 = load i8** %hw_addr210, align 8
  %tobool212 = icmp ne i8* %201, null
  %lnot213 = xor i1 %tobool212, true
  %lnot215 = xor i1 %lnot213, true
  %lnot217 = xor i1 %lnot215, true
  %lnot.ext218 = zext i1 %lnot217 to i32
  %conv219 = sext i32 %lnot.ext218 to i64
  %expval220 = call i64 @llvm.expect.i64(i64 %conv219, i64 0)
  %tobool221 = icmp ne i64 %expval220, 0
  br i1 %tobool221, label %if.end224, label %if.then222

if.then222:                                       ; preds = %do.body209
  %202 = load i8** %hw_addr210, align 8
  %arrayidx223 = getelementptr i8* %202, i64 13316
  call void @writel(i32 67108884, i8* %arrayidx223) noredzone
  br label %if.end224

if.end224:                                        ; preds = %if.then222, %do.body209
  br label %do.end225

do.end225:                                        ; preds = %if.end224
  br label %if.end226

if.end226:                                        ; preds = %do.end225, %if.end188
  br label %do.body227

do.body227:                                       ; preds = %if.end226
  %203 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %203, i32 0, i32 18
  call void @init_timer_key(%struct.timer_list* %watchdog_timer, i32 0, i8* null, %struct.lock_class_key* null) noredzone
  %204 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer228 = getelementptr inbounds %struct.igb_adapter* %204, i32 0, i32 18
  %function = getelementptr inbounds %struct.timer_list* %watchdog_timer228, i32 0, i32 3
  store void (i64)* @igb_watchdog, void (i64)** %function, align 8
  %205 = load %struct.igb_adapter** %adapter, align 8
  %206 = ptrtoint %struct.igb_adapter* %205 to i64
  %207 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer229 = getelementptr inbounds %struct.igb_adapter* %207, i32 0, i32 18
  %data = getelementptr inbounds %struct.timer_list* %watchdog_timer229, i32 0, i32 4
  store i64 %206, i64* %data, align 8
  br label %do.end230

do.end230:                                        ; preds = %do.body227
  br label %do.body231

do.body231:                                       ; preds = %do.end230
  %208 = load %struct.igb_adapter** %adapter, align 8
  %phy_info_timer = getelementptr inbounds %struct.igb_adapter* %208, i32 0, i32 19
  call void @init_timer_key(%struct.timer_list* %phy_info_timer, i32 0, i8* null, %struct.lock_class_key* null) noredzone
  %209 = load %struct.igb_adapter** %adapter, align 8
  %phy_info_timer232 = getelementptr inbounds %struct.igb_adapter* %209, i32 0, i32 19
  %function233 = getelementptr inbounds %struct.timer_list* %phy_info_timer232, i32 0, i32 3
  store void (i64)* @igb_update_phy_info, void (i64)** %function233, align 8
  %210 = load %struct.igb_adapter** %adapter, align 8
  %211 = ptrtoint %struct.igb_adapter* %210 to i64
  %212 = load %struct.igb_adapter** %adapter, align 8
  %phy_info_timer234 = getelementptr inbounds %struct.igb_adapter* %212, i32 0, i32 19
  %data235 = getelementptr inbounds %struct.timer_list* %phy_info_timer234, i32 0, i32 4
  store i64 %211, i64* %data235, align 8
  br label %do.end236

do.end236:                                        ; preds = %do.body231
  br label %do.body237

do.body237:                                       ; preds = %do.end236
  br label %do.body238

do.body238:                                       ; preds = %do.body237
  %213 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %213, i32 0, i32 26
  call void @__init_work(%struct.work_struct* %reset_task, i32 0) noredzone
  %214 = load %struct.igb_adapter** %adapter, align 8
  %reset_task239 = getelementptr inbounds %struct.igb_adapter* %214, i32 0, i32 26
  %data240 = getelementptr inbounds %struct.work_struct* %reset_task239, i32 0, i32 0
  %counter = getelementptr inbounds %struct.atomic64_t* %.compoundliteral, i32 0, i32 0
  store i64 68719476704, i64* %counter, align 8
  %215 = bitcast %struct.atomic64_t* %data240 to i8*
  %216 = bitcast %struct.atomic64_t* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %215, i8* %216, i64 8, i32 8, i1 false)
  %217 = load %struct.igb_adapter** %adapter, align 8
  %reset_task241 = getelementptr inbounds %struct.igb_adapter* %217, i32 0, i32 26
  %entry242 = getelementptr inbounds %struct.work_struct* %reset_task241, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry242) noredzone
  %218 = load %struct.igb_adapter** %adapter, align 8
  %reset_task243 = getelementptr inbounds %struct.igb_adapter* %218, i32 0, i32 26
  %func = getelementptr inbounds %struct.work_struct* %reset_task243, i32 0, i32 2
  store void (%struct.work_struct*)* @igb_reset_task, void (%struct.work_struct*)** %func, align 8
  br label %do.end244

do.end244:                                        ; preds = %do.body238
  br label %do.end245

do.end245:                                        ; preds = %do.end244
  br label %do.body246

do.body246:                                       ; preds = %do.end245
  br label %do.body247

do.body247:                                       ; preds = %do.body246
  %219 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task = getelementptr inbounds %struct.igb_adapter* %219, i32 0, i32 27
  call void @__init_work(%struct.work_struct* %watchdog_task, i32 0) noredzone
  %220 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task248 = getelementptr inbounds %struct.igb_adapter* %220, i32 0, i32 27
  %data249 = getelementptr inbounds %struct.work_struct* %watchdog_task248, i32 0, i32 0
  %counter251 = getelementptr inbounds %struct.atomic64_t* %.compoundliteral250, i32 0, i32 0
  store i64 68719476704, i64* %counter251, align 8
  %221 = bitcast %struct.atomic64_t* %data249 to i8*
  %222 = bitcast %struct.atomic64_t* %.compoundliteral250 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %221, i8* %222, i64 8, i32 8, i1 false)
  %223 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task252 = getelementptr inbounds %struct.igb_adapter* %223, i32 0, i32 27
  %entry253 = getelementptr inbounds %struct.work_struct* %watchdog_task252, i32 0, i32 1
  call void @INIT_LIST_HEAD(%struct.list_head* %entry253) noredzone
  %224 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task254 = getelementptr inbounds %struct.igb_adapter* %224, i32 0, i32 27
  %func255 = getelementptr inbounds %struct.work_struct* %watchdog_task254, i32 0, i32 2
  store void (%struct.work_struct*)* @igb_watchdog_task, void (%struct.work_struct*)** %func255, align 8
  br label %do.end256

do.end256:                                        ; preds = %do.body247
  br label %do.end257

do.end257:                                        ; preds = %do.end256
  %225 = load %struct.igb_adapter** %adapter, align 8
  %fc_autoneg = getelementptr inbounds %struct.igb_adapter* %225, i32 0, i32 28
  store i8 1, i8* %fc_autoneg, align 1
  %226 = load %struct.e1000_hw** %hw, align 8
  %mac258 = getelementptr inbounds %struct.e1000_hw* %226, i32 0, i32 4
  %autoneg = getelementptr inbounds %struct.e1000_mac_info* %mac258, i32 0, i32 17
  store i8 1, i8* %autoneg, align 1
  %227 = load %struct.e1000_hw** %hw, align 8
  %phy259 = getelementptr inbounds %struct.e1000_hw* %227, i32 0, i32 6
  %autoneg_advertised = getelementptr inbounds %struct.e1000_phy_info* %phy259, i32 0, i32 13
  store i16 47, i16* %autoneg_advertised, align 2
  %228 = load %struct.e1000_hw** %hw, align 8
  %fc = getelementptr inbounds %struct.e1000_hw* %228, i32 0, i32 5
  %requested_mode = getelementptr inbounds %struct.e1000_fc_info* %fc, i32 0, i32 6
  store i32 255, i32* %requested_mode, align 4
  %229 = load %struct.e1000_hw** %hw, align 8
  %fc260 = getelementptr inbounds %struct.e1000_hw* %229, i32 0, i32 5
  %current_mode = getelementptr inbounds %struct.e1000_fc_info* %fc260, i32 0, i32 5
  store i32 255, i32* %current_mode, align 4
  %230 = load %struct.e1000_hw** %hw, align 8
  %call261 = call i32 @igb_validate_mdi_setting(%struct.e1000_hw* %230) noredzone
  %231 = load %struct.e1000_hw** %hw, align 8
  %bus = getelementptr inbounds %struct.e1000_hw* %231, i32 0, i32 8
  %func262 = getelementptr inbounds %struct.e1000_bus_info* %bus, i32 0, i32 4
  %232 = load i16* %func262, align 2
  %conv263 = zext i16 %232 to i32
  %cmp264 = icmp eq i32 %conv263, 0
  br i1 %cmp264, label %if.then266, label %if.end268

if.then266:                                       ; preds = %do.end257
  %233 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %233, i32 0, i32 3
  %234 = load i32* %flags, align 4
  %or267 = or i32 %234, 256
  store i32 %or267, i32* %flags, align 4
  br label %if.end268

if.end268:                                        ; preds = %if.then266, %do.end257
  %235 = load %struct.e1000_hw** %hw, align 8
  %mac269 = getelementptr inbounds %struct.e1000_hw* %235, i32 0, i32 4
  %type270 = getelementptr inbounds %struct.e1000_mac_info* %mac269, i32 0, i32 3
  %236 = load i32* %type270, align 4
  %cmp271 = icmp uge i32 %236, 3
  br i1 %cmp271, label %if.then273, label %if.else286

if.then273:                                       ; preds = %if.end268
  %237 = load %struct.e1000_hw** %hw, align 8
  %nvm274 = getelementptr inbounds %struct.e1000_hw* %237, i32 0, i32 7
  %ops275 = getelementptr inbounds %struct.e1000_nvm_info* %nvm274, i32 0, i32 0
  %read = getelementptr inbounds %struct.e1000_nvm_operations* %ops275, i32 0, i32 1
  %238 = load i32 (%struct.e1000_hw*, i16, i16, i16*)** %read, align 8
  %239 = load %struct.e1000_hw** %hw, align 8
  %240 = load %struct.e1000_hw** %hw, align 8
  %bus276 = getelementptr inbounds %struct.e1000_hw* %240, i32 0, i32 8
  %func277 = getelementptr inbounds %struct.e1000_bus_info* %bus276, i32 0, i32 4
  %241 = load i16* %func277, align 2
  %conv278 = zext i16 %241 to i32
  %tobool279 = icmp ne i32 %conv278, 0
  br i1 %tobool279, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.then273
  %242 = load %struct.e1000_hw** %hw, align 8
  %bus280 = getelementptr inbounds %struct.e1000_hw* %242, i32 0, i32 8
  %func281 = getelementptr inbounds %struct.e1000_bus_info* %bus280, i32 0, i32 4
  %243 = load i16* %func281, align 2
  %conv282 = zext i16 %243 to i32
  %mul = mul i32 64, %conv282
  %add = add i32 64, %mul
  br label %cond.end

cond.false:                                       ; preds = %if.then273
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ 0, %cond.false ]
  %add283 = add i32 36, %cond
  %conv284 = trunc i32 %add283 to i16
  %call285 = call i32 %238(%struct.e1000_hw* %239, i16 zeroext %conv284, i16 zeroext 1, i16* %eeprom_data) noredzone
  br label %if.end298

if.else286:                                       ; preds = %if.end268
  %244 = load %struct.e1000_hw** %hw, align 8
  %bus287 = getelementptr inbounds %struct.e1000_hw* %244, i32 0, i32 8
  %func288 = getelementptr inbounds %struct.e1000_bus_info* %bus287, i32 0, i32 4
  %245 = load i16* %func288, align 2
  %conv289 = zext i16 %245 to i32
  %cmp290 = icmp eq i32 %conv289, 1
  br i1 %cmp290, label %if.then292, label %if.end297

if.then292:                                       ; preds = %if.else286
  %246 = load %struct.e1000_hw** %hw, align 8
  %nvm293 = getelementptr inbounds %struct.e1000_hw* %246, i32 0, i32 7
  %ops294 = getelementptr inbounds %struct.e1000_nvm_info* %nvm293, i32 0, i32 0
  %read295 = getelementptr inbounds %struct.e1000_nvm_operations* %ops294, i32 0, i32 1
  %247 = load i32 (%struct.e1000_hw*, i16, i16, i16*)** %read295, align 8
  %248 = load %struct.e1000_hw** %hw, align 8
  %call296 = call i32 %247(%struct.e1000_hw* %248, i16 zeroext 20, i16 zeroext 1, i16* %eeprom_data) noredzone
  br label %if.end297

if.end297:                                        ; preds = %if.then292, %if.else286
  br label %if.end298

if.end298:                                        ; preds = %if.end297, %cond.end
  %249 = load i16* %eeprom_data, align 2
  %conv299 = zext i16 %249 to i32
  %and = and i32 %conv299, 1024
  %tobool300 = icmp ne i32 %and, 0
  br i1 %tobool300, label %if.then301, label %if.end304

if.then301:                                       ; preds = %if.end298
  %250 = load %struct.igb_adapter** %adapter, align 8
  %flags302 = getelementptr inbounds %struct.igb_adapter* %250, i32 0, i32 3
  %251 = load i32* %flags302, align 4
  %or303 = or i32 %251, 256
  store i32 %or303, i32* %flags302, align 4
  br label %if.end304

if.end304:                                        ; preds = %if.then301, %if.end298
  %252 = load %struct.pci_dev** %pdev.addr, align 8
  %device305 = getelementptr inbounds %struct.pci_dev* %252, i32 0, i32 8
  %253 = load i16* %device305, align 2
  %conv306 = zext i16 %253 to i32
  switch i32 %conv306, label %sw.default332 [
    i32 4310, label %sw.bb307
    i32 4265, label %sw.bb310
    i32 4326, label %sw.bb310
    i32 4327, label %sw.bb310
    i32 4328, label %sw.bb318
    i32 5414, label %sw.bb318
  ]

sw.bb307:                                         ; preds = %if.end304
  %254 = load %struct.igb_adapter** %adapter, align 8
  %flags308 = getelementptr inbounds %struct.igb_adapter* %254, i32 0, i32 3
  %255 = load i32* %flags308, align 4
  %and309 = and i32 %255, -257
  store i32 %and309, i32* %flags308, align 4
  br label %sw.epilog340

sw.bb310:                                         ; preds = %if.end304, %if.end304, %if.end304
  %256 = load %struct.e1000_hw** %hw, align 8
  %call311 = call i32 @igb_rd32(%struct.e1000_hw* %256, i32 8) noredzone
  %and312 = and i32 %call311, 4
  %tobool313 = icmp ne i32 %and312, 0
  br i1 %tobool313, label %if.then314, label %if.end317

if.then314:                                       ; preds = %sw.bb310
  %257 = load %struct.igb_adapter** %adapter, align 8
  %flags315 = getelementptr inbounds %struct.igb_adapter* %257, i32 0, i32 3
  %258 = load i32* %flags315, align 4
  %and316 = and i32 %258, -257
  store i32 %and316, i32* %flags315, align 4
  br label %if.end317

if.end317:                                        ; preds = %if.then314, %sw.bb310
  br label %sw.epilog340

sw.bb318:                                         ; preds = %if.end304, %if.end304
  %259 = load i32* @igb_probe.global_quad_port_a, align 4
  %cmp319 = icmp ne i32 %259, 0
  br i1 %cmp319, label %if.then321, label %if.else324

if.then321:                                       ; preds = %sw.bb318
  %260 = load %struct.igb_adapter** %adapter, align 8
  %flags322 = getelementptr inbounds %struct.igb_adapter* %260, i32 0, i32 3
  %261 = load i32* %flags322, align 4
  %and323 = and i32 %261, -257
  store i32 %and323, i32* %flags322, align 4
  br label %if.end327

if.else324:                                       ; preds = %sw.bb318
  %262 = load %struct.igb_adapter** %adapter, align 8
  %flags325 = getelementptr inbounds %struct.igb_adapter* %262, i32 0, i32 3
  %263 = load i32* %flags325, align 4
  %or326 = or i32 %263, 4
  store i32 %or326, i32* %flags325, align 4
  br label %if.end327

if.end327:                                        ; preds = %if.else324, %if.then321
  %264 = load i32* @igb_probe.global_quad_port_a, align 4
  %inc = add i32 %264, 1
  store i32 %inc, i32* @igb_probe.global_quad_port_a, align 4
  %cmp328 = icmp eq i32 %inc, 4
  br i1 %cmp328, label %if.then330, label %if.end331

if.then330:                                       ; preds = %if.end327
  store i32 0, i32* @igb_probe.global_quad_port_a, align 4
  br label %if.end331

if.end331:                                        ; preds = %if.then330, %if.end327
  br label %sw.epilog340

sw.default332:                                    ; preds = %if.end304
  %265 = load %struct.igb_adapter** %adapter, align 8
  %pdev333 = getelementptr inbounds %struct.igb_adapter* %265, i32 0, i32 32
  %266 = load %struct.pci_dev** %pdev333, align 8
  %dev334 = getelementptr inbounds %struct.pci_dev* %266, i32 0, i32 33
  %call335 = call zeroext i1 @device_can_wakeup(%struct.device* %dev334) noredzone
  br i1 %call335, label %if.end339, label %if.then336

if.then336:                                       ; preds = %sw.default332
  %267 = load %struct.igb_adapter** %adapter, align 8
  %flags337 = getelementptr inbounds %struct.igb_adapter* %267, i32 0, i32 3
  %268 = load i32* %flags337, align 4
  %and338 = and i32 %268, -257
  store i32 %and338, i32* %flags337, align 4
  br label %if.end339

if.end339:                                        ; preds = %if.then336, %sw.default332
  br label %sw.epilog340

sw.epilog340:                                     ; preds = %if.end339, %if.end331, %if.end317, %sw.bb307
  %269 = load %struct.igb_adapter** %adapter, align 8
  %flags341 = getelementptr inbounds %struct.igb_adapter* %269, i32 0, i32 3
  %270 = load i32* %flags341, align 4
  %and342 = and i32 %270, 256
  %tobool343 = icmp ne i32 %and342, 0
  br i1 %tobool343, label %if.then344, label %if.end346

if.then344:                                       ; preds = %sw.epilog340
  %271 = load %struct.igb_adapter** %adapter, align 8
  %wol = getelementptr inbounds %struct.igb_adapter* %271, i32 0, i32 22
  %272 = load i32* %wol, align 4
  %or345 = or i32 %272, 2
  store i32 %or345, i32* %wol, align 4
  br label %if.end346

if.end346:                                        ; preds = %if.then344, %sw.epilog340
  %273 = load %struct.e1000_hw** %hw, align 8
  %mac347 = getelementptr inbounds %struct.e1000_hw* %273, i32 0, i32 4
  %type348 = getelementptr inbounds %struct.e1000_mac_info* %mac347, i32 0, i32 3
  %274 = load i32* %type348, align 4
  %cmp349 = icmp eq i32 %274, 4
  br i1 %cmp349, label %land.lhs.true, label %if.end359

land.lhs.true:                                    ; preds = %if.end346
  %275 = load %struct.pci_dev** %pdev.addr, align 8
  %subsystem_vendor351 = getelementptr inbounds %struct.pci_dev* %275, i32 0, i32 9
  %276 = load i16* %subsystem_vendor351, align 2
  %conv352 = zext i16 %276 to i32
  %cmp353 = icmp eq i32 %conv352, 4156
  br i1 %cmp353, label %if.then355, label %if.end359

if.then355:                                       ; preds = %land.lhs.true
  %277 = load %struct.igb_adapter** %adapter, align 8
  %flags356 = getelementptr inbounds %struct.igb_adapter* %277, i32 0, i32 3
  %278 = load i32* %flags356, align 4
  %or357 = or i32 %278, 256
  store i32 %or357, i32* %flags356, align 4
  %279 = load %struct.igb_adapter** %adapter, align 8
  %wol358 = getelementptr inbounds %struct.igb_adapter* %279, i32 0, i32 22
  store i32 0, i32* %wol358, align 4
  br label %if.end359

if.end359:                                        ; preds = %if.then355, %land.lhs.true, %if.end346
  %280 = load %struct.igb_adapter** %adapter, align 8
  %pdev360 = getelementptr inbounds %struct.igb_adapter* %280, i32 0, i32 32
  %281 = load %struct.pci_dev** %pdev360, align 8
  %dev361 = getelementptr inbounds %struct.pci_dev* %281, i32 0, i32 33
  %282 = load %struct.igb_adapter** %adapter, align 8
  %flags362 = getelementptr inbounds %struct.igb_adapter* %282, i32 0, i32 3
  %283 = load i32* %flags362, align 4
  %and363 = and i32 %283, 256
  %tobool364 = icmp ne i32 %and363, 0
  %call365 = call i32 @device_set_wakeup_enable(%struct.device* %dev361, i1 zeroext %tobool364) noredzone
  %284 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %284) noredzone
  %285 = load %struct.igb_adapter** %adapter, align 8
  %call366 = call i32 @igb_init_i2c(%struct.igb_adapter* %285) noredzone
  store i32 %call366, i32* %err, align 4
  %286 = load i32* %err, align 4
  %tobool367 = icmp ne i32 %286, 0
  br i1 %tobool367, label %if.then368, label %if.end371

if.then368:                                       ; preds = %if.end359
  %287 = load %struct.pci_dev** %pdev.addr, align 8
  %dev369 = getelementptr inbounds %struct.pci_dev* %287, i32 0, i32 33
  %call370 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev369, i8* getelementptr inbounds ([30 x i8]* @.str54, i32 0, i32 0)) noredzone
  br label %err_eeprom

if.end371:                                        ; preds = %if.end359
  %288 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_get_hw_control(%struct.igb_adapter* %288) noredzone
  %289 = load %struct.net_device** %netdev, align 8
  %name372 = getelementptr inbounds %struct.net_device* %289, i32 0, i32 0
  %arraydecay373 = getelementptr inbounds [16 x i8]* %name372, i32 0, i32 0
  %call374 = call i8* @strcpy(i8* %arraydecay373, i8* getelementptr inbounds ([6 x i8]* @.str55, i32 0, i32 0)) noredzone
  %290 = load %struct.net_device** %netdev, align 8
  %call375 = call i32 @register_netdev(%struct.net_device* %290) noredzone
  store i32 %call375, i32* %err, align 4
  %291 = load i32* %err, align 4
  %tobool376 = icmp ne i32 %291, 0
  br i1 %tobool376, label %if.then377, label %if.end378

if.then377:                                       ; preds = %if.end371
  br label %err_register

if.end378:                                        ; preds = %if.end371
  %292 = load %struct.net_device** %netdev, align 8
  call void @netif_carrier_off(%struct.net_device* %292) noredzone
  %293 = load %struct.pci_dev** %pdev.addr, align 8
  %dev379 = getelementptr inbounds %struct.pci_dev* %293, i32 0, i32 33
  %call380 = call i32 @dca_add_requester(%struct.device* %dev379) noredzone
  %cmp381 = icmp eq i32 %call380, 0
  br i1 %cmp381, label %if.then383, label %if.end388

if.then383:                                       ; preds = %if.end378
  %294 = load %struct.igb_adapter** %adapter, align 8
  %flags384 = getelementptr inbounds %struct.igb_adapter* %294, i32 0, i32 3
  %295 = load i32* %flags384, align 4
  %or385 = or i32 %295, 2
  store i32 %or385, i32* %flags384, align 4
  %296 = load %struct.pci_dev** %pdev.addr, align 8
  %dev386 = getelementptr inbounds %struct.pci_dev* %296, i32 0, i32 33
  %call387 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev386, i8* getelementptr inbounds ([13 x i8]* @.str56, i32 0, i32 0)) noredzone
  %297 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_setup_dca(%struct.igb_adapter* %297) noredzone
  br label %if.end388

if.end388:                                        ; preds = %if.then383, %if.end378
  %298 = load %struct.e1000_hw** %hw, align 8
  %mac389 = getelementptr inbounds %struct.e1000_hw* %298, i32 0, i32 4
  %type390 = getelementptr inbounds %struct.e1000_mac_info* %mac389, i32 0, i32 3
  %299 = load i32* %type390, align 4
  %cmp391 = icmp eq i32 %299, 4
  br i1 %cmp391, label %land.lhs.true393, label %if.else421

land.lhs.true393:                                 ; preds = %if.end388
  %300 = load %struct.e1000_hw** %hw, align 8
  %bus394 = getelementptr inbounds %struct.e1000_hw* %300, i32 0, i32 8
  %func395 = getelementptr inbounds %struct.e1000_bus_info* %bus394, i32 0, i32 4
  %301 = load i16* %func395, align 2
  %conv396 = zext i16 %301 to i32
  %cmp397 = icmp eq i32 %conv396, 0
  br i1 %cmp397, label %if.then399, label %if.else421

if.then399:                                       ; preds = %land.lhs.true393
  %302 = load %struct.e1000_hw** %hw, align 8
  %nvm400 = getelementptr inbounds %struct.e1000_hw* %302, i32 0, i32 7
  %ops401 = getelementptr inbounds %struct.e1000_nvm_info* %nvm400, i32 0, i32 0
  %read402 = getelementptr inbounds %struct.e1000_nvm_operations* %ops401, i32 0, i32 1
  %303 = load i32 (%struct.e1000_hw*, i16, i16, i16*)** %read402, align 8
  %304 = load %struct.e1000_hw** %hw, align 8
  %call403 = call i32 %303(%struct.e1000_hw* %304, i16 zeroext 62, i16 zeroext 1, i16* %ets_word) noredzone
  %305 = load i16* %ets_word, align 2
  %conv404 = zext i16 %305 to i32
  %cmp405 = icmp ne i32 %conv404, 0
  br i1 %cmp405, label %land.lhs.true407, label %if.else412

land.lhs.true407:                                 ; preds = %if.then399
  %306 = load i16* %ets_word, align 2
  %conv408 = zext i16 %306 to i32
  %cmp409 = icmp ne i32 %conv408, 65535
  br i1 %cmp409, label %if.then411, label %if.else412

if.then411:                                       ; preds = %land.lhs.true407
  %307 = load %struct.igb_adapter** %adapter, align 8
  %ets = getelementptr inbounds %struct.igb_adapter* %307, i32 0, i32 71
  store i8 1, i8* %ets, align 1
  br label %if.end414

if.else412:                                       ; preds = %land.lhs.true407, %if.then399
  %308 = load %struct.igb_adapter** %adapter, align 8
  %ets413 = getelementptr inbounds %struct.igb_adapter* %308, i32 0, i32 71
  store i8 0, i8* %ets413, align 1
  br label %if.end414

if.end414:                                        ; preds = %if.else412, %if.then411
  %309 = load %struct.igb_adapter** %adapter, align 8
  %call415 = call i32 @igb_sysfs_init(%struct.igb_adapter* %309) noredzone
  %tobool416 = icmp ne i32 %call415, 0
  br i1 %tobool416, label %if.then417, label %if.end420

if.then417:                                       ; preds = %if.end414
  %310 = load %struct.pci_dev** %pdev.addr, align 8
  %dev418 = getelementptr inbounds %struct.pci_dev* %310, i32 0, i32 33
  %call419 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev418, i8* getelementptr inbounds ([36 x i8]* @.str57, i32 0, i32 0)) noredzone
  br label %if.end420

if.end420:                                        ; preds = %if.then417, %if.end414
  br label %if.end423

if.else421:                                       ; preds = %land.lhs.true393, %if.end388
  %311 = load %struct.igb_adapter** %adapter, align 8
  %ets422 = getelementptr inbounds %struct.igb_adapter* %311, i32 0, i32 71
  store i8 0, i8* %ets422, align 1
  br label %if.end423

if.end423:                                        ; preds = %if.else421, %if.end420
  %312 = load %struct.igb_adapter** %adapter, align 8
  %ei424 = getelementptr inbounds %struct.igb_adapter* %312, i32 0, i32 79
  %313 = load %struct.e1000_info** %ei, align 8
  %314 = bitcast %struct.e1000_info* %ei424 to i8*
  %315 = bitcast %struct.e1000_info* %313 to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %314, i8* %315, i64 32, i32 8, i1 false)
  %316 = load %struct.e1000_hw** %hw, align 8
  %dev_spec = getelementptr inbounds %struct.e1000_hw* %316, i32 0, i32 11
  %_82575 = bitcast %union.anon.86* %dev_spec to %struct.e1000_dev_spec_82575*
  %mas_capable = getelementptr inbounds %struct.e1000_dev_spec_82575* %_82575, i32 0, i32 8
  %317 = load i8* %mas_capable, align 1
  %tobool425 = trunc i8 %317 to i1
  br i1 %tobool425, label %if.then426, label %if.end427

if.then426:                                       ; preds = %if.end423
  %318 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_init_mas(%struct.igb_adapter* %318) noredzone
  br label %if.end427

if.end427:                                        ; preds = %if.then426, %if.end423
  %319 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_ptp_init(%struct.igb_adapter* %319) noredzone
  %320 = load %struct.pci_dev** %pdev.addr, align 8
  %dev428 = getelementptr inbounds %struct.pci_dev* %320, i32 0, i32 33
  %call429 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev428, i8* getelementptr inbounds ([46 x i8]* @.str58, i32 0, i32 0)) noredzone
  %321 = load %struct.e1000_hw** %hw, align 8
  %mac430 = getelementptr inbounds %struct.e1000_hw* %321, i32 0, i32 4
  %type431 = getelementptr inbounds %struct.e1000_mac_info* %mac430, i32 0, i32 3
  %322 = load i32* %type431, align 4
  %cmp432 = icmp ne i32 %322, 5
  br i1 %cmp432, label %if.then434, label %if.end472

if.then434:                                       ; preds = %if.end427
  %323 = load %struct.pci_dev** %pdev.addr, align 8
  %dev435 = getelementptr inbounds %struct.pci_dev* %323, i32 0, i32 33
  %324 = load %struct.net_device** %netdev, align 8
  %name436 = getelementptr inbounds %struct.net_device* %324, i32 0, i32 0
  %arraydecay437 = getelementptr inbounds [16 x i8]* %name436, i32 0, i32 0
  %325 = load %struct.e1000_hw** %hw, align 8
  %bus438 = getelementptr inbounds %struct.e1000_hw* %325, i32 0, i32 8
  %speed = getelementptr inbounds %struct.e1000_bus_info* %bus438, i32 0, i32 1
  %326 = load i32* %speed, align 4
  %cmp439 = icmp eq i32 %326, 6
  br i1 %cmp439, label %cond.true441, label %cond.false442

cond.true441:                                     ; preds = %if.then434
  br label %cond.end448

cond.false442:                                    ; preds = %if.then434
  %327 = load %struct.e1000_hw** %hw, align 8
  %bus443 = getelementptr inbounds %struct.e1000_hw* %327, i32 0, i32 8
  %speed444 = getelementptr inbounds %struct.e1000_bus_info* %bus443, i32 0, i32 1
  %328 = load i32* %speed444, align 4
  %cmp445 = icmp eq i32 %328, 7
  %cond447 = select i1 %cmp445, i8* getelementptr inbounds ([8 x i8]* @.str61, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str62, i32 0, i32 0)
  br label %cond.end448

cond.end448:                                      ; preds = %cond.false442, %cond.true441
  %cond449 = phi i8* [ getelementptr inbounds ([8 x i8]* @.str60, i32 0, i32 0), %cond.true441 ], [ %cond447, %cond.false442 ]
  %329 = load %struct.e1000_hw** %hw, align 8
  %bus450 = getelementptr inbounds %struct.e1000_hw* %329, i32 0, i32 8
  %width = getelementptr inbounds %struct.e1000_bus_info* %bus450, i32 0, i32 2
  %330 = load i32* %width, align 4
  %cmp451 = icmp eq i32 %330, 4
  br i1 %cmp451, label %cond.true453, label %cond.false454

cond.true453:                                     ; preds = %cond.end448
  br label %cond.end468

cond.false454:                                    ; preds = %cond.end448
  %331 = load %struct.e1000_hw** %hw, align 8
  %bus455 = getelementptr inbounds %struct.e1000_hw* %331, i32 0, i32 8
  %width456 = getelementptr inbounds %struct.e1000_bus_info* %bus455, i32 0, i32 2
  %332 = load i32* %width456, align 4
  %cmp457 = icmp eq i32 %332, 2
  br i1 %cmp457, label %cond.true459, label %cond.false460

cond.true459:                                     ; preds = %cond.false454
  br label %cond.end466

cond.false460:                                    ; preds = %cond.false454
  %333 = load %struct.e1000_hw** %hw, align 8
  %bus461 = getelementptr inbounds %struct.e1000_hw* %333, i32 0, i32 8
  %width462 = getelementptr inbounds %struct.e1000_bus_info* %bus461, i32 0, i32 2
  %334 = load i32* %width462, align 4
  %cmp463 = icmp eq i32 %334, 1
  %cond465 = select i1 %cmp463, i8* getelementptr inbounds ([9 x i8]* @.str65, i32 0, i32 0), i8* getelementptr inbounds ([8 x i8]* @.str62, i32 0, i32 0)
  br label %cond.end466

cond.end466:                                      ; preds = %cond.false460, %cond.true459
  %cond467 = phi i8* [ getelementptr inbounds ([9 x i8]* @.str64, i32 0, i32 0), %cond.true459 ], [ %cond465, %cond.false460 ]
  br label %cond.end468

cond.end468:                                      ; preds = %cond.end466, %cond.true453
  %cond469 = phi i8* [ getelementptr inbounds ([9 x i8]* @.str63, i32 0, i32 0), %cond.true453 ], [ %cond467, %cond.end466 ]
  %335 = load %struct.net_device** %netdev, align 8
  %dev_addr470 = getelementptr inbounds %struct.net_device* %335, i32 0, i32 70
  %336 = load i8** %dev_addr470, align 8
  %call471 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev435, i8* getelementptr inbounds ([22 x i8]* @.str59, i32 0, i32 0), i8* %arraydecay437, i8* %cond449, i8* %cond469, i8* %336) noredzone
  br label %if.end472

if.end472:                                        ; preds = %cond.end468, %if.end427
  %337 = load %struct.e1000_hw** %hw, align 8
  %mac473 = getelementptr inbounds %struct.e1000_hw* %337, i32 0, i32 4
  %type474 = getelementptr inbounds %struct.e1000_mac_info* %mac473, i32 0, i32 3
  %338 = load i32* %type474, align 4
  %cmp475 = icmp uge i32 %338, 6
  br i1 %cmp475, label %if.then479, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end472
  %339 = load %struct.e1000_hw** %hw, align 8
  %call477 = call zeroext i1 @igb_get_flash_presence_i210(%struct.e1000_hw* %339) noredzone
  br i1 %call477, label %if.then479, label %if.else482

if.then479:                                       ; preds = %lor.lhs.false, %if.end472
  %340 = load %struct.e1000_hw** %hw, align 8
  %arraydecay480 = getelementptr inbounds [11 x i8]* %part_str, i32 0, i32 0
  %call481 = call i32 @igb_read_part_string(%struct.e1000_hw* %340, i8* %arraydecay480, i32 11) noredzone
  store i32 %call481, i32* %ret_val, align 4
  br label %if.end483

if.else482:                                       ; preds = %lor.lhs.false
  store i32 -19, i32* %ret_val, align 4
  br label %if.end483

if.end483:                                        ; preds = %if.else482, %if.then479
  %341 = load i32* %ret_val, align 4
  %tobool484 = icmp ne i32 %341, 0
  br i1 %tobool484, label %if.then485, label %if.end488

if.then485:                                       ; preds = %if.end483
  %arraydecay486 = getelementptr inbounds [11 x i8]* %part_str, i32 0, i32 0
  %call487 = call i8* @strcpy(i8* %arraydecay486, i8* getelementptr inbounds ([8 x i8]* @.str66, i32 0, i32 0)) noredzone
  br label %if.end488

if.end488:                                        ; preds = %if.then485, %if.end483
  %342 = load %struct.pci_dev** %pdev.addr, align 8
  %dev489 = getelementptr inbounds %struct.pci_dev* %342, i32 0, i32 33
  %343 = load %struct.net_device** %netdev, align 8
  %name490 = getelementptr inbounds %struct.net_device* %343, i32 0, i32 0
  %arraydecay491 = getelementptr inbounds [16 x i8]* %name490, i32 0, i32 0
  %arraydecay492 = getelementptr inbounds [11 x i8]* %part_str, i32 0, i32 0
  %call493 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev489, i8* getelementptr inbounds ([16 x i8]* @.str67, i32 0, i32 0), i8* %arraydecay491, i8* %arraydecay492) noredzone
  %344 = load %struct.pci_dev** %pdev.addr, align 8
  %dev494 = getelementptr inbounds %struct.pci_dev* %344, i32 0, i32 33
  %345 = load %struct.igb_adapter** %adapter, align 8
  %flags495 = getelementptr inbounds %struct.igb_adapter* %345, i32 0, i32 3
  %346 = load i32* %flags495, align 4
  %and496 = and i32 %346, 8192
  %tobool497 = icmp ne i32 %and496, 0
  br i1 %tobool497, label %cond.true498, label %cond.false499

cond.true498:                                     ; preds = %if.end488
  br label %cond.end504

cond.false499:                                    ; preds = %if.end488
  %347 = load %struct.igb_adapter** %adapter, align 8
  %flags500 = getelementptr inbounds %struct.igb_adapter* %347, i32 0, i32 3
  %348 = load i32* %flags500, align 4
  %and501 = and i32 %348, 1
  %tobool502 = icmp ne i32 %and501, 0
  %cond503 = select i1 %tobool502, i8* getelementptr inbounds ([4 x i8]* @.str70, i32 0, i32 0), i8* getelementptr inbounds ([7 x i8]* @.str71, i32 0, i32 0)
  br label %cond.end504

cond.end504:                                      ; preds = %cond.false499, %cond.true498
  %cond505 = phi i8* [ getelementptr inbounds ([6 x i8]* @.str69, i32 0, i32 0), %cond.true498 ], [ %cond503, %cond.false499 ]
  %349 = load %struct.igb_adapter** %adapter, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %349, i32 0, i32 14
  %350 = load i32* %num_rx_queues, align 4
  %351 = load %struct.igb_adapter** %adapter, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %351, i32 0, i32 12
  %352 = load i32* %num_tx_queues, align 4
  %call506 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev494, i8* getelementptr inbounds ([53 x i8]* @.str68, i32 0, i32 0), i8* %cond505, i32 %350, i32 %352) noredzone
  %353 = load %struct.e1000_hw** %hw, align 8
  %phy507 = getelementptr inbounds %struct.e1000_hw* %353, i32 0, i32 6
  %media_type508 = getelementptr inbounds %struct.e1000_phy_info* %phy507, i32 0, i32 12
  %354 = load i32* %media_type508, align 4
  %cmp509 = icmp eq i32 %354, 1
  br i1 %cmp509, label %if.then511, label %if.end545

if.then511:                                       ; preds = %cond.end504
  %355 = load %struct.e1000_hw** %hw, align 8
  %mac512 = getelementptr inbounds %struct.e1000_hw* %355, i32 0, i32 4
  %type513 = getelementptr inbounds %struct.e1000_mac_info* %mac512, i32 0, i32 3
  %356 = load i32* %type513, align 4
  switch i32 %356, label %sw.default543 [
    i32 4, label %sw.bb514
    i32 6, label %sw.bb514
    i32 7, label %sw.bb514
    i32 5, label %sw.bb525
  ]

sw.bb514:                                         ; preds = %if.then511, %if.then511, %if.then511
  %357 = load %struct.e1000_hw** %hw, align 8
  %call515 = call i32 @igb_set_eee_i350(%struct.e1000_hw* %357) noredzone
  store i32 %call515, i32* %err, align 4
  %358 = load i32* %err, align 4
  %tobool516 = icmp ne i32 %358, 0
  br i1 %tobool516, label %if.end524, label %land.lhs.true517

land.lhs.true517:                                 ; preds = %sw.bb514
  %359 = load %struct.e1000_hw** %hw, align 8
  %dev_spec518 = getelementptr inbounds %struct.e1000_hw* %359, i32 0, i32 11
  %_82575519 = bitcast %union.anon.86* %dev_spec518 to %struct.e1000_dev_spec_82575*
  %eee_disable = getelementptr inbounds %struct.e1000_dev_spec_82575* %_82575519, i32 0, i32 2
  %360 = load i8* %eee_disable, align 1
  %tobool520 = trunc i8 %360 to i1
  br i1 %tobool520, label %if.end524, label %if.then521

if.then521:                                       ; preds = %land.lhs.true517
  %361 = load %struct.igb_adapter** %adapter, align 8
  %eee_advert = getelementptr inbounds %struct.igb_adapter* %361, i32 0, i32 80
  store i16 6, i16* %eee_advert, align 2
  %362 = load %struct.igb_adapter** %adapter, align 8
  %flags522 = getelementptr inbounds %struct.igb_adapter* %362, i32 0, i32 3
  %363 = load i32* %flags522, align 4
  %or523 = or i32 %363, 16384
  store i32 %or523, i32* %flags522, align 4
  br label %if.end524

if.end524:                                        ; preds = %if.then521, %land.lhs.true517, %sw.bb514
  br label %sw.epilog544

sw.bb525:                                         ; preds = %if.then511
  %364 = load %struct.e1000_hw** %hw, align 8
  %call526 = call i32 @igb_rd32(%struct.e1000_hw* %364, i32 24) noredzone
  %and527 = and i32 %call526, 8388608
  %tobool528 = icmp ne i32 %and527, 0
  br i1 %tobool528, label %if.then529, label %if.end542

if.then529:                                       ; preds = %sw.bb525
  %365 = load %struct.e1000_hw** %hw, align 8
  %call530 = call i32 @igb_set_eee_i354(%struct.e1000_hw* %365) noredzone
  store i32 %call530, i32* %err, align 4
  %366 = load i32* %err, align 4
  %tobool531 = icmp ne i32 %366, 0
  br i1 %tobool531, label %if.end541, label %land.lhs.true532

land.lhs.true532:                                 ; preds = %if.then529
  %367 = load %struct.e1000_hw** %hw, align 8
  %dev_spec533 = getelementptr inbounds %struct.e1000_hw* %367, i32 0, i32 11
  %_82575534 = bitcast %union.anon.86* %dev_spec533 to %struct.e1000_dev_spec_82575*
  %eee_disable535 = getelementptr inbounds %struct.e1000_dev_spec_82575* %_82575534, i32 0, i32 2
  %368 = load i8* %eee_disable535, align 1
  %tobool536 = trunc i8 %368 to i1
  br i1 %tobool536, label %if.end541, label %if.then537

if.then537:                                       ; preds = %land.lhs.true532
  %369 = load %struct.igb_adapter** %adapter, align 8
  %eee_advert538 = getelementptr inbounds %struct.igb_adapter* %369, i32 0, i32 80
  store i16 6, i16* %eee_advert538, align 2
  %370 = load %struct.igb_adapter** %adapter, align 8
  %flags539 = getelementptr inbounds %struct.igb_adapter* %370, i32 0, i32 3
  %371 = load i32* %flags539, align 4
  %or540 = or i32 %371, 16384
  store i32 %or540, i32* %flags539, align 4
  br label %if.end541

if.end541:                                        ; preds = %if.then537, %land.lhs.true532, %if.then529
  br label %if.end542

if.end542:                                        ; preds = %if.end541, %sw.bb525
  br label %sw.epilog544

sw.default543:                                    ; preds = %if.then511
  br label %sw.epilog544

sw.epilog544:                                     ; preds = %sw.default543, %if.end542, %if.end524
  br label %if.end545

if.end545:                                        ; preds = %sw.epilog544, %cond.end504
  %372 = load %struct.pci_dev** %pdev.addr, align 8
  %dev546 = getelementptr inbounds %struct.pci_dev* %372, i32 0, i32 33
  call void @pm_runtime_put_noidle(%struct.device* %dev546) noredzone
  store i32 0, i32* %retval
  br label %return

err_register:                                     ; preds = %if.then377
  %373 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_release_hw_control(%struct.igb_adapter* %373) noredzone
  %374 = load %struct.igb_adapter** %adapter, align 8
  %i2c_adap = getelementptr inbounds %struct.igb_adapter* %374, i32 0, i32 73
  %375 = bitcast %struct.i2c_adapter* %i2c_adap to i8*
  call void @llvm.memset.p0i8.i64(i8* %375, i8 0, i64 912, i32 8, i1 false)
  br label %err_eeprom

err_eeprom:                                       ; preds = %err_register, %if.then368, %if.then185, %if.then167, %if.then156
  %376 = load %struct.e1000_hw** %hw, align 8
  %call547 = call i32 @igb_check_reset_block(%struct.e1000_hw* %376) noredzone
  %tobool548 = icmp ne i32 %call547, 0
  br i1 %tobool548, label %if.end551, label %if.then549

if.then549:                                       ; preds = %err_eeprom
  %377 = load %struct.e1000_hw** %hw, align 8
  %call550 = call i32 @igb_reset_phy(%struct.e1000_hw* %377) noredzone
  br label %if.end551

if.end551:                                        ; preds = %if.then549, %err_eeprom
  %378 = load %struct.e1000_hw** %hw, align 8
  %flash_address = getelementptr inbounds %struct.e1000_hw* %378, i32 0, i32 2
  %379 = load i8** %flash_address, align 8
  %tobool552 = icmp ne i8* %379, null
  br i1 %tobool552, label %if.then553, label %if.end555

if.then553:                                       ; preds = %if.end551
  %380 = load %struct.e1000_hw** %hw, align 8
  %flash_address554 = getelementptr inbounds %struct.e1000_hw* %380, i32 0, i32 2
  %381 = load i8** %flash_address554, align 8
  call void @iounmap(i8* %381) noredzone
  br label %if.end555

if.end555:                                        ; preds = %if.then553, %if.end551
  br label %err_sw_init

err_sw_init:                                      ; preds = %if.end555, %if.then98, %if.then94
  %382 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_clear_interrupt_scheme(%struct.igb_adapter* %382) noredzone
  %383 = load %struct.pci_dev** %pdev.addr, align 8
  %384 = load %struct.e1000_hw** %hw, align 8
  %hw_addr556 = getelementptr inbounds %struct.e1000_hw* %384, i32 0, i32 1
  %385 = load i8** %hw_addr556, align 8
  call void @pci_iounmap(%struct.pci_dev* %383, i8* %385) noredzone
  br label %err_ioremap

err_ioremap:                                      ; preds = %err_sw_init, %if.then51
  %386 = load %struct.net_device** %netdev, align 8
  call void @free_netdev(%struct.net_device* %386) noredzone
  br label %err_alloc_etherdev

err_alloc_etherdev:                               ; preds = %err_ioremap, %if.then39
  %387 = load %struct.pci_dev** %pdev.addr, align 8
  %388 = load %struct.pci_dev** %pdev.addr, align 8
  %call557 = call i32 @pci_select_bars(%struct.pci_dev* %388, i64 512) noredzone
  call void @pci_release_selected_regions(%struct.pci_dev* %387, i32 %call557) noredzone
  br label %err_pci_reg

err_pci_reg:                                      ; preds = %err_alloc_etherdev, %if.then33
  br label %err_dma

err_dma:                                          ; preds = %err_pci_reg, %if.then25
  %389 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_disable_device(%struct.pci_dev* %389) noredzone
  %390 = load i32* %err, align 4
  store i32 %390, i32* %retval
  br label %return

return:                                           ; preds = %err_dma, %if.end545, %if.then17, %if.end
  %391 = load i32* %retval
  ret i32 %391
}

define internal void @igb_remove(%struct.pci_dev* %pdev) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %5 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %5, i32 0, i32 33
  call void @pm_runtime_get_noresume(%struct.device* %dev) noredzone
  %6 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_sysfs_exit(%struct.igb_adapter* %6) noredzone
  %7 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_remove_i2c(%struct.igb_adapter* %7) noredzone
  %8 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_ptp_stop(%struct.igb_adapter* %8) noredzone
  %9 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %10 = load i64** %addr.addr.i, align 8
  %11 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %10, i64 %11, i64* %10) nounwind, !srcloc !6
  %12 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 18
  %call3 = call i32 @del_timer_sync(%struct.timer_list* %watchdog_timer) noredzone
  %13 = load %struct.igb_adapter** %adapter, align 8
  %phy_info_timer = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 19
  %call4 = call i32 @del_timer_sync(%struct.timer_list* %phy_info_timer) noredzone
  %14 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 26
  %call5 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %reset_task) noredzone
  %15 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 27
  %call6 = call zeroext i1 @cancel_work_sync(%struct.work_struct* %watchdog_task) noredzone
  %16 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 3
  %17 = load i32* %flags, align 4
  %and = and i32 %17, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end19

if.then:                                          ; preds = %entry
  %18 = load %struct.pci_dev** %pdev.addr, align 8
  %dev7 = getelementptr inbounds %struct.pci_dev* %18, i32 0, i32 33
  %call8 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev7, i8* getelementptr inbounds ([14 x i8]* @.str47, i32 0, i32 0)) noredzone
  %19 = load %struct.pci_dev** %pdev.addr, align 8
  %dev9 = getelementptr inbounds %struct.pci_dev* %19, i32 0, i32 33
  %call10 = call i32 @dca_remove_requester(%struct.device* %dev9) noredzone
  %20 = load %struct.igb_adapter** %adapter, align 8
  %flags11 = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 3
  %21 = load i32* %flags11, align 4
  %and12 = and i32 %21, -3
  store i32 %and12, i32* %flags11, align 4
  br label %do.body

do.body:                                          ; preds = %if.then
  %22 = load %struct.e1000_hw** %hw, align 8
  %hw_addr13 = getelementptr inbounds %struct.e1000_hw* %22, i32 0, i32 1
  %23 = load volatile i8** %hw_addr13, align 8
  store i8* %23, i8** %hw_addr, align 8
  %24 = load i8** %hw_addr, align 8
  %tobool14 = icmp ne i8* %24, null
  %lnot = xor i1 %tobool14, true
  %lnot15 = xor i1 %lnot, true
  %lnot16 = xor i1 %lnot15, true
  %lnot.ext = zext i1 %lnot16 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool17 = icmp ne i64 %expval, 0
  br i1 %tobool17, label %if.end, label %if.then18

if.then18:                                        ; preds = %do.body
  %25 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %25, i64 23412
  call void @writel(i32 1, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then18, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end19

if.end19:                                         ; preds = %do.end, %entry
  %26 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_release_hw_control(%struct.igb_adapter* %26) noredzone
  %27 = load %struct.net_device** %netdev, align 8
  call void @unregister_netdev(%struct.net_device* %27) noredzone
  %28 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_clear_interrupt_scheme(%struct.igb_adapter* %28) noredzone
  %29 = load %struct.pci_dev** %pdev.addr, align 8
  %call20 = call i32 @igb_disable_sriov(%struct.pci_dev* %29) noredzone
  %30 = load %struct.pci_dev** %pdev.addr, align 8
  %31 = load %struct.e1000_hw** %hw, align 8
  %hw_addr21 = getelementptr inbounds %struct.e1000_hw* %31, i32 0, i32 1
  %32 = load i8** %hw_addr21, align 8
  call void @pci_iounmap(%struct.pci_dev* %30, i8* %32) noredzone
  %33 = load %struct.e1000_hw** %hw, align 8
  %flash_address = getelementptr inbounds %struct.e1000_hw* %33, i32 0, i32 2
  %34 = load i8** %flash_address, align 8
  %tobool22 = icmp ne i8* %34, null
  br i1 %tobool22, label %if.then23, label %if.end25

if.then23:                                        ; preds = %if.end19
  %35 = load %struct.e1000_hw** %hw, align 8
  %flash_address24 = getelementptr inbounds %struct.e1000_hw* %35, i32 0, i32 2
  %36 = load i8** %flash_address24, align 8
  call void @iounmap(i8* %36) noredzone
  br label %if.end25

if.end25:                                         ; preds = %if.then23, %if.end19
  %37 = load %struct.pci_dev** %pdev.addr, align 8
  %38 = load %struct.pci_dev** %pdev.addr, align 8
  %call26 = call i32 @pci_select_bars(%struct.pci_dev* %38, i64 512) noredzone
  call void @pci_release_selected_regions(%struct.pci_dev* %37, i32 %call26) noredzone
  %39 = load %struct.igb_adapter** %adapter, align 8
  %shadow_vfta = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 54
  %40 = load i32** %shadow_vfta, align 8
  %41 = bitcast i32* %40 to i8*
  call void @kfree(i8* %41) noredzone
  %42 = load %struct.net_device** %netdev, align 8
  call void @free_netdev(%struct.net_device* %42) noredzone
  %43 = load %struct.pci_dev** %pdev.addr, align 8
  %call27 = call i32 @pci_disable_pcie_error_reporting(%struct.pci_dev* %43) noredzone
  %44 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_disable_device(%struct.pci_dev* %44) noredzone
  ret void
}

define internal void @igb_shutdown(%struct.pci_dev* %pdev) nounwind noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %wake = alloca i8, align 1
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i32 @__igb_shutdown(%struct.pci_dev* %0, i8* %wake, i1 zeroext false) noredzone
  %1 = load i32* @system_state, align 4
  %cmp = icmp eq i32 %1, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.pci_dev** %pdev.addr, align 8
  %3 = load i8* %wake, align 1
  %tobool = trunc i8 %3 to i1
  %call1 = call i32 @pci_wake_from_d3(%struct.pci_dev* %2, i1 zeroext %tobool) noredzone
  %4 = load %struct.pci_dev** %pdev.addr, align 8
  %call2 = call i32 @pci_set_power_state(%struct.pci_dev* %4, i32 3) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

define internal i32 @igb_pci_sriov_configure(%struct.pci_dev* %dev, i32 %num_vfs) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.pci_dev*, align 8
  %num_vfs.addr = alloca i32, align 4
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  store i32 %num_vfs, i32* %num_vfs.addr, align 4
  %0 = load i32* %num_vfs.addr, align 4
  %cmp = icmp eq i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load %struct.pci_dev** %dev.addr, align 8
  %call = call i32 @igb_pci_disable_sriov(%struct.pci_dev* %1) noredzone
  store i32 %call, i32* %retval
  br label %return

if.else:                                          ; preds = %entry
  %2 = load %struct.pci_dev** %dev.addr, align 8
  %3 = load i32* %num_vfs.addr, align 4
  %call1 = call i32 @igb_pci_enable_sriov(%struct.pci_dev* %2, i32 %3) noredzone
  store i32 %call1, i32* %retval
  br label %return

return:                                           ; preds = %if.else, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

define internal i32 @igb_suspend(%struct.device* %dev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.device*, align 8
  %retval1 = alloca i32, align 4
  %wake = alloca i8, align 1
  %pdev = alloca %struct.pci_dev*, align 8
  %__mptr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  store %struct.device* %0, %struct.device** %__mptr, align 8
  %1 = load %struct.device** %__mptr, align 8
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.pci_dev*
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  %4 = load %struct.pci_dev** %pdev, align 8
  %call = call i32 @__igb_shutdown(%struct.pci_dev* %4, i8* %wake, i1 zeroext false) noredzone
  store i32 %call, i32* %retval1, align 4
  %5 = load i32* %retval1, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32* %retval1, align 4
  store i32 %6, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i8* %wake, align 1
  %tobool2 = trunc i8 %7 to i1
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %8 = load %struct.pci_dev** %pdev, align 8
  %call4 = call i32 @pci_prepare_to_sleep(%struct.pci_dev* %8) noredzone
  br label %if.end7

if.else:                                          ; preds = %if.end
  %9 = load %struct.pci_dev** %pdev, align 8
  %call5 = call i32 @pci_wake_from_d3(%struct.pci_dev* %9, i1 zeroext false) noredzone
  %10 = load %struct.pci_dev** %pdev, align 8
  %call6 = call i32 @pci_set_power_state(%struct.pci_dev* %10, i32 3) noredzone
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.then
  %11 = load i32* %retval
  ret i32 %11
}

define internal i32 @igb_resume(%struct.device* %dev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.device*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %__mptr = alloca %struct.device*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %err = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  store %struct.device* %0, %struct.device** %__mptr, align 8
  %1 = load %struct.device** %__mptr, align 8
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.pci_dev*
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  %4 = load %struct.pci_dev** %pdev, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %4) noredzone
  %5 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %5, %struct.net_device** %netdev, align 8
  %6 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %6) noredzone
  %7 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %7, %struct.igb_adapter** %adapter, align 8
  %8 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %9 = load %struct.pci_dev** %pdev, align 8
  %call3 = call i32 @pci_set_power_state(%struct.pci_dev* %9, i32 0) noredzone
  %10 = load %struct.pci_dev** %pdev, align 8
  call void @pci_restore_state(%struct.pci_dev* %10) noredzone
  %11 = load %struct.pci_dev** %pdev, align 8
  %call4 = call i32 @pci_save_state(%struct.pci_dev* %11) noredzone
  %12 = load %struct.pci_dev** %pdev, align 8
  %call5 = call i32 @pci_enable_device_mem(%struct.pci_dev* %12) noredzone
  store i32 %call5, i32* %err, align 4
  %13 = load i32* %err, align 4
  %tobool = icmp ne i32 %13, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %14 = load %struct.pci_dev** %pdev, align 8
  %dev6 = getelementptr inbounds %struct.pci_dev* %14, i32 0, i32 33
  %call7 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev6, i8* getelementptr inbounds ([44 x i8]* @.str39, i32 0, i32 0)) noredzone
  %15 = load i32* %err, align 4
  store i32 %15, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %16 = load %struct.pci_dev** %pdev, align 8
  call void @pci_set_master(%struct.pci_dev* %16) noredzone
  %17 = load %struct.pci_dev** %pdev, align 8
  %call8 = call i32 @pci_enable_wake(%struct.pci_dev* %17, i32 3, i1 zeroext false) noredzone
  %18 = load %struct.pci_dev** %pdev, align 8
  %call9 = call i32 @pci_enable_wake(%struct.pci_dev* %18, i32 4, i1 zeroext false) noredzone
  %19 = load %struct.igb_adapter** %adapter, align 8
  %call10 = call i32 @igb_init_interrupt_scheme(%struct.igb_adapter* %19, i1 zeroext true) noredzone
  %tobool11 = icmp ne i32 %call10, 0
  br i1 %tobool11, label %if.then12, label %if.end15

if.then12:                                        ; preds = %if.end
  %20 = load %struct.pci_dev** %pdev, align 8
  %dev13 = getelementptr inbounds %struct.pci_dev* %20, i32 0, i32 33
  %call14 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev13, i8* getelementptr inbounds ([38 x i8]* @.str11, i32 0, i32 0)) noredzone
  store i32 -12, i32* %retval
  br label %return

if.end15:                                         ; preds = %if.end
  %21 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %21) noredzone
  %22 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_get_hw_control(%struct.igb_adapter* %22) noredzone
  br label %do.body

do.body:                                          ; preds = %if.end15
  %23 = load %struct.e1000_hw** %hw, align 8
  %hw_addr16 = getelementptr inbounds %struct.e1000_hw* %23, i32 0, i32 1
  %24 = load volatile i8** %hw_addr16, align 8
  store i8* %24, i8** %hw_addr, align 8
  %25 = load i8** %hw_addr, align 8
  %tobool17 = icmp ne i8* %25, null
  %lnot = xor i1 %tobool17, true
  %lnot18 = xor i1 %lnot, true
  %lnot19 = xor i1 %lnot18, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool20 = icmp ne i64 %expval, 0
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %do.body
  %26 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %26, i64 22544
  call void @writel(i32 -1, i8* %arrayidx) noredzone
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end22
  %27 = load %struct.net_device** %netdev, align 8
  %flags = getelementptr inbounds %struct.net_device* %27, i32 0, i32 32
  %28 = load i32* %flags, align 4
  %and = and i32 %28, 1
  %tobool23 = icmp ne i32 %and, 0
  br i1 %tobool23, label %if.then24, label %if.end29

if.then24:                                        ; preds = %do.end
  call void @rtnl_lock() noredzone
  %29 = load %struct.net_device** %netdev, align 8
  %call25 = call i32 @__igb_open(%struct.net_device* %29, i1 zeroext true) noredzone
  store i32 %call25, i32* %err, align 4
  call void @rtnl_unlock() noredzone
  %30 = load i32* %err, align 4
  %tobool26 = icmp ne i32 %30, 0
  br i1 %tobool26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.then24
  %31 = load i32* %err, align 4
  store i32 %31, i32* %retval
  br label %return

if.end28:                                         ; preds = %if.then24
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %do.end
  %32 = load %struct.net_device** %netdev, align 8
  call void @netif_device_attach(%struct.net_device* %32) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end29, %if.then27, %if.then12, %if.then
  %33 = load i32* %retval
  ret i32 %33
}

define internal i32 @igb_runtime_suspend(%struct.device* %dev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.device*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %__mptr = alloca %struct.device*, align 8
  %retval1 = alloca i32, align 4
  %wake = alloca i8, align 1
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  store %struct.device* %0, %struct.device** %__mptr, align 8
  %1 = load %struct.device** %__mptr, align 8
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.pci_dev*
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  %4 = load %struct.pci_dev** %pdev, align 8
  %call = call i32 @__igb_shutdown(%struct.pci_dev* %4, i8* %wake, i1 zeroext true) noredzone
  store i32 %call, i32* %retval1, align 4
  %5 = load i32* %retval1, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load i32* %retval1, align 4
  store i32 %6, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %7 = load i8* %wake, align 1
  %tobool2 = trunc i8 %7 to i1
  br i1 %tobool2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %8 = load %struct.pci_dev** %pdev, align 8
  %call4 = call i32 @pci_prepare_to_sleep(%struct.pci_dev* %8) noredzone
  br label %if.end7

if.else:                                          ; preds = %if.end
  %9 = load %struct.pci_dev** %pdev, align 8
  %call5 = call i32 @pci_wake_from_d3(%struct.pci_dev* %9, i1 zeroext false) noredzone
  %10 = load %struct.pci_dev** %pdev, align 8
  %call6 = call i32 @pci_set_power_state(%struct.pci_dev* %10, i32 3) noredzone
  br label %if.end7

if.end7:                                          ; preds = %if.else, %if.then3
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end7, %if.then
  %11 = load i32* %retval
  ret i32 %11
}

define internal i32 @igb_runtime_resume(%struct.device* %dev) nounwind noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call i32 @igb_resume(%struct.device* %0) noredzone
  ret i32 %call
}

define internal i32 @igb_runtime_idle(%struct.device* %dev) nounwind noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %__mptr = alloca %struct.device*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  store %struct.device* %0, %struct.device** %__mptr, align 8
  %1 = load %struct.device** %__mptr, align 8
  %2 = bitcast %struct.device* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -152
  %3 = bitcast i8* %add.ptr to %struct.pci_dev*
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  %4 = load %struct.pci_dev** %pdev, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %4) noredzone
  %5 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %5, %struct.net_device** %netdev, align 8
  %6 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %6) noredzone
  %7 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %7, %struct.igb_adapter** %adapter, align 8
  %8 = load %struct.igb_adapter** %adapter, align 8
  %call2 = call zeroext i1 @igb_has_link(%struct.igb_adapter* %8) noredzone
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %9 = load %struct.device** %dev.addr, align 8
  %call3 = call i32 @pm_schedule_suspend(%struct.device* %9, i32 5000) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret i32 -16
}

define internal i8* @pci_get_drvdata(%struct.pci_dev* %pdev) nounwind inlinehint noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %0, i32 0, i32 33
  %call = call i8* @dev_get_drvdata(%struct.device* %dev) noredzone
  ret i8* %call
}

declare i32 @pm_schedule_suspend(%struct.device*, i32) noredzone

define internal i8* @dev_get_drvdata(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %driver_data = getelementptr inbounds %struct.device* %0, i32 0, i32 9
  %1 = load i8** %driver_data, align 8
  ret i8* %1
}

define internal i32 @__igb_shutdown(%struct.pci_dev* %pdev, i8* %enable_wake, i1 zeroext %runtime) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %enable_wake.addr = alloca i8*, align 8
  %runtime.addr = alloca i8, align 1
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ctrl = alloca i32, align 4
  %rctl = alloca i32, align 4
  %status = alloca i32, align 4
  %wufc = alloca i32, align 4
  %retval3 = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr32 = alloca i8*, align 8
  %hw_addr50 = alloca i8*, align 8
  %hw_addr67 = alloca i8*, align 8
  %hw_addr84 = alloca i8*, align 8
  %hw_addr101 = alloca i8*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  store i8* %enable_wake, i8** %enable_wake.addr, align 8
  %frombool = zext i1 %runtime to i8
  store i8 %frombool, i8* %runtime.addr, align 1
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %5 = load i8* %runtime.addr, align 1
  %tobool = trunc i8 %5 to i1
  br i1 %tobool, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  br label %cond.end

cond.false:                                       ; preds = %entry
  %6 = load %struct.igb_adapter** %adapter, align 8
  %wol = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 22
  %7 = load i32* %wol, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ 1, %cond.true ], [ %7, %cond.false ]
  store i32 %cond, i32* %wufc, align 4
  store i32 0, i32* %retval3, align 4
  %8 = load %struct.net_device** %netdev, align 8
  call void @netif_device_detach(%struct.net_device* %8) noredzone
  %9 = load %struct.net_device** %netdev, align 8
  %call4 = call zeroext i1 @netif_running(%struct.net_device* %9) noredzone
  br i1 %call4, label %if.then, label %if.end

if.then:                                          ; preds = %cond.end
  %10 = load %struct.net_device** %netdev, align 8
  %call5 = call i32 @__igb_close(%struct.net_device* %10, i1 zeroext true) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %cond.end
  %11 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_clear_interrupt_scheme(%struct.igb_adapter* %11) noredzone
  %12 = load %struct.pci_dev** %pdev.addr, align 8
  %call6 = call i32 @pci_save_state(%struct.pci_dev* %12) noredzone
  store i32 %call6, i32* %retval3, align 4
  %13 = load i32* %retval3, align 4
  %tobool7 = icmp ne i32 %13, 0
  br i1 %tobool7, label %if.then8, label %if.end9

if.then8:                                         ; preds = %if.end
  %14 = load i32* %retval3, align 4
  store i32 %14, i32* %retval
  br label %return

if.end9:                                          ; preds = %if.end
  %15 = load %struct.e1000_hw** %hw, align 8
  %call10 = call i32 @igb_rd32(%struct.e1000_hw* %15, i32 8) noredzone
  store i32 %call10, i32* %status, align 4
  %16 = load i32* %status, align 4
  %and = and i32 %16, 2
  %tobool11 = icmp ne i32 %and, 0
  br i1 %tobool11, label %if.then12, label %if.end14

if.then12:                                        ; preds = %if.end9
  %17 = load i32* %wufc, align 4
  %and13 = and i32 %17, -2
  store i32 %and13, i32* %wufc, align 4
  br label %if.end14

if.end14:                                         ; preds = %if.then12, %if.end9
  %18 = load i32* %wufc, align 4
  %tobool15 = icmp ne i32 %18, 0
  br i1 %tobool15, label %if.then16, label %if.else

if.then16:                                        ; preds = %if.end14
  %19 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_setup_rctl(%struct.igb_adapter* %19) noredzone
  %20 = load %struct.net_device** %netdev, align 8
  call void @igb_set_rx_mode(%struct.net_device* %20) noredzone
  %21 = load i32* %wufc, align 4
  %and17 = and i32 %21, 8
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end28

if.then19:                                        ; preds = %if.then16
  %22 = load %struct.e1000_hw** %hw, align 8
  %call20 = call i32 @igb_rd32(%struct.e1000_hw* %22, i32 256) noredzone
  store i32 %call20, i32* %rctl, align 4
  %23 = load i32* %rctl, align 4
  %or = or i32 %23, 16
  store i32 %or, i32* %rctl, align 4
  br label %do.body

do.body:                                          ; preds = %if.then19
  %24 = load %struct.e1000_hw** %hw, align 8
  %hw_addr21 = getelementptr inbounds %struct.e1000_hw* %24, i32 0, i32 1
  %25 = load volatile i8** %hw_addr21, align 8
  store i8* %25, i8** %hw_addr, align 8
  %26 = load i8** %hw_addr, align 8
  %tobool22 = icmp ne i8* %26, null
  %lnot = xor i1 %tobool22, true
  %lnot23 = xor i1 %lnot, true
  %lnot24 = xor i1 %lnot23, true
  %lnot.ext = zext i1 %lnot24 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool25 = icmp ne i64 %expval, 0
  br i1 %tobool25, label %if.end27, label %if.then26

if.then26:                                        ; preds = %do.body
  %27 = load i32* %rctl, align 4
  %28 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %28, i64 256
  call void @writel(i32 %27, i8* %arrayidx) noredzone
  br label %if.end27

if.end27:                                         ; preds = %if.then26, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end27
  br label %if.end28

if.end28:                                         ; preds = %do.end, %if.then16
  %29 = load %struct.e1000_hw** %hw, align 8
  %call29 = call i32 @igb_rd32(%struct.e1000_hw* %29, i32 0) noredzone
  store i32 %call29, i32* %ctrl, align 4
  %30 = load i32* %ctrl, align 4
  %or30 = or i32 %30, 1048576
  store i32 %or30, i32* %ctrl, align 4
  br label %do.body31

do.body31:                                        ; preds = %if.end28
  %31 = load %struct.e1000_hw** %hw, align 8
  %hw_addr33 = getelementptr inbounds %struct.e1000_hw* %31, i32 0, i32 1
  %32 = load volatile i8** %hw_addr33, align 8
  store i8* %32, i8** %hw_addr32, align 8
  %33 = load i8** %hw_addr32, align 8
  %tobool34 = icmp ne i8* %33, null
  %lnot35 = xor i1 %tobool34, true
  %lnot37 = xor i1 %lnot35, true
  %lnot39 = xor i1 %lnot37, true
  %lnot.ext40 = zext i1 %lnot39 to i32
  %conv41 = sext i32 %lnot.ext40 to i64
  %expval42 = call i64 @llvm.expect.i64(i64 %conv41, i64 0)
  %tobool43 = icmp ne i64 %expval42, 0
  br i1 %tobool43, label %if.end46, label %if.then44

if.then44:                                        ; preds = %do.body31
  %34 = load i32* %ctrl, align 4
  %35 = load i8** %hw_addr32, align 8
  %arrayidx45 = getelementptr i8* %35, i64 0
  call void @writel(i32 %34, i8* %arrayidx45) noredzone
  br label %if.end46

if.end46:                                         ; preds = %if.then44, %do.body31
  br label %do.end47

do.end47:                                         ; preds = %if.end46
  %36 = load %struct.e1000_hw** %hw, align 8
  %call48 = call i32 @igb_disable_pcie_master(%struct.e1000_hw* %36) noredzone
  br label %do.body49

do.body49:                                        ; preds = %do.end47
  %37 = load %struct.e1000_hw** %hw, align 8
  %hw_addr51 = getelementptr inbounds %struct.e1000_hw* %37, i32 0, i32 1
  %38 = load volatile i8** %hw_addr51, align 8
  store i8* %38, i8** %hw_addr50, align 8
  %39 = load i8** %hw_addr50, align 8
  %tobool52 = icmp ne i8* %39, null
  %lnot53 = xor i1 %tobool52, true
  %lnot55 = xor i1 %lnot53, true
  %lnot57 = xor i1 %lnot55, true
  %lnot.ext58 = zext i1 %lnot57 to i32
  %conv59 = sext i32 %lnot.ext58 to i64
  %expval60 = call i64 @llvm.expect.i64(i64 %conv59, i64 0)
  %tobool61 = icmp ne i64 %expval60, 0
  br i1 %tobool61, label %if.end64, label %if.then62

if.then62:                                        ; preds = %do.body49
  %40 = load i8** %hw_addr50, align 8
  %arrayidx63 = getelementptr i8* %40, i64 22528
  call void @writel(i32 2, i8* %arrayidx63) noredzone
  br label %if.end64

if.end64:                                         ; preds = %if.then62, %do.body49
  br label %do.end65

do.end65:                                         ; preds = %if.end64
  br label %do.body66

do.body66:                                        ; preds = %do.end65
  %41 = load %struct.e1000_hw** %hw, align 8
  %hw_addr68 = getelementptr inbounds %struct.e1000_hw* %41, i32 0, i32 1
  %42 = load volatile i8** %hw_addr68, align 8
  store i8* %42, i8** %hw_addr67, align 8
  %43 = load i8** %hw_addr67, align 8
  %tobool69 = icmp ne i8* %43, null
  %lnot70 = xor i1 %tobool69, true
  %lnot72 = xor i1 %lnot70, true
  %lnot74 = xor i1 %lnot72, true
  %lnot.ext75 = zext i1 %lnot74 to i32
  %conv76 = sext i32 %lnot.ext75 to i64
  %expval77 = call i64 @llvm.expect.i64(i64 %conv76, i64 0)
  %tobool78 = icmp ne i64 %expval77, 0
  br i1 %tobool78, label %if.end81, label %if.then79

if.then79:                                        ; preds = %do.body66
  %44 = load i32* %wufc, align 4
  %45 = load i8** %hw_addr67, align 8
  %arrayidx80 = getelementptr i8* %45, i64 22536
  call void @writel(i32 %44, i8* %arrayidx80) noredzone
  br label %if.end81

if.end81:                                         ; preds = %if.then79, %do.body66
  br label %do.end82

do.end82:                                         ; preds = %if.end81
  br label %if.end117

if.else:                                          ; preds = %if.end14
  br label %do.body83

do.body83:                                        ; preds = %if.else
  %46 = load %struct.e1000_hw** %hw, align 8
  %hw_addr85 = getelementptr inbounds %struct.e1000_hw* %46, i32 0, i32 1
  %47 = load volatile i8** %hw_addr85, align 8
  store i8* %47, i8** %hw_addr84, align 8
  %48 = load i8** %hw_addr84, align 8
  %tobool86 = icmp ne i8* %48, null
  %lnot87 = xor i1 %tobool86, true
  %lnot89 = xor i1 %lnot87, true
  %lnot91 = xor i1 %lnot89, true
  %lnot.ext92 = zext i1 %lnot91 to i32
  %conv93 = sext i32 %lnot.ext92 to i64
  %expval94 = call i64 @llvm.expect.i64(i64 %conv93, i64 0)
  %tobool95 = icmp ne i64 %expval94, 0
  br i1 %tobool95, label %if.end98, label %if.then96

if.then96:                                        ; preds = %do.body83
  %49 = load i8** %hw_addr84, align 8
  %arrayidx97 = getelementptr i8* %49, i64 22528
  call void @writel(i32 0, i8* %arrayidx97) noredzone
  br label %if.end98

if.end98:                                         ; preds = %if.then96, %do.body83
  br label %do.end99

do.end99:                                         ; preds = %if.end98
  br label %do.body100

do.body100:                                       ; preds = %do.end99
  %50 = load %struct.e1000_hw** %hw, align 8
  %hw_addr102 = getelementptr inbounds %struct.e1000_hw* %50, i32 0, i32 1
  %51 = load volatile i8** %hw_addr102, align 8
  store i8* %51, i8** %hw_addr101, align 8
  %52 = load i8** %hw_addr101, align 8
  %tobool103 = icmp ne i8* %52, null
  %lnot104 = xor i1 %tobool103, true
  %lnot106 = xor i1 %lnot104, true
  %lnot108 = xor i1 %lnot106, true
  %lnot.ext109 = zext i1 %lnot108 to i32
  %conv110 = sext i32 %lnot.ext109 to i64
  %expval111 = call i64 @llvm.expect.i64(i64 %conv110, i64 0)
  %tobool112 = icmp ne i64 %expval111, 0
  br i1 %tobool112, label %if.end115, label %if.then113

if.then113:                                       ; preds = %do.body100
  %53 = load i8** %hw_addr101, align 8
  %arrayidx114 = getelementptr i8* %53, i64 22536
  call void @writel(i32 0, i8* %arrayidx114) noredzone
  br label %if.end115

if.end115:                                        ; preds = %if.then113, %do.body100
  br label %do.end116

do.end116:                                        ; preds = %if.end115
  br label %if.end117

if.end117:                                        ; preds = %do.end116, %do.end82
  %54 = load i32* %wufc, align 4
  %tobool118 = icmp ne i32 %54, 0
  br i1 %tobool118, label %lor.end, label %lor.rhs

lor.rhs:                                          ; preds = %if.end117
  %55 = load %struct.igb_adapter** %adapter, align 8
  %en_mng_pt = getelementptr inbounds %struct.igb_adapter* %55, i32 0, i32 23
  %56 = load i32* %en_mng_pt, align 4
  %tobool119 = icmp ne i32 %56, 0
  br label %lor.end

lor.end:                                          ; preds = %lor.rhs, %if.end117
  %57 = phi i1 [ true, %if.end117 ], [ %tobool119, %lor.rhs ]
  %58 = load i8** %enable_wake.addr, align 8
  %frombool120 = zext i1 %57 to i8
  store i8 %frombool120, i8* %58, align 1
  %59 = load i8** %enable_wake.addr, align 8
  %60 = load i8* %59, align 1
  %tobool121 = trunc i8 %60 to i1
  br i1 %tobool121, label %if.else123, label %if.then122

if.then122:                                       ; preds = %lor.end
  %61 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_power_down_link(%struct.igb_adapter* %61) noredzone
  br label %if.end124

if.else123:                                       ; preds = %lor.end
  %62 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_power_up_link(%struct.igb_adapter* %62) noredzone
  br label %if.end124

if.end124:                                        ; preds = %if.else123, %if.then122
  %63 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_release_hw_control(%struct.igb_adapter* %63) noredzone
  %64 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_disable_device(%struct.pci_dev* %64) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end124, %if.then8
  %65 = load i32* %retval
  ret i32 %65
}

declare i32 @pci_prepare_to_sleep(%struct.pci_dev*) noredzone

declare i32 @pci_wake_from_d3(%struct.pci_dev*, i1 zeroext) noredzone

declare i32 @pci_set_power_state(%struct.pci_dev*, i32) noredzone

declare i32 @pci_save_state(%struct.pci_dev*) noredzone

declare i32 @igb_disable_pcie_master(%struct.e1000_hw*) noredzone

declare void @pci_disable_device(%struct.pci_dev*) noredzone

declare void @pci_restore_state(%struct.pci_dev*) noredzone

declare i32 @pci_enable_device_mem(%struct.pci_dev*) noredzone

declare void @pci_set_master(%struct.pci_dev*) noredzone

define internal i32 @pci_enable_wake(%struct.pci_dev* %dev, i32 %state, i1 zeroext %enable) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.pci_dev*, align 8
  %state.addr = alloca i32, align 4
  %enable.addr = alloca i8, align 1
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  store i32 %state, i32* %state.addr, align 4
  %frombool = zext i1 %enable to i8
  store i8 %frombool, i8* %enable.addr, align 1
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %1 = load i32* %state.addr, align 4
  %2 = load i8* %enable.addr, align 1
  %tobool = trunc i8 %2 to i1
  %call = call i32 @__pci_enable_wake(%struct.pci_dev* %0, i32 %1, i1 zeroext false, i1 zeroext %tobool) noredzone
  ret i32 %call
}

declare void @rtnl_lock() noredzone

declare void @rtnl_unlock() noredzone

declare void @netif_device_attach(%struct.net_device*) noredzone

declare i32 @__pci_enable_wake(%struct.pci_dev*, i32, i1 zeroext, i1 zeroext) noredzone

define internal i32 @igb_io_error_detected(%struct.pci_dev* %pdev, i32 %state) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %state.addr = alloca i32, align 4
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  store i32 %state, i32* %state.addr, align 4
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.net_device** %netdev, align 8
  call void @netif_device_detach(%struct.net_device* %4) noredzone
  %5 = load i32* %state.addr, align 4
  %cmp = icmp eq i32 %5, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 4, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.net_device** %netdev, align 8
  %call2 = call zeroext i1 @netif_running(%struct.net_device* %6) noredzone
  br i1 %call2, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  %7 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_down(%struct.igb_adapter* %7) noredzone
  br label %if.end4

if.end4:                                          ; preds = %if.then3, %if.end
  %8 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_disable_device(%struct.pci_dev* %8) noredzone
  store i32 3, i32* %retval
  br label %return

return:                                           ; preds = %if.end4, %if.then
  %9 = load i32* %retval
  ret i32 %9
}

define internal i32 @igb_io_slot_reset(%struct.pci_dev* %pdev) nounwind noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %result = alloca i32, align 4
  %err = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %5 = load %struct.pci_dev** %pdev.addr, align 8
  %call3 = call i32 @pci_enable_device_mem(%struct.pci_dev* %5) noredzone
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %6, i32 0, i32 33
  %call4 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([42 x i8]* @.str41, i32 0, i32 0)) noredzone
  store i32 4, i32* %result, align 4
  br label %if.end14

if.else:                                          ; preds = %entry
  %7 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_set_master(%struct.pci_dev* %7) noredzone
  %8 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_restore_state(%struct.pci_dev* %8) noredzone
  %9 = load %struct.pci_dev** %pdev.addr, align 8
  %call5 = call i32 @pci_save_state(%struct.pci_dev* %9) noredzone
  %10 = load %struct.pci_dev** %pdev.addr, align 8
  %call6 = call i32 @pci_enable_wake(%struct.pci_dev* %10, i32 3, i1 zeroext false) noredzone
  %11 = load %struct.pci_dev** %pdev.addr, align 8
  %call7 = call i32 @pci_enable_wake(%struct.pci_dev* %11, i32 4, i1 zeroext false) noredzone
  %12 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %12) noredzone
  br label %do.body

do.body:                                          ; preds = %if.else
  %13 = load %struct.e1000_hw** %hw, align 8
  %hw_addr8 = getelementptr inbounds %struct.e1000_hw* %13, i32 0, i32 1
  %14 = load volatile i8** %hw_addr8, align 8
  store i8* %14, i8** %hw_addr, align 8
  %15 = load i8** %hw_addr, align 8
  %tobool9 = icmp ne i8* %15, null
  %lnot = xor i1 %tobool9, true
  %lnot10 = xor i1 %lnot, true
  %lnot11 = xor i1 %lnot10, true
  %lnot.ext = zext i1 %lnot11 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool12 = icmp ne i64 %expval, 0
  br i1 %tobool12, label %if.end, label %if.then13

if.then13:                                        ; preds = %do.body
  %16 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %16, i64 22544
  call void @writel(i32 -1, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then13, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  store i32 5, i32* %result, align 4
  br label %if.end14

if.end14:                                         ; preds = %do.end, %if.then
  %17 = load %struct.pci_dev** %pdev.addr, align 8
  %call15 = call i32 @pci_cleanup_aer_uncorrect_error_status(%struct.pci_dev* %17) noredzone
  store i32 %call15, i32* %err, align 4
  %18 = load i32* %err, align 4
  %tobool16 = icmp ne i32 %18, 0
  br i1 %tobool16, label %if.then17, label %if.end20

if.then17:                                        ; preds = %if.end14
  %19 = load %struct.pci_dev** %pdev.addr, align 8
  %dev18 = getelementptr inbounds %struct.pci_dev* %19, i32 0, i32 33
  %20 = load i32* %err, align 4
  %call19 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev18, i8* getelementptr inbounds ([53 x i8]* @.str42, i32 0, i32 0), i32 %20) noredzone
  br label %if.end20

if.end20:                                         ; preds = %if.then17, %if.end14
  %21 = load i32* %result, align 4
  ret i32 %21
}

define internal void @igb_io_resume(%struct.pci_dev* %pdev) nounwind noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.net_device** %netdev, align 8
  %call2 = call zeroext i1 @netif_running(%struct.net_device* %4) noredzone
  br i1 %call2, label %if.then, label %if.end6

if.then:                                          ; preds = %entry
  %5 = load %struct.igb_adapter** %adapter, align 8
  %call3 = call i32 @igb_up(%struct.igb_adapter* %5) noredzone
  %tobool = icmp ne i32 %call3, 0
  br i1 %tobool, label %if.then4, label %if.end

if.then4:                                         ; preds = %if.then
  %6 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %6, i32 0, i32 33
  %call5 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([27 x i8]* @.str40, i32 0, i32 0)) noredzone
  br label %return

if.end:                                           ; preds = %if.then
  br label %if.end6

if.end6:                                          ; preds = %if.end, %entry
  %7 = load %struct.net_device** %netdev, align 8
  call void @netif_device_attach(%struct.net_device* %7) noredzone
  %8 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_get_hw_control(%struct.igb_adapter* %8) noredzone
  br label %return

return:                                           ; preds = %if.end6, %if.then4
  ret void
}

declare i32 @pci_cleanup_aer_uncorrect_error_status(%struct.pci_dev*) noredzone

define internal i32 @igb_pci_disable_sriov(%struct.pci_dev* %dev) nounwind noredzone {
entry:
  %dev.addr = alloca %struct.pci_dev*, align 8
  %err = alloca i32, align 4
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %call = call i32 @igb_disable_sriov(%struct.pci_dev* %0) noredzone
  store i32 %call, i32* %err, align 4
  %1 = load i32* %err, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load %struct.pci_dev** %dev.addr, align 8
  %call1 = call i32 @igb_sriov_reinit(%struct.pci_dev* %2) noredzone
  store i32 %call1, i32* %err, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32* %err, align 4
  ret i32 %3
}

define internal i32 @igb_pci_enable_sriov(%struct.pci_dev* %dev, i32 %num_vfs) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.pci_dev*, align 8
  %num_vfs.addr = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  store i32 %num_vfs, i32* %num_vfs.addr, align 4
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %1 = load i32* %num_vfs.addr, align 4
  %call = call i32 @igb_enable_sriov(%struct.pci_dev* %0, i32 %1) noredzone
  store i32 %call, i32* %err, align 4
  %2 = load i32* %err, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  br label %out

if.end:                                           ; preds = %entry
  %3 = load %struct.pci_dev** %dev.addr, align 8
  %call1 = call i32 @igb_sriov_reinit(%struct.pci_dev* %3) noredzone
  store i32 %call1, i32* %err, align 4
  %4 = load i32* %err, align 4
  %tobool2 = icmp ne i32 %4, 0
  br i1 %tobool2, label %if.end4, label %if.then3

if.then3:                                         ; preds = %if.end
  %5 = load i32* %num_vfs.addr, align 4
  store i32 %5, i32* %retval
  br label %return

if.end4:                                          ; preds = %if.end
  br label %out

out:                                              ; preds = %if.end4, %if.then
  %6 = load i32* %err, align 4
  store i32 %6, i32* %retval
  br label %return

return:                                           ; preds = %out, %if.then3
  %7 = load i32* %retval
  ret i32 %7
}

define internal i32 @igb_enable_sriov(%struct.pci_dev* %pdev, i32 %num_vfs) nounwind noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %num_vfs.addr = alloca i32, align 4
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %old_vfs = alloca i32, align 4
  %err = alloca i32, align 4
  %i = alloca i32, align 4
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  store i32 %num_vfs, i32* %num_vfs.addr, align 4
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.pci_dev** %pdev.addr, align 8
  %call2 = call i32 @pci_num_vf(%struct.pci_dev* %4) noredzone
  store i32 %call2, i32* %old_vfs, align 4
  store i32 0, i32* %err, align 4
  %5 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 3
  %6 = load i32* %flags, align 4
  %and = and i32 %6, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %7 = load i32* %num_vfs.addr, align 4
  %cmp = icmp sgt i32 %7, 7
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -1, i32* %err, align 4
  br label %out

if.end:                                           ; preds = %lor.lhs.false
  %8 = load i32* %num_vfs.addr, align 4
  %tobool3 = icmp ne i32 %8, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  br label %out

if.end5:                                          ; preds = %if.end
  %9 = load i32* %old_vfs, align 4
  %tobool6 = icmp ne i32 %9, 0
  br i1 %tobool6, label %if.then7, label %if.else

if.then7:                                         ; preds = %if.end5
  %10 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %10, i32 0, i32 33
  %11 = load i32* %old_vfs, align 4
  %12 = load i32* @max_vfs, align 4
  %call8 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([61 x i8]* @.str43, i32 0, i32 0), i32 %11, i32 %12) noredzone
  %13 = load i32* %old_vfs, align 4
  %14 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 49
  store i32 %13, i32* %vfs_allocated_count, align 4
  br label %if.end10

if.else:                                          ; preds = %if.end5
  %15 = load i32* %num_vfs.addr, align 4
  %16 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count9 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 49
  store i32 %15, i32* %vfs_allocated_count9, align 4
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then7
  %17 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count11 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 49
  %18 = load i32* %vfs_allocated_count11, align 4
  %conv = zext i32 %18 to i64
  %call12 = call i8* @kcalloc(i64 %conv, i64 96, i32 208) noredzone
  %19 = bitcast i8* %call12 to %struct.vf_data_storage*
  %20 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 50
  store %struct.vf_data_storage* %19, %struct.vf_data_storage** %vf_data, align 8
  %21 = load %struct.igb_adapter** %adapter, align 8
  %vf_data13 = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 50
  %22 = load %struct.vf_data_storage** %vf_data13, align 8
  %tobool14 = icmp ne %struct.vf_data_storage* %22, null
  br i1 %tobool14, label %if.end19, label %if.then15

if.then15:                                        ; preds = %if.end10
  %23 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count16 = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 49
  store i32 0, i32* %vfs_allocated_count16, align 4
  %24 = load %struct.pci_dev** %pdev.addr, align 8
  %dev17 = getelementptr inbounds %struct.pci_dev* %24, i32 0, i32 33
  %call18 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev17, i8* getelementptr inbounds ([47 x i8]* @.str44, i32 0, i32 0)) noredzone
  store i32 -12, i32* %err, align 4
  br label %out

if.end19:                                         ; preds = %if.end10
  %25 = load i32* %old_vfs, align 4
  %tobool20 = icmp ne i32 %25, 0
  br i1 %tobool20, label %if.end27, label %if.then21

if.then21:                                        ; preds = %if.end19
  %26 = load %struct.pci_dev** %pdev.addr, align 8
  %27 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count22 = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 49
  %28 = load i32* %vfs_allocated_count22, align 4
  %call23 = call i32 @pci_enable_sriov(%struct.pci_dev* %26, i32 %28) noredzone
  store i32 %call23, i32* %err, align 4
  %29 = load i32* %err, align 4
  %tobool24 = icmp ne i32 %29, 0
  br i1 %tobool24, label %if.then25, label %if.end26

if.then25:                                        ; preds = %if.then21
  br label %err_out

if.end26:                                         ; preds = %if.then21
  br label %if.end27

if.end27:                                         ; preds = %if.end26, %if.end19
  %30 = load %struct.pci_dev** %pdev.addr, align 8
  %dev28 = getelementptr inbounds %struct.pci_dev* %30, i32 0, i32 33
  %31 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count29 = getelementptr inbounds %struct.igb_adapter* %31, i32 0, i32 49
  %32 = load i32* %vfs_allocated_count29, align 4
  %call30 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev28, i8* getelementptr inbounds ([18 x i8]* @.str45, i32 0, i32 0), i32 %32) noredzone
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end27
  %33 = load i32* %i, align 4
  %34 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count31 = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 49
  %35 = load i32* %vfs_allocated_count31, align 4
  %cmp32 = icmp ult i32 %33, %35
  br i1 %cmp32, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %36 = load %struct.igb_adapter** %adapter, align 8
  %37 = load i32* %i, align 4
  %call34 = call i32 @igb_vf_configure(%struct.igb_adapter* %36, i32 %37) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %38 = load i32* %i, align 4
  %inc = add i32 %38, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %39 = load %struct.igb_adapter** %adapter, align 8
  %flags35 = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 3
  %40 = load i32* %flags35, align 4
  %and36 = and i32 %40, -17
  store i32 %and36, i32* %flags35, align 4
  br label %out

err_out:                                          ; preds = %if.then25
  %41 = load %struct.igb_adapter** %adapter, align 8
  %vf_data37 = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 50
  %42 = load %struct.vf_data_storage** %vf_data37, align 8
  %43 = bitcast %struct.vf_data_storage* %42 to i8*
  call void @kfree(i8* %43) noredzone
  %44 = load %struct.igb_adapter** %adapter, align 8
  %vf_data38 = getelementptr inbounds %struct.igb_adapter* %44, i32 0, i32 50
  store %struct.vf_data_storage* null, %struct.vf_data_storage** %vf_data38, align 8
  %45 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count39 = getelementptr inbounds %struct.igb_adapter* %45, i32 0, i32 49
  store i32 0, i32* %vfs_allocated_count39, align 4
  br label %out

out:                                              ; preds = %err_out, %for.end, %if.then15, %if.then4, %if.then
  %46 = load i32* %err, align 4
  ret i32 %46
}

define internal i32 @igb_sriov_reinit(%struct.pci_dev* %dev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.pci_dev*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  store %struct.pci_dev* %dev, %struct.pci_dev** %dev.addr, align 8
  %0 = load %struct.pci_dev** %dev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %pdev2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 32
  %5 = load %struct.pci_dev** %pdev2, align 8
  store %struct.pci_dev* %5, %struct.pci_dev** %pdev, align 8
  call void @rtnl_lock() noredzone
  %6 = load %struct.net_device** %netdev, align 8
  %call3 = call zeroext i1 @netif_running(%struct.net_device* %6) noredzone
  br i1 %call3, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %7 = load %struct.net_device** %netdev, align 8
  %call4 = call i32 @igb_close(%struct.net_device* %7) noredzone
  br label %if.end

if.else:                                          ; preds = %entry
  %8 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %8) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %9 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_clear_interrupt_scheme(%struct.igb_adapter* %9) noredzone
  %10 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_init_queue_configuration(%struct.igb_adapter* %10) noredzone
  %11 = load %struct.igb_adapter** %adapter, align 8
  %call5 = call i32 @igb_init_interrupt_scheme(%struct.igb_adapter* %11, i1 zeroext true) noredzone
  %tobool = icmp ne i32 %call5, 0
  br i1 %tobool, label %if.then6, label %if.end9

if.then6:                                         ; preds = %if.end
  %12 = load %struct.pci_dev** %pdev, align 8
  %dev7 = getelementptr inbounds %struct.pci_dev* %12, i32 0, i32 33
  %call8 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev7, i8* getelementptr inbounds ([38 x i8]* @.str11, i32 0, i32 0)) noredzone
  store i32 -12, i32* %retval
  br label %return

if.end9:                                          ; preds = %if.end
  %13 = load %struct.net_device** %netdev, align 8
  %call10 = call zeroext i1 @netif_running(%struct.net_device* %13) noredzone
  br i1 %call10, label %if.then11, label %if.end13

if.then11:                                        ; preds = %if.end9
  %14 = load %struct.net_device** %netdev, align 8
  %call12 = call i32 @igb_open(%struct.net_device* %14) noredzone
  br label %if.end13

if.end13:                                         ; preds = %if.then11, %if.end9
  call void @rtnl_unlock() noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end13, %if.then6
  %15 = load i32* %retval
  ret i32 %15
}

define internal void @igb_init_queue_configuration(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %max_rss_queues = alloca i32, align 4
  %__min1 = alloca i32, align 4
  %__min2 = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %2 = load i32* %type, align 4
  switch i32 %2, label %sw.default [
    i32 7, label %sw.bb
    i32 1, label %sw.bb2
    i32 6, label %sw.bb2
    i32 4, label %sw.bb3
    i32 2, label %sw.bb4
    i32 3, label %sw.bb9
    i32 5, label %sw.bb9
  ]

sw.bb:                                            ; preds = %entry
  store i32 2, i32* %max_rss_queues, align 4
  br label %sw.epilog

sw.bb2:                                           ; preds = %entry, %entry
  store i32 4, i32* %max_rss_queues, align 4
  br label %sw.epilog

sw.bb3:                                           ; preds = %entry
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb3
  store i32 1, i32* %max_rss_queues, align 4
  br label %sw.epilog

if.end:                                           ; preds = %sw.bb3
  br label %sw.bb4

sw.bb4:                                           ; preds = %entry, %if.end
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count5 = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 49
  %6 = load i32* %vfs_allocated_count5, align 4
  %tobool6 = icmp ne i32 %6, 0
  br i1 %tobool6, label %if.then7, label %if.end8

if.then7:                                         ; preds = %sw.bb4
  store i32 2, i32* %max_rss_queues, align 4
  br label %sw.epilog

if.end8:                                          ; preds = %sw.bb4
  br label %sw.bb9

sw.bb9:                                           ; preds = %entry, %entry, %if.end8
  br label %sw.default

sw.default:                                       ; preds = %entry, %sw.bb9
  store i32 8, i32* %max_rss_queues, align 4
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.then7, %if.then, %sw.bb2, %sw.bb
  %7 = load i32* %max_rss_queues, align 4
  store i32 %7, i32* %__min1, align 4
  %8 = load %struct.cpumask** @cpu_online_mask, align 8
  %call = call i32 @cpumask_weight(%struct.cpumask* %8) noredzone
  store i32 %call, i32* %__min2, align 4
  %9 = load i32* %__min1, align 4
  %10 = load i32* %__min2, align 4
  %cmp = icmp ult i32 %9, %10
  br i1 %cmp, label %cond.true, label %cond.false

cond.true:                                        ; preds = %sw.epilog
  %11 = load i32* %__min1, align 4
  br label %cond.end

cond.false:                                       ; preds = %sw.epilog
  %12 = load i32* %__min2, align 4
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %11, %cond.true ], [ %12, %cond.false ]
  %13 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 52
  store i32 %cond, i32* %rss_queues, align 4
  %14 = load %struct.e1000_hw** %hw, align 8
  %mac10 = getelementptr inbounds %struct.e1000_hw* %14, i32 0, i32 4
  %type11 = getelementptr inbounds %struct.e1000_mac_info* %mac10, i32 0, i32 3
  %15 = load i32* %type11, align 4
  switch i32 %15, label %sw.default21 [
    i32 1, label %sw.bb12
    i32 7, label %sw.bb12
    i32 2, label %sw.bb13
    i32 3, label %sw.bb20
    i32 4, label %sw.bb20
    i32 5, label %sw.bb20
    i32 6, label %sw.bb20
  ]

sw.bb12:                                          ; preds = %cond.end, %cond.end
  br label %sw.epilog28

sw.bb13:                                          ; preds = %cond.end
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues14 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 52
  %17 = load i32* %rss_queues14, align 4
  %cmp15 = icmp ugt i32 %17, 1
  br i1 %cmp15, label %land.lhs.true, label %if.end19

land.lhs.true:                                    ; preds = %sw.bb13
  %18 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count16 = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 49
  %19 = load i32* %vfs_allocated_count16, align 4
  %cmp17 = icmp ugt i32 %19, 6
  br i1 %cmp17, label %if.then18, label %if.end19

if.then18:                                        ; preds = %land.lhs.true
  %20 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %20, i32 0, i32 3
  %21 = load i32* %flags, align 4
  %or = or i32 %21, 8
  store i32 %or, i32* %flags, align 4
  br label %if.end19

if.end19:                                         ; preds = %if.then18, %land.lhs.true, %sw.bb13
  br label %sw.bb20

sw.bb20:                                          ; preds = %cond.end, %cond.end, %cond.end, %cond.end, %if.end19
  br label %sw.default21

sw.default21:                                     ; preds = %cond.end, %sw.bb20
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %rss_queues22 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 52
  %23 = load i32* %rss_queues22, align 4
  %24 = load i32* %max_rss_queues, align 4
  %div = udiv i32 %24, 2
  %cmp23 = icmp ugt i32 %23, %div
  br i1 %cmp23, label %if.then24, label %if.end27

if.then24:                                        ; preds = %sw.default21
  %25 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags25 = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 3
  %26 = load i32* %flags25, align 4
  %or26 = or i32 %26, 8
  store i32 %or26, i32* %flags25, align 4
  br label %if.end27

if.end27:                                         ; preds = %if.then24, %sw.default21
  br label %sw.epilog28

sw.epilog28:                                      ; preds = %if.end27, %sw.bb12
  ret void
}

define internal i32 @cpumask_weight(%struct.cpumask* %srcp) nounwind inlinehint noredzone {
entry:
  %srcp.addr = alloca %struct.cpumask*, align 8
  store %struct.cpumask* %srcp, %struct.cpumask** %srcp.addr, align 8
  %0 = load %struct.cpumask** %srcp.addr, align 8
  %bits = getelementptr inbounds %struct.cpumask* %0, i32 0, i32 0
  %arraydecay = getelementptr inbounds [4 x i64]* %bits, i32 0, i32 0
  %call = call i32 @bitmap_weight(i64* %arraydecay, i32 256) noredzone
  ret i32 %call
}

define internal i32 @bitmap_weight(i64* %src, i32 %nbits) nounwind inlinehint noredzone {
entry:
  %src.addr = alloca i64*, align 8
  %nbits.addr = alloca i32, align 4
  store i64* %src, i64** %src.addr, align 8
  store i32 %nbits, i32* %nbits.addr, align 4
  %0 = load i64** %src.addr, align 8
  %1 = load i32* %nbits.addr, align 4
  %call = call i32 @__bitmap_weight(i64* %0, i32 %1) noredzone
  ret i32 %call
}

declare i32 @__bitmap_weight(i64*, i32) noredzone

declare i32 @pci_num_vf(%struct.pci_dev*) noredzone

define internal i8* @kcalloc(i64 %n, i64 %size, i32 %flags) nounwind inlinehint noredzone {
entry:
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64* %n.addr, align 8
  %1 = load i64* %size.addr, align 8
  %2 = load i32* %flags.addr, align 4
  %or = or i32 %2, 32768
  %call = call i8* @kmalloc_array(i64 %0, i64 %1, i32 %or) noredzone
  ret i8* %call
}

declare i32 @pci_enable_sriov(%struct.pci_dev*, i32) noredzone

define internal i32 @igb_vf_configure(%struct.igb_adapter* %adapter, i32 %vf) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %vf.addr = alloca i32, align 4
  %mac_addr = alloca [6 x i8], align 1
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %arraydecay = getelementptr inbounds [6 x i8]* %mac_addr, i32 0, i32 0
  call void @eth_zero_addr(i8* %arraydecay) noredzone
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %1 = load i32* %vf.addr, align 4
  %arraydecay1 = getelementptr inbounds [6 x i8]* %mac_addr, i32 0, i32 0
  %call = call i32 @igb_set_vf_mac(%struct.igb_adapter* %0, i32 %1, i8* %arraydecay1) noredzone
  %2 = load i32* %vf.addr, align 4
  %idxprom = sext i32 %2 to i64
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 50
  %4 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %4, i64 %idxprom
  %spoofchk_enabled = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 9
  store i8 1, i8* %spoofchk_enabled, align 1
  ret i32 0
}

define internal i8* @kmalloc_array(i64 %n, i64 %size, i32 %flags) nounwind inlinehint noredzone {
entry:
  %retval = alloca i8*, align 8
  %n.addr = alloca i64, align 8
  %size.addr = alloca i64, align 8
  %flags.addr = alloca i32, align 4
  store i64 %n, i64* %n.addr, align 8
  store i64 %size, i64* %size.addr, align 8
  store i32 %flags, i32* %flags.addr, align 4
  %0 = load i64* %size.addr, align 8
  %cmp = icmp ne i64 %0, 0
  br i1 %cmp, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %entry
  %1 = load i64* %n.addr, align 8
  %2 = load i64* %size.addr, align 8
  %div = udiv i64 -1, %2
  %cmp1 = icmp ugt i64 %1, %div
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %land.lhs.true
  store i8* null, i8** %retval
  br label %return

if.end:                                           ; preds = %land.lhs.true, %entry
  %3 = load i64* %n.addr, align 8
  %4 = load i64* %size.addr, align 8
  %mul = mul i64 %3, %4
  %5 = load i32* %flags.addr, align 4
  %call = call i8* @__kmalloc(i64 %mul, i32 %5) noredzone
  store i8* %call, i8** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %6 = load i8** %retval
  ret i8* %6
}

define internal i32 @igb_disable_sriov(%struct.pci_dev* %pdev) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %call = call i8* @pci_get_drvdata(%struct.pci_dev* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %5 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 50
  %6 = load %struct.vf_data_storage** %vf_data, align 8
  %tobool = icmp ne %struct.vf_data_storage* %6, null
  br i1 %tobool, label %if.then, label %if.end19

if.then:                                          ; preds = %entry
  %7 = load %struct.pci_dev** %pdev.addr, align 8
  %call3 = call i32 @pci_vfs_assigned(%struct.pci_dev* %7) noredzone
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then5, label %if.else

if.then5:                                         ; preds = %if.then
  %8 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %8, i32 0, i32 33
  %call6 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([98 x i8]* @.str46, i32 0, i32 0)) noredzone
  store i32 -1, i32* %retval
  br label %return

if.else:                                          ; preds = %if.then
  %9 = load %struct.pci_dev** %pdev.addr, align 8
  call void @pci_disable_sriov(%struct.pci_dev* %9) noredzone
  call void @msleep(i32 500) noredzone
  br label %if.end

if.end:                                           ; preds = %if.else
  %10 = load %struct.igb_adapter** %adapter, align 8
  %vf_data7 = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 50
  %11 = load %struct.vf_data_storage** %vf_data7, align 8
  %12 = bitcast %struct.vf_data_storage* %11 to i8*
  call void @kfree(i8* %12) noredzone
  %13 = load %struct.igb_adapter** %adapter, align 8
  %vf_data8 = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 50
  store %struct.vf_data_storage* null, %struct.vf_data_storage** %vf_data8, align 8
  %14 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 49
  store i32 0, i32* %vfs_allocated_count, align 4
  br label %do.body

do.body:                                          ; preds = %if.end
  %15 = load %struct.e1000_hw** %hw, align 8
  %hw_addr9 = getelementptr inbounds %struct.e1000_hw* %15, i32 0, i32 1
  %16 = load volatile i8** %hw_addr9, align 8
  store i8* %16, i8** %hw_addr, align 8
  %17 = load i8** %hw_addr, align 8
  %tobool10 = icmp ne i8* %17, null
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot12 = xor i1 %lnot11, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.end15, label %if.then14

if.then14:                                        ; preds = %do.body
  %18 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %18, i64 23484
  call void @writel(i32 1, i8* %arrayidx) noredzone
  br label %if.end15

if.end15:                                         ; preds = %if.then14, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end15
  %19 = load %struct.e1000_hw** %hw, align 8
  %call16 = call i32 @igb_rd32(%struct.e1000_hw* %19, i32 8) noredzone
  call void @msleep(i32 100) noredzone
  %20 = load %struct.pci_dev** %pdev.addr, align 8
  %dev17 = getelementptr inbounds %struct.pci_dev* %20, i32 0, i32 33
  %call18 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev17, i8* getelementptr inbounds ([14 x i8]* @.str32, i32 0, i32 0)) noredzone
  %21 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 3
  %22 = load i32* %flags, align 4
  %or = or i32 %22, 16
  store i32 %or, i32* %flags, align 4
  br label %if.end19

if.end19:                                         ; preds = %do.end, %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end19, %if.then5
  %23 = load i32* %retval
  ret i32 %23
}

declare i32 @pci_vfs_assigned(%struct.pci_dev*) noredzone

define internal void @pm_runtime_get_noresume(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %power = getelementptr inbounds %struct.device* %0, i32 0, i32 10
  %usage_count = getelementptr inbounds %struct.dev_pm_info* %power, i32 0, i32 12
  call void @atomic_inc(%struct.atomic_t* %usage_count) noredzone
  ret void
}

declare void @igb_sysfs_exit(%struct.igb_adapter*) noredzone

define internal void @igb_remove_i2c(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_adap = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 73
  call void @i2c_del_adapter(%struct.i2c_adapter* %i2c_adap) noredzone
  ret void
}

declare void @igb_ptp_stop(%struct.igb_adapter*) noredzone

declare zeroext i1 @cancel_work_sync(%struct.work_struct*) noredzone

declare i32 @dca_remove_requester(%struct.device*) noredzone

declare void @unregister_netdev(%struct.net_device*) noredzone

declare void @pci_iounmap(%struct.pci_dev*, i8*) noredzone

declare void @iounmap(i8*) noredzone

declare void @pci_release_selected_regions(%struct.pci_dev*, i32) noredzone

declare i32 @pci_select_bars(%struct.pci_dev*, i64) noredzone

declare void @free_netdev(%struct.net_device*) noredzone

declare i32 @pci_disable_pcie_error_reporting(%struct.pci_dev*) noredzone

declare void @i2c_del_adapter(%struct.i2c_adapter*) noredzone

declare void @warn_slowpath_fmt(i8*, i32, i8*, ...) noredzone

define internal i8* @pci_name(%struct.pci_dev* %pdev) nounwind inlinehint noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %0, i32 0, i32 33
  %call = call i8* @dev_name(%struct.device* %dev) noredzone
  ret i8* %call
}

define internal i32 @dma_set_mask_and_coherent(%struct.device* %dev, i64 %mask) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %mask.addr = alloca i64, align 8
  %rc = alloca i32, align 4
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %1 = load i64* %mask.addr, align 8
  %call = call i32 @dma_set_mask(%struct.device* %0, i64 %1) noredzone
  store i32 %call, i32* %rc, align 4
  %2 = load i32* %rc, align 4
  %cmp = icmp eq i32 %2, 0
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %3 = load %struct.device** %dev.addr, align 8
  %4 = load i64* %mask.addr, align 8
  %call1 = call i32 @dma_set_coherent_mask(%struct.device* %3, i64 %4) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %5 = load i32* %rc, align 4
  ret i32 %5
}

declare i32 @pci_request_selected_regions(%struct.pci_dev*, i32, i8*) noredzone

declare i32 @pci_enable_pcie_error_reporting(%struct.pci_dev*) noredzone

declare %struct.net_device* @alloc_etherdev_mqs(i32, i32, i32) noredzone

define internal void @pci_set_drvdata(%struct.pci_dev* %pdev, i8* %data) nounwind inlinehint noredzone {
entry:
  %pdev.addr = alloca %struct.pci_dev*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.pci_dev* %pdev, %struct.pci_dev** %pdev.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.pci_dev** %pdev.addr, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %0, i32 0, i32 33
  %1 = load i8** %data.addr, align 8
  call void @dev_set_drvdata(%struct.device* %dev, i8* %1) noredzone
  ret void
}

define internal i32 @netif_msg_init(i32 %debug_value, i32 %default_msg_enable_bits) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %debug_value.addr = alloca i32, align 4
  %default_msg_enable_bits.addr = alloca i32, align 4
  store i32 %debug_value, i32* %debug_value.addr, align 4
  store i32 %default_msg_enable_bits, i32* %default_msg_enable_bits.addr, align 4
  %0 = load i32* %debug_value.addr, align 4
  %cmp = icmp slt i32 %0, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32* %debug_value.addr, align 4
  %conv = sext i32 %1 to i64
  %cmp1 = icmp uge i64 %conv, 32
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %2 = load i32* %default_msg_enable_bits.addr, align 4
  store i32 %2, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %3 = load i32* %debug_value.addr, align 4
  %cmp3 = icmp eq i32 %3, 0
  br i1 %cmp3, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end6:                                          ; preds = %if.end
  %4 = load i32* %debug_value.addr, align 4
  %shl = shl i32 1, %4
  %sub = sub i32 %shl, 1
  store i32 %sub, i32* %retval
  br label %return

return:                                           ; preds = %if.end6, %if.then5, %if.then
  %5 = load i32* %retval
  ret i32 %5
}

declare i8* @pci_iomap(%struct.pci_dev*, i32, i64) noredzone

declare void @igb_set_ethtool_ops(%struct.net_device*) noredzone

declare i8* @strncpy(i8*, i8*, i64) noredzone

define internal i32 @igb_sw_init(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %.compoundliteral = alloca %struct.raw_spinlock, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev2 = getelementptr inbounds %struct.igb_adapter* %1, i32 0, i32 1
  %2 = load %struct.net_device** %netdev2, align 8
  store %struct.net_device* %2, %struct.net_device** %netdev, align 8
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev3 = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 32
  %4 = load %struct.pci_dev** %pdev3, align 8
  store %struct.pci_dev* %4, %struct.pci_dev** %pdev, align 8
  %5 = load %struct.pci_dev** %pdev, align 8
  %6 = load %struct.e1000_hw** %hw, align 8
  %bus = getelementptr inbounds %struct.e1000_hw* %6, i32 0, i32 8
  %pci_cmd_word = getelementptr inbounds %struct.e1000_bus_info* %bus, i32 0, i32 5
  %call = call i32 @pci_read_config_word(%struct.pci_dev* %5, i32 4, i16* %pci_cmd_word) noredzone
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring_count = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 47
  store i16 256, i16* %tx_ring_count, align 2
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring_count = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 48
  store i16 256, i16* %rx_ring_count, align 2
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_itr_setting = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 6
  store i32 3, i32* %rx_itr_setting, align 4
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_itr_setting = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 7
  store i32 3, i32* %tx_itr_setting, align 4
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_work_limit = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 10
  store i16 128, i16* %tx_work_limit, align 2
  %12 = load %struct.net_device** %netdev, align 8
  %mtu = getelementptr inbounds %struct.net_device* %12, i32 0, i32 40
  %13 = load i32* %mtu, align 4
  %add = add i32 %13, 14
  %add4 = add i32 %add, 4
  %add5 = add i32 %add4, 4
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %max_frame_size = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 16
  store i32 %add5, i32* %max_frame_size, align 4
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %min_frame_size = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 17
  store i32 64, i32* %min_frame_size, align 4
  br label %do.body

do.body:                                          ; preds = %entry
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats64_lock = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 33
  %call6 = call %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %stats64_lock) noredzone
  br label %do.body7

do.body7:                                         ; preds = %do.body
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %stats64_lock8 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 33
  %18 = getelementptr inbounds %struct.spinlock* %stats64_lock8, i32 0, i32 0
  %rlock = bitcast %union.anon.3* %18 to %struct.raw_spinlock*
  %raw_lock = getelementptr inbounds %struct.raw_spinlock* %.compoundliteral, i32 0, i32 0
  %19 = getelementptr inbounds %struct.arch_spinlock* %raw_lock, i32 0, i32 0
  %head_tail = bitcast %union.anon.4* %19 to i32*
  store i32 0, i32* %head_tail, align 4
  %20 = bitcast %struct.raw_spinlock* %rlock to i8*
  %21 = bitcast %struct.raw_spinlock* %.compoundliteral to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %20, i8* %21, i64 4, i32 4, i1 false)
  br label %do.end

do.end:                                           ; preds = %do.body7
  br label %do.end9

do.end9:                                          ; preds = %do.end
  %22 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %22, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %23 = load i32* %type, align 4
  switch i32 %23, label %sw.default [
    i32 2, label %sw.bb
    i32 4, label %sw.bb
  ]

sw.bb:                                            ; preds = %do.end9, %do.end9
  %24 = load i32* @max_vfs, align 4
  %cmp = icmp ugt i32 %24, 7
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %sw.bb
  %25 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %25, i32 0, i32 33
  %call10 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([36 x i8]* @.str149, i32 0, i32 0)) noredzone
  %26 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %26, i32 0, i32 49
  store i32 7, i32* %vfs_allocated_count, align 4
  store i32 7, i32* @max_vfs, align 4
  br label %if.end

if.else:                                          ; preds = %sw.bb
  %27 = load i32* @max_vfs, align 4
  %28 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count11 = getelementptr inbounds %struct.igb_adapter* %28, i32 0, i32 49
  store i32 %27, i32* %vfs_allocated_count11, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %29 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count12 = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 49
  %30 = load i32* %vfs_allocated_count12, align 4
  %tobool = icmp ne i32 %30, 0
  br i1 %tobool, label %if.then13, label %if.end16

if.then13:                                        ; preds = %if.end
  %31 = load %struct.pci_dev** %pdev, align 8
  %dev14 = getelementptr inbounds %struct.pci_dev* %31, i32 0, i32 33
  %call15 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev14, i8* getelementptr inbounds ([100 x i8]* @.str150, i32 0, i32 0)) noredzone
  br label %if.end16

if.end16:                                         ; preds = %if.then13, %if.end
  br label %sw.epilog

sw.default:                                       ; preds = %do.end9
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end16
  %32 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_init_queue_configuration(%struct.igb_adapter* %32) noredzone
  %call17 = call i8* @kcalloc(i64 128, i64 4, i32 32) noredzone
  %33 = bitcast i8* %call17 to i32*
  %34 = load %struct.igb_adapter** %adapter.addr, align 8
  %shadow_vfta = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 54
  store i32* %33, i32** %shadow_vfta, align 8
  %35 = load %struct.igb_adapter** %adapter.addr, align 8
  %call18 = call i32 @igb_init_interrupt_scheme(%struct.igb_adapter* %35, i1 zeroext true) noredzone
  %tobool19 = icmp ne i32 %call18, 0
  br i1 %tobool19, label %if.then20, label %if.end23

if.then20:                                        ; preds = %sw.epilog
  %36 = load %struct.pci_dev** %pdev, align 8
  %dev21 = getelementptr inbounds %struct.pci_dev* %36, i32 0, i32 33
  %call22 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev21, i8* getelementptr inbounds ([38 x i8]* @.str11, i32 0, i32 0)) noredzone
  store i32 -12, i32* %retval
  br label %return

if.end23:                                         ; preds = %sw.epilog
  %37 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_probe_vfs(%struct.igb_adapter* %37) noredzone
  %38 = load %struct.igb_adapter** %adapter.addr, align 8
  call void @igb_irq_disable(%struct.igb_adapter* %38) noredzone
  %39 = load %struct.e1000_hw** %hw, align 8
  %mac24 = getelementptr inbounds %struct.e1000_hw* %39, i32 0, i32 4
  %type25 = getelementptr inbounds %struct.e1000_mac_info* %mac24, i32 0, i32 3
  %40 = load i32* %type25, align 4
  %cmp26 = icmp uge i32 %40, 4
  br i1 %cmp26, label %if.then27, label %if.end28

if.then27:                                        ; preds = %if.end23
  %41 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %41, i32 0, i32 3
  %42 = load i32* %flags, align 4
  %and = and i32 %42, -17
  store i32 %and, i32* %flags, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.end23
  %43 = load %struct.igb_adapter** %adapter.addr, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %43, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %44 = load i64** %addr.addr.i, align 8
  %45 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %44, i64 %45, i64* %44) nounwind, !srcloc !6
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end28, %if.then20
  %46 = load i32* %retval
  ret i32 %46
}

declare i32 @igb_get_bus_info_pcie(%struct.e1000_hw*) noredzone

declare i32 @igb_check_reset_block(%struct.e1000_hw*) noredzone

declare zeroext i1 @igb_enable_mng_pass_thru(%struct.e1000_hw*) noredzone

declare void @init_timer_key(%struct.timer_list*, i32, i8*, %struct.lock_class_key*) noredzone

define internal void @igb_watchdog(i64 %data) nounwind noredzone {
entry:
  %data.addr = alloca i64, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store i64 %data, i64* %data.addr, align 8
  %0 = load i64* %data.addr, align 8
  %1 = inttoptr i64 %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_task = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 27
  %call = call zeroext i1 @schedule_work(%struct.work_struct* %watchdog_task) noredzone
  ret void
}

define internal void @igb_update_phy_info(i64 %data) nounwind noredzone {
entry:
  %data.addr = alloca i64, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store i64 %data, i64* %data.addr, align 8
  %0 = load i64* %data.addr, align 8
  %1 = inttoptr i64 %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  %call = call i32 @igb_get_phy_info(%struct.e1000_hw* %hw) noredzone
  ret void
}

define internal void @__init_work(%struct.work_struct* %work, i32 %onstack) nounwind inlinehint noredzone {
entry:
  %work.addr = alloca %struct.work_struct*, align 8
  %onstack.addr = alloca i32, align 4
  store %struct.work_struct* %work, %struct.work_struct** %work.addr, align 8
  store i32 %onstack, i32* %onstack.addr, align 4
  ret void
}

define internal void @INIT_LIST_HEAD(%struct.list_head* %list) nounwind inlinehint noredzone {
entry:
  %list.addr = alloca %struct.list_head*, align 8
  store %struct.list_head* %list, %struct.list_head** %list.addr, align 8
  %0 = load %struct.list_head** %list.addr, align 8
  %1 = load %struct.list_head** %list.addr, align 8
  %next = getelementptr inbounds %struct.list_head* %1, i32 0, i32 0
  store %struct.list_head* %0, %struct.list_head** %next, align 8
  %2 = load %struct.list_head** %list.addr, align 8
  %3 = load %struct.list_head** %list.addr, align 8
  %prev = getelementptr inbounds %struct.list_head* %3, i32 0, i32 1
  store %struct.list_head* %2, %struct.list_head** %prev, align 8
  ret void
}

define internal void @igb_reset_task(%struct.work_struct* %work) nounwind noredzone {
entry:
  %work.addr = alloca %struct.work_struct*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %__mptr = alloca %struct.work_struct*, align 8
  store %struct.work_struct* %work, %struct.work_struct** %work.addr, align 8
  %0 = load %struct.work_struct** %work.addr, align 8
  store %struct.work_struct* %0, %struct.work_struct** %__mptr, align 8
  %1 = load %struct.work_struct** %__mptr, align 8
  %2 = bitcast %struct.work_struct* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -1096
  %3 = bitcast i8* %add.ptr to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_dump(%struct.igb_adapter* %4) noredzone
  %5 = load %struct.igb_adapter** %adapter, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 1
  %6 = load %struct.net_device** %netdev, align 8
  %call = call i32 (%struct.net_device*, i8*, ...)* @netdev_err(%struct.net_device* %6, i8* getelementptr inbounds ([15 x i8]* @.str93, i32 0, i32 0)) noredzone
  %7 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reinit_locked(%struct.igb_adapter* %7) noredzone
  ret void
}

define internal void @igb_watchdog_task(%struct.work_struct* %work) nounwind noredzone {
entry:
  %nr.addr.i272 = alloca i64, align 8
  %addr.addr.i273 = alloca i64*, align 8
  %nr.addr.i270 = alloca i64, align 8
  %addr.addr.i271 = alloca i64*, align 8
  %nr.addr.i261 = alloca i64, align 8
  %addr.addr.i262 = alloca i64*, align 8
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %work.addr = alloca %struct.work_struct*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %__mptr = alloca %struct.work_struct*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %phy = alloca %struct.e1000_phy_info*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %link = alloca i32, align 4
  %i = alloca i32, align 4
  %connsw = alloca i32, align 4
  %__dummy = alloca i64, align 8
  %__dummy2 = alloca i64, align 8
  %__dummy5 = alloca i64, align 8
  %__dummy26 = alloca i64, align 8
  %ctrl = alloca i32, align 4
  %tx_ring = alloca %struct.igb_ring*, align 8
  %eics = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr210 = alloca i8*, align 8
  store %struct.work_struct* %work, %struct.work_struct** %work.addr, align 8
  %0 = load %struct.work_struct** %work.addr, align 8
  store %struct.work_struct* %0, %struct.work_struct** %__mptr, align 8
  %1 = load %struct.work_struct** %__mptr, align 8
  %2 = bitcast %struct.work_struct* %1 to i8*
  %add.ptr = getelementptr i8* %2, i64 -1128
  %3 = bitcast i8* %add.ptr to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %5 = load %struct.e1000_hw** %hw, align 8
  %phy2 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 6
  store %struct.e1000_phy_info* %phy2, %struct.e1000_phy_info** %phy, align 8
  %6 = load %struct.igb_adapter** %adapter, align 8
  %netdev3 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 1
  %7 = load %struct.net_device** %netdev3, align 8
  store %struct.net_device* %7, %struct.net_device** %netdev, align 8
  %8 = load %struct.igb_adapter** %adapter, align 8
  %call = call zeroext i1 @igb_has_link(%struct.igb_adapter* %8) noredzone
  %conv = zext i1 %call to i32
  store i32 %conv, i32* %link, align 4
  %9 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 3
  %10 = load i32* %flags, align 4
  %and = and i32 %10, 512
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end15

if.then:                                          ; preds = %entry
  %cmp = icmp eq i64* %__dummy, %__dummy2
  %conv4 = zext i1 %cmp to i32
  br i1 true, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %if.then
  %cmp7 = icmp eq i64* %__dummy5, %__dummy26
  %conv8 = zext i1 %cmp7 to i32
  br i1 true, label %land.lhs.true9, label %if.else

land.lhs.true9:                                   ; preds = %land.lhs.true
  %11 = load %struct.igb_adapter** %adapter, align 8
  %link_check_timeout = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 77
  %12 = load i64* %link_check_timeout, align 8
  %add = add i64 %12, 250
  %13 = load volatile i64* @jiffies, align 8
  %sub = sub i64 %add, %13
  %cmp10 = icmp slt i64 %sub, 0
  br i1 %cmp10, label %if.then12, label %if.else

if.then12:                                        ; preds = %land.lhs.true9
  %14 = load %struct.igb_adapter** %adapter, align 8
  %flags13 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 3
  %15 = load i32* %flags13, align 4
  %and14 = and i32 %15, -513
  store i32 %and14, i32* %flags13, align 4
  br label %if.end

if.else:                                          ; preds = %land.lhs.true9, %land.lhs.true, %if.then
  store i32 0, i32* %link, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then12
  br label %if.end15

if.end15:                                         ; preds = %if.end, %entry
  %16 = load %struct.igb_adapter** %adapter, align 8
  %flags16 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 3
  %17 = load i32* %flags16, align 4
  %and17 = and i32 %17, 4096
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %if.then19, label %if.end30

if.then19:                                        ; preds = %if.end15
  %18 = load %struct.e1000_hw** %hw, align 8
  %phy20 = getelementptr inbounds %struct.e1000_hw* %18, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy20, i32 0, i32 12
  %19 = load i32* %media_type, align 4
  %cmp21 = icmp eq i32 %19, 1
  br i1 %cmp21, label %if.then23, label %if.end29

if.then23:                                        ; preds = %if.then19
  %20 = load %struct.e1000_hw** %hw, align 8
  %call24 = call i32 @igb_rd32(%struct.e1000_hw* %20, i32 52) noredzone
  store i32 %call24, i32* %connsw, align 4
  %21 = load i32* %connsw, align 4
  %and25 = and i32 %21, 1
  %tobool26 = icmp ne i32 %and25, 0
  br i1 %tobool26, label %if.end28, label %if.then27

if.then27:                                        ; preds = %if.then23
  store i32 0, i32* %link, align 4
  br label %if.end28

if.end28:                                         ; preds = %if.then27, %if.then23
  br label %if.end29

if.end29:                                         ; preds = %if.end28, %if.then19
  br label %if.end30

if.end30:                                         ; preds = %if.end29, %if.end15
  %22 = load i32* %link, align 4
  %tobool31 = icmp ne i32 %22, 0
  br i1 %tobool31, label %if.then32, label %if.else110

if.then32:                                        ; preds = %if.end30
  %23 = load %struct.e1000_hw** %hw, align 8
  %dev_spec = getelementptr inbounds %struct.e1000_hw* %23, i32 0, i32 11
  %_82575 = bitcast %union.anon.86* %dev_spec to %struct.e1000_dev_spec_82575*
  %media_changed = getelementptr inbounds %struct.e1000_dev_spec_82575* %_82575, i32 0, i32 7
  %24 = load i8* %media_changed, align 1
  %tobool33 = trunc i8 %24 to i1
  br i1 %tobool33, label %if.then34, label %if.end39

if.then34:                                        ; preds = %if.then32
  %25 = load %struct.e1000_hw** %hw, align 8
  %dev_spec35 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 11
  %_8257536 = bitcast %union.anon.86* %dev_spec35 to %struct.e1000_dev_spec_82575*
  %media_changed37 = getelementptr inbounds %struct.e1000_dev_spec_82575* %_8257536, i32 0, i32 7
  store i8 0, i8* %media_changed37, align 1
  %26 = load %struct.igb_adapter** %adapter, align 8
  %flags38 = getelementptr inbounds %struct.igb_adapter* %26, i32 0, i32 3
  %27 = load i32* %flags38, align 4
  %or = or i32 %27, 1024
  store i32 %or, i32* %flags38, align 4
  %28 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %28) noredzone
  br label %if.end39

if.end39:                                         ; preds = %if.then34, %if.then32
  %29 = load %struct.net_device** %netdev, align 8
  %dev = getelementptr inbounds %struct.net_device* %29, i32 0, i32 103
  %parent = getelementptr inbounds %struct.device* %dev, i32 0, i32 0
  %30 = load %struct.device** %parent, align 8
  %call40 = call i32 @pm_runtime_resume(%struct.device* %30) noredzone
  %31 = load %struct.net_device** %netdev, align 8
  %call41 = call zeroext i1 @netif_carrier_ok(%struct.net_device* %31) noredzone
  br i1 %call41, label %if.end109, label %if.then42

if.then42:                                        ; preds = %if.end39
  %32 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %32, i32 0, i32 4
  %ops = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 0
  %get_speed_and_duplex = getelementptr inbounds %struct.e1000_mac_operations* %ops, i32 0, i32 7
  %33 = load i32 (%struct.e1000_hw*, i16*, i16*)** %get_speed_and_duplex, align 8
  %34 = load %struct.e1000_hw** %hw, align 8
  %35 = load %struct.igb_adapter** %adapter, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 24
  %36 = load %struct.igb_adapter** %adapter, align 8
  %link_duplex = getelementptr inbounds %struct.igb_adapter* %36, i32 0, i32 25
  %call43 = call i32 %33(%struct.e1000_hw* %34, i16* %link_speed, i16* %link_duplex) noredzone
  %37 = load %struct.e1000_hw** %hw, align 8
  %call44 = call i32 @igb_rd32(%struct.e1000_hw* %37, i32 0) noredzone
  store i32 %call44, i32* %ctrl, align 4
  %38 = load %struct.net_device** %netdev, align 8
  %39 = load %struct.net_device** %netdev, align 8
  %name = getelementptr inbounds %struct.net_device* %39, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8]* %name, i32 0, i32 0
  %40 = load %struct.igb_adapter** %adapter, align 8
  %link_speed45 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 24
  %41 = load i16* %link_speed45, align 2
  %conv46 = zext i16 %41 to i32
  %42 = load %struct.igb_adapter** %adapter, align 8
  %link_duplex47 = getelementptr inbounds %struct.igb_adapter* %42, i32 0, i32 25
  %43 = load i16* %link_duplex47, align 2
  %conv48 = zext i16 %43 to i32
  %cmp49 = icmp eq i32 %conv48, 2
  %cond = select i1 %cmp49, i8* getelementptr inbounds ([5 x i8]* @.str76, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str77, i32 0, i32 0)
  %44 = load i32* %ctrl, align 4
  %and51 = and i32 %44, 268435456
  %tobool52 = icmp ne i32 %and51, 0
  br i1 %tobool52, label %land.lhs.true53, label %cond.false

land.lhs.true53:                                  ; preds = %if.then42
  %45 = load i32* %ctrl, align 4
  %and54 = and i32 %45, 134217728
  %tobool55 = icmp ne i32 %and54, 0
  br i1 %tobool55, label %cond.true, label %cond.false

cond.true:                                        ; preds = %land.lhs.true53
  br label %cond.end64

cond.false:                                       ; preds = %land.lhs.true53, %if.then42
  %46 = load i32* %ctrl, align 4
  %and56 = and i32 %46, 134217728
  %tobool57 = icmp ne i32 %and56, 0
  br i1 %tobool57, label %cond.true58, label %cond.false59

cond.true58:                                      ; preds = %cond.false
  br label %cond.end

cond.false59:                                     ; preds = %cond.false
  %47 = load i32* %ctrl, align 4
  %and60 = and i32 %47, 268435456
  %tobool61 = icmp ne i32 %and60, 0
  %cond62 = select i1 %tobool61, i8* getelementptr inbounds ([3 x i8]* @.str80, i32 0, i32 0), i8* getelementptr inbounds ([5 x i8]* @.str81, i32 0, i32 0)
  br label %cond.end

cond.end:                                         ; preds = %cond.false59, %cond.true58
  %cond63 = phi i8* [ getelementptr inbounds ([3 x i8]* @.str79, i32 0, i32 0), %cond.true58 ], [ %cond62, %cond.false59 ]
  br label %cond.end64

cond.end64:                                       ; preds = %cond.end, %cond.true
  %cond65 = phi i8* [ getelementptr inbounds ([6 x i8]* @.str78, i32 0, i32 0), %cond.true ], [ %cond63, %cond.end ]
  %call66 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %38, i8* getelementptr inbounds ([60 x i8]* @.str75, i32 0, i32 0), i8* %arraydecay, i32 %conv46, i8* %cond, i8* %cond65) noredzone
  %48 = load %struct.igb_adapter** %adapter, align 8
  %flags67 = getelementptr inbounds %struct.igb_adapter* %48, i32 0, i32 3
  %49 = load i32* %flags67, align 4
  %and68 = and i32 %49, 16384
  %tobool69 = icmp ne i32 %and68, 0
  br i1 %tobool69, label %land.lhs.true70, label %if.end83

land.lhs.true70:                                  ; preds = %cond.end64
  %50 = load %struct.igb_adapter** %adapter, align 8
  %link_duplex71 = getelementptr inbounds %struct.igb_adapter* %50, i32 0, i32 25
  %51 = load i16* %link_duplex71, align 2
  %conv72 = zext i16 %51 to i32
  %cmp73 = icmp eq i32 %conv72, 1
  br i1 %cmp73, label %if.then75, label %if.end83

if.then75:                                        ; preds = %land.lhs.true70
  %52 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %52, i32 0, i32 32
  %53 = load %struct.pci_dev** %pdev, align 8
  %dev76 = getelementptr inbounds %struct.pci_dev* %53, i32 0, i32 33
  %call77 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev76, i8* getelementptr inbounds ([88 x i8]* @.str82, i32 0, i32 0)) noredzone
  %54 = load %struct.igb_adapter** %adapter, align 8
  %hw78 = getelementptr inbounds %struct.igb_adapter* %54, i32 0, i32 35
  %dev_spec79 = getelementptr inbounds %struct.e1000_hw* %hw78, i32 0, i32 11
  %_8257580 = bitcast %union.anon.86* %dev_spec79 to %struct.e1000_dev_spec_82575*
  %eee_disable = getelementptr inbounds %struct.e1000_dev_spec_82575* %_8257580, i32 0, i32 2
  store i8 1, i8* %eee_disable, align 1
  %55 = load %struct.igb_adapter** %adapter, align 8
  %flags81 = getelementptr inbounds %struct.igb_adapter* %55, i32 0, i32 3
  %56 = load i32* %flags81, align 4
  %and82 = and i32 %56, -16385
  store i32 %and82, i32* %flags81, align 4
  br label %if.end83

if.end83:                                         ; preds = %if.then75, %land.lhs.true70, %cond.end64
  %57 = load %struct.e1000_hw** %hw, align 8
  %call84 = call i32 @igb_check_downshift(%struct.e1000_hw* %57) noredzone
  %58 = load %struct.e1000_phy_info** %phy, align 8
  %speed_downgraded = getelementptr inbounds %struct.e1000_phy_info* %58, i32 0, i32 23
  %59 = load i8* %speed_downgraded, align 1
  %tobool85 = trunc i8 %59 to i1
  br i1 %tobool85, label %if.then86, label %if.end88

if.then86:                                        ; preds = %if.end83
  %60 = load %struct.net_device** %netdev, align 8
  %call87 = call i32 (%struct.net_device*, i8*, ...)* @netdev_warn(%struct.net_device* %60, i8* getelementptr inbounds ([41 x i8]* @.str83, i32 0, i32 0)) noredzone
  br label %if.end88

if.end88:                                         ; preds = %if.then86, %if.end83
  %61 = load %struct.e1000_hw** %hw, align 8
  %call89 = call zeroext i1 @igb_thermal_sensor_event(%struct.e1000_hw* %61, i32 2) noredzone
  br i1 %call89, label %if.then90, label %if.end92

if.then90:                                        ; preds = %if.end88
  %62 = load %struct.net_device** %netdev, align 8
  %call91 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %62, i8* getelementptr inbounds ([70 x i8]* @.str84, i32 0, i32 0)) noredzone
  br label %if.end92

if.end92:                                         ; preds = %if.then90, %if.end88
  %63 = load %struct.igb_adapter** %adapter, align 8
  %tx_timeout_factor = getelementptr inbounds %struct.igb_adapter* %63, i32 0, i32 29
  store i8 1, i8* %tx_timeout_factor, align 1
  %64 = load %struct.igb_adapter** %adapter, align 8
  %link_speed93 = getelementptr inbounds %struct.igb_adapter* %64, i32 0, i32 24
  %65 = load i16* %link_speed93, align 2
  %conv94 = zext i16 %65 to i32
  switch i32 %conv94, label %sw.epilog [
    i32 10, label %sw.bb
    i32 100, label %sw.bb96
  ]

sw.bb:                                            ; preds = %if.end92
  %66 = load %struct.igb_adapter** %adapter, align 8
  %tx_timeout_factor95 = getelementptr inbounds %struct.igb_adapter* %66, i32 0, i32 29
  store i8 14, i8* %tx_timeout_factor95, align 1
  br label %sw.epilog

sw.bb96:                                          ; preds = %if.end92
  br label %sw.epilog

sw.epilog:                                        ; preds = %if.end92, %sw.bb96, %sw.bb
  %67 = load %struct.net_device** %netdev, align 8
  call void @netif_carrier_on(%struct.net_device* %67) noredzone
  %68 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_ping_all_vfs(%struct.igb_adapter* %68) noredzone
  %69 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_check_vf_rate_limit(%struct.igb_adapter* %69) noredzone
  br i1 true, label %cond.true97, label %cond.false100

cond.true97:                                      ; preds = %sw.epilog
  %70 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %70, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %71 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %71, 63
  %shl.i = shl i64 1, %and.i
  %72 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %72, 6
  %73 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %73, i64 %shr.i
  %74 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %74
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool99 = icmp ne i32 %conv.i, 0
  br i1 %tobool99, label %if.end108, label %if.then104

cond.false100:                                    ; preds = %sw.epilog
  %75 = load %struct.igb_adapter** %adapter, align 8
  %state101 = getelementptr inbounds %struct.igb_adapter* %75, i32 0, i32 2
  %call102 = call i32 @variable_test_bit(i64 2, i64* %state101) noredzone
  %tobool103 = icmp ne i32 %call102, 0
  br i1 %tobool103, label %if.end108, label %if.then104

if.then104:                                       ; preds = %cond.false100, %cond.true97
  %76 = load %struct.igb_adapter** %adapter, align 8
  %phy_info_timer = getelementptr inbounds %struct.igb_adapter* %76, i32 0, i32 19
  %77 = load volatile i64* @jiffies, align 8
  %add105 = add i64 %77, 500
  %call106 = call i64 @round_jiffies(i64 %add105) noredzone
  %call107 = call i32 @mod_timer(%struct.timer_list* %phy_info_timer, i64 %call106) noredzone
  br label %if.end108

if.end108:                                        ; preds = %if.then104, %cond.false100, %cond.true97
  br label %if.end109

if.end109:                                        ; preds = %if.end108, %if.end39
  br label %if.end166

if.else110:                                       ; preds = %if.end30
  %78 = load %struct.net_device** %netdev, align 8
  %call111 = call zeroext i1 @netif_carrier_ok(%struct.net_device* %78) noredzone
  br i1 %call111, label %if.then112, label %if.else150

if.then112:                                       ; preds = %if.else110
  %79 = load %struct.igb_adapter** %adapter, align 8
  %link_speed113 = getelementptr inbounds %struct.igb_adapter* %79, i32 0, i32 24
  store i16 0, i16* %link_speed113, align 2
  %80 = load %struct.igb_adapter** %adapter, align 8
  %link_duplex114 = getelementptr inbounds %struct.igb_adapter* %80, i32 0, i32 25
  store i16 0, i16* %link_duplex114, align 2
  %81 = load %struct.e1000_hw** %hw, align 8
  %call115 = call zeroext i1 @igb_thermal_sensor_event(%struct.e1000_hw* %81, i32 1) noredzone
  br i1 %call115, label %if.then116, label %if.end118

if.then116:                                       ; preds = %if.then112
  %82 = load %struct.net_device** %netdev, align 8
  %call117 = call i32 (%struct.net_device*, i8*, ...)* @netdev_err(%struct.net_device* %82, i8* getelementptr inbounds ([55 x i8]* @.str85, i32 0, i32 0)) noredzone
  br label %if.end118

if.end118:                                        ; preds = %if.then116, %if.then112
  %83 = load %struct.net_device** %netdev, align 8
  %84 = load %struct.net_device** %netdev, align 8
  %name119 = getelementptr inbounds %struct.net_device* %84, i32 0, i32 0
  %arraydecay120 = getelementptr inbounds [16 x i8]* %name119, i32 0, i32 0
  %call121 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %83, i8* getelementptr inbounds ([26 x i8]* @.str86, i32 0, i32 0), i8* %arraydecay120) noredzone
  %85 = load %struct.net_device** %netdev, align 8
  call void @netif_carrier_off(%struct.net_device* %85) noredzone
  %86 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_ping_all_vfs(%struct.igb_adapter* %86) noredzone
  br i1 true, label %cond.true122, label %cond.false126

cond.true122:                                     ; preds = %if.end118
  %87 = load %struct.igb_adapter** %adapter, align 8
  %state123 = getelementptr inbounds %struct.igb_adapter* %87, i32 0, i32 2
  store i64 2, i64* %nr.addr.i261, align 8
  store i64* %state123, i64** %addr.addr.i262, align 8
  %88 = load i64* %nr.addr.i261, align 8
  %and.i263 = and i64 %88, 63
  %shl.i264 = shl i64 1, %and.i263
  %89 = load i64* %nr.addr.i261, align 8
  %shr.i265 = ashr i64 %89, 6
  %90 = load i64** %addr.addr.i262, align 8
  %arrayidx.i266 = getelementptr i64* %90, i64 %shr.i265
  %91 = load volatile i64* %arrayidx.i266, align 8
  %and1.i267 = and i64 %shl.i264, %91
  %cmp.i268 = icmp ne i64 %and1.i267, 0
  %conv.i269 = zext i1 %cmp.i268 to i32
  %tobool125 = icmp ne i32 %conv.i269, 0
  br i1 %tobool125, label %if.end135, label %if.then130

cond.false126:                                    ; preds = %if.end118
  %92 = load %struct.igb_adapter** %adapter, align 8
  %state127 = getelementptr inbounds %struct.igb_adapter* %92, i32 0, i32 2
  %call128 = call i32 @variable_test_bit(i64 2, i64* %state127) noredzone
  %tobool129 = icmp ne i32 %call128, 0
  br i1 %tobool129, label %if.end135, label %if.then130

if.then130:                                       ; preds = %cond.false126, %cond.true122
  %93 = load %struct.igb_adapter** %adapter, align 8
  %phy_info_timer131 = getelementptr inbounds %struct.igb_adapter* %93, i32 0, i32 19
  %94 = load volatile i64* @jiffies, align 8
  %add132 = add i64 %94, 500
  %call133 = call i64 @round_jiffies(i64 %add132) noredzone
  %call134 = call i32 @mod_timer(%struct.timer_list* %phy_info_timer131, i64 %call133) noredzone
  br label %if.end135

if.end135:                                        ; preds = %if.then130, %cond.false126, %cond.true122
  %95 = load %struct.igb_adapter** %adapter, align 8
  %flags136 = getelementptr inbounds %struct.igb_adapter* %95, i32 0, i32 3
  %96 = load i32* %flags136, align 4
  %and137 = and i32 %96, 4096
  %tobool138 = icmp ne i32 %and137, 0
  br i1 %tobool138, label %if.then139, label %if.end146

if.then139:                                       ; preds = %if.end135
  %97 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_check_swap_media(%struct.igb_adapter* %97) noredzone
  %98 = load %struct.igb_adapter** %adapter, align 8
  %flags140 = getelementptr inbounds %struct.igb_adapter* %98, i32 0, i32 3
  %99 = load i32* %flags140, align 4
  %and141 = and i32 %99, 1024
  %tobool142 = icmp ne i32 %and141, 0
  br i1 %tobool142, label %if.then143, label %if.end145

if.then143:                                       ; preds = %if.then139
  %100 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %100, i32 0, i32 26
  %call144 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task) noredzone
  br label %if.end260

if.end145:                                        ; preds = %if.then139
  br label %if.end146

if.end146:                                        ; preds = %if.end145, %if.end135
  %101 = load %struct.net_device** %netdev, align 8
  %dev147 = getelementptr inbounds %struct.net_device* %101, i32 0, i32 103
  %parent148 = getelementptr inbounds %struct.device* %dev147, i32 0, i32 0
  %102 = load %struct.device** %parent148, align 8
  %call149 = call i32 @pm_schedule_suspend(%struct.device* %102, i32 5000) noredzone
  br label %if.end165

if.else150:                                       ; preds = %if.else110
  %103 = load %struct.net_device** %netdev, align 8
  %call151 = call zeroext i1 @netif_carrier_ok(%struct.net_device* %103) noredzone
  br i1 %call151, label %if.end164, label %land.lhs.true152

land.lhs.true152:                                 ; preds = %if.else150
  %104 = load %struct.igb_adapter** %adapter, align 8
  %flags153 = getelementptr inbounds %struct.igb_adapter* %104, i32 0, i32 3
  %105 = load i32* %flags153, align 4
  %and154 = and i32 %105, 4096
  %tobool155 = icmp ne i32 %and154, 0
  br i1 %tobool155, label %if.then156, label %if.end164

if.then156:                                       ; preds = %land.lhs.true152
  %106 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_check_swap_media(%struct.igb_adapter* %106) noredzone
  %107 = load %struct.igb_adapter** %adapter, align 8
  %flags157 = getelementptr inbounds %struct.igb_adapter* %107, i32 0, i32 3
  %108 = load i32* %flags157, align 4
  %and158 = and i32 %108, 1024
  %tobool159 = icmp ne i32 %and158, 0
  br i1 %tobool159, label %if.then160, label %if.end163

if.then160:                                       ; preds = %if.then156
  %109 = load %struct.igb_adapter** %adapter, align 8
  %reset_task161 = getelementptr inbounds %struct.igb_adapter* %109, i32 0, i32 26
  %call162 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task161) noredzone
  br label %if.end260

if.end163:                                        ; preds = %if.then156
  br label %if.end164

if.end164:                                        ; preds = %if.end163, %land.lhs.true152, %if.else150
  br label %if.end165

if.end165:                                        ; preds = %if.end164, %if.end146
  br label %if.end166

if.end166:                                        ; preds = %if.end165, %if.end109
  %110 = load %struct.igb_adapter** %adapter, align 8
  %stats64_lock = getelementptr inbounds %struct.igb_adapter* %110, i32 0, i32 33
  call void @spin_lock(%struct.spinlock* %stats64_lock) noredzone
  %111 = load %struct.igb_adapter** %adapter, align 8
  %112 = load %struct.igb_adapter** %adapter, align 8
  %stats64 = getelementptr inbounds %struct.igb_adapter* %112, i32 0, i32 34
  call void @igb_update_stats(%struct.igb_adapter* %111, %struct.rtnl_link_stats64* %stats64) noredzone
  %113 = load %struct.igb_adapter** %adapter, align 8
  %stats64_lock167 = getelementptr inbounds %struct.igb_adapter* %113, i32 0, i32 33
  call void @spin_unlock(%struct.spinlock* %stats64_lock167) noredzone
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end166
  %114 = load i32* %i, align 4
  %115 = load %struct.igb_adapter** %adapter, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %115, i32 0, i32 12
  %116 = load i32* %num_tx_queues, align 4
  %cmp168 = icmp slt i32 %114, %116
  br i1 %cmp168, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %117 = load i32* %i, align 4
  %idxprom = sext i32 %117 to i64
  %118 = load %struct.igb_adapter** %adapter, align 8
  %tx_ring170 = getelementptr inbounds %struct.igb_adapter* %118, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring170, i32 0, i64 %idxprom
  %119 = load %struct.igb_ring** %arrayidx, align 8
  store %struct.igb_ring* %119, %struct.igb_ring** %tx_ring, align 8
  %120 = load %struct.net_device** %netdev, align 8
  %call171 = call zeroext i1 @netif_carrier_ok(%struct.net_device* %120) noredzone
  br i1 %call171, label %if.end182, label %if.then172

if.then172:                                       ; preds = %for.body
  %121 = load %struct.igb_ring** %tx_ring, align 8
  %call173 = call i32 @igb_desc_unused(%struct.igb_ring* %121) noredzone
  %add174 = add i32 %call173, 1
  %122 = load %struct.igb_ring** %tx_ring, align 8
  %count = getelementptr inbounds %struct.igb_ring* %122, i32 0, i32 9
  %123 = load i16* %count, align 2
  %conv175 = zext i16 %123 to i32
  %cmp176 = icmp slt i32 %add174, %conv175
  br i1 %cmp176, label %if.then178, label %if.end181

if.then178:                                       ; preds = %if.then172
  %124 = load %struct.igb_adapter** %adapter, align 8
  %tx_timeout_count = getelementptr inbounds %struct.igb_adapter* %124, i32 0, i32 11
  %125 = load i32* %tx_timeout_count, align 4
  %inc = add i32 %125, 1
  store i32 %inc, i32* %tx_timeout_count, align 4
  %126 = load %struct.igb_adapter** %adapter, align 8
  %reset_task179 = getelementptr inbounds %struct.igb_adapter* %126, i32 0, i32 26
  %call180 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task179) noredzone
  br label %if.end260

if.end181:                                        ; preds = %if.then172
  br label %if.end182

if.end182:                                        ; preds = %if.end181, %for.body
  %127 = load %struct.igb_ring** %tx_ring, align 8
  %flags183 = getelementptr inbounds %struct.igb_ring* %127, i32 0, i32 5
  store i64 3, i64* %nr.addr.i270, align 8
  store i64* %flags183, i64** %addr.addr.i271, align 8
  %128 = load i64** %addr.addr.i271, align 8
  %129 = load i64* %nr.addr.i270, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; bts $1,$0", "=*m,Ir,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i64* %128, i64 %129, i64* %128) nounwind, !srcloc !6
  br label %for.inc

for.inc:                                          ; preds = %if.end182
  %130 = load i32* %i, align 4
  %inc184 = add i32 %130, 1
  store i32 %inc184, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %131 = load %struct.igb_adapter** %adapter, align 8
  %flags185 = getelementptr inbounds %struct.igb_adapter* %131, i32 0, i32 3
  %132 = load i32* %flags185, align 4
  %and186 = and i32 %132, 8192
  %tobool187 = icmp ne i32 %and186, 0
  br i1 %tobool187, label %if.then188, label %if.else208

if.then188:                                       ; preds = %for.end
  store i32 0, i32* %eics, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond189

for.cond189:                                      ; preds = %for.inc196, %if.then188
  %133 = load i32* %i, align 4
  %134 = load %struct.igb_adapter** %adapter, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %134, i32 0, i32 4
  %135 = load i32* %num_q_vectors, align 4
  %cmp190 = icmp ult i32 %133, %135
  br i1 %cmp190, label %for.body192, label %for.end198

for.body192:                                      ; preds = %for.cond189
  %136 = load i32* %i, align 4
  %idxprom193 = sext i32 %136 to i64
  %137 = load %struct.igb_adapter** %adapter, align 8
  %q_vector = getelementptr inbounds %struct.igb_adapter* %137, i32 0, i32 44
  %arrayidx194 = getelementptr [8 x %struct.igb_q_vector*]* %q_vector, i32 0, i64 %idxprom193
  %138 = load %struct.igb_q_vector** %arrayidx194, align 8
  %eims_value = getelementptr inbounds %struct.igb_q_vector* %138, i32 0, i32 2
  %139 = load i32* %eims_value, align 4
  %140 = load i32* %eics, align 4
  %or195 = or i32 %140, %139
  store i32 %or195, i32* %eics, align 4
  br label %for.inc196

for.inc196:                                       ; preds = %for.body192
  %141 = load i32* %i, align 4
  %inc197 = add i32 %141, 1
  store i32 %inc197, i32* %i, align 4
  br label %for.cond189

for.end198:                                       ; preds = %for.cond189
  br label %do.body

do.body:                                          ; preds = %for.end198
  %142 = load %struct.e1000_hw** %hw, align 8
  %hw_addr199 = getelementptr inbounds %struct.e1000_hw* %142, i32 0, i32 1
  %143 = load volatile i8** %hw_addr199, align 8
  store i8* %143, i8** %hw_addr, align 8
  %144 = load i8** %hw_addr, align 8
  %tobool200 = icmp ne i8* %144, null
  %lnot = xor i1 %tobool200, true
  %lnot201 = xor i1 %lnot, true
  %lnot202 = xor i1 %lnot201, true
  %lnot.ext = zext i1 %lnot202 to i32
  %conv203 = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv203, i64 0)
  %tobool204 = icmp ne i64 %expval, 0
  br i1 %tobool204, label %if.end207, label %if.then205

if.then205:                                       ; preds = %do.body
  %145 = load i32* %eics, align 4
  %146 = load i8** %hw_addr, align 8
  %arrayidx206 = getelementptr i8* %146, i64 5408
  call void @writel(i32 %145, i8* %arrayidx206) noredzone
  br label %if.end207

if.end207:                                        ; preds = %if.then205, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end207
  br label %if.end226

if.else208:                                       ; preds = %for.end
  br label %do.body209

do.body209:                                       ; preds = %if.else208
  %147 = load %struct.e1000_hw** %hw, align 8
  %hw_addr211 = getelementptr inbounds %struct.e1000_hw* %147, i32 0, i32 1
  %148 = load volatile i8** %hw_addr211, align 8
  store i8* %148, i8** %hw_addr210, align 8
  %149 = load i8** %hw_addr210, align 8
  %tobool212 = icmp ne i8* %149, null
  %lnot213 = xor i1 %tobool212, true
  %lnot215 = xor i1 %lnot213, true
  %lnot217 = xor i1 %lnot215, true
  %lnot.ext218 = zext i1 %lnot217 to i32
  %conv219 = sext i32 %lnot.ext218 to i64
  %expval220 = call i64 @llvm.expect.i64(i64 %conv219, i64 0)
  %tobool221 = icmp ne i64 %expval220, 0
  br i1 %tobool221, label %if.end224, label %if.then222

if.then222:                                       ; preds = %do.body209
  %150 = load i8** %hw_addr210, align 8
  %arrayidx223 = getelementptr i8* %150, i64 200
  call void @writel(i32 16, i8* %arrayidx223) noredzone
  br label %if.end224

if.end224:                                        ; preds = %if.then222, %do.body209
  br label %do.end225

do.end225:                                        ; preds = %if.end224
  br label %if.end226

if.end226:                                        ; preds = %do.end225, %do.end
  %151 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_spoof_check(%struct.igb_adapter* %151) noredzone
  %152 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_ptp_rx_hang(%struct.igb_adapter* %152) noredzone
  %153 = load %struct.igb_adapter** %adapter, align 8
  %hw227 = getelementptr inbounds %struct.igb_adapter* %153, i32 0, i32 35
  %mac228 = getelementptr inbounds %struct.e1000_hw* %hw227, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac228, i32 0, i32 3
  %154 = load i32* %type, align 4
  %cmp229 = icmp eq i32 %154, 4
  br i1 %cmp229, label %if.then236, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end226
  %155 = load %struct.igb_adapter** %adapter, align 8
  %hw231 = getelementptr inbounds %struct.igb_adapter* %155, i32 0, i32 35
  %mac232 = getelementptr inbounds %struct.e1000_hw* %hw231, i32 0, i32 4
  %type233 = getelementptr inbounds %struct.e1000_mac_info* %mac232, i32 0, i32 3
  %156 = load i32* %type233, align 4
  %cmp234 = icmp eq i32 %156, 5
  br i1 %cmp234, label %if.then236, label %if.end237

if.then236:                                       ; preds = %lor.lhs.false, %if.end226
  %157 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_check_lvmmc(%struct.igb_adapter* %157) noredzone
  br label %if.end237

if.end237:                                        ; preds = %if.then236, %lor.lhs.false
  br i1 true, label %cond.true238, label %cond.false242

cond.true238:                                     ; preds = %if.end237
  %158 = load %struct.igb_adapter** %adapter, align 8
  %state239 = getelementptr inbounds %struct.igb_adapter* %158, i32 0, i32 2
  store i64 2, i64* %nr.addr.i272, align 8
  store i64* %state239, i64** %addr.addr.i273, align 8
  %159 = load i64* %nr.addr.i272, align 8
  %and.i274 = and i64 %159, 63
  %shl.i275 = shl i64 1, %and.i274
  %160 = load i64* %nr.addr.i272, align 8
  %shr.i276 = ashr i64 %160, 6
  %161 = load i64** %addr.addr.i273, align 8
  %arrayidx.i277 = getelementptr i64* %161, i64 %shr.i276
  %162 = load volatile i64* %arrayidx.i277, align 8
  %and1.i278 = and i64 %shl.i275, %162
  %cmp.i279 = icmp ne i64 %and1.i278, 0
  %conv.i280 = zext i1 %cmp.i279 to i32
  %tobool241 = icmp ne i32 %conv.i280, 0
  br i1 %tobool241, label %if.end260, label %if.then246

cond.false242:                                    ; preds = %if.end237
  %163 = load %struct.igb_adapter** %adapter, align 8
  %state243 = getelementptr inbounds %struct.igb_adapter* %163, i32 0, i32 2
  %call244 = call i32 @variable_test_bit(i64 2, i64* %state243) noredzone
  %tobool245 = icmp ne i32 %call244, 0
  br i1 %tobool245, label %if.end260, label %if.then246

if.then246:                                       ; preds = %cond.false242, %cond.true238
  %164 = load %struct.igb_adapter** %adapter, align 8
  %flags247 = getelementptr inbounds %struct.igb_adapter* %164, i32 0, i32 3
  %165 = load i32* %flags247, align 4
  %and248 = and i32 %165, 512
  %tobool249 = icmp ne i32 %and248, 0
  br i1 %tobool249, label %if.then250, label %if.else254

if.then250:                                       ; preds = %if.then246
  %166 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer = getelementptr inbounds %struct.igb_adapter* %166, i32 0, i32 18
  %167 = load volatile i64* @jiffies, align 8
  %add251 = add i64 %167, 250
  %call252 = call i64 @round_jiffies(i64 %add251) noredzone
  %call253 = call i32 @mod_timer(%struct.timer_list* %watchdog_timer, i64 %call252) noredzone
  br label %if.end259

if.else254:                                       ; preds = %if.then246
  %168 = load %struct.igb_adapter** %adapter, align 8
  %watchdog_timer255 = getelementptr inbounds %struct.igb_adapter* %168, i32 0, i32 18
  %169 = load volatile i64* @jiffies, align 8
  %add256 = add i64 %169, 500
  %call257 = call i64 @round_jiffies(i64 %add256) noredzone
  %call258 = call i32 @mod_timer(%struct.timer_list* %watchdog_timer255, i64 %call257) noredzone
  br label %if.end259

if.end259:                                        ; preds = %if.else254, %if.then250
  br label %if.end260

if.end260:                                        ; preds = %if.then143, %if.then160, %if.then178, %if.end259, %cond.false242, %cond.true238
  ret void
}

declare i32 @igb_validate_mdi_setting(%struct.e1000_hw*) noredzone

define internal zeroext i1 @device_can_wakeup(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %power = getelementptr inbounds %struct.device* %0, i32 0, i32 10
  %1 = bitcast %struct.dev_pm_info* %power to i8*
  %bf.field.offs = getelementptr i8* %1, i32 4
  %2 = bitcast i8* %bf.field.offs to i32*
  %3 = load i32* %2, align 4
  %bf.clear = and i32 %3, 1
  %tobool = icmp ne i32 %bf.clear, 0
  ret i1 %tobool
}

declare i32 @device_set_wakeup_enable(%struct.device*, i1 zeroext) noredzone

define internal i32 @igb_init_i2c(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %status = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i32 0, i32* %status, align 4
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %1 = load i32* %type, align 4
  %cmp = icmp ne i32 %1, 4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_adap = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 73
  %owner = getelementptr inbounds %struct.i2c_adapter* %i2c_adap, i32 0, i32 0
  store %struct.module* @__this_module, %struct.module** %owner, align 8
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_algo = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 72
  %4 = bitcast %struct.i2c_algo_bit_data* %i2c_algo to i8*
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %4, i8* bitcast (%struct.i2c_algo_bit_data* @igb_i2c_algo to i8*), i64 64, i32 8, i1 false)
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %6 = bitcast %struct.igb_adapter* %5 to i8*
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_algo1 = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 72
  %data = getelementptr inbounds %struct.i2c_algo_bit_data* %i2c_algo1, i32 0, i32 0
  store i8* %6, i8** %data, align 8
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_algo2 = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 72
  %9 = bitcast %struct.i2c_algo_bit_data* %i2c_algo2 to i8*
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_adap3 = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 73
  %algo_data = getelementptr inbounds %struct.i2c_adapter* %i2c_adap3, i32 0, i32 3
  store i8* %9, i8** %algo_data, align 8
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 32
  %12 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %12, i32 0, i32 33
  %13 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_adap4 = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 73
  %dev5 = getelementptr inbounds %struct.i2c_adapter* %i2c_adap4, i32 0, i32 7
  %parent = getelementptr inbounds %struct.device* %dev5, i32 0, i32 0
  store %struct.device* %dev, %struct.device** %parent, align 8
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_adap6 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 73
  %name = getelementptr inbounds %struct.i2c_adapter* %i2c_adap6, i32 0, i32 9
  %arraydecay = getelementptr inbounds [48 x i8]* %name, i32 0, i32 0
  %call = call i64 @strlcpy(i8* %arraydecay, i8* getelementptr inbounds ([7 x i8]* @.str74, i32 0, i32 0), i64 48) noredzone
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %i2c_adap7 = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 73
  %call8 = call i32 @i2c_bit_add_bus(%struct.i2c_adapter* %i2c_adap7) noredzone
  store i32 %call8, i32* %status, align 4
  %16 = load i32* %status, align 4
  store i32 %16, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %17 = load i32* %retval
  ret i32 %17
}

declare i8* @strcpy(i8*, i8*) noredzone

declare i32 @register_netdev(%struct.net_device*) noredzone

declare i32 @dca_add_requester(%struct.device*) noredzone

declare i32 @igb_sysfs_init(%struct.igb_adapter*) noredzone

define internal void @igb_init_mas(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %eeprom_data = alloca i16, align 2
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %nvm = getelementptr inbounds %struct.e1000_hw* %1, i32 0, i32 7
  %ops = getelementptr inbounds %struct.e1000_nvm_info* %nvm, i32 0, i32 0
  %read = getelementptr inbounds %struct.e1000_nvm_operations* %ops, i32 0, i32 1
  %2 = load i32 (%struct.e1000_hw*, i16, i16, i16*)** %read, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 %2(%struct.e1000_hw* %3, i16 zeroext 3, i16 zeroext 1, i16* %eeprom_data) noredzone
  %4 = load %struct.e1000_hw** %hw, align 8
  %bus = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 8
  %func = getelementptr inbounds %struct.e1000_bus_info* %bus, i32 0, i32 4
  %5 = load i16* %func, align 2
  %conv = zext i16 %5 to i32
  switch i32 %conv, label %sw.default [
    i32 0, label %sw.bb
    i32 1, label %sw.bb7
    i32 2, label %sw.bb20
    i32 3, label %sw.bb33
  ]

sw.bb:                                            ; preds = %entry
  %6 = load i16* %eeprom_data, align 2
  %conv2 = zext i16 %6 to i32
  %and = and i32 %conv2, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 3
  %8 = load i32* %flags, align 4
  %or = or i32 %8, 4096
  store i32 %or, i32* %flags, align 4
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 1
  %10 = load %struct.net_device** %netdev, align 8
  %11 = load %struct.e1000_hw** %hw, align 8
  %bus3 = getelementptr inbounds %struct.e1000_hw* %11, i32 0, i32 8
  %func4 = getelementptr inbounds %struct.e1000_bus_info* %bus3, i32 0, i32 4
  %12 = load i16* %func4, align 2
  %conv5 = zext i16 %12 to i32
  %call6 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %10, i8* getelementptr inbounds ([43 x i8]* @.str72, i32 0, i32 0), i32 %conv5) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %sw.bb
  br label %sw.epilog

sw.bb7:                                           ; preds = %entry
  %13 = load i16* %eeprom_data, align 2
  %conv8 = zext i16 %13 to i32
  %and9 = and i32 %conv8, 2
  %tobool10 = icmp ne i32 %and9, 0
  br i1 %tobool10, label %if.then11, label %if.end19

if.then11:                                        ; preds = %sw.bb7
  %14 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags12 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 3
  %15 = load i32* %flags12, align 4
  %or13 = or i32 %15, 4096
  store i32 %or13, i32* %flags12, align 4
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev14 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 1
  %17 = load %struct.net_device** %netdev14, align 8
  %18 = load %struct.e1000_hw** %hw, align 8
  %bus15 = getelementptr inbounds %struct.e1000_hw* %18, i32 0, i32 8
  %func16 = getelementptr inbounds %struct.e1000_bus_info* %bus15, i32 0, i32 4
  %19 = load i16* %func16, align 2
  %conv17 = zext i16 %19 to i32
  %call18 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %17, i8* getelementptr inbounds ([43 x i8]* @.str72, i32 0, i32 0), i32 %conv17) noredzone
  br label %if.end19

if.end19:                                         ; preds = %if.then11, %sw.bb7
  br label %sw.epilog

sw.bb20:                                          ; preds = %entry
  %20 = load i16* %eeprom_data, align 2
  %conv21 = zext i16 %20 to i32
  %and22 = and i32 %conv21, 4
  %tobool23 = icmp ne i32 %and22, 0
  br i1 %tobool23, label %if.then24, label %if.end32

if.then24:                                        ; preds = %sw.bb20
  %21 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags25 = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 3
  %22 = load i32* %flags25, align 4
  %or26 = or i32 %22, 4096
  store i32 %or26, i32* %flags25, align 4
  %23 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev27 = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 1
  %24 = load %struct.net_device** %netdev27, align 8
  %25 = load %struct.e1000_hw** %hw, align 8
  %bus28 = getelementptr inbounds %struct.e1000_hw* %25, i32 0, i32 8
  %func29 = getelementptr inbounds %struct.e1000_bus_info* %bus28, i32 0, i32 4
  %26 = load i16* %func29, align 2
  %conv30 = zext i16 %26 to i32
  %call31 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %24, i8* getelementptr inbounds ([43 x i8]* @.str72, i32 0, i32 0), i32 %conv30) noredzone
  br label %if.end32

if.end32:                                         ; preds = %if.then24, %sw.bb20
  br label %sw.epilog

sw.bb33:                                          ; preds = %entry
  %27 = load i16* %eeprom_data, align 2
  %conv34 = zext i16 %27 to i32
  %and35 = and i32 %conv34, 8
  %tobool36 = icmp ne i32 %and35, 0
  br i1 %tobool36, label %if.then37, label %if.end45

if.then37:                                        ; preds = %sw.bb33
  %28 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags38 = getelementptr inbounds %struct.igb_adapter* %28, i32 0, i32 3
  %29 = load i32* %flags38, align 4
  %or39 = or i32 %29, 4096
  store i32 %or39, i32* %flags38, align 4
  %30 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev40 = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 1
  %31 = load %struct.net_device** %netdev40, align 8
  %32 = load %struct.e1000_hw** %hw, align 8
  %bus41 = getelementptr inbounds %struct.e1000_hw* %32, i32 0, i32 8
  %func42 = getelementptr inbounds %struct.e1000_bus_info* %bus41, i32 0, i32 4
  %33 = load i16* %func42, align 2
  %conv43 = zext i16 %33 to i32
  %call44 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %31, i8* getelementptr inbounds ([43 x i8]* @.str72, i32 0, i32 0), i32 %conv43) noredzone
  br label %if.end45

if.end45:                                         ; preds = %if.then37, %sw.bb33
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %34 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev46 = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 1
  %35 = load %struct.net_device** %netdev46, align 8
  %call47 = call i32 (%struct.net_device*, i8*, ...)* @netdev_err(%struct.net_device* %35, i8* getelementptr inbounds ([44 x i8]* @.str73, i32 0, i32 0)) noredzone
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %if.end45, %if.end32, %if.end19, %if.end
  ret void
}

declare void @igb_ptp_init(%struct.igb_adapter*) noredzone

declare i32 @igb_read_part_string(%struct.e1000_hw*, i8*, i32) noredzone

define internal void @pm_runtime_put_noidle(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %power = getelementptr inbounds %struct.device* %0, i32 0, i32 10
  %usage_count = getelementptr inbounds %struct.dev_pm_info* %power, i32 0, i32 12
  %call = call i32 @atomic_add_unless(%struct.atomic_t* %usage_count, i32 -1, i32 0) noredzone
  ret void
}

define internal i32 @atomic_add_unless(%struct.atomic_t* %v, i32 %a, i32 %u) nounwind inlinehint noredzone {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  %a.addr = alloca i32, align 4
  %u.addr = alloca i32, align 4
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  store i32 %a, i32* %a.addr, align 4
  store i32 %u, i32* %u.addr, align 4
  %0 = load %struct.atomic_t** %v.addr, align 8
  %1 = load i32* %a.addr, align 4
  %2 = load i32* %u.addr, align 4
  %call = call i32 @__atomic_add_unless(%struct.atomic_t* %0, i32 %1, i32 %2) noredzone
  %3 = load i32* %u.addr, align 4
  %cmp = icmp ne i32 %call, %3
  %conv = zext i1 %cmp to i32
  ret i32 %conv
}

define internal i32 @__atomic_add_unless(%struct.atomic_t* %v, i32 %a, i32 %u) nounwind inlinehint noredzone {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  %a.addr = alloca i32, align 4
  %u.addr = alloca i32, align 4
  %c = alloca i32, align 4
  %old = alloca i32, align 4
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  store i32 %a, i32* %a.addr, align 4
  store i32 %u, i32* %u.addr, align 4
  %0 = load %struct.atomic_t** %v.addr, align 8
  %call = call i32 @atomic_read(%struct.atomic_t* %0) noredzone
  store i32 %call, i32* %c, align 4
  br label %for.cond

for.cond:                                         ; preds = %if.end13, %entry
  %1 = load i32* %c, align 4
  %2 = load i32* %u.addr, align 4
  %cmp = icmp eq i32 %1, %2
  %lnot = xor i1 %cmp, true
  %lnot1 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot1 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool = icmp ne i64 %expval, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.cond
  br label %for.end

if.end:                                           ; preds = %for.cond
  %3 = load %struct.atomic_t** %v.addr, align 8
  %4 = load i32* %c, align 4
  %5 = load i32* %c, align 4
  %6 = load i32* %a.addr, align 4
  %add = add i32 %5, %6
  %call2 = call i32 @atomic_cmpxchg(%struct.atomic_t* %3, i32 %4, i32 %add) noredzone
  store i32 %call2, i32* %old, align 4
  %7 = load i32* %old, align 4
  %8 = load i32* %c, align 4
  %cmp3 = icmp eq i32 %7, %8
  %lnot5 = xor i1 %cmp3, true
  %lnot7 = xor i1 %lnot5, true
  %lnot.ext8 = zext i1 %lnot7 to i32
  %conv9 = sext i32 %lnot.ext8 to i64
  %expval10 = call i64 @llvm.expect.i64(i64 %conv9, i64 1)
  %tobool11 = icmp ne i64 %expval10, 0
  br i1 %tobool11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end
  br label %for.end

if.end13:                                         ; preds = %if.end
  %9 = load i32* %old, align 4
  store i32 %9, i32* %c, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then12, %if.then
  %10 = load i32* %c, align 4
  ret i32 %10
}

define internal i32 @atomic_cmpxchg(%struct.atomic_t* %v, i32 %old, i32 %new) nounwind inlinehint noredzone {
entry:
  %v.addr = alloca %struct.atomic_t*, align 8
  %old.addr = alloca i32, align 4
  %new.addr = alloca i32, align 4
  %__ret = alloca i32, align 4
  %__old = alloca i32, align 4
  %__new = alloca i32, align 4
  %__ptr = alloca i32*, align 8
  store %struct.atomic_t* %v, %struct.atomic_t** %v.addr, align 8
  store i32 %old, i32* %old.addr, align 4
  store i32 %new, i32* %new.addr, align 4
  %0 = load i32* %old.addr, align 4
  store i32 %0, i32* %__old, align 4
  %1 = load i32* %new.addr, align 4
  store i32 %1, i32* %__new, align 4
  %2 = load %struct.atomic_t** %v.addr, align 8
  %counter = getelementptr inbounds %struct.atomic_t* %2, i32 0, i32 0
  store i32* %counter, i32** %__ptr, align 8
  %3 = load i32** %__ptr, align 8
  %4 = load i32* %__new, align 4
  %5 = load i32* %__old, align 4
  %6 = call i32 asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; cmpxchgl $2,$1", "={ax},=*m,r,0,*m,~{memory},~{dirflag},~{fpsr},~{flags}"(i32* %3, i32 %4, i32 %5, i32* %3) nounwind, !srcloc !41
  store i32 %6, i32* %__ret, align 4
  %7 = load i32* %__ret, align 4
  ret i32 %7
}

declare i64 @strlcpy(i8*, i8*, i64) noredzone

declare i32 @i2c_bit_add_bus(%struct.i2c_adapter*) noredzone

define internal void @igb_set_i2c_data(i8* %data, i32 %state) nounwind noredzone {
entry:
  %data.addr = alloca i8*, align 8
  %state.addr = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i2cctl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store i8* %data, i8** %data.addr, align 8
  store i32 %state, i32* %state.addr, align 4
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 4140) noredzone
  store i32 %call, i32* %i2cctl, align 4
  %4 = load i32* %state.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i32* %i2cctl, align 4
  %or = or i32 %5, 1024
  store i32 %or, i32* %i2cctl, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %6 = load i32* %i2cctl, align 4
  %and = and i32 %6, -1025
  store i32 %and, i32* %i2cctl, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %7 = load i32* %i2cctl, align 4
  %and2 = and i32 %7, -2049
  store i32 %and2, i32* %i2cctl, align 4
  %8 = load i32* %i2cctl, align 4
  %or3 = or i32 %8, 8192
  store i32 %or3, i32* %i2cctl, align 4
  br label %do.body

do.body:                                          ; preds = %if.end
  %9 = load %struct.e1000_hw** %hw, align 8
  %hw_addr4 = getelementptr inbounds %struct.e1000_hw* %9, i32 0, i32 1
  %10 = load volatile i8** %hw_addr4, align 8
  store i8* %10, i8** %hw_addr, align 8
  %11 = load i8** %hw_addr, align 8
  %tobool5 = icmp ne i8* %11, null
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %do.body
  %12 = load i32* %i2cctl, align 4
  %13 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %13, i64 4140
  call void @writel(i32 %12, i8* %arrayidx) noredzone
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end10
  %14 = load %struct.e1000_hw** %hw, align 8
  %call11 = call i32 @igb_rd32(%struct.e1000_hw* %14, i32 8) noredzone
  ret void
}

define internal void @igb_set_i2c_clk(i8* %data, i32 %state) nounwind noredzone {
entry:
  %data.addr = alloca i8*, align 8
  %state.addr = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i2cctl = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store i8* %data, i8** %data.addr, align 8
  store i32 %state, i32* %state.addr, align 4
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 4140) noredzone
  store i32 %call, i32* %i2cctl, align 4
  %4 = load i32* %state.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %5 = load i32* %i2cctl, align 4
  %or = or i32 %5, 512
  store i32 %or, i32* %i2cctl, align 4
  %6 = load i32* %i2cctl, align 4
  %and = and i32 %6, -8193
  store i32 %and, i32* %i2cctl, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  %7 = load i32* %i2cctl, align 4
  %and2 = and i32 %7, -513
  store i32 %and2, i32* %i2cctl, align 4
  %8 = load i32* %i2cctl, align 4
  %and3 = and i32 %8, -8193
  store i32 %and3, i32* %i2cctl, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %9 = load %struct.e1000_hw** %hw, align 8
  %hw_addr4 = getelementptr inbounds %struct.e1000_hw* %9, i32 0, i32 1
  %10 = load volatile i8** %hw_addr4, align 8
  store i8* %10, i8** %hw_addr, align 8
  %11 = load i8** %hw_addr, align 8
  %tobool5 = icmp ne i8* %11, null
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %do.body
  %12 = load i32* %i2cctl, align 4
  %13 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %13, i64 4140
  call void @writel(i32 %12, i8* %arrayidx) noredzone
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end10
  %14 = load %struct.e1000_hw** %hw, align 8
  %call11 = call i32 @igb_rd32(%struct.e1000_hw* %14, i32 8) noredzone
  ret void
}

define internal i32 @igb_get_i2c_data(i8* %data) nounwind noredzone {
entry:
  %data.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i2cctl = alloca i32, align 4
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 4140) noredzone
  store i32 %call, i32* %i2cctl, align 4
  %4 = load i32* %i2cctl, align 4
  %and = and i32 %4, 4096
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  ret i32 %lnot.ext
}

define internal i32 @igb_get_i2c_clk(i8* %data) nounwind noredzone {
entry:
  %data.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %i2cctl = alloca i32, align 4
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = bitcast i8* %0 to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 4140) noredzone
  store i32 %call, i32* %i2cctl, align 4
  %4 = load i32* %i2cctl, align 4
  %and = and i32 %4, 16384
  %tobool = icmp ne i32 %and, 0
  %lnot = xor i1 %tobool, true
  %lnot2 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot2 to i32
  ret i32 %lnot.ext
}

define internal i32 @pm_runtime_resume(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call i32 @__pm_runtime_resume(%struct.device* %0, i32 0) noredzone
  ret i32 %call
}

declare i32 @igb_check_downshift(%struct.e1000_hw*) noredzone

declare i32 @netdev_warn(%struct.net_device*, i8*, ...) noredzone

define internal zeroext i1 @igb_thermal_sensor_event(%struct.e1000_hw* %hw, i32 %event) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %event.addr = alloca i32, align 4
  %ret = alloca i8, align 1
  %ctrl_ext = alloca i32, align 4
  %thstat = alloca i32, align 4
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %event, i32* %event.addr, align 4
  store i8 0, i8* %ret, align 1
  %0 = load %struct.e1000_hw** %hw.addr, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %0, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %1 = load i32* %type, align 4
  %cmp = icmp eq i32 %1, 4
  br i1 %cmp, label %if.then, label %if.end7

if.then:                                          ; preds = %entry
  %2 = load %struct.e1000_hw** %hw.addr, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %2, i32 33040) noredzone
  store i32 %call, i32* %thstat, align 4
  %3 = load %struct.e1000_hw** %hw.addr, align 8
  %call1 = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 24) noredzone
  store i32 %call1, i32* %ctrl_ext, align 4
  %4 = load %struct.e1000_hw** %hw.addr, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %4, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %5 = load i32* %media_type, align 4
  %cmp2 = icmp eq i32 %5, 1
  br i1 %cmp2, label %land.lhs.true, label %if.end

land.lhs.true:                                    ; preds = %if.then
  %6 = load i32* %ctrl_ext, align 4
  %and = and i32 %6, 8388608
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then3

if.then3:                                         ; preds = %land.lhs.true
  %7 = load i32* %thstat, align 4
  %8 = load i32* %event.addr, align 4
  %and4 = and i32 %7, %8
  %tobool5 = icmp ne i32 %and4, 0
  %lnot = xor i1 %tobool5, true
  %lnot6 = xor i1 %lnot, true
  %frombool = zext i1 %lnot6 to i8
  store i8 %frombool, i8* %ret, align 1
  br label %if.end

if.end:                                           ; preds = %if.then3, %land.lhs.true, %if.then
  br label %if.end7

if.end7:                                          ; preds = %if.end, %entry
  %9 = load i8* %ret, align 1
  %tobool8 = trunc i8 %9 to i1
  ret i1 %tobool8
}

declare void @netif_carrier_on(%struct.net_device*) noredzone

define internal void @igb_check_vf_rate_limit(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %actual_link_speed = alloca i32, align 4
  %i = alloca i32, align 4
  %reset_rate = alloca i8, align 1
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store i8 0, i8* %reset_rate, align 1
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_rate_link_speed = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 51
  %1 = load i32* %vf_rate_link_speed, align 4
  %cmp = icmp eq i32 %1, 0
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  %mac = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %3 = load i32* %type, align 4
  %cmp1 = icmp ne i32 %3, 2
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %for.end

if.end:                                           ; preds = %lor.lhs.false
  %4 = load %struct.igb_adapter** %adapter.addr, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 24
  %5 = load i16* %link_speed, align 2
  %conv = zext i16 %5 to i32
  %call = call i32 @igb_link_mbps(i32 %conv) noredzone
  store i32 %call, i32* %actual_link_speed, align 4
  %6 = load i32* %actual_link_speed, align 4
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_rate_link_speed2 = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 51
  %8 = load i32* %vf_rate_link_speed2, align 4
  %cmp3 = icmp ne i32 %6, %8
  br i1 %cmp3, label %if.then5, label %if.end8

if.then5:                                         ; preds = %if.end
  store i8 1, i8* %reset_rate, align 1
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_rate_link_speed6 = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 51
  store i32 0, i32* %vf_rate_link_speed6, align 4
  %10 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 32
  %11 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %11, i32 0, i32 33
  %call7 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([59 x i8]* @.str92, i32 0, i32 0)) noredzone
  br label %if.end8

if.end8:                                          ; preds = %if.then5, %if.end
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end8
  %12 = load i32* %i, align 4
  %13 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 49
  %14 = load i32* %vfs_allocated_count, align 4
  %cmp9 = icmp ult i32 %12, %14
  br i1 %cmp9, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %15 = load i8* %reset_rate, align 1
  %tobool = trunc i8 %15 to i1
  br i1 %tobool, label %if.then11, label %if.end12

if.then11:                                        ; preds = %for.body
  %16 = load i32* %i, align 4
  %idxprom = sext i32 %16 to i64
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 50
  %18 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %18, i64 %idxprom
  %tx_rate = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 8
  store i16 0, i16* %tx_rate, align 2
  br label %if.end12

if.end12:                                         ; preds = %if.then11, %for.body
  %19 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw13 = getelementptr inbounds %struct.igb_adapter* %19, i32 0, i32 35
  %20 = load i32* %i, align 4
  %21 = load i32* %i, align 4
  %idxprom14 = sext i32 %21 to i64
  %22 = load %struct.igb_adapter** %adapter.addr, align 8
  %vf_data15 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 50
  %23 = load %struct.vf_data_storage** %vf_data15, align 8
  %arrayidx16 = getelementptr %struct.vf_data_storage* %23, i64 %idxprom14
  %tx_rate17 = getelementptr inbounds %struct.vf_data_storage* %arrayidx16, i32 0, i32 8
  %24 = load i16* %tx_rate17, align 2
  %conv18 = zext i16 %24 to i32
  %25 = load i32* %actual_link_speed, align 4
  call void @igb_set_vf_rate_limit(%struct.e1000_hw* %hw13, i32 %20, i32 %conv18, i32 %25) noredzone
  br label %for.inc

for.inc:                                          ; preds = %if.end12
  %26 = load i32* %i, align 4
  %inc = add i32 %26, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

declare i64 @round_jiffies(i64) noredzone

define internal void @igb_check_swap_media(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %ctrl_ext = alloca i32, align 4
  %connsw = alloca i32, align 4
  %swap_now = alloca i8, align 1
  %hw_addr = alloca i8*, align 8
  %hw_addr25 = alloca i8*, align 8
  %hw_addr63 = alloca i8*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i8 0, i8* %swap_now, align 1
  %1 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 24) noredzone
  store i32 %call, i32* %ctrl_ext, align 4
  %2 = load %struct.e1000_hw** %hw, align 8
  %call2 = call i32 @igb_rd32(%struct.e1000_hw* %2, i32 52) noredzone
  store i32 %call2, i32* %connsw, align 4
  %3 = load %struct.e1000_hw** %hw, align 8
  %phy = getelementptr inbounds %struct.e1000_hw* %3, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %4 = load i32* %media_type, align 4
  %cmp = icmp eq i32 %4, 1
  br i1 %cmp, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %entry
  %5 = load i32* %connsw, align 4
  %and = and i32 %5, 1
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.else, label %if.then

if.then:                                          ; preds = %land.lhs.true
  store i8 1, i8* %swap_now, align 1
  br label %if.end44

if.else:                                          ; preds = %land.lhs.true, %entry
  %6 = load i32* %connsw, align 4
  %and3 = and i32 %6, 512
  %tobool4 = icmp ne i32 %and3, 0
  br i1 %tobool4, label %if.end43, label %if.then5

if.then5:                                         ; preds = %if.else
  %7 = load %struct.igb_adapter** %adapter.addr, align 8
  %copper_tries = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 78
  %8 = load i32* %copper_tries, align 4
  %cmp6 = icmp slt i32 %8, 4
  br i1 %cmp6, label %if.then7, label %if.else15

if.then7:                                         ; preds = %if.then5
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %copper_tries8 = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 78
  %10 = load i32* %copper_tries8, align 4
  %inc = add i32 %10, 1
  store i32 %inc, i32* %copper_tries8, align 4
  %11 = load i32* %connsw, align 4
  %or = or i32 %11, 2
  store i32 %or, i32* %connsw, align 4
  br label %do.body

do.body:                                          ; preds = %if.then7
  %12 = load %struct.e1000_hw** %hw, align 8
  %hw_addr9 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 1
  %13 = load volatile i8** %hw_addr9, align 8
  store i8* %13, i8** %hw_addr, align 8
  %14 = load i8** %hw_addr, align 8
  %tobool10 = icmp ne i8* %14, null
  %lnot = xor i1 %tobool10, true
  %lnot11 = xor i1 %lnot, true
  %lnot12 = xor i1 %lnot11, true
  %lnot.ext = zext i1 %lnot12 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool13 = icmp ne i64 %expval, 0
  br i1 %tobool13, label %if.end, label %if.then14

if.then14:                                        ; preds = %do.body
  %15 = load i32* %connsw, align 4
  %16 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %16, i64 52
  call void @writel(i32 %15, i8* %arrayidx) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then14, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %do.end78

if.else15:                                        ; preds = %if.then5
  %17 = load %struct.igb_adapter** %adapter.addr, align 8
  %copper_tries16 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 78
  store i32 0, i32* %copper_tries16, align 4
  %18 = load i32* %connsw, align 4
  %and17 = and i32 %18, 1024
  %tobool18 = icmp ne i32 %and17, 0
  br i1 %tobool18, label %land.lhs.true19, label %if.end41

land.lhs.true19:                                  ; preds = %if.else15
  %19 = load i32* %connsw, align 4
  %and20 = and i32 %19, 2048
  %tobool21 = icmp ne i32 %and20, 0
  br i1 %tobool21, label %if.end41, label %if.then22

if.then22:                                        ; preds = %land.lhs.true19
  store i8 1, i8* %swap_now, align 1
  %20 = load i32* %connsw, align 4
  %and23 = and i32 %20, -3
  store i32 %and23, i32* %connsw, align 4
  br label %do.body24

do.body24:                                        ; preds = %if.then22
  %21 = load %struct.e1000_hw** %hw, align 8
  %hw_addr26 = getelementptr inbounds %struct.e1000_hw* %21, i32 0, i32 1
  %22 = load volatile i8** %hw_addr26, align 8
  store i8* %22, i8** %hw_addr25, align 8
  %23 = load i8** %hw_addr25, align 8
  %tobool27 = icmp ne i8* %23, null
  %lnot28 = xor i1 %tobool27, true
  %lnot30 = xor i1 %lnot28, true
  %lnot32 = xor i1 %lnot30, true
  %lnot.ext33 = zext i1 %lnot32 to i32
  %conv34 = sext i32 %lnot.ext33 to i64
  %expval35 = call i64 @llvm.expect.i64(i64 %conv34, i64 0)
  %tobool36 = icmp ne i64 %expval35, 0
  br i1 %tobool36, label %if.end39, label %if.then37

if.then37:                                        ; preds = %do.body24
  %24 = load i32* %connsw, align 4
  %25 = load i8** %hw_addr25, align 8
  %arrayidx38 = getelementptr i8* %25, i64 52
  call void @writel(i32 %24, i8* %arrayidx38) noredzone
  br label %if.end39

if.end39:                                         ; preds = %if.then37, %do.body24
  br label %do.end40

do.end40:                                         ; preds = %if.end39
  br label %if.end41

if.end41:                                         ; preds = %do.end40, %land.lhs.true19, %if.else15
  br label %if.end42

if.end42:                                         ; preds = %if.end41
  br label %if.end43

if.end43:                                         ; preds = %if.end42, %if.else
  br label %if.end44

if.end44:                                         ; preds = %if.end43, %if.then
  %26 = load i8* %swap_now, align 1
  %tobool45 = trunc i8 %26 to i1
  br i1 %tobool45, label %if.end47, label %if.then46

if.then46:                                        ; preds = %if.end44
  br label %do.end78

if.end47:                                         ; preds = %if.end44
  %27 = load %struct.e1000_hw** %hw, align 8
  %phy48 = getelementptr inbounds %struct.e1000_hw* %27, i32 0, i32 6
  %media_type49 = getelementptr inbounds %struct.e1000_phy_info* %phy48, i32 0, i32 12
  %28 = load i32* %media_type49, align 4
  switch i32 %28, label %sw.default [
    i32 1, label %sw.bb
    i32 3, label %sw.bb54
    i32 2, label %sw.bb54
  ]

sw.bb:                                            ; preds = %if.end47
  %29 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 1
  %30 = load %struct.net_device** %netdev, align 8
  %call50 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %30, i8* getelementptr inbounds ([37 x i8]* @.str89, i32 0, i32 0)) noredzone
  %31 = load i32* %ctrl_ext, align 4
  %or51 = or i32 %31, 12582912
  store i32 %or51, i32* %ctrl_ext, align 4
  %32 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %32, i32 0, i32 3
  %33 = load i32* %flags, align 4
  %or52 = or i32 %33, 1024
  store i32 %or52, i32* %flags, align 4
  %34 = load %struct.igb_adapter** %adapter.addr, align 8
  %copper_tries53 = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 78
  store i32 0, i32* %copper_tries53, align 4
  br label %sw.epilog

sw.bb54:                                          ; preds = %if.end47, %if.end47
  %35 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev55 = getelementptr inbounds %struct.igb_adapter* %35, i32 0, i32 1
  %36 = load %struct.net_device** %netdev55, align 8
  %call56 = call i32 (%struct.net_device*, i8*, ...)* @netdev_info(%struct.net_device* %36, i8* getelementptr inbounds ([31 x i8]* @.str90, i32 0, i32 0)) noredzone
  %37 = load i32* %ctrl_ext, align 4
  %and57 = and i32 %37, -12582913
  store i32 %and57, i32* %ctrl_ext, align 4
  %38 = load %struct.igb_adapter** %adapter.addr, align 8
  %flags58 = getelementptr inbounds %struct.igb_adapter* %38, i32 0, i32 3
  %39 = load i32* %flags58, align 4
  %or59 = or i32 %39, 1024
  store i32 %or59, i32* %flags58, align 4
  br label %sw.epilog

sw.default:                                       ; preds = %if.end47
  %40 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev60 = getelementptr inbounds %struct.igb_adapter* %40, i32 0, i32 1
  %41 = load %struct.net_device** %netdev60, align 8
  %call61 = call i32 (%struct.net_device*, i8*, ...)* @netdev_err(%struct.net_device* %41, i8* getelementptr inbounds ([42 x i8]* @.str91, i32 0, i32 0)) noredzone
  br label %sw.epilog

sw.epilog:                                        ; preds = %sw.default, %sw.bb54, %sw.bb
  br label %do.body62

do.body62:                                        ; preds = %sw.epilog
  %42 = load %struct.e1000_hw** %hw, align 8
  %hw_addr64 = getelementptr inbounds %struct.e1000_hw* %42, i32 0, i32 1
  %43 = load volatile i8** %hw_addr64, align 8
  store i8* %43, i8** %hw_addr63, align 8
  %44 = load i8** %hw_addr63, align 8
  %tobool65 = icmp ne i8* %44, null
  %lnot66 = xor i1 %tobool65, true
  %lnot68 = xor i1 %lnot66, true
  %lnot70 = xor i1 %lnot68, true
  %lnot.ext71 = zext i1 %lnot70 to i32
  %conv72 = sext i32 %lnot.ext71 to i64
  %expval73 = call i64 @llvm.expect.i64(i64 %conv72, i64 0)
  %tobool74 = icmp ne i64 %expval73, 0
  br i1 %tobool74, label %if.end77, label %if.then75

if.then75:                                        ; preds = %do.body62
  %45 = load i32* %ctrl_ext, align 4
  %46 = load i8** %hw_addr63, align 8
  %arrayidx76 = getelementptr i8* %46, i64 24
  call void @writel(i32 %45, i8* %arrayidx76) noredzone
  br label %if.end77

if.end77:                                         ; preds = %if.then75, %do.body62
  br label %do.end78

do.end78:                                         ; preds = %do.end, %if.then46, %if.end77
  ret void
}

define internal void @igb_spoof_check(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %j = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %wvbr = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 53
  %1 = load i32* %wvbr, align 4
  %tobool = icmp ne i32 %1, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %for.end

if.end:                                           ; preds = %entry
  store i32 0, i32* %j, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end
  %2 = load i32* %j, align 4
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp ult i32 %2, %4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %5 = load %struct.igb_adapter** %adapter.addr, align 8
  %wvbr1 = getelementptr inbounds %struct.igb_adapter* %5, i32 0, i32 53
  %6 = load i32* %wvbr1, align 4
  %7 = load i32* %j, align 4
  %shl = shl i32 1, %7
  %and = and i32 %6, %shl
  %tobool2 = icmp ne i32 %and, 0
  br i1 %tobool2, label %if.then7, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %for.body
  %8 = load %struct.igb_adapter** %adapter.addr, align 8
  %wvbr3 = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 53
  %9 = load i32* %wvbr3, align 4
  %10 = load i32* %j, align 4
  %add = add i32 %10, 8
  %shl4 = shl i32 1, %add
  %and5 = and i32 %9, %shl4
  %tobool6 = icmp ne i32 %and5, 0
  br i1 %tobool6, label %if.then7, label %if.end13

if.then7:                                         ; preds = %lor.lhs.false, %for.body
  %11 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 32
  %12 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %12, i32 0, i32 33
  %13 = load i32* %j, align 4
  %call = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev, i8* getelementptr inbounds ([34 x i8]* @.str88, i32 0, i32 0), i32 %13) noredzone
  %14 = load i32* %j, align 4
  %shl8 = shl i32 1, %14
  %15 = load i32* %j, align 4
  %add9 = add i32 %15, 8
  %shl10 = shl i32 1, %add9
  %or = or i32 %shl8, %shl10
  %neg = xor i32 %or, -1
  %16 = load %struct.igb_adapter** %adapter.addr, align 8
  %wvbr11 = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 53
  %17 = load i32* %wvbr11, align 4
  %and12 = and i32 %17, %neg
  store i32 %and12, i32* %wvbr11, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then7, %lor.lhs.false
  br label %for.inc

for.inc:                                          ; preds = %if.end13
  %18 = load i32* %j, align 4
  %inc = add i32 %18, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond

for.end:                                          ; preds = %if.then, %for.cond
  ret void
}

declare void @igb_ptp_rx_hang(%struct.igb_adapter*) noredzone

define internal void @igb_check_lvmmc(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %lvmmc = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %1 = load %struct.e1000_hw** %hw, align 8
  %call = call i32 @igb_rd32(%struct.e1000_hw* %1, i32 13640) noredzone
  store i32 %call, i32* %lvmmc, align 4
  %2 = load i32* %lvmmc, align 4
  %tobool = icmp ne i32 %2, 0
  br i1 %tobool, label %if.then, label %if.end8

if.then:                                          ; preds = %entry
  %call2 = call i32 @net_ratelimit() noredzone
  %tobool3 = icmp ne i32 %call2, 0
  %lnot = xor i1 %tobool3, true
  %lnot4 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot4 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool5 = icmp ne i64 %expval, 0
  br i1 %tobool5, label %if.then6, label %if.end

if.then6:                                         ; preds = %if.then
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 1
  %4 = load %struct.net_device** %netdev, align 8
  %5 = load i32* %lvmmc, align 4
  %call7 = call i32 (%struct.net_device*, i8*, ...)* @netdev_warn(%struct.net_device* %4, i8* getelementptr inbounds ([56 x i8]* @.str87, i32 0, i32 0), i32 %5) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then6, %if.then
  br label %if.end8

if.end8:                                          ; preds = %if.end, %entry
  ret void
}

define internal i32 @igb_link_mbps(i32 %internal_link_speed) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %internal_link_speed.addr = alloca i32, align 4
  store i32 %internal_link_speed, i32* %internal_link_speed.addr, align 4
  %0 = load i32* %internal_link_speed.addr, align 4
  switch i32 %0, label %sw.default [
    i32 100, label %sw.bb
    i32 1000, label %sw.bb1
  ]

sw.bb:                                            ; preds = %entry
  store i32 100, i32* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  store i32 1000, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb1, %sw.bb
  %1 = load i32* %retval
  ret i32 %1
}

define internal void @igb_set_vf_rate_limit(%struct.e1000_hw* %hw, i32 %vf, i32 %tx_rate, i32 %link_speed) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %vf.addr = alloca i32, align 4
  %tx_rate.addr = alloca i32, align 4
  %link_speed.addr = alloca i32, align 4
  %rf_dec = alloca i32, align 4
  %rf_int = alloca i32, align 4
  %bcnrc_val = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  %hw_addr12 = alloca i8*, align 8
  %hw_addr29 = alloca i8*, align 8
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  store i32 %tx_rate, i32* %tx_rate.addr, align 4
  store i32 %link_speed, i32* %link_speed.addr, align 4
  %0 = load i32* %tx_rate.addr, align 4
  %cmp = icmp ne i32 %0, 0
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i32* %link_speed.addr, align 4
  %2 = load i32* %tx_rate.addr, align 4
  %div = sdiv i32 %1, %2
  store i32 %div, i32* %rf_int, align 4
  %3 = load i32* %link_speed.addr, align 4
  %4 = load i32* %rf_int, align 4
  %5 = load i32* %tx_rate.addr, align 4
  %mul = mul i32 %4, %5
  %sub = sub i32 %3, %mul
  store i32 %sub, i32* %rf_dec, align 4
  %6 = load i32* %rf_dec, align 4
  %mul1 = mul i32 %6, 16384
  %7 = load i32* %tx_rate.addr, align 4
  %div2 = sdiv i32 %mul1, %7
  store i32 %div2, i32* %rf_dec, align 4
  store i32 -2147483648, i32* %bcnrc_val, align 4
  %8 = load i32* %rf_int, align 4
  %shl = shl i32 %8, 14
  %and = and i32 %shl, 268419072
  %9 = load i32* %bcnrc_val, align 4
  %or = or i32 %9, %and
  store i32 %or, i32* %bcnrc_val, align 4
  %10 = load i32* %rf_dec, align 4
  %and3 = and i32 %10, 16383
  %11 = load i32* %bcnrc_val, align 4
  %or4 = or i32 %11, %and3
  store i32 %or4, i32* %bcnrc_val, align 4
  br label %if.end

if.else:                                          ; preds = %entry
  store i32 0, i32* %bcnrc_val, align 4
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  br label %do.body

do.body:                                          ; preds = %if.end
  %12 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr5 = getelementptr inbounds %struct.e1000_hw* %12, i32 0, i32 1
  %13 = load volatile i8** %hw_addr5, align 8
  store i8* %13, i8** %hw_addr, align 8
  %14 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %14, null
  %lnot = xor i1 %tobool, true
  %lnot6 = xor i1 %lnot, true
  %lnot7 = xor i1 %lnot6, true
  %lnot.ext = zext i1 %lnot7 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool8 = icmp ne i64 %expval, 0
  br i1 %tobool8, label %if.end10, label %if.then9

if.then9:                                         ; preds = %do.body
  %15 = load i32* %vf.addr, align 4
  %16 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %16, i64 13828
  call void @writel(i32 %15, i8* %arrayidx) noredzone
  br label %if.end10

if.end10:                                         ; preds = %if.then9, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end10
  br label %do.body11

do.body11:                                        ; preds = %do.end
  %17 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr13 = getelementptr inbounds %struct.e1000_hw* %17, i32 0, i32 1
  %18 = load volatile i8** %hw_addr13, align 8
  store i8* %18, i8** %hw_addr12, align 8
  %19 = load i8** %hw_addr12, align 8
  %tobool14 = icmp ne i8* %19, null
  %lnot15 = xor i1 %tobool14, true
  %lnot17 = xor i1 %lnot15, true
  %lnot19 = xor i1 %lnot17, true
  %lnot.ext20 = zext i1 %lnot19 to i32
  %conv21 = sext i32 %lnot.ext20 to i64
  %expval22 = call i64 @llvm.expect.i64(i64 %conv21, i64 0)
  %tobool23 = icmp ne i64 %expval22, 0
  br i1 %tobool23, label %if.end26, label %if.then24

if.then24:                                        ; preds = %do.body11
  %20 = load i8** %hw_addr12, align 8
  %arrayidx25 = getelementptr i8* %20, i64 13968
  call void @writel(i32 20, i8* %arrayidx25) noredzone
  br label %if.end26

if.end26:                                         ; preds = %if.then24, %do.body11
  br label %do.end27

do.end27:                                         ; preds = %if.end26
  br label %do.body28

do.body28:                                        ; preds = %do.end27
  %21 = load %struct.e1000_hw** %hw.addr, align 8
  %hw_addr30 = getelementptr inbounds %struct.e1000_hw* %21, i32 0, i32 1
  %22 = load volatile i8** %hw_addr30, align 8
  store i8* %22, i8** %hw_addr29, align 8
  %23 = load i8** %hw_addr29, align 8
  %tobool31 = icmp ne i8* %23, null
  %lnot32 = xor i1 %tobool31, true
  %lnot34 = xor i1 %lnot32, true
  %lnot36 = xor i1 %lnot34, true
  %lnot.ext37 = zext i1 %lnot36 to i32
  %conv38 = sext i32 %lnot.ext37 to i64
  %expval39 = call i64 @llvm.expect.i64(i64 %conv38, i64 0)
  %tobool40 = icmp ne i64 %expval39, 0
  br i1 %tobool40, label %if.end43, label %if.then41

if.then41:                                        ; preds = %do.body28
  %24 = load i32* %bcnrc_val, align 4
  %25 = load i8** %hw_addr29, align 8
  %arrayidx42 = getelementptr i8* %25, i64 14000
  call void @writel(i32 %24, i8* %arrayidx42) noredzone
  br label %if.end43

if.end43:                                         ; preds = %if.then41, %do.body28
  br label %do.end44

do.end44:                                         ; preds = %if.end43
  ret void
}

define internal void @igb_dump(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %page.addr.i = alloca %struct.page*, align 8
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %reginfo = alloca %struct.igb_reg_info*, align 8
  %tx_ring = alloca %struct.igb_ring*, align 8
  %tx_desc = alloca %union.e1000_adv_tx_desc*, align 8
  %u0 = alloca %struct.my_u0*, align 8
  %rx_ring = alloca %struct.igb_ring*, align 8
  %rx_desc = alloca %union.e1000_adv_rx_desc*, align 8
  %staterr = alloca i32, align 4
  %i = alloca i16, align 2
  %n = alloca i16, align 2
  %buffer_info = alloca %struct.igb_tx_buffer*, align 8
  %next_desc = alloca i8*, align 8
  %buffer_info64 = alloca %struct.igb_tx_buffer*, align 8
  %next_desc174 = alloca i8*, align 8
  %buffer_info175 = alloca %struct.igb_rx_buffer*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %netdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 1
  %1 = load %struct.net_device** %netdev1, align 8
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %msg_enable = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 43
  %4 = load i32* %msg_enable, align 4
  %and = and i32 %4, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  br label %return

if.end:                                           ; preds = %entry
  %5 = load %struct.net_device** %netdev, align 8
  %tobool3 = icmp ne %struct.net_device* %5, null
  br i1 %tobool3, label %if.then4, label %if.end7

if.then4:                                         ; preds = %if.end
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 32
  %7 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %7, i32 0, i32 33
  %call = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([17 x i8]* @.str94, i32 0, i32 0)) noredzone
  %call5 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([66 x i8]* @.str95, i32 0, i32 0)) noredzone
  %8 = load %struct.net_device** %netdev, align 8
  %name = getelementptr inbounds %struct.net_device* %8, i32 0, i32 0
  %arraydecay = getelementptr inbounds [16 x i8]* %name, i32 0, i32 0
  %9 = load %struct.net_device** %netdev, align 8
  %state = getelementptr inbounds %struct.net_device* %9, i32 0, i32 7
  %10 = load i64* %state, align 8
  %11 = load %struct.net_device** %netdev, align 8
  %trans_start = getelementptr inbounds %struct.net_device* %11, i32 0, i32 87
  %12 = load i64* %trans_start, align 8
  %13 = load %struct.net_device** %netdev, align 8
  %last_rx = getelementptr inbounds %struct.net_device* %13, i32 0, i32 69
  %14 = load i64* %last_rx, align 8
  %call6 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([35 x i8]* @.str96, i32 0, i32 0), i8* %arraydecay, i64 %10, i64 %12, i64 %14) noredzone
  br label %if.end7

if.end7:                                          ; preds = %if.then4, %if.end
  %15 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev8 = getelementptr inbounds %struct.igb_adapter* %15, i32 0, i32 32
  %16 = load %struct.pci_dev** %pdev8, align 8
  %dev9 = getelementptr inbounds %struct.pci_dev* %16, i32 0, i32 33
  %call10 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev9, i8* getelementptr inbounds ([15 x i8]* @.str97, i32 0, i32 0)) noredzone
  %call11 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([31 x i8]* @.str98, i32 0, i32 0)) noredzone
  store %struct.igb_reg_info* getelementptr inbounds ([23 x %struct.igb_reg_info]* @igb_reg_info_tbl, i32 0, i32 0), %struct.igb_reg_info** %reginfo, align 8
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %if.end7
  %17 = load %struct.igb_reg_info** %reginfo, align 8
  %name12 = getelementptr inbounds %struct.igb_reg_info* %17, i32 0, i32 1
  %18 = load i8** %name12, align 8
  %tobool13 = icmp ne i8* %18, null
  br i1 %tobool13, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %19 = load %struct.e1000_hw** %hw, align 8
  %20 = load %struct.igb_reg_info** %reginfo, align 8
  call void @igb_regdump(%struct.e1000_hw* %19, %struct.igb_reg_info* %20) noredzone
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %21 = load %struct.igb_reg_info** %reginfo, align 8
  %incdec.ptr = getelementptr %struct.igb_reg_info* %21, i32 1
  store %struct.igb_reg_info* %incdec.ptr, %struct.igb_reg_info** %reginfo, align 8
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %22 = load %struct.net_device** %netdev, align 8
  %tobool14 = icmp ne %struct.net_device* %22, null
  br i1 %tobool14, label %lor.lhs.false, label %if.then16

lor.lhs.false:                                    ; preds = %for.end
  %23 = load %struct.net_device** %netdev, align 8
  %call15 = call zeroext i1 @netif_running(%struct.net_device* %23) noredzone
  br i1 %call15, label %if.end17, label %if.then16

if.then16:                                        ; preds = %lor.lhs.false, %for.end
  br label %exit

if.end17:                                         ; preds = %lor.lhs.false
  %24 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev18 = getelementptr inbounds %struct.igb_adapter* %24, i32 0, i32 32
  %25 = load %struct.pci_dev** %pdev18, align 8
  %dev19 = getelementptr inbounds %struct.pci_dev* %25, i32 0, i32 33
  %call20 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev19, i8* getelementptr inbounds ([18 x i8]* @.str99, i32 0, i32 0)) noredzone
  %call21 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([62 x i8]* @.str100, i32 0, i32 0)) noredzone
  store i16 0, i16* %n, align 2
  br label %for.cond22

for.cond22:                                       ; preds = %for.inc33, %if.end17
  %26 = load i16* %n, align 2
  %conv = zext i16 %26 to i32
  %27 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 12
  %28 = load i32* %num_tx_queues, align 4
  %cmp = icmp slt i32 %conv, %28
  br i1 %cmp, label %for.body24, label %for.end34

for.body24:                                       ; preds = %for.cond22
  %29 = load i16* %n, align 2
  %idxprom = zext i16 %29 to i64
  %30 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring25 = getelementptr inbounds %struct.igb_adapter* %30, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring25, i32 0, i64 %idxprom
  %31 = load %struct.igb_ring** %arrayidx, align 8
  store %struct.igb_ring* %31, %struct.igb_ring** %tx_ring, align 8
  %32 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean = getelementptr inbounds %struct.igb_ring* %32, i32 0, i32 12
  %33 = load i16* %next_to_clean, align 2
  %idxprom26 = zext i16 %33 to i64
  %34 = load %struct.igb_ring** %tx_ring, align 8
  %35 = getelementptr inbounds %struct.igb_ring* %34, i32 0, i32 3
  %tx_buffer_info = bitcast %union.anon.87* %35 to %struct.igb_tx_buffer**
  %36 = load %struct.igb_tx_buffer** %tx_buffer_info, align 8
  %arrayidx27 = getelementptr %struct.igb_tx_buffer* %36, i64 %idxprom26
  store %struct.igb_tx_buffer* %arrayidx27, %struct.igb_tx_buffer** %buffer_info, align 8
  %37 = load i16* %n, align 2
  %conv28 = zext i16 %37 to i32
  %38 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_use = getelementptr inbounds %struct.igb_ring* %38, i32 0, i32 13
  %39 = load i16* %next_to_use, align 2
  %conv29 = zext i16 %39 to i32
  %40 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean30 = getelementptr inbounds %struct.igb_ring* %40, i32 0, i32 12
  %41 = load i16* %next_to_clean30, align 2
  %conv31 = zext i16 %41 to i32
  %42 = load %struct.igb_tx_buffer** %buffer_info, align 8
  %dma = getelementptr inbounds %struct.igb_tx_buffer* %42, i32 0, i32 6
  %43 = load i64* %dma, align 8
  %44 = load %struct.igb_tx_buffer** %buffer_info, align 8
  %len = getelementptr inbounds %struct.igb_tx_buffer* %44, i32 0, i32 7
  %45 = load i32* %len, align 4
  %46 = load %struct.igb_tx_buffer** %buffer_info, align 8
  %next_to_watch = getelementptr inbounds %struct.igb_tx_buffer* %46, i32 0, i32 0
  %47 = load %union.e1000_adv_tx_desc** %next_to_watch, align 8
  %48 = load %struct.igb_tx_buffer** %buffer_info, align 8
  %time_stamp = getelementptr inbounds %struct.igb_tx_buffer* %48, i32 0, i32 1
  %49 = load i64* %time_stamp, align 8
  %call32 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([45 x i8]* @.str101, i32 0, i32 0), i32 %conv28, i32 %conv29, i32 %conv31, i64 %43, i32 %45, %union.e1000_adv_tx_desc* %47, i64 %49) noredzone
  br label %for.inc33

for.inc33:                                        ; preds = %for.body24
  %50 = load i16* %n, align 2
  %inc = add i16 %50, 1
  store i16 %inc, i16* %n, align 2
  br label %for.cond22

for.end34:                                        ; preds = %for.cond22
  %51 = load %struct.igb_adapter** %adapter.addr, align 8
  %msg_enable35 = getelementptr inbounds %struct.igb_adapter* %51, i32 0, i32 43
  %52 = load i32* %msg_enable35, align 4
  %and36 = and i32 %52, 1024
  %tobool37 = icmp ne i32 %and36, 0
  br i1 %tobool37, label %if.end39, label %if.then38

if.then38:                                        ; preds = %for.end34
  br label %rx_ring_summary

if.end39:                                         ; preds = %for.end34
  %53 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev40 = getelementptr inbounds %struct.igb_adapter* %53, i32 0, i32 32
  %54 = load %struct.pci_dev** %pdev40, align 8
  %dev41 = getelementptr inbounds %struct.pci_dev* %54, i32 0, i32 33
  %call42 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev41, i8* getelementptr inbounds ([15 x i8]* @.str102, i32 0, i32 0)) noredzone
  store i16 0, i16* %n, align 2
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc119, %if.end39
  %55 = load i16* %n, align 2
  %conv44 = zext i16 %55 to i32
  %56 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues45 = getelementptr inbounds %struct.igb_adapter* %56, i32 0, i32 12
  %57 = load i32* %num_tx_queues45, align 4
  %cmp46 = icmp slt i32 %conv44, %57
  br i1 %cmp46, label %for.body48, label %for.end121

for.body48:                                       ; preds = %for.cond43
  %58 = load i16* %n, align 2
  %idxprom49 = zext i16 %58 to i64
  %59 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring50 = getelementptr inbounds %struct.igb_adapter* %59, i32 0, i32 13
  %arrayidx51 = getelementptr [16 x %struct.igb_ring*]* %tx_ring50, i32 0, i64 %idxprom49
  %60 = load %struct.igb_ring** %arrayidx51, align 8
  store %struct.igb_ring* %60, %struct.igb_ring** %tx_ring, align 8
  %call52 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([45 x i8]* @.str103, i32 0, i32 0)) noredzone
  %61 = load %struct.igb_ring** %tx_ring, align 8
  %queue_index = getelementptr inbounds %struct.igb_ring* %61, i32 0, i32 10
  %62 = load i8* %queue_index, align 1
  %conv53 = zext i8 %62 to i32
  %call54 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([28 x i8]* @.str104, i32 0, i32 0), i32 %conv53) noredzone
  %call55 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([45 x i8]* @.str103, i32 0, i32 0)) noredzone
  %call56 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([107 x i8]* @.str105, i32 0, i32 0)) noredzone
  store i16 0, i16* %i, align 2
  br label %for.cond57

for.cond57:                                       ; preds = %for.inc116, %for.body48
  %63 = load %struct.igb_ring** %tx_ring, align 8
  %desc = getelementptr inbounds %struct.igb_ring* %63, i32 0, i32 4
  %64 = load i8** %desc, align 8
  %tobool58 = icmp ne i8* %64, null
  br i1 %tobool58, label %land.rhs, label %land.end

land.rhs:                                         ; preds = %for.cond57
  %65 = load i16* %i, align 2
  %conv59 = zext i16 %65 to i32
  %66 = load %struct.igb_ring** %tx_ring, align 8
  %count = getelementptr inbounds %struct.igb_ring* %66, i32 0, i32 9
  %67 = load i16* %count, align 2
  %conv60 = zext i16 %67 to i32
  %cmp61 = icmp slt i32 %conv59, %conv60
  br label %land.end

land.end:                                         ; preds = %land.rhs, %for.cond57
  %68 = phi i1 [ false, %for.cond57 ], [ %cmp61, %land.rhs ]
  br i1 %68, label %for.body63, label %for.end118

for.body63:                                       ; preds = %land.end
  %69 = load i16* %i, align 2
  %idxprom65 = zext i16 %69 to i64
  %70 = load %struct.igb_ring** %tx_ring, align 8
  %desc66 = getelementptr inbounds %struct.igb_ring* %70, i32 0, i32 4
  %71 = load i8** %desc66, align 8
  %72 = bitcast i8* %71 to %union.e1000_adv_tx_desc*
  %arrayidx67 = getelementptr %union.e1000_adv_tx_desc* %72, i64 %idxprom65
  store %union.e1000_adv_tx_desc* %arrayidx67, %union.e1000_adv_tx_desc** %tx_desc, align 8
  %73 = load i16* %i, align 2
  %idxprom68 = zext i16 %73 to i64
  %74 = load %struct.igb_ring** %tx_ring, align 8
  %75 = getelementptr inbounds %struct.igb_ring* %74, i32 0, i32 3
  %tx_buffer_info69 = bitcast %union.anon.87* %75 to %struct.igb_tx_buffer**
  %76 = load %struct.igb_tx_buffer** %tx_buffer_info69, align 8
  %arrayidx70 = getelementptr %struct.igb_tx_buffer* %76, i64 %idxprom68
  store %struct.igb_tx_buffer* %arrayidx70, %struct.igb_tx_buffer** %buffer_info64, align 8
  %77 = load %union.e1000_adv_tx_desc** %tx_desc, align 8
  %78 = bitcast %union.e1000_adv_tx_desc* %77 to %struct.my_u0*
  store %struct.my_u0* %78, %struct.my_u0** %u0, align 8
  %79 = load i16* %i, align 2
  %conv71 = zext i16 %79 to i32
  %80 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_use72 = getelementptr inbounds %struct.igb_ring* %80, i32 0, i32 13
  %81 = load i16* %next_to_use72, align 2
  %conv73 = zext i16 %81 to i32
  %cmp74 = icmp eq i32 %conv71, %conv73
  br i1 %cmp74, label %land.lhs.true, label %if.else

land.lhs.true:                                    ; preds = %for.body63
  %82 = load i16* %i, align 2
  %conv76 = zext i16 %82 to i32
  %83 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean77 = getelementptr inbounds %struct.igb_ring* %83, i32 0, i32 12
  %84 = load i16* %next_to_clean77, align 2
  %conv78 = zext i16 %84 to i32
  %cmp79 = icmp eq i32 %conv76, %conv78
  br i1 %cmp79, label %if.then81, label %if.else

if.then81:                                        ; preds = %land.lhs.true
  store i8* getelementptr inbounds ([7 x i8]* @.str106, i32 0, i32 0), i8** %next_desc, align 8
  br label %if.end98

if.else:                                          ; preds = %land.lhs.true, %for.body63
  %85 = load i16* %i, align 2
  %conv82 = zext i16 %85 to i32
  %86 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_use83 = getelementptr inbounds %struct.igb_ring* %86, i32 0, i32 13
  %87 = load i16* %next_to_use83, align 2
  %conv84 = zext i16 %87 to i32
  %cmp85 = icmp eq i32 %conv82, %conv84
  br i1 %cmp85, label %if.then87, label %if.else88

if.then87:                                        ; preds = %if.else
  store i8* getelementptr inbounds ([5 x i8]* @.str107, i32 0, i32 0), i8** %next_desc, align 8
  br label %if.end97

if.else88:                                        ; preds = %if.else
  %88 = load i16* %i, align 2
  %conv89 = zext i16 %88 to i32
  %89 = load %struct.igb_ring** %tx_ring, align 8
  %next_to_clean90 = getelementptr inbounds %struct.igb_ring* %89, i32 0, i32 12
  %90 = load i16* %next_to_clean90, align 2
  %conv91 = zext i16 %90 to i32
  %cmp92 = icmp eq i32 %conv89, %conv91
  br i1 %cmp92, label %if.then94, label %if.else95

if.then94:                                        ; preds = %if.else88
  store i8* getelementptr inbounds ([5 x i8]* @.str108, i32 0, i32 0), i8** %next_desc, align 8
  br label %if.end96

if.else95:                                        ; preds = %if.else88
  store i8* getelementptr inbounds ([1 x i8]* @.str109, i32 0, i32 0), i8** %next_desc, align 8
  br label %if.end96

if.end96:                                         ; preds = %if.else95, %if.then94
  br label %if.end97

if.end97:                                         ; preds = %if.end96, %if.then87
  br label %if.end98

if.end98:                                         ; preds = %if.end97, %if.then81
  %91 = load i16* %i, align 2
  %conv99 = zext i16 %91 to i32
  %92 = load %struct.my_u0** %u0, align 8
  %a = getelementptr inbounds %struct.my_u0* %92, i32 0, i32 0
  %93 = load i64* %a, align 8
  %94 = load %struct.my_u0** %u0, align 8
  %b = getelementptr inbounds %struct.my_u0* %94, i32 0, i32 1
  %95 = load i64* %b, align 8
  %96 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %dma100 = getelementptr inbounds %struct.igb_tx_buffer* %96, i32 0, i32 6
  %97 = load i64* %dma100, align 8
  %98 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %len101 = getelementptr inbounds %struct.igb_tx_buffer* %98, i32 0, i32 7
  %99 = load i32* %len101, align 4
  %100 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %next_to_watch102 = getelementptr inbounds %struct.igb_tx_buffer* %100, i32 0, i32 0
  %101 = load %union.e1000_adv_tx_desc** %next_to_watch102, align 8
  %102 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %time_stamp103 = getelementptr inbounds %struct.igb_tx_buffer* %102, i32 0, i32 1
  %103 = load i64* %time_stamp103, align 8
  %104 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %skb = getelementptr inbounds %struct.igb_tx_buffer* %104, i32 0, i32 2
  %105 = load %struct.sk_buff** %skb, align 8
  %106 = load i8** %next_desc, align 8
  %call104 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([68 x i8]* @.str110, i32 0, i32 0), i32 %conv99, i64 %93, i64 %95, i64 %97, i32 %99, %union.e1000_adv_tx_desc* %101, i64 %103, %struct.sk_buff* %105, i8* %106) noredzone
  %107 = load %struct.igb_adapter** %adapter.addr, align 8
  %msg_enable105 = getelementptr inbounds %struct.igb_adapter* %107, i32 0, i32 43
  %108 = load i32* %msg_enable105, align 4
  %and106 = and i32 %108, 4096
  %tobool107 = icmp ne i32 %and106, 0
  br i1 %tobool107, label %land.lhs.true108, label %if.end115

land.lhs.true108:                                 ; preds = %if.end98
  %109 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %skb109 = getelementptr inbounds %struct.igb_tx_buffer* %109, i32 0, i32 2
  %110 = load %struct.sk_buff** %skb109, align 8
  %tobool110 = icmp ne %struct.sk_buff* %110, null
  br i1 %tobool110, label %if.then111, label %if.end115

if.then111:                                       ; preds = %land.lhs.true108
  %111 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %skb112 = getelementptr inbounds %struct.igb_tx_buffer* %111, i32 0, i32 2
  %112 = load %struct.sk_buff** %skb112, align 8
  %data = getelementptr inbounds %struct.sk_buff* %112, i32 0, i32 42
  %113 = load i8** %data, align 8
  %114 = load %struct.igb_tx_buffer** %buffer_info64, align 8
  %len113 = getelementptr inbounds %struct.igb_tx_buffer* %114, i32 0, i32 7
  %115 = load i32* %len113, align 4
  %conv114 = zext i32 %115 to i64
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8]* @.str111, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str109, i32 0, i32 0), i32 1, i32 16, i32 1, i8* %113, i64 %conv114, i1 zeroext true) noredzone
  br label %if.end115

if.end115:                                        ; preds = %if.then111, %land.lhs.true108, %if.end98
  br label %for.inc116

for.inc116:                                       ; preds = %if.end115
  %116 = load i16* %i, align 2
  %inc117 = add i16 %116, 1
  store i16 %inc117, i16* %i, align 2
  br label %for.cond57

for.end118:                                       ; preds = %land.end
  br label %for.inc119

for.inc119:                                       ; preds = %for.end118
  %117 = load i16* %n, align 2
  %inc120 = add i16 %117, 1
  store i16 %inc120, i16* %n, align 2
  br label %for.cond43

for.end121:                                       ; preds = %for.cond43
  br label %rx_ring_summary

rx_ring_summary:                                  ; preds = %for.end121, %if.then38
  %118 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev122 = getelementptr inbounds %struct.igb_adapter* %118, i32 0, i32 32
  %119 = load %struct.pci_dev** %pdev122, align 8
  %dev123 = getelementptr inbounds %struct.pci_dev* %119, i32 0, i32 33
  %call124 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev123, i8* getelementptr inbounds ([18 x i8]* @.str112, i32 0, i32 0)) noredzone
  %call125 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([26 x i8]* @.str113, i32 0, i32 0)) noredzone
  store i16 0, i16* %n, align 2
  br label %for.cond126

for.cond126:                                      ; preds = %for.inc140, %rx_ring_summary
  %120 = load i16* %n, align 2
  %conv127 = zext i16 %120 to i32
  %121 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues = getelementptr inbounds %struct.igb_adapter* %121, i32 0, i32 14
  %122 = load i32* %num_rx_queues, align 4
  %cmp128 = icmp slt i32 %conv127, %122
  br i1 %cmp128, label %for.body130, label %for.end142

for.body130:                                      ; preds = %for.cond126
  %123 = load i16* %n, align 2
  %idxprom131 = zext i16 %123 to i64
  %124 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring132 = getelementptr inbounds %struct.igb_adapter* %124, i32 0, i32 15
  %arrayidx133 = getelementptr [16 x %struct.igb_ring*]* %rx_ring132, i32 0, i64 %idxprom131
  %125 = load %struct.igb_ring** %arrayidx133, align 8
  store %struct.igb_ring* %125, %struct.igb_ring** %rx_ring, align 8
  %126 = load i16* %n, align 2
  %conv134 = zext i16 %126 to i32
  %127 = load %struct.igb_ring** %rx_ring, align 8
  %next_to_use135 = getelementptr inbounds %struct.igb_ring* %127, i32 0, i32 13
  %128 = load i16* %next_to_use135, align 2
  %conv136 = zext i16 %128 to i32
  %129 = load %struct.igb_ring** %rx_ring, align 8
  %next_to_clean137 = getelementptr inbounds %struct.igb_ring* %129, i32 0, i32 12
  %130 = load i16* %next_to_clean137, align 2
  %conv138 = zext i16 %130 to i32
  %call139 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([21 x i8]* @.str114, i32 0, i32 0), i32 %conv134, i32 %conv136, i32 %conv138) noredzone
  br label %for.inc140

for.inc140:                                       ; preds = %for.body130
  %131 = load i16* %n, align 2
  %inc141 = add i16 %131, 1
  store i16 %inc141, i16* %n, align 2
  br label %for.cond126

for.end142:                                       ; preds = %for.cond126
  %132 = load %struct.igb_adapter** %adapter.addr, align 8
  %msg_enable143 = getelementptr inbounds %struct.igb_adapter* %132, i32 0, i32 43
  %133 = load i32* %msg_enable143, align 4
  %and144 = and i32 %133, 2048
  %tobool145 = icmp ne i32 %and144, 0
  br i1 %tobool145, label %if.end147, label %if.then146

if.then146:                                       ; preds = %for.end142
  br label %exit

if.end147:                                        ; preds = %for.end142
  %134 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev148 = getelementptr inbounds %struct.igb_adapter* %134, i32 0, i32 32
  %135 = load %struct.pci_dev** %pdev148, align 8
  %dev149 = getelementptr inbounds %struct.pci_dev* %135, i32 0, i32 33
  %call150 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev149, i8* getelementptr inbounds ([15 x i8]* @.str115, i32 0, i32 0)) noredzone
  store i16 0, i16* %n, align 2
  br label %for.cond151

for.cond151:                                      ; preds = %for.inc226, %if.end147
  %136 = load i16* %n, align 2
  %conv152 = zext i16 %136 to i32
  %137 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_rx_queues153 = getelementptr inbounds %struct.igb_adapter* %137, i32 0, i32 14
  %138 = load i32* %num_rx_queues153, align 4
  %cmp154 = icmp slt i32 %conv152, %138
  br i1 %cmp154, label %for.body156, label %for.end228

for.body156:                                      ; preds = %for.cond151
  %139 = load i16* %n, align 2
  %idxprom157 = zext i16 %139 to i64
  %140 = load %struct.igb_adapter** %adapter.addr, align 8
  %rx_ring158 = getelementptr inbounds %struct.igb_adapter* %140, i32 0, i32 15
  %arrayidx159 = getelementptr [16 x %struct.igb_ring*]* %rx_ring158, i32 0, i64 %idxprom157
  %141 = load %struct.igb_ring** %arrayidx159, align 8
  store %struct.igb_ring* %141, %struct.igb_ring** %rx_ring, align 8
  %call160 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([45 x i8]* @.str103, i32 0, i32 0)) noredzone
  %142 = load %struct.igb_ring** %rx_ring, align 8
  %queue_index161 = getelementptr inbounds %struct.igb_ring* %142, i32 0, i32 10
  %143 = load i8* %queue_index161, align 1
  %conv162 = zext i8 %143 to i32
  %call163 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([28 x i8]* @.str116, i32 0, i32 0), i32 %conv162) noredzone
  %call164 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([45 x i8]* @.str103, i32 0, i32 0)) noredzone
  %call165 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([107 x i8]* @.str117, i32 0, i32 0)) noredzone
  %call166 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([113 x i8]* @.str118, i32 0, i32 0)) noredzone
  store i16 0, i16* %i, align 2
  br label %for.cond167

for.cond167:                                      ; preds = %for.inc223, %for.body156
  %144 = load i16* %i, align 2
  %conv168 = zext i16 %144 to i32
  %145 = load %struct.igb_ring** %rx_ring, align 8
  %count169 = getelementptr inbounds %struct.igb_ring* %145, i32 0, i32 9
  %146 = load i16* %count169, align 2
  %conv170 = zext i16 %146 to i32
  %cmp171 = icmp slt i32 %conv168, %conv170
  br i1 %cmp171, label %for.body173, label %for.end225

for.body173:                                      ; preds = %for.cond167
  %147 = load i16* %i, align 2
  %idxprom176 = zext i16 %147 to i64
  %148 = load %struct.igb_ring** %rx_ring, align 8
  %149 = getelementptr inbounds %struct.igb_ring* %148, i32 0, i32 3
  %rx_buffer_info = bitcast %union.anon.87* %149 to %struct.igb_rx_buffer**
  %150 = load %struct.igb_rx_buffer** %rx_buffer_info, align 8
  %arrayidx177 = getelementptr %struct.igb_rx_buffer* %150, i64 %idxprom176
  store %struct.igb_rx_buffer* %arrayidx177, %struct.igb_rx_buffer** %buffer_info175, align 8
  %151 = load i16* %i, align 2
  %idxprom178 = zext i16 %151 to i64
  %152 = load %struct.igb_ring** %rx_ring, align 8
  %desc179 = getelementptr inbounds %struct.igb_ring* %152, i32 0, i32 4
  %153 = load i8** %desc179, align 8
  %154 = bitcast i8* %153 to %union.e1000_adv_rx_desc*
  %arrayidx180 = getelementptr %union.e1000_adv_rx_desc* %154, i64 %idxprom178
  store %union.e1000_adv_rx_desc* %arrayidx180, %union.e1000_adv_rx_desc** %rx_desc, align 8
  %155 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %156 = bitcast %union.e1000_adv_rx_desc* %155 to %struct.my_u0*
  store %struct.my_u0* %156, %struct.my_u0** %u0, align 8
  %157 = load %union.e1000_adv_rx_desc** %rx_desc, align 8
  %wb = bitcast %union.e1000_adv_rx_desc* %157 to %struct.anon.97*
  %upper = getelementptr inbounds %struct.anon.97* %wb, i32 0, i32 1
  %status_error = getelementptr inbounds %struct.anon.102* %upper, i32 0, i32 0
  %158 = load i32* %status_error, align 4
  store i32 %158, i32* %staterr, align 4
  %159 = load i16* %i, align 2
  %conv181 = zext i16 %159 to i32
  %160 = load %struct.igb_ring** %rx_ring, align 8
  %next_to_use182 = getelementptr inbounds %struct.igb_ring* %160, i32 0, i32 13
  %161 = load i16* %next_to_use182, align 2
  %conv183 = zext i16 %161 to i32
  %cmp184 = icmp eq i32 %conv181, %conv183
  br i1 %cmp184, label %if.then186, label %if.else187

if.then186:                                       ; preds = %for.body173
  store i8* getelementptr inbounds ([5 x i8]* @.str107, i32 0, i32 0), i8** %next_desc174, align 8
  br label %if.end196

if.else187:                                       ; preds = %for.body173
  %162 = load i16* %i, align 2
  %conv188 = zext i16 %162 to i32
  %163 = load %struct.igb_ring** %rx_ring, align 8
  %next_to_clean189 = getelementptr inbounds %struct.igb_ring* %163, i32 0, i32 12
  %164 = load i16* %next_to_clean189, align 2
  %conv190 = zext i16 %164 to i32
  %cmp191 = icmp eq i32 %conv188, %conv190
  br i1 %cmp191, label %if.then193, label %if.else194

if.then193:                                       ; preds = %if.else187
  store i8* getelementptr inbounds ([5 x i8]* @.str108, i32 0, i32 0), i8** %next_desc174, align 8
  br label %if.end195

if.else194:                                       ; preds = %if.else187
  store i8* getelementptr inbounds ([1 x i8]* @.str109, i32 0, i32 0), i8** %next_desc174, align 8
  br label %if.end195

if.end195:                                        ; preds = %if.else194, %if.then193
  br label %if.end196

if.end196:                                        ; preds = %if.end195, %if.then186
  %165 = load i32* %staterr, align 4
  %and197 = and i32 %165, 1
  %tobool198 = icmp ne i32 %and197, 0
  br i1 %tobool198, label %if.then199, label %if.else204

if.then199:                                       ; preds = %if.end196
  %166 = load i16* %i, align 2
  %conv200 = zext i16 %166 to i32
  %167 = load %struct.my_u0** %u0, align 8
  %a201 = getelementptr inbounds %struct.my_u0* %167, i32 0, i32 0
  %168 = load i64* %a201, align 8
  %169 = load %struct.my_u0** %u0, align 8
  %b202 = getelementptr inbounds %struct.my_u0* %169, i32 0, i32 1
  %170 = load i64* %b202, align 8
  %171 = load i8** %next_desc174, align 8
  %call203 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([59 x i8]* @.str119, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str120, i32 0, i32 0), i32 %conv200, i64 %168, i64 %170, i8* %171) noredzone
  br label %if.end222

if.else204:                                       ; preds = %if.end196
  %172 = load i16* %i, align 2
  %conv205 = zext i16 %172 to i32
  %173 = load %struct.my_u0** %u0, align 8
  %a206 = getelementptr inbounds %struct.my_u0* %173, i32 0, i32 0
  %174 = load i64* %a206, align 8
  %175 = load %struct.my_u0** %u0, align 8
  %b207 = getelementptr inbounds %struct.my_u0* %175, i32 0, i32 1
  %176 = load i64* %b207, align 8
  %177 = load %struct.igb_rx_buffer** %buffer_info175, align 8
  %dma208 = getelementptr inbounds %struct.igb_rx_buffer* %177, i32 0, i32 0
  %178 = load i64* %dma208, align 8
  %179 = load i8** %next_desc174, align 8
  %call209 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([50 x i8]* @.str121, i32 0, i32 0), i8* getelementptr inbounds ([4 x i8]* @.str122, i32 0, i32 0), i32 %conv205, i64 %174, i64 %176, i64 %178, i8* %179) noredzone
  %180 = load %struct.igb_adapter** %adapter.addr, align 8
  %msg_enable210 = getelementptr inbounds %struct.igb_adapter* %180, i32 0, i32 43
  %181 = load i32* %msg_enable210, align 4
  %and211 = and i32 %181, 4096
  %tobool212 = icmp ne i32 %and211, 0
  br i1 %tobool212, label %land.lhs.true213, label %if.end221

land.lhs.true213:                                 ; preds = %if.else204
  %182 = load %struct.igb_rx_buffer** %buffer_info175, align 8
  %dma214 = getelementptr inbounds %struct.igb_rx_buffer* %182, i32 0, i32 0
  %183 = load i64* %dma214, align 8
  %tobool215 = icmp ne i64 %183, 0
  br i1 %tobool215, label %land.lhs.true216, label %if.end221

land.lhs.true216:                                 ; preds = %land.lhs.true213
  %184 = load %struct.igb_rx_buffer** %buffer_info175, align 8
  %page = getelementptr inbounds %struct.igb_rx_buffer* %184, i32 0, i32 1
  %185 = load %struct.page** %page, align 8
  %tobool217 = icmp ne %struct.page* %185, null
  br i1 %tobool217, label %if.then218, label %if.end221

if.then218:                                       ; preds = %land.lhs.true216
  %186 = load %struct.igb_rx_buffer** %buffer_info175, align 8
  %page219 = getelementptr inbounds %struct.igb_rx_buffer* %186, i32 0, i32 1
  %187 = load %struct.page** %page219, align 8
  store %struct.page* %187, %struct.page** %page.addr.i, align 8
  %188 = load %struct.page** %page.addr.i, align 8
  %sub.ptr.lhs.cast.i = ptrtoint %struct.page* %188 to i64
  %sub.ptr.sub.i = sub i64 %sub.ptr.lhs.cast.i, -24189255811072
  %sub.ptr.div.i = sdiv exact i64 %sub.ptr.sub.i, 64
  %shl.i = shl i64 %sub.ptr.div.i, 12
  %add.i = add i64 %shl.i, -131941395333120
  %189 = inttoptr i64 %add.i to i8*
  %190 = load %struct.igb_rx_buffer** %buffer_info175, align 8
  %page_offset = getelementptr inbounds %struct.igb_rx_buffer* %190, i32 0, i32 2
  %191 = load i32* %page_offset, align 4
  %idx.ext = zext i32 %191 to i64
  %add.ptr = getelementptr i8* %189, i64 %idx.ext
  call void @print_hex_dump(i8* getelementptr inbounds ([3 x i8]* @.str111, i32 0, i32 0), i8* getelementptr inbounds ([1 x i8]* @.str109, i32 0, i32 0), i32 1, i32 16, i32 1, i8* %add.ptr, i64 2048, i1 zeroext true) noredzone
  br label %if.end221

if.end221:                                        ; preds = %if.then218, %land.lhs.true216, %land.lhs.true213, %if.else204
  br label %if.end222

if.end222:                                        ; preds = %if.end221, %if.then199
  br label %for.inc223

for.inc223:                                       ; preds = %if.end222
  %192 = load i16* %i, align 2
  %inc224 = add i16 %192, 1
  store i16 %inc224, i16* %i, align 2
  br label %for.cond167

for.end225:                                       ; preds = %for.cond167
  br label %for.inc226

for.inc226:                                       ; preds = %for.end225
  %193 = load i16* %n, align 2
  %inc227 = add i16 %193, 1
  store i16 %inc227, i16* %n, align 2
  br label %for.cond151

for.end228:                                       ; preds = %for.cond151
  br label %exit

exit:                                             ; preds = %for.end228, %if.then146, %if.then16
  br label %return

return:                                           ; preds = %exit, %if.then
  ret void
}

define internal void @igb_regdump(%struct.e1000_hw* %hw, %struct.igb_reg_info* %reginfo) nounwind noredzone {
entry:
  %hw.addr = alloca %struct.e1000_hw*, align 8
  %reginfo.addr = alloca %struct.igb_reg_info*, align 8
  %n = alloca i32, align 4
  %rname = alloca [16 x i8], align 16
  %regs = alloca [8 x i32], align 16
  store %struct.e1000_hw* %hw, %struct.e1000_hw** %hw.addr, align 8
  store %struct.igb_reg_info* %reginfo, %struct.igb_reg_info** %reginfo.addr, align 8
  store i32 0, i32* %n, align 4
  %0 = load %struct.igb_reg_info** %reginfo.addr, align 8
  %ofs = getelementptr inbounds %struct.igb_reg_info* %0, i32 0, i32 0
  %1 = load i32* %ofs, align 4
  switch i32 %1, label %sw.default [
    i32 10248, label %sw.bb
    i32 10256, label %sw.bb4
    i32 10264, label %sw.bb23
    i32 10280, label %sw.bb42
    i32 10240, label %sw.bb61
    i32 10244, label %sw.bb80
    i32 14336, label %sw.bb99
    i32 14340, label %sw.bb118
    i32 14344, label %sw.bb137
    i32 14352, label %sw.bb156
    i32 14360, label %sw.bb175
    i32 14376, label %sw.bb194
  ]

sw.bb:                                            ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %sw.bb
  %2 = load i32* %n, align 4
  %cmp = icmp slt i32 %2, 4
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %3 = load %struct.e1000_hw** %hw.addr, align 8
  %4 = load i32* %n, align 4
  %cmp1 = icmp slt i32 %4, 4
  br i1 %cmp1, label %cond.true, label %cond.false

cond.true:                                        ; preds = %for.body
  %5 = load i32* %n, align 4
  %mul = mul i32 %5, 256
  %add = add i32 10248, %mul
  br label %cond.end

cond.false:                                       ; preds = %for.body
  %6 = load i32* %n, align 4
  %mul2 = mul i32 %6, 64
  %add3 = add i32 49160, %mul2
  br label %cond.end

cond.end:                                         ; preds = %cond.false, %cond.true
  %cond = phi i32 [ %add, %cond.true ], [ %add3, %cond.false ]
  %call = call i32 @igb_rd32(%struct.e1000_hw* %3, i32 %cond) noredzone
  %7 = load i32* %n, align 4
  %idxprom = sext i32 %7 to i64
  %arrayidx = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom
  store i32 %call, i32* %arrayidx, align 4
  br label %for.inc

for.inc:                                          ; preds = %cond.end
  %8 = load i32* %n, align 4
  %inc = add i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  br label %sw.epilog

sw.bb4:                                           ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond5

for.cond5:                                        ; preds = %for.inc20, %sw.bb4
  %9 = load i32* %n, align 4
  %cmp6 = icmp slt i32 %9, 4
  br i1 %cmp6, label %for.body7, label %for.end22

for.body7:                                        ; preds = %for.cond5
  %10 = load %struct.e1000_hw** %hw.addr, align 8
  %11 = load i32* %n, align 4
  %cmp8 = icmp slt i32 %11, 4
  br i1 %cmp8, label %cond.true9, label %cond.false12

cond.true9:                                       ; preds = %for.body7
  %12 = load i32* %n, align 4
  %mul10 = mul i32 %12, 256
  %add11 = add i32 10256, %mul10
  br label %cond.end15

cond.false12:                                     ; preds = %for.body7
  %13 = load i32* %n, align 4
  %mul13 = mul i32 %13, 64
  %add14 = add i32 49168, %mul13
  br label %cond.end15

cond.end15:                                       ; preds = %cond.false12, %cond.true9
  %cond16 = phi i32 [ %add11, %cond.true9 ], [ %add14, %cond.false12 ]
  %call17 = call i32 @igb_rd32(%struct.e1000_hw* %10, i32 %cond16) noredzone
  %14 = load i32* %n, align 4
  %idxprom18 = sext i32 %14 to i64
  %arrayidx19 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom18
  store i32 %call17, i32* %arrayidx19, align 4
  br label %for.inc20

for.inc20:                                        ; preds = %cond.end15
  %15 = load i32* %n, align 4
  %inc21 = add i32 %15, 1
  store i32 %inc21, i32* %n, align 4
  br label %for.cond5

for.end22:                                        ; preds = %for.cond5
  br label %sw.epilog

sw.bb23:                                          ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc39, %sw.bb23
  %16 = load i32* %n, align 4
  %cmp25 = icmp slt i32 %16, 4
  br i1 %cmp25, label %for.body26, label %for.end41

for.body26:                                       ; preds = %for.cond24
  %17 = load %struct.e1000_hw** %hw.addr, align 8
  %18 = load i32* %n, align 4
  %cmp27 = icmp slt i32 %18, 4
  br i1 %cmp27, label %cond.true28, label %cond.false31

cond.true28:                                      ; preds = %for.body26
  %19 = load i32* %n, align 4
  %mul29 = mul i32 %19, 256
  %add30 = add i32 10264, %mul29
  br label %cond.end34

cond.false31:                                     ; preds = %for.body26
  %20 = load i32* %n, align 4
  %mul32 = mul i32 %20, 64
  %add33 = add i32 49176, %mul32
  br label %cond.end34

cond.end34:                                       ; preds = %cond.false31, %cond.true28
  %cond35 = phi i32 [ %add30, %cond.true28 ], [ %add33, %cond.false31 ]
  %call36 = call i32 @igb_rd32(%struct.e1000_hw* %17, i32 %cond35) noredzone
  %21 = load i32* %n, align 4
  %idxprom37 = sext i32 %21 to i64
  %arrayidx38 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom37
  store i32 %call36, i32* %arrayidx38, align 4
  br label %for.inc39

for.inc39:                                        ; preds = %cond.end34
  %22 = load i32* %n, align 4
  %inc40 = add i32 %22, 1
  store i32 %inc40, i32* %n, align 4
  br label %for.cond24

for.end41:                                        ; preds = %for.cond24
  br label %sw.epilog

sw.bb42:                                          ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond43

for.cond43:                                       ; preds = %for.inc58, %sw.bb42
  %23 = load i32* %n, align 4
  %cmp44 = icmp slt i32 %23, 4
  br i1 %cmp44, label %for.body45, label %for.end60

for.body45:                                       ; preds = %for.cond43
  %24 = load %struct.e1000_hw** %hw.addr, align 8
  %25 = load i32* %n, align 4
  %cmp46 = icmp slt i32 %25, 4
  br i1 %cmp46, label %cond.true47, label %cond.false50

cond.true47:                                      ; preds = %for.body45
  %26 = load i32* %n, align 4
  %mul48 = mul i32 %26, 256
  %add49 = add i32 10280, %mul48
  br label %cond.end53

cond.false50:                                     ; preds = %for.body45
  %27 = load i32* %n, align 4
  %mul51 = mul i32 %27, 64
  %add52 = add i32 49192, %mul51
  br label %cond.end53

cond.end53:                                       ; preds = %cond.false50, %cond.true47
  %cond54 = phi i32 [ %add49, %cond.true47 ], [ %add52, %cond.false50 ]
  %call55 = call i32 @igb_rd32(%struct.e1000_hw* %24, i32 %cond54) noredzone
  %28 = load i32* %n, align 4
  %idxprom56 = sext i32 %28 to i64
  %arrayidx57 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom56
  store i32 %call55, i32* %arrayidx57, align 4
  br label %for.inc58

for.inc58:                                        ; preds = %cond.end53
  %29 = load i32* %n, align 4
  %inc59 = add i32 %29, 1
  store i32 %inc59, i32* %n, align 4
  br label %for.cond43

for.end60:                                        ; preds = %for.cond43
  br label %sw.epilog

sw.bb61:                                          ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond62

for.cond62:                                       ; preds = %for.inc77, %sw.bb61
  %30 = load i32* %n, align 4
  %cmp63 = icmp slt i32 %30, 4
  br i1 %cmp63, label %for.body64, label %for.end79

for.body64:                                       ; preds = %for.cond62
  %31 = load %struct.e1000_hw** %hw.addr, align 8
  %32 = load i32* %n, align 4
  %cmp65 = icmp slt i32 %32, 4
  br i1 %cmp65, label %cond.true66, label %cond.false69

cond.true66:                                      ; preds = %for.body64
  %33 = load i32* %n, align 4
  %mul67 = mul i32 %33, 256
  %add68 = add i32 10240, %mul67
  br label %cond.end72

cond.false69:                                     ; preds = %for.body64
  %34 = load i32* %n, align 4
  %mul70 = mul i32 %34, 64
  %add71 = add i32 49152, %mul70
  br label %cond.end72

cond.end72:                                       ; preds = %cond.false69, %cond.true66
  %cond73 = phi i32 [ %add68, %cond.true66 ], [ %add71, %cond.false69 ]
  %call74 = call i32 @igb_rd32(%struct.e1000_hw* %31, i32 %cond73) noredzone
  %35 = load i32* %n, align 4
  %idxprom75 = sext i32 %35 to i64
  %arrayidx76 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom75
  store i32 %call74, i32* %arrayidx76, align 4
  br label %for.inc77

for.inc77:                                        ; preds = %cond.end72
  %36 = load i32* %n, align 4
  %inc78 = add i32 %36, 1
  store i32 %inc78, i32* %n, align 4
  br label %for.cond62

for.end79:                                        ; preds = %for.cond62
  br label %sw.epilog

sw.bb80:                                          ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond81

for.cond81:                                       ; preds = %for.inc96, %sw.bb80
  %37 = load i32* %n, align 4
  %cmp82 = icmp slt i32 %37, 4
  br i1 %cmp82, label %for.body83, label %for.end98

for.body83:                                       ; preds = %for.cond81
  %38 = load %struct.e1000_hw** %hw.addr, align 8
  %39 = load i32* %n, align 4
  %cmp84 = icmp slt i32 %39, 4
  br i1 %cmp84, label %cond.true85, label %cond.false88

cond.true85:                                      ; preds = %for.body83
  %40 = load i32* %n, align 4
  %mul86 = mul i32 %40, 256
  %add87 = add i32 10244, %mul86
  br label %cond.end91

cond.false88:                                     ; preds = %for.body83
  %41 = load i32* %n, align 4
  %mul89 = mul i32 %41, 64
  %add90 = add i32 49156, %mul89
  br label %cond.end91

cond.end91:                                       ; preds = %cond.false88, %cond.true85
  %cond92 = phi i32 [ %add87, %cond.true85 ], [ %add90, %cond.false88 ]
  %call93 = call i32 @igb_rd32(%struct.e1000_hw* %38, i32 %cond92) noredzone
  %42 = load i32* %n, align 4
  %idxprom94 = sext i32 %42 to i64
  %arrayidx95 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom94
  store i32 %call93, i32* %arrayidx95, align 4
  br label %for.inc96

for.inc96:                                        ; preds = %cond.end91
  %43 = load i32* %n, align 4
  %inc97 = add i32 %43, 1
  store i32 %inc97, i32* %n, align 4
  br label %for.cond81

for.end98:                                        ; preds = %for.cond81
  br label %sw.epilog

sw.bb99:                                          ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond100

for.cond100:                                      ; preds = %for.inc115, %sw.bb99
  %44 = load i32* %n, align 4
  %cmp101 = icmp slt i32 %44, 4
  br i1 %cmp101, label %for.body102, label %for.end117

for.body102:                                      ; preds = %for.cond100
  %45 = load %struct.e1000_hw** %hw.addr, align 8
  %46 = load i32* %n, align 4
  %cmp103 = icmp slt i32 %46, 4
  br i1 %cmp103, label %cond.true104, label %cond.false107

cond.true104:                                     ; preds = %for.body102
  %47 = load i32* %n, align 4
  %mul105 = mul i32 %47, 256
  %add106 = add i32 10240, %mul105
  br label %cond.end110

cond.false107:                                    ; preds = %for.body102
  %48 = load i32* %n, align 4
  %mul108 = mul i32 %48, 64
  %add109 = add i32 49152, %mul108
  br label %cond.end110

cond.end110:                                      ; preds = %cond.false107, %cond.true104
  %cond111 = phi i32 [ %add106, %cond.true104 ], [ %add109, %cond.false107 ]
  %call112 = call i32 @igb_rd32(%struct.e1000_hw* %45, i32 %cond111) noredzone
  %49 = load i32* %n, align 4
  %idxprom113 = sext i32 %49 to i64
  %arrayidx114 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom113
  store i32 %call112, i32* %arrayidx114, align 4
  br label %for.inc115

for.inc115:                                       ; preds = %cond.end110
  %50 = load i32* %n, align 4
  %inc116 = add i32 %50, 1
  store i32 %inc116, i32* %n, align 4
  br label %for.cond100

for.end117:                                       ; preds = %for.cond100
  br label %sw.epilog

sw.bb118:                                         ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond119

for.cond119:                                      ; preds = %for.inc134, %sw.bb118
  %51 = load i32* %n, align 4
  %cmp120 = icmp slt i32 %51, 4
  br i1 %cmp120, label %for.body121, label %for.end136

for.body121:                                      ; preds = %for.cond119
  %52 = load %struct.e1000_hw** %hw.addr, align 8
  %53 = load i32* %n, align 4
  %cmp122 = icmp slt i32 %53, 4
  br i1 %cmp122, label %cond.true123, label %cond.false126

cond.true123:                                     ; preds = %for.body121
  %54 = load i32* %n, align 4
  %mul124 = mul i32 %54, 256
  %add125 = add i32 14340, %mul124
  br label %cond.end129

cond.false126:                                    ; preds = %for.body121
  %55 = load i32* %n, align 4
  %mul127 = mul i32 %55, 64
  %add128 = add i32 57348, %mul127
  br label %cond.end129

cond.end129:                                      ; preds = %cond.false126, %cond.true123
  %cond130 = phi i32 [ %add125, %cond.true123 ], [ %add128, %cond.false126 ]
  %call131 = call i32 @igb_rd32(%struct.e1000_hw* %52, i32 %cond130) noredzone
  %56 = load i32* %n, align 4
  %idxprom132 = sext i32 %56 to i64
  %arrayidx133 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom132
  store i32 %call131, i32* %arrayidx133, align 4
  br label %for.inc134

for.inc134:                                       ; preds = %cond.end129
  %57 = load i32* %n, align 4
  %inc135 = add i32 %57, 1
  store i32 %inc135, i32* %n, align 4
  br label %for.cond119

for.end136:                                       ; preds = %for.cond119
  br label %sw.epilog

sw.bb137:                                         ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond138

for.cond138:                                      ; preds = %for.inc153, %sw.bb137
  %58 = load i32* %n, align 4
  %cmp139 = icmp slt i32 %58, 4
  br i1 %cmp139, label %for.body140, label %for.end155

for.body140:                                      ; preds = %for.cond138
  %59 = load %struct.e1000_hw** %hw.addr, align 8
  %60 = load i32* %n, align 4
  %cmp141 = icmp slt i32 %60, 4
  br i1 %cmp141, label %cond.true142, label %cond.false145

cond.true142:                                     ; preds = %for.body140
  %61 = load i32* %n, align 4
  %mul143 = mul i32 %61, 256
  %add144 = add i32 14344, %mul143
  br label %cond.end148

cond.false145:                                    ; preds = %for.body140
  %62 = load i32* %n, align 4
  %mul146 = mul i32 %62, 64
  %add147 = add i32 57352, %mul146
  br label %cond.end148

cond.end148:                                      ; preds = %cond.false145, %cond.true142
  %cond149 = phi i32 [ %add144, %cond.true142 ], [ %add147, %cond.false145 ]
  %call150 = call i32 @igb_rd32(%struct.e1000_hw* %59, i32 %cond149) noredzone
  %63 = load i32* %n, align 4
  %idxprom151 = sext i32 %63 to i64
  %arrayidx152 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom151
  store i32 %call150, i32* %arrayidx152, align 4
  br label %for.inc153

for.inc153:                                       ; preds = %cond.end148
  %64 = load i32* %n, align 4
  %inc154 = add i32 %64, 1
  store i32 %inc154, i32* %n, align 4
  br label %for.cond138

for.end155:                                       ; preds = %for.cond138
  br label %sw.epilog

sw.bb156:                                         ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond157

for.cond157:                                      ; preds = %for.inc172, %sw.bb156
  %65 = load i32* %n, align 4
  %cmp158 = icmp slt i32 %65, 4
  br i1 %cmp158, label %for.body159, label %for.end174

for.body159:                                      ; preds = %for.cond157
  %66 = load %struct.e1000_hw** %hw.addr, align 8
  %67 = load i32* %n, align 4
  %cmp160 = icmp slt i32 %67, 4
  br i1 %cmp160, label %cond.true161, label %cond.false164

cond.true161:                                     ; preds = %for.body159
  %68 = load i32* %n, align 4
  %mul162 = mul i32 %68, 256
  %add163 = add i32 14352, %mul162
  br label %cond.end167

cond.false164:                                    ; preds = %for.body159
  %69 = load i32* %n, align 4
  %mul165 = mul i32 %69, 64
  %add166 = add i32 57360, %mul165
  br label %cond.end167

cond.end167:                                      ; preds = %cond.false164, %cond.true161
  %cond168 = phi i32 [ %add163, %cond.true161 ], [ %add166, %cond.false164 ]
  %call169 = call i32 @igb_rd32(%struct.e1000_hw* %66, i32 %cond168) noredzone
  %70 = load i32* %n, align 4
  %idxprom170 = sext i32 %70 to i64
  %arrayidx171 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom170
  store i32 %call169, i32* %arrayidx171, align 4
  br label %for.inc172

for.inc172:                                       ; preds = %cond.end167
  %71 = load i32* %n, align 4
  %inc173 = add i32 %71, 1
  store i32 %inc173, i32* %n, align 4
  br label %for.cond157

for.end174:                                       ; preds = %for.cond157
  br label %sw.epilog

sw.bb175:                                         ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond176

for.cond176:                                      ; preds = %for.inc191, %sw.bb175
  %72 = load i32* %n, align 4
  %cmp177 = icmp slt i32 %72, 4
  br i1 %cmp177, label %for.body178, label %for.end193

for.body178:                                      ; preds = %for.cond176
  %73 = load %struct.e1000_hw** %hw.addr, align 8
  %74 = load i32* %n, align 4
  %cmp179 = icmp slt i32 %74, 4
  br i1 %cmp179, label %cond.true180, label %cond.false183

cond.true180:                                     ; preds = %for.body178
  %75 = load i32* %n, align 4
  %mul181 = mul i32 %75, 256
  %add182 = add i32 14360, %mul181
  br label %cond.end186

cond.false183:                                    ; preds = %for.body178
  %76 = load i32* %n, align 4
  %mul184 = mul i32 %76, 64
  %add185 = add i32 57368, %mul184
  br label %cond.end186

cond.end186:                                      ; preds = %cond.false183, %cond.true180
  %cond187 = phi i32 [ %add182, %cond.true180 ], [ %add185, %cond.false183 ]
  %call188 = call i32 @igb_rd32(%struct.e1000_hw* %73, i32 %cond187) noredzone
  %77 = load i32* %n, align 4
  %idxprom189 = sext i32 %77 to i64
  %arrayidx190 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom189
  store i32 %call188, i32* %arrayidx190, align 4
  br label %for.inc191

for.inc191:                                       ; preds = %cond.end186
  %78 = load i32* %n, align 4
  %inc192 = add i32 %78, 1
  store i32 %inc192, i32* %n, align 4
  br label %for.cond176

for.end193:                                       ; preds = %for.cond176
  br label %sw.epilog

sw.bb194:                                         ; preds = %entry
  store i32 0, i32* %n, align 4
  br label %for.cond195

for.cond195:                                      ; preds = %for.inc210, %sw.bb194
  %79 = load i32* %n, align 4
  %cmp196 = icmp slt i32 %79, 4
  br i1 %cmp196, label %for.body197, label %for.end212

for.body197:                                      ; preds = %for.cond195
  %80 = load %struct.e1000_hw** %hw.addr, align 8
  %81 = load i32* %n, align 4
  %cmp198 = icmp slt i32 %81, 4
  br i1 %cmp198, label %cond.true199, label %cond.false202

cond.true199:                                     ; preds = %for.body197
  %82 = load i32* %n, align 4
  %mul200 = mul i32 %82, 256
  %add201 = add i32 14376, %mul200
  br label %cond.end205

cond.false202:                                    ; preds = %for.body197
  %83 = load i32* %n, align 4
  %mul203 = mul i32 %83, 64
  %add204 = add i32 57384, %mul203
  br label %cond.end205

cond.end205:                                      ; preds = %cond.false202, %cond.true199
  %cond206 = phi i32 [ %add201, %cond.true199 ], [ %add204, %cond.false202 ]
  %call207 = call i32 @igb_rd32(%struct.e1000_hw* %80, i32 %cond206) noredzone
  %84 = load i32* %n, align 4
  %idxprom208 = sext i32 %84 to i64
  %arrayidx209 = getelementptr [8 x i32]* %regs, i32 0, i64 %idxprom208
  store i32 %call207, i32* %arrayidx209, align 4
  br label %for.inc210

for.inc210:                                       ; preds = %cond.end205
  %85 = load i32* %n, align 4
  %inc211 = add i32 %85, 1
  store i32 %inc211, i32* %n, align 4
  br label %for.cond195

for.end212:                                       ; preds = %for.cond195
  br label %sw.epilog

sw.default:                                       ; preds = %entry
  %86 = load %struct.igb_reg_info** %reginfo.addr, align 8
  %name = getelementptr inbounds %struct.igb_reg_info* %86, i32 0, i32 1
  %87 = load i8** %name, align 8
  %88 = load %struct.e1000_hw** %hw.addr, align 8
  %89 = load %struct.igb_reg_info** %reginfo.addr, align 8
  %ofs213 = getelementptr inbounds %struct.igb_reg_info* %89, i32 0, i32 0
  %90 = load i32* %ofs213, align 4
  %call214 = call i32 @igb_rd32(%struct.e1000_hw* %88, i32 %90) noredzone
  %call215 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([19 x i8]* @.str123, i32 0, i32 0), i8* %87, i32 %call214) noredzone
  br label %return

sw.epilog:                                        ; preds = %for.end212, %for.end193, %for.end174, %for.end155, %for.end136, %for.end117, %for.end98, %for.end79, %for.end60, %for.end41, %for.end22, %for.end
  %arraydecay = getelementptr inbounds [16 x i8]* %rname, i32 0, i32 0
  %91 = load %struct.igb_reg_info** %reginfo.addr, align 8
  %name216 = getelementptr inbounds %struct.igb_reg_info* %91, i32 0, i32 1
  %92 = load i8** %name216, align 8
  %call217 = call i32 (i8*, i64, i8*, ...)* @snprintf(i8* %arraydecay, i64 16, i8* getelementptr inbounds ([5 x i8]* @.str124, i32 0, i32 0), i8* %92, i8* getelementptr inbounds ([6 x i8]* @.str125, i32 0, i32 0)) noredzone
  %arraydecay218 = getelementptr inbounds [16 x i8]* %rname, i32 0, i32 0
  %arrayidx219 = getelementptr [8 x i32]* %regs, i32 0, i64 0
  %93 = load i32* %arrayidx219, align 4
  %arrayidx220 = getelementptr [8 x i32]* %regs, i32 0, i64 1
  %94 = load i32* %arrayidx220, align 4
  %arrayidx221 = getelementptr [8 x i32]* %regs, i32 0, i64 2
  %95 = load i32* %arrayidx221, align 4
  %arrayidx222 = getelementptr [8 x i32]* %regs, i32 0, i64 3
  %96 = load i32* %arrayidx222, align 4
  %call223 = call i32 (i8*, ...)* @printk(i8* getelementptr inbounds ([34 x i8]* @.str126, i32 0, i32 0), i8* %arraydecay218, i32 %93, i32 %94, i32 %95, i32 %96) noredzone
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default
  ret void
}

declare void @print_hex_dump(i8*, i8*, i32, i32, i32, i8*, i64, i1 zeroext) noredzone

define internal %struct.raw_spinlock* @spinlock_check(%struct.spinlock* %lock) nounwind inlinehint noredzone {
entry:
  %lock.addr = alloca %struct.spinlock*, align 8
  store %struct.spinlock* %lock, %struct.spinlock** %lock.addr, align 8
  %0 = load %struct.spinlock** %lock.addr, align 8
  %1 = getelementptr inbounds %struct.spinlock* %0, i32 0, i32 0
  %rlock = bitcast %union.anon.3* %1 to %struct.raw_spinlock*
  ret %struct.raw_spinlock* %rlock
}

define internal void @igb_probe_vfs(%struct.igb_adapter* %adapter) nounwind noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  %0 = load %struct.igb_adapter** %adapter.addr, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %0, i32 0, i32 32
  %1 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %1, %struct.pci_dev** %pdev, align 8
  %2 = load %struct.igb_adapter** %adapter.addr, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw2, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %3, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %4 = load i32* %type, align 4
  %cmp = icmp eq i32 %4, 6
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %5 = load %struct.e1000_hw** %hw, align 8
  %mac3 = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 4
  %type4 = getelementptr inbounds %struct.e1000_mac_info* %mac3, i32 0, i32 3
  %6 = load i32* %type4, align 4
  %cmp5 = icmp eq i32 %6, 7
  br i1 %cmp5, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %7 = load %struct.pci_dev** %pdev, align 8
  %call = call i32 @pci_sriov_set_totalvfs(%struct.pci_dev* %7, i16 zeroext 7) noredzone
  %8 = load %struct.pci_dev** %pdev, align 8
  %9 = load i32* @max_vfs, align 4
  %call6 = call i32 @igb_pci_enable_sriov(%struct.pci_dev* %8, i32 %9) noredzone
  br label %return

return:                                           ; preds = %if.end, %if.then
  ret void
}

declare i32 @pci_sriov_set_totalvfs(%struct.pci_dev*, i16 zeroext) noredzone

define internal i32 @igb_xmit_frame(%struct.sk_buff* %skb, %struct.net_device* %netdev) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %skb.addr = alloca %struct.sk_buff*, align 8
  %netdev.addr = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %entry
  %2 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %3 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %3, 63
  %shl.i = shl i64 1, %and.i
  %4 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %4, 6
  %5 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %5, i64 %shr.i
  %6 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %6
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then, label %if.end

cond.false:                                       ; preds = %entry
  %7 = load %struct.igb_adapter** %adapter, align 8
  %state2 = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 2
  %call3 = call i32 @variable_test_bit(i64 2, i64* %state2) noredzone
  %tobool4 = icmp ne i32 %call3, 0
  br i1 %tobool4, label %if.then, label %if.end

if.then:                                          ; preds = %cond.false, %cond.true
  %8 = load %struct.sk_buff** %skb.addr, align 8
  call void @dev_kfree_skb_any(%struct.sk_buff* %8) noredzone
  store i32 0, i32* %retval
  br label %return

if.end:                                           ; preds = %cond.false, %cond.true
  %9 = load %struct.sk_buff** %skb.addr, align 8
  %len = getelementptr inbounds %struct.sk_buff* %9, i32 0, i32 8
  %10 = load i32* %len, align 4
  %cmp = icmp ule i32 %10, 0
  br i1 %cmp, label %if.then5, label %if.end6

if.then5:                                         ; preds = %if.end
  %11 = load %struct.sk_buff** %skb.addr, align 8
  call void @dev_kfree_skb_any(%struct.sk_buff* %11) noredzone
  store i32 0, i32* %retval
  br label %return

if.end6:                                          ; preds = %if.end
  %12 = load %struct.sk_buff** %skb.addr, align 8
  %len7 = getelementptr inbounds %struct.sk_buff* %12, i32 0, i32 8
  %13 = load i32* %len7, align 4
  %cmp8 = icmp ult i32 %13, 17
  %lnot = xor i1 %cmp8, true
  %lnot9 = xor i1 %lnot, true
  %lnot.ext = zext i1 %lnot9 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool10 = icmp ne i64 %expval, 0
  br i1 %tobool10, label %if.then11, label %if.end18

if.then11:                                        ; preds = %if.end6
  %14 = load %struct.sk_buff** %skb.addr, align 8
  %15 = load %struct.sk_buff** %skb.addr, align 8
  %len12 = getelementptr inbounds %struct.sk_buff* %15, i32 0, i32 8
  %16 = load i32* %len12, align 4
  %sub = sub i32 17, %16
  %call13 = call i32 @skb_pad(%struct.sk_buff* %14, i32 %sub) noredzone
  %tobool14 = icmp ne i32 %call13, 0
  br i1 %tobool14, label %if.then15, label %if.end16

if.then15:                                        ; preds = %if.then11
  store i32 0, i32* %retval
  br label %return

if.end16:                                         ; preds = %if.then11
  %17 = load %struct.sk_buff** %skb.addr, align 8
  %len17 = getelementptr inbounds %struct.sk_buff* %17, i32 0, i32 8
  store i32 17, i32* %len17, align 4
  %18 = load %struct.sk_buff** %skb.addr, align 8
  call void @skb_set_tail_pointer(%struct.sk_buff* %18, i32 17) noredzone
  br label %if.end18

if.end18:                                         ; preds = %if.end16, %if.end6
  %19 = load %struct.sk_buff** %skb.addr, align 8
  %20 = load %struct.igb_adapter** %adapter, align 8
  %21 = load %struct.sk_buff** %skb.addr, align 8
  %call19 = call %struct.igb_ring* @igb_tx_queue_mapping(%struct.igb_adapter* %20, %struct.sk_buff* %21) noredzone
  %call20 = call i32 @igb_xmit_frame_ring(%struct.sk_buff* %19, %struct.igb_ring* %call19) noredzone
  store i32 %call20, i32* %retval
  br label %return

return:                                           ; preds = %if.end18, %if.then15, %if.then5, %if.then
  %22 = load i32* %retval
  ret i32 %22
}

define internal i32 @igb_set_mac(%struct.net_device* %netdev, i8* %p) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %p.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %addr = alloca %struct.sockaddr*, align 8
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  %__len4 = alloca i64, align 8
  %__ret7 = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load i8** %p.addr, align 8
  %4 = bitcast i8* %3 to %struct.sockaddr*
  store %struct.sockaddr* %4, %struct.sockaddr** %addr, align 8
  %5 = load %struct.sockaddr** %addr, align 8
  %sa_data = getelementptr inbounds %struct.sockaddr* %5, i32 0, i32 1
  %arraydecay = getelementptr inbounds [14 x i8]* %sa_data, i32 0, i32 0
  %call2 = call zeroext i1 @is_valid_ether_addr(i8* %arraydecay) noredzone
  br i1 %call2, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -99, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %6 = load %struct.net_device** %netdev.addr, align 8
  %addr_len = getelementptr inbounds %struct.net_device* %6, i32 0, i32 47
  %7 = load i8* %addr_len, align 1
  %conv = zext i8 %7 to i64
  store i64 %conv, i64* %__len, align 8
  %8 = load %struct.net_device** %netdev.addr, align 8
  %dev_addr = getelementptr inbounds %struct.net_device* %8, i32 0, i32 70
  %9 = load i8** %dev_addr, align 8
  %10 = load %struct.sockaddr** %addr, align 8
  %sa_data3 = getelementptr inbounds %struct.sockaddr* %10, i32 0, i32 1
  %11 = bitcast [14 x i8]* %sa_data3 to i8*
  %12 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %9, i8* %11, i64 %12, i32 1, i1 false)
  store i8* %9, i8** %__ret, align 8
  %13 = load i8** %__ret, align 8
  %14 = load %struct.net_device** %netdev.addr, align 8
  %addr_len5 = getelementptr inbounds %struct.net_device* %14, i32 0, i32 47
  %15 = load i8* %addr_len5, align 1
  %conv6 = zext i8 %15 to i64
  store i64 %conv6, i64* %__len4, align 8
  %16 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %16, i32 0, i32 4
  %addr8 = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 1
  %17 = bitcast [6 x i8]* %addr8 to i8*
  %18 = load %struct.sockaddr** %addr, align 8
  %sa_data9 = getelementptr inbounds %struct.sockaddr* %18, i32 0, i32 1
  %19 = bitcast [14 x i8]* %sa_data9 to i8*
  %20 = load i64* %__len4, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %17, i8* %19, i64 %20, i32 1, i1 false)
  store i8* %17, i8** %__ret7, align 8
  %21 = load i8** %__ret7, align 8
  %22 = load %struct.igb_adapter** %adapter, align 8
  %23 = load %struct.e1000_hw** %hw, align 8
  %mac10 = getelementptr inbounds %struct.e1000_hw* %23, i32 0, i32 4
  %addr11 = getelementptr inbounds %struct.e1000_mac_info* %mac10, i32 0, i32 1
  %arraydecay12 = getelementptr inbounds [6 x i8]* %addr11, i32 0, i32 0
  %24 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %24, i32 0, i32 49
  %25 = load i32* %vfs_allocated_count, align 4
  %conv13 = trunc i32 %25 to i8
  call void @igb_rar_set_qsel(%struct.igb_adapter* %22, i8* %arraydecay12, i32 0, i8 zeroext %conv13) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %26 = load i32* %retval
  ret i32 %26
}

declare i32 @eth_validate_addr(%struct.net_device*) noredzone

define internal i32 @igb_ioctl(%struct.net_device* %netdev, %struct.ifreq* %ifr, i32 %cmd) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %ifr.addr = alloca %struct.ifreq*, align 8
  %cmd.addr = alloca i32, align 4
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store %struct.ifreq* %ifr, %struct.ifreq** %ifr.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  %0 = load i32* %cmd.addr, align 4
  switch i32 %0, label %sw.default [
    i32 35143, label %sw.bb
    i32 35144, label %sw.bb
    i32 35145, label %sw.bb
    i32 35249, label %sw.bb1
    i32 35248, label %sw.bb3
  ]

sw.bb:                                            ; preds = %entry, %entry, %entry
  %1 = load %struct.net_device** %netdev.addr, align 8
  %2 = load %struct.ifreq** %ifr.addr, align 8
  %3 = load i32* %cmd.addr, align 4
  %call = call i32 @igb_mii_ioctl(%struct.net_device* %1, %struct.ifreq* %2, i32 %3) noredzone
  store i32 %call, i32* %retval
  br label %return

sw.bb1:                                           ; preds = %entry
  %4 = load %struct.net_device** %netdev.addr, align 8
  %5 = load %struct.ifreq** %ifr.addr, align 8
  %call2 = call i32 @igb_ptp_get_ts_config(%struct.net_device* %4, %struct.ifreq* %5) noredzone
  store i32 %call2, i32* %retval
  br label %return

sw.bb3:                                           ; preds = %entry
  %6 = load %struct.net_device** %netdev.addr, align 8
  %7 = load %struct.ifreq** %ifr.addr, align 8
  %call4 = call i32 @igb_ptp_set_ts_config(%struct.net_device* %6, %struct.ifreq* %7) noredzone
  store i32 %call4, i32* %retval
  br label %return

sw.default:                                       ; preds = %entry
  store i32 -95, i32* %retval
  br label %return

return:                                           ; preds = %sw.default, %sw.bb3, %sw.bb1, %sw.bb
  %8 = load i32* %retval
  ret i32 %8
}

define internal i32 @igb_change_mtu(%struct.net_device* %netdev, i32 %new_mtu) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %new_mtu.addr = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %max_frame = alloca i32, align 4
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i32 %new_mtu, i32* %new_mtu.addr, align 4
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %pdev1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 32
  %3 = load %struct.pci_dev** %pdev1, align 8
  store %struct.pci_dev* %3, %struct.pci_dev** %pdev, align 8
  %4 = load i32* %new_mtu.addr, align 4
  %add = add i32 %4, 14
  %add2 = add i32 %add, 4
  %add3 = add i32 %add2, 4
  store i32 %add3, i32* %max_frame, align 4
  %5 = load i32* %new_mtu.addr, align 4
  %cmp = icmp slt i32 %5, 68
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %6 = load i32* %max_frame, align 4
  %cmp4 = icmp sgt i32 %6, 16128
  br i1 %cmp4, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  %7 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %7, i32 0, i32 33
  %call5 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev, i8* getelementptr inbounds ([21 x i8]* @.str154, i32 0, i32 0)) noredzone
  store i32 -22, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %8 = load i32* %max_frame, align 4
  %cmp6 = icmp sgt i32 %8, 9238
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end
  %9 = load %struct.pci_dev** %pdev, align 8
  %dev8 = getelementptr inbounds %struct.pci_dev* %9, i32 0, i32 33
  %call9 = call i32 (%struct.device*, i8*, ...)* @dev_err(%struct.device* %dev8, i8* getelementptr inbounds ([27 x i8]* @.str155, i32 0, i32 0)) noredzone
  store i32 -22, i32* %retval
  br label %return

if.end10:                                         ; preds = %if.end
  %10 = load i32* %max_frame, align 4
  %cmp11 = icmp slt i32 %10, 1518
  br i1 %cmp11, label %if.then12, label %if.end13

if.then12:                                        ; preds = %if.end10
  store i32 1518, i32* %max_frame, align 4
  br label %if.end13

if.end13:                                         ; preds = %if.then12, %if.end10
  br label %while.cond

while.cond:                                       ; preds = %while.body, %if.end13
  %11 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 2
  %call14 = call i32 @test_and_set_bit(i64 1, i64* %state) noredzone
  %tobool = icmp ne i32 %call14, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  call void @usleep_range(i64 1000, i64 2000) noredzone
  br label %while.cond

while.end:                                        ; preds = %while.cond
  %12 = load i32* %max_frame, align 4
  %13 = load %struct.igb_adapter** %adapter, align 8
  %max_frame_size = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 16
  store i32 %12, i32* %max_frame_size, align 4
  %14 = load %struct.net_device** %netdev.addr, align 8
  %call15 = call zeroext i1 @netif_running(%struct.net_device* %14) noredzone
  br i1 %call15, label %if.then16, label %if.end17

if.then16:                                        ; preds = %while.end
  %15 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_down(%struct.igb_adapter* %15) noredzone
  br label %if.end17

if.end17:                                         ; preds = %if.then16, %while.end
  %16 = load %struct.pci_dev** %pdev, align 8
  %dev18 = getelementptr inbounds %struct.pci_dev* %16, i32 0, i32 33
  %17 = load %struct.net_device** %netdev.addr, align 8
  %mtu = getelementptr inbounds %struct.net_device* %17, i32 0, i32 40
  %18 = load i32* %mtu, align 4
  %19 = load i32* %new_mtu.addr, align 4
  %call19 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev18, i8* getelementptr inbounds ([28 x i8]* @.str156, i32 0, i32 0), i32 %18, i32 %19) noredzone
  %20 = load i32* %new_mtu.addr, align 4
  %21 = load %struct.net_device** %netdev.addr, align 8
  %mtu20 = getelementptr inbounds %struct.net_device* %21, i32 0, i32 40
  store i32 %20, i32* %mtu20, align 4
  %22 = load %struct.net_device** %netdev.addr, align 8
  %call21 = call zeroext i1 @netif_running(%struct.net_device* %22) noredzone
  br i1 %call21, label %if.then22, label %if.else

if.then22:                                        ; preds = %if.end17
  %23 = load %struct.igb_adapter** %adapter, align 8
  %call23 = call i32 @igb_up(%struct.igb_adapter* %23) noredzone
  br label %if.end24

if.else:                                          ; preds = %if.end17
  %24 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %24) noredzone
  br label %if.end24

if.end24:                                         ; preds = %if.else, %if.then22
  %25 = load %struct.igb_adapter** %adapter, align 8
  %state25 = getelementptr inbounds %struct.igb_adapter* %25, i32 0, i32 2
  store i64 1, i64* %nr.addr.i, align 8
  store i64* %state25, i64** %addr.addr.i, align 8
  %26 = load i64** %addr.addr.i, align 8
  %27 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %26, i64 %27, i64* %26) nounwind, !srcloc !1
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end24, %if.then7, %if.then
  %28 = load i32* %retval
  ret i32 %28
}

define internal void @igb_tx_timeout(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %hw_addr = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %tx_timeout_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 11
  %4 = load i32* %tx_timeout_count, align 4
  %inc = add i32 %4, 1
  store i32 %inc, i32* %tx_timeout_count, align 4
  %5 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %5, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %6 = load i32* %type, align 4
  %cmp = icmp uge i32 %6, 3
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load %struct.e1000_hw** %hw, align 8
  %dev_spec = getelementptr inbounds %struct.e1000_hw* %7, i32 0, i32 11
  %_82575 = bitcast %union.anon.86* %dev_spec to %struct.e1000_dev_spec_82575*
  %global_device_reset = getelementptr inbounds %struct.e1000_dev_spec_82575* %_82575, i32 0, i32 1
  store i8 1, i8* %global_device_reset, align 1
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load %struct.igb_adapter** %adapter, align 8
  %reset_task = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 26
  %call2 = call zeroext i1 @schedule_work(%struct.work_struct* %reset_task) noredzone
  br label %do.body

do.body:                                          ; preds = %if.end
  %9 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %9, i32 0, i32 1
  %10 = load volatile i8** %hw_addr3, align 8
  store i8* %10, i8** %hw_addr, align 8
  %11 = load i8** %hw_addr, align 8
  %tobool = icmp ne i8* %11, null
  %lnot = xor i1 %tobool, true
  %lnot4 = xor i1 %lnot, true
  %lnot5 = xor i1 %lnot4, true
  %lnot.ext = zext i1 %lnot5 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool6 = icmp ne i64 %expval, 0
  br i1 %tobool6, label %if.end8, label %if.then7

if.then7:                                         ; preds = %do.body
  %12 = load %struct.igb_adapter** %adapter, align 8
  %eims_enable_mask = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 45
  %13 = load i32* %eims_enable_mask, align 4
  %14 = load %struct.igb_adapter** %adapter, align 8
  %eims_other = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 46
  %15 = load i32* %eims_other, align 4
  %neg = xor i32 %15, -1
  %and = and i32 %13, %neg
  %16 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %16, i64 5408
  call void @writel(i32 %and, i8* %arrayidx) noredzone
  br label %if.end8

if.end8:                                          ; preds = %if.then7, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end8
  ret void
}

define internal %struct.rtnl_link_stats64* @igb_get_stats64(%struct.net_device* %netdev, %struct.rtnl_link_stats64* %stats) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  %stats.addr = alloca %struct.rtnl_link_stats64*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store %struct.rtnl_link_stats64* %stats, %struct.rtnl_link_stats64** %stats.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %stats64_lock = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 33
  call void @spin_lock(%struct.spinlock* %stats64_lock) noredzone
  %3 = load %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %stats64 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 34
  call void @igb_update_stats(%struct.igb_adapter* %3, %struct.rtnl_link_stats64* %stats64) noredzone
  store i64 184, i64* %__len, align 8
  %5 = load i64* %__len, align 8
  %cmp = icmp uge i64 %5, 64
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %6 = load %struct.rtnl_link_stats64** %stats.addr, align 8
  %7 = bitcast %struct.rtnl_link_stats64* %6 to i8*
  %8 = load %struct.igb_adapter** %adapter, align 8
  %stats641 = getelementptr inbounds %struct.igb_adapter* %8, i32 0, i32 34
  %9 = bitcast %struct.rtnl_link_stats64* %stats641 to i8*
  %10 = load i64* %__len, align 8
  %call2 = call i8* @__memcpy(i8* %7, i8* %9, i64 %10) noredzone
  store i8* %call2, i8** %__ret, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %11 = load %struct.rtnl_link_stats64** %stats.addr, align 8
  %12 = bitcast %struct.rtnl_link_stats64* %11 to i8*
  %13 = load %struct.igb_adapter** %adapter, align 8
  %stats643 = getelementptr inbounds %struct.igb_adapter* %13, i32 0, i32 34
  %14 = bitcast %struct.rtnl_link_stats64* %stats643 to i8*
  %15 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %12, i8* %14, i64 %15, i32 8, i1 false)
  store i8* %12, i8** %__ret, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %16 = load i8** %__ret, align 8
  %17 = load %struct.igb_adapter** %adapter, align 8
  %stats64_lock4 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 33
  call void @spin_unlock(%struct.spinlock* %stats64_lock4) noredzone
  %18 = load %struct.rtnl_link_stats64** %stats.addr, align 8
  ret %struct.rtnl_link_stats64* %18
}

define internal i32 @igb_vlan_rx_kill_vid(%struct.net_device* %netdev, i16 zeroext %proto, i16 zeroext %vid) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %netdev.addr = alloca %struct.net_device*, align 8
  %proto.addr = alloca i16, align 2
  %vid.addr = alloca i16, align 2
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %pf_id = alloca i32, align 4
  %err = alloca i32, align 4
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i16 %proto, i16* %proto.addr, align 2
  store i16 %vid, i16* %vid.addr, align 2
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  store i32 %4, i32* %pf_id, align 4
  %5 = load %struct.igb_adapter** %adapter, align 8
  %6 = load i16* %vid.addr, align 2
  %conv = zext i16 %6 to i32
  %7 = load i32* %pf_id, align 4
  %call2 = call i32 @igb_vlvf_set(%struct.igb_adapter* %5, i32 %conv, i1 zeroext false, i32 %7) noredzone
  store i32 %call2, i32* %err, align 4
  %8 = load i32* %err, align 4
  %tobool = icmp ne i32 %8, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load %struct.e1000_hw** %hw, align 8
  %10 = load i16* %vid.addr, align 2
  %conv3 = zext i16 %10 to i32
  %call4 = call i32 @igb_vfta_set(%struct.e1000_hw* %9, i32 %conv3, i1 zeroext false) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %11 = load i16* %vid.addr, align 2
  %conv5 = zext i16 %11 to i64
  %12 = load %struct.igb_adapter** %adapter, align 8
  %active_vlans = getelementptr inbounds %struct.igb_adapter* %12, i32 0, i32 0
  %arraydecay = getelementptr inbounds [64 x i64]* %active_vlans, i32 0, i32 0
  store i64 %conv5, i64* %nr.addr.i, align 8
  store i64* %arraydecay, i64** %addr.addr.i, align 8
  %13 = load i64** %addr.addr.i, align 8
  %14 = load i64* %nr.addr.i, align 8
  call void asm sideeffect ".pushsection .smp_locks,\22a\22\0A.balign 4\0A.long 671f - .\0A.popsection\0A671:\0A\09lock; btr $1,$0", "=*m,Ir,*m,~{dirflag},~{fpsr},~{flags}"(i64* %13, i64 %14, i64* %13) nounwind, !srcloc !1
  ret i32 0
}

define internal void @igb_netpoll(%struct.net_device* %netdev) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %q_vector = alloca %struct.igb_q_vector*, align 8
  %i = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %3 = load i32* %i, align 4
  %4 = load %struct.igb_adapter** %adapter, align 8
  %num_q_vectors = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 4
  %5 = load i32* %num_q_vectors, align 4
  %cmp = icmp ult i32 %3, %5
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %6 = load i32* %i, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.igb_adapter** %adapter, align 8
  %q_vector2 = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 44
  %arrayidx = getelementptr [8 x %struct.igb_q_vector*]* %q_vector2, i32 0, i64 %idxprom
  %8 = load %struct.igb_q_vector** %arrayidx, align 8
  store %struct.igb_q_vector* %8, %struct.igb_q_vector** %q_vector, align 8
  %9 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 3
  %10 = load i32* %flags, align 4
  %and = and i32 %10, 8192
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %for.body
  br label %do.body

do.body:                                          ; preds = %if.then
  %11 = load %struct.e1000_hw** %hw, align 8
  %hw_addr3 = getelementptr inbounds %struct.e1000_hw* %11, i32 0, i32 1
  %12 = load volatile i8** %hw_addr3, align 8
  store i8* %12, i8** %hw_addr, align 8
  %13 = load i8** %hw_addr, align 8
  %tobool4 = icmp ne i8* %13, null
  %lnot = xor i1 %tobool4, true
  %lnot5 = xor i1 %lnot, true
  %lnot6 = xor i1 %lnot5, true
  %lnot.ext = zext i1 %lnot6 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool7 = icmp ne i64 %expval, 0
  br i1 %tobool7, label %if.end, label %if.then8

if.then8:                                         ; preds = %do.body
  %14 = load %struct.igb_q_vector** %q_vector, align 8
  %eims_value = getelementptr inbounds %struct.igb_q_vector* %14, i32 0, i32 2
  %15 = load i32* %eims_value, align 4
  %16 = load i8** %hw_addr, align 8
  %arrayidx9 = getelementptr i8* %16, i64 5416
  call void @writel(i32 %15, i8* %arrayidx9) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then8, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end
  br label %if.end10

if.else:                                          ; preds = %for.body
  %17 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_irq_disable(%struct.igb_adapter* %17) noredzone
  br label %if.end10

if.end10:                                         ; preds = %if.else, %do.end
  %18 = load %struct.igb_q_vector** %q_vector, align 8
  %napi = getelementptr inbounds %struct.igb_q_vector* %18, i32 0, i32 8
  call void @napi_schedule(%struct.napi_struct* %napi) noredzone
  br label %for.inc

for.inc:                                          ; preds = %if.end10
  %19 = load i32* %i, align 4
  %inc = add i32 %19, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  ret void
}

define internal i32 @igb_ndo_set_vf_mac(%struct.net_device* %netdev, i32 %vf, i8* %mac) nounwind noredzone {
entry:
  %nr.addr.i = alloca i64, align 8
  %addr.addr.i = alloca i64*, align 8
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %vf.addr = alloca i32, align 4
  %mac.addr = alloca i8*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  store i8* %mac, i8** %mac.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load i8** %mac.addr, align 8
  %call1 = call zeroext i1 @is_valid_ether_addr(i8* %2) noredzone
  br i1 %call1, label %lor.lhs.false, label %if.then

lor.lhs.false:                                    ; preds = %entry
  %3 = load i32* %vf.addr, align 4
  %4 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 49
  %5 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp uge i32 %3, %5
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %lor.lhs.false, %entry
  store i32 -22, i32* %retval
  br label %return

if.end:                                           ; preds = %lor.lhs.false
  %6 = load i32* %vf.addr, align 4
  %idxprom = sext i32 %6 to i64
  %7 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %7, i32 0, i32 50
  %8 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %8, i64 %idxprom
  %flags = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 4
  %9 = load i32* %flags, align 4
  %or = or i32 %9, 8
  store i32 %or, i32* %flags, align 4
  %10 = load %struct.igb_adapter** %adapter, align 8
  %pdev = getelementptr inbounds %struct.igb_adapter* %10, i32 0, i32 32
  %11 = load %struct.pci_dev** %pdev, align 8
  %dev = getelementptr inbounds %struct.pci_dev* %11, i32 0, i32 33
  %12 = load i8** %mac.addr, align 8
  %13 = load i32* %vf.addr, align 4
  %call2 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev, i8* getelementptr inbounds ([26 x i8]* @.str151, i32 0, i32 0), i8* %12, i32 %13) noredzone
  %14 = load %struct.igb_adapter** %adapter, align 8
  %pdev3 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 32
  %15 = load %struct.pci_dev** %pdev3, align 8
  %dev4 = getelementptr inbounds %struct.pci_dev* %15, i32 0, i32 33
  %call5 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev4, i8* getelementptr inbounds ([52 x i8]* @.str152, i32 0, i32 0)) noredzone
  br i1 true, label %cond.true, label %cond.false

cond.true:                                        ; preds = %if.end
  %16 = load %struct.igb_adapter** %adapter, align 8
  %state = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 2
  store i64 2, i64* %nr.addr.i, align 8
  store i64* %state, i64** %addr.addr.i, align 8
  %17 = load i64* %nr.addr.i, align 8
  %and.i = and i64 %17, 63
  %shl.i = shl i64 1, %and.i
  %18 = load i64* %nr.addr.i, align 8
  %shr.i = ashr i64 %18, 6
  %19 = load i64** %addr.addr.i, align 8
  %arrayidx.i = getelementptr i64* %19, i64 %shr.i
  %20 = load volatile i64* %arrayidx.i, align 8
  %and1.i = and i64 %shl.i, %20
  %cmp.i = icmp ne i64 %and1.i, 0
  %conv.i = zext i1 %cmp.i to i32
  %tobool = icmp ne i32 %conv.i, 0
  br i1 %tobool, label %if.then10, label %if.end17

cond.false:                                       ; preds = %if.end
  %21 = load %struct.igb_adapter** %adapter, align 8
  %state7 = getelementptr inbounds %struct.igb_adapter* %21, i32 0, i32 2
  %call8 = call i32 @variable_test_bit(i64 2, i64* %state7) noredzone
  %tobool9 = icmp ne i32 %call8, 0
  br i1 %tobool9, label %if.then10, label %if.end17

if.then10:                                        ; preds = %cond.false, %cond.true
  %22 = load %struct.igb_adapter** %adapter, align 8
  %pdev11 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 32
  %23 = load %struct.pci_dev** %pdev11, align 8
  %dev12 = getelementptr inbounds %struct.pci_dev* %23, i32 0, i32 33
  %call13 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev12, i8* getelementptr inbounds ([63 x i8]* @.str153, i32 0, i32 0)) noredzone
  %24 = load %struct.igb_adapter** %adapter, align 8
  %pdev14 = getelementptr inbounds %struct.igb_adapter* %24, i32 0, i32 32
  %25 = load %struct.pci_dev** %pdev14, align 8
  %dev15 = getelementptr inbounds %struct.pci_dev* %25, i32 0, i32 33
  %call16 = call i32 (%struct.device*, i8*, ...)* @dev_warn(%struct.device* %dev15, i8* getelementptr inbounds ([64 x i8]* @.str23, i32 0, i32 0)) noredzone
  br label %if.end17

if.end17:                                         ; preds = %if.then10, %cond.false, %cond.true
  %26 = load %struct.igb_adapter** %adapter, align 8
  %27 = load i32* %vf.addr, align 4
  %28 = load i8** %mac.addr, align 8
  %call18 = call i32 @igb_set_vf_mac(%struct.igb_adapter* %26, i32 %27, i8* %28) noredzone
  store i32 %call18, i32* %retval
  br label %return

return:                                           ; preds = %if.end17, %if.then
  %29 = load i32* %retval
  ret i32 %29
}

define internal i32 @igb_ndo_set_vf_bw(%struct.net_device* %netdev, i32 %vf, i32 %min_tx_rate, i32 %max_tx_rate) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %vf.addr = alloca i32, align 4
  %min_tx_rate.addr = alloca i32, align 4
  %max_tx_rate.addr = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %actual_link_speed = alloca i32, align 4
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  store i32 %min_tx_rate, i32* %min_tx_rate.addr, align 4
  store i32 %max_tx_rate, i32* %max_tx_rate.addr, align 4
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %3, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %4 = load i32* %type, align 4
  %cmp = icmp ne i32 %4, 2
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -95, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32* %min_tx_rate.addr, align 4
  %tobool = icmp ne i32 %5, 0
  br i1 %tobool, label %if.then2, label %if.end3

if.then2:                                         ; preds = %if.end
  store i32 -22, i32* %retval
  br label %return

if.end3:                                          ; preds = %if.end
  %6 = load %struct.igb_adapter** %adapter, align 8
  %link_speed = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 24
  %7 = load i16* %link_speed, align 2
  %conv = zext i16 %7 to i32
  %call4 = call i32 @igb_link_mbps(i32 %conv) noredzone
  store i32 %call4, i32* %actual_link_speed, align 4
  %8 = load i32* %vf.addr, align 4
  %9 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 49
  %10 = load i32* %vfs_allocated_count, align 4
  %cmp5 = icmp uge i32 %8, %10
  br i1 %cmp5, label %if.then15, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %if.end3
  %11 = load %struct.e1000_hw** %hw, align 8
  %call7 = call i32 @igb_rd32(%struct.e1000_hw* %11, i32 8) noredzone
  %and = and i32 %call7, 2
  %tobool8 = icmp ne i32 %and, 0
  br i1 %tobool8, label %lor.lhs.false9, label %if.then15

lor.lhs.false9:                                   ; preds = %lor.lhs.false
  %12 = load i32* %max_tx_rate.addr, align 4
  %cmp10 = icmp slt i32 %12, 0
  br i1 %cmp10, label %if.then15, label %lor.lhs.false12

lor.lhs.false12:                                  ; preds = %lor.lhs.false9
  %13 = load i32* %max_tx_rate.addr, align 4
  %14 = load i32* %actual_link_speed, align 4
  %cmp13 = icmp sgt i32 %13, %14
  br i1 %cmp13, label %if.then15, label %if.end16

if.then15:                                        ; preds = %lor.lhs.false12, %lor.lhs.false9, %lor.lhs.false, %if.end3
  store i32 -22, i32* %retval
  br label %return

if.end16:                                         ; preds = %lor.lhs.false12
  %15 = load i32* %actual_link_speed, align 4
  %16 = load %struct.igb_adapter** %adapter, align 8
  %vf_rate_link_speed = getelementptr inbounds %struct.igb_adapter* %16, i32 0, i32 51
  store i32 %15, i32* %vf_rate_link_speed, align 4
  %17 = load i32* %max_tx_rate.addr, align 4
  %conv17 = trunc i32 %17 to i16
  %18 = load i32* %vf.addr, align 4
  %idxprom = sext i32 %18 to i64
  %19 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %19, i32 0, i32 50
  %20 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %20, i64 %idxprom
  %tx_rate = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 8
  store i16 %conv17, i16* %tx_rate, align 2
  %21 = load %struct.e1000_hw** %hw, align 8
  %22 = load i32* %vf.addr, align 4
  %23 = load i32* %max_tx_rate.addr, align 4
  %24 = load i32* %actual_link_speed, align 4
  call void @igb_set_vf_rate_limit(%struct.e1000_hw* %21, i32 %22, i32 %23, i32 %24) noredzone
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end16, %if.then15, %if.then2, %if.then
  %25 = load i32* %retval
  ret i32 %25
}

define internal i32 @igb_ndo_set_vf_spoofchk(%struct.net_device* %netdev, i32 %vf, i1 zeroext %setting) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %vf.addr = alloca i32, align 4
  %setting.addr = alloca i8, align 1
  %adapter = alloca %struct.igb_adapter*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %reg_val = alloca i32, align 4
  %reg_offset = alloca i32, align 4
  %hw_addr = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  %frombool = zext i1 %setting to i8
  store i8 %frombool, i8* %setting.addr, align 1
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.igb_adapter** %adapter, align 8
  %hw1 = getelementptr inbounds %struct.igb_adapter* %2, i32 0, i32 35
  store %struct.e1000_hw* %hw1, %struct.e1000_hw** %hw, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -95, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32* %vf.addr, align 4
  %6 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count2 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 49
  %7 = load i32* %vfs_allocated_count2, align 4
  %cmp = icmp uge i32 %5, %7
  br i1 %cmp, label %if.then3, label %if.end4

if.then3:                                         ; preds = %if.end
  store i32 -22, i32* %retval
  br label %return

if.end4:                                          ; preds = %if.end
  %8 = load %struct.e1000_hw** %hw, align 8
  %mac = getelementptr inbounds %struct.e1000_hw* %8, i32 0, i32 4
  %type = getelementptr inbounds %struct.e1000_mac_info* %mac, i32 0, i32 3
  %9 = load i32* %type, align 4
  %cmp5 = icmp eq i32 %9, 2
  %cond = select i1 %cmp5, i32 13568, i32 23244
  store i32 %cond, i32* %reg_offset, align 4
  %10 = load %struct.e1000_hw** %hw, align 8
  %11 = load i32* %reg_offset, align 4
  %call6 = call i32 @igb_rd32(%struct.e1000_hw* %10, i32 %11) noredzone
  store i32 %call6, i32* %reg_val, align 4
  %12 = load i8* %setting.addr, align 1
  %tobool7 = trunc i8 %12 to i1
  br i1 %tobool7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end4
  %13 = load i32* %vf.addr, align 4
  %shl = shl i32 1, %13
  %14 = load i32* %vf.addr, align 4
  %add = add i32 %14, 8
  %shl9 = shl i32 1, %add
  %or = or i32 %shl, %shl9
  %15 = load i32* %reg_val, align 4
  %or10 = or i32 %15, %or
  store i32 %or10, i32* %reg_val, align 4
  br label %if.end15

if.else:                                          ; preds = %if.end4
  %16 = load i32* %vf.addr, align 4
  %shl11 = shl i32 1, %16
  %17 = load i32* %vf.addr, align 4
  %add12 = add i32 %17, 8
  %shl13 = shl i32 1, %add12
  %or14 = or i32 %shl11, %shl13
  %neg = xor i32 %or14, -1
  %18 = load i32* %reg_val, align 4
  %and = and i32 %18, %neg
  store i32 %and, i32* %reg_val, align 4
  br label %if.end15

if.end15:                                         ; preds = %if.else, %if.then8
  br label %do.body

do.body:                                          ; preds = %if.end15
  %19 = load %struct.e1000_hw** %hw, align 8
  %hw_addr16 = getelementptr inbounds %struct.e1000_hw* %19, i32 0, i32 1
  %20 = load volatile i8** %hw_addr16, align 8
  store i8* %20, i8** %hw_addr, align 8
  %21 = load i8** %hw_addr, align 8
  %tobool17 = icmp ne i8* %21, null
  %lnot = xor i1 %tobool17, true
  %lnot18 = xor i1 %lnot, true
  %lnot19 = xor i1 %lnot18, true
  %lnot.ext = zext i1 %lnot19 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool20 = icmp ne i64 %expval, 0
  br i1 %tobool20, label %if.end22, label %if.then21

if.then21:                                        ; preds = %do.body
  %22 = load i32* %reg_val, align 4
  %23 = load i32* %reg_offset, align 4
  %idxprom = zext i32 %23 to i64
  %24 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %24, i64 %idxprom
  call void @writel(i32 %22, i8* %arrayidx) noredzone
  br label %if.end22

if.end22:                                         ; preds = %if.then21, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end22
  %25 = load i8* %setting.addr, align 1
  %tobool23 = trunc i8 %25 to i1
  %26 = load i32* %vf.addr, align 4
  %idxprom24 = sext i32 %26 to i64
  %27 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %27, i32 0, i32 50
  %28 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx25 = getelementptr %struct.vf_data_storage* %28, i64 %idxprom24
  %spoofchk_enabled = getelementptr inbounds %struct.vf_data_storage* %arrayidx25, i32 0, i32 9
  %frombool26 = zext i1 %tobool23 to i8
  store i8 %frombool26, i8* %spoofchk_enabled, align 1
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %do.end, %if.then3, %if.then
  %29 = load i32* %retval
  ret i32 %29
}

define internal i32 @igb_ndo_get_vf_config(%struct.net_device* %netdev, i32 %vf, %struct.ifla_vf_info* %ivi) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %vf.addr = alloca i32, align 4
  %ivi.addr = alloca %struct.ifla_vf_info*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %__len = alloca i64, align 8
  %__ret = alloca i8*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i32 %vf, i32* %vf.addr, align 4
  store %struct.ifla_vf_info* %ivi, %struct.ifla_vf_info** %ivi.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load i32* %vf.addr, align 4
  %3 = load %struct.igb_adapter** %adapter, align 8
  %vfs_allocated_count = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 49
  %4 = load i32* %vfs_allocated_count, align 4
  %cmp = icmp uge i32 %2, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -22, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32* %vf.addr, align 4
  %6 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %vf1 = getelementptr inbounds %struct.ifla_vf_info* %6, i32 0, i32 0
  store i32 %5, i32* %vf1, align 4
  store i64 6, i64* %__len, align 8
  %7 = load i64* %__len, align 8
  %cmp2 = icmp uge i64 %7, 64
  br i1 %cmp2, label %if.then3, label %if.else

if.then3:                                         ; preds = %if.end
  %8 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %mac = getelementptr inbounds %struct.ifla_vf_info* %8, i32 0, i32 1
  %9 = bitcast [32 x i8]* %mac to i8*
  %10 = load i32* %vf.addr, align 4
  %idxprom = sext i32 %10 to i64
  %11 = load %struct.igb_adapter** %adapter, align 8
  %vf_data = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 50
  %12 = load %struct.vf_data_storage** %vf_data, align 8
  %arrayidx = getelementptr %struct.vf_data_storage* %12, i64 %idxprom
  %vf_mac_addresses = getelementptr inbounds %struct.vf_data_storage* %arrayidx, i32 0, i32 0
  %arraydecay = getelementptr inbounds [6 x i8]* %vf_mac_addresses, i32 0, i32 0
  %13 = load i64* %__len, align 8
  %call4 = call i8* @__memcpy(i8* %9, i8* %arraydecay, i64 %13) noredzone
  store i8* %call4, i8** %__ret, align 8
  br label %if.end10

if.else:                                          ; preds = %if.end
  %14 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %mac5 = getelementptr inbounds %struct.ifla_vf_info* %14, i32 0, i32 1
  %15 = bitcast [32 x i8]* %mac5 to i8*
  %16 = load i32* %vf.addr, align 4
  %idxprom6 = sext i32 %16 to i64
  %17 = load %struct.igb_adapter** %adapter, align 8
  %vf_data7 = getelementptr inbounds %struct.igb_adapter* %17, i32 0, i32 50
  %18 = load %struct.vf_data_storage** %vf_data7, align 8
  %arrayidx8 = getelementptr %struct.vf_data_storage* %18, i64 %idxprom6
  %vf_mac_addresses9 = getelementptr inbounds %struct.vf_data_storage* %arrayidx8, i32 0, i32 0
  %19 = bitcast [6 x i8]* %vf_mac_addresses9 to i8*
  %20 = load i64* %__len, align 8
  call void @llvm.memcpy.p0i8.p0i8.i64(i8* %15, i8* %19, i64 %20, i32 1, i1 false)
  store i8* %15, i8** %__ret, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.else, %if.then3
  %21 = load i8** %__ret, align 8
  %22 = load i32* %vf.addr, align 4
  %idxprom11 = sext i32 %22 to i64
  %23 = load %struct.igb_adapter** %adapter, align 8
  %vf_data12 = getelementptr inbounds %struct.igb_adapter* %23, i32 0, i32 50
  %24 = load %struct.vf_data_storage** %vf_data12, align 8
  %arrayidx13 = getelementptr %struct.vf_data_storage* %24, i64 %idxprom11
  %tx_rate = getelementptr inbounds %struct.vf_data_storage* %arrayidx13, i32 0, i32 8
  %25 = load i16* %tx_rate, align 2
  %conv = zext i16 %25 to i32
  %26 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %max_tx_rate = getelementptr inbounds %struct.ifla_vf_info* %26, i32 0, i32 7
  store i32 %conv, i32* %max_tx_rate, align 4
  %27 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %min_tx_rate = getelementptr inbounds %struct.ifla_vf_info* %27, i32 0, i32 6
  store i32 0, i32* %min_tx_rate, align 4
  %28 = load i32* %vf.addr, align 4
  %idxprom14 = sext i32 %28 to i64
  %29 = load %struct.igb_adapter** %adapter, align 8
  %vf_data15 = getelementptr inbounds %struct.igb_adapter* %29, i32 0, i32 50
  %30 = load %struct.vf_data_storage** %vf_data15, align 8
  %arrayidx16 = getelementptr %struct.vf_data_storage* %30, i64 %idxprom14
  %pf_vlan = getelementptr inbounds %struct.vf_data_storage* %arrayidx16, i32 0, i32 6
  %31 = load i16* %pf_vlan, align 2
  %conv17 = zext i16 %31 to i32
  %32 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %vlan = getelementptr inbounds %struct.ifla_vf_info* %32, i32 0, i32 2
  store i32 %conv17, i32* %vlan, align 4
  %33 = load i32* %vf.addr, align 4
  %idxprom18 = sext i32 %33 to i64
  %34 = load %struct.igb_adapter** %adapter, align 8
  %vf_data19 = getelementptr inbounds %struct.igb_adapter* %34, i32 0, i32 50
  %35 = load %struct.vf_data_storage** %vf_data19, align 8
  %arrayidx20 = getelementptr %struct.vf_data_storage* %35, i64 %idxprom18
  %pf_qos = getelementptr inbounds %struct.vf_data_storage* %arrayidx20, i32 0, i32 7
  %36 = load i16* %pf_qos, align 2
  %conv21 = zext i16 %36 to i32
  %37 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %qos = getelementptr inbounds %struct.ifla_vf_info* %37, i32 0, i32 3
  store i32 %conv21, i32* %qos, align 4
  %38 = load i32* %vf.addr, align 4
  %idxprom22 = sext i32 %38 to i64
  %39 = load %struct.igb_adapter** %adapter, align 8
  %vf_data23 = getelementptr inbounds %struct.igb_adapter* %39, i32 0, i32 50
  %40 = load %struct.vf_data_storage** %vf_data23, align 8
  %arrayidx24 = getelementptr %struct.vf_data_storage* %40, i64 %idxprom22
  %spoofchk_enabled = getelementptr inbounds %struct.vf_data_storage* %arrayidx24, i32 0, i32 9
  %41 = load i8* %spoofchk_enabled, align 1
  %tobool = trunc i8 %41 to i1
  %conv25 = zext i1 %tobool to i32
  %42 = load %struct.ifla_vf_info** %ivi.addr, align 8
  %spoofchk = getelementptr inbounds %struct.ifla_vf_info* %42, i32 0, i32 4
  store i32 %conv25, i32* %spoofchk, align 4
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end10, %if.then
  %43 = load i32* %retval
  ret i32 %43
}

define internal i64 @igb_fix_features(%struct.net_device* %netdev, i64 %features) nounwind noredzone {
entry:
  %netdev.addr = alloca %struct.net_device*, align 8
  %features.addr = alloca i64, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i64 %features, i64* %features.addr, align 8
  %0 = load i64* %features.addr, align 8
  %and = and i64 %0, 256
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  %1 = load i64* %features.addr, align 8
  %or = or i64 %1, 128
  store i64 %or, i64* %features.addr, align 8
  br label %if.end

if.else:                                          ; preds = %entry
  %2 = load i64* %features.addr, align 8
  %and1 = and i64 %2, -129
  store i64 %and1, i64* %features.addr, align 8
  br label %if.end

if.end:                                           ; preds = %if.else, %if.then
  %3 = load i64* %features.addr, align 8
  ret i64 %3
}

define internal i32 @igb_set_features(%struct.net_device* %netdev, i64 %features) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %features.addr = alloca i64, align 8
  %changed = alloca i64, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store i64 %features, i64* %features.addr, align 8
  %0 = load %struct.net_device** %netdev.addr, align 8
  %features1 = getelementptr inbounds %struct.net_device* %0, i32 0, i32 14
  %1 = load i64* %features1, align 8
  %2 = load i64* %features.addr, align 8
  %xor = xor i64 %1, %2
  store i64 %xor, i64* %changed, align 8
  %3 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %3) noredzone
  %4 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %4, %struct.igb_adapter** %adapter, align 8
  %5 = load i64* %changed, align 8
  %and = and i64 %5, 256
  %tobool = icmp ne i64 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %6 = load %struct.net_device** %netdev.addr, align 8
  %7 = load i64* %features.addr, align 8
  call void @igb_vlan_mode(%struct.net_device* %6, i64 %7) noredzone
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i64* %changed, align 8
  %and2 = and i64 %8, 274877906944
  %tobool3 = icmp ne i64 %and2, 0
  br i1 %tobool3, label %if.end5, label %if.then4

if.then4:                                         ; preds = %if.end
  store i32 0, i32* %retval
  br label %return

if.end5:                                          ; preds = %if.end
  %9 = load i64* %features.addr, align 8
  %10 = load %struct.net_device** %netdev.addr, align 8
  %features6 = getelementptr inbounds %struct.net_device* %10, i32 0, i32 14
  store i64 %9, i64* %features6, align 8
  %11 = load %struct.net_device** %netdev.addr, align 8
  %call7 = call zeroext i1 @netif_running(%struct.net_device* %11) noredzone
  br i1 %call7, label %if.then8, label %if.else

if.then8:                                         ; preds = %if.end5
  %12 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reinit_locked(%struct.igb_adapter* %12) noredzone
  br label %if.end9

if.else:                                          ; preds = %if.end5
  %13 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_reset(%struct.igb_adapter* %13) noredzone
  br label %if.end9

if.end9:                                          ; preds = %if.else, %if.then8
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end9, %if.then4
  %14 = load i32* %retval
  ret i32 %14
}

define internal i32 @igb_mii_ioctl(%struct.net_device* %netdev, %struct.ifreq* %ifr, i32 %cmd) nounwind noredzone {
entry:
  %retval = alloca i32, align 4
  %netdev.addr = alloca %struct.net_device*, align 8
  %ifr.addr = alloca %struct.ifreq*, align 8
  %cmd.addr = alloca i32, align 4
  %adapter = alloca %struct.igb_adapter*, align 8
  %data = alloca %struct.mii_ioctl_data*, align 8
  store %struct.net_device* %netdev, %struct.net_device** %netdev.addr, align 8
  store %struct.ifreq* %ifr, %struct.ifreq** %ifr.addr, align 8
  store i32 %cmd, i32* %cmd.addr, align 4
  %0 = load %struct.net_device** %netdev.addr, align 8
  %call = call i8* @netdev_priv(%struct.net_device* %0) noredzone
  %1 = bitcast i8* %call to %struct.igb_adapter*
  store %struct.igb_adapter* %1, %struct.igb_adapter** %adapter, align 8
  %2 = load %struct.ifreq** %ifr.addr, align 8
  %call1 = call %struct.mii_ioctl_data* @if_mii(%struct.ifreq* %2) noredzone
  store %struct.mii_ioctl_data* %call1, %struct.mii_ioctl_data** %data, align 8
  %3 = load %struct.igb_adapter** %adapter, align 8
  %hw = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 35
  %phy = getelementptr inbounds %struct.e1000_hw* %hw, i32 0, i32 6
  %media_type = getelementptr inbounds %struct.e1000_phy_info* %phy, i32 0, i32 12
  %4 = load i32* %media_type, align 4
  %cmp = icmp ne i32 %4, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  store i32 -95, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %5 = load i32* %cmd.addr, align 4
  switch i32 %5, label %sw.default [
    i32 35143, label %sw.bb
    i32 35144, label %sw.bb4
    i32 35145, label %sw.bb10
  ]

sw.bb:                                            ; preds = %if.end
  %6 = load %struct.igb_adapter** %adapter, align 8
  %hw2 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 35
  %phy3 = getelementptr inbounds %struct.e1000_hw* %hw2, i32 0, i32 6
  %addr = getelementptr inbounds %struct.e1000_phy_info* %phy3, i32 0, i32 8
  %7 = load i32* %addr, align 4
  %conv = trunc i32 %7 to i16
  %8 = load %struct.mii_ioctl_data** %data, align 8
  %phy_id = getelementptr inbounds %struct.mii_ioctl_data* %8, i32 0, i32 0
  store i16 %conv, i16* %phy_id, align 2
  br label %sw.epilog

sw.bb4:                                           ; preds = %if.end
  %9 = load %struct.igb_adapter** %adapter, align 8
  %hw5 = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 35
  %10 = load %struct.mii_ioctl_data** %data, align 8
  %reg_num = getelementptr inbounds %struct.mii_ioctl_data* %10, i32 0, i32 1
  %11 = load i16* %reg_num, align 2
  %conv6 = zext i16 %11 to i32
  %and = and i32 %conv6, 31
  %12 = load %struct.mii_ioctl_data** %data, align 8
  %val_out = getelementptr inbounds %struct.mii_ioctl_data* %12, i32 0, i32 3
  %call7 = call i32 @igb_read_phy_reg(%struct.e1000_hw* %hw5, i32 %and, i16* %val_out) noredzone
  %tobool = icmp ne i32 %call7, 0
  br i1 %tobool, label %if.then8, label %if.end9

if.then8:                                         ; preds = %sw.bb4
  store i32 -5, i32* %retval
  br label %return

if.end9:                                          ; preds = %sw.bb4
  br label %sw.epilog

sw.bb10:                                          ; preds = %if.end
  br label %sw.default

sw.default:                                       ; preds = %if.end, %sw.bb10
  store i32 -95, i32* %retval
  br label %return

sw.epilog:                                        ; preds = %if.end9, %sw.bb
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %sw.epilog, %sw.default, %if.then8, %if.then
  %13 = load i32* %retval
  ret i32 %13
}

declare i32 @igb_ptp_get_ts_config(%struct.net_device*, %struct.ifreq*) noredzone

declare i32 @igb_ptp_set_ts_config(%struct.net_device*, %struct.ifreq*) noredzone

define internal %struct.mii_ioctl_data* @if_mii(%struct.ifreq* %rq) nounwind inlinehint noredzone {
entry:
  %rq.addr = alloca %struct.ifreq*, align 8
  store %struct.ifreq* %rq, %struct.ifreq** %rq.addr, align 8
  %0 = load %struct.ifreq** %rq.addr, align 8
  %ifr_ifru = getelementptr inbounds %struct.ifreq* %0, i32 0, i32 1
  %1 = bitcast %union.anon.65* %ifr_ifru to %struct.mii_ioctl_data*
  ret %struct.mii_ioctl_data* %1
}

define internal void @skb_set_tail_pointer(%struct.sk_buff* %skb, i32 %offset) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  %offset.addr = alloca i32, align 4
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  store i32 %offset, i32* %offset.addr, align 4
  %0 = load %struct.sk_buff** %skb.addr, align 8
  call void @skb_reset_tail_pointer(%struct.sk_buff* %0) noredzone
  %1 = load i32* %offset.addr, align 4
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %tail = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 39
  %3 = load i32* %tail, align 4
  %add = add i32 %3, %1
  store i32 %add, i32* %tail, align 4
  ret void
}

define internal %struct.igb_ring* @igb_tx_queue_mapping(%struct.igb_adapter* %adapter, %struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %adapter.addr = alloca %struct.igb_adapter*, align 8
  %skb.addr = alloca %struct.sk_buff*, align 8
  %r_idx = alloca i32, align 4
  store %struct.igb_adapter* %adapter, %struct.igb_adapter** %adapter.addr, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %queue_mapping = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 26
  %1 = load i16* %queue_mapping, align 2
  %conv = zext i16 %1 to i32
  store i32 %conv, i32* %r_idx, align 4
  %2 = load i32* %r_idx, align 4
  %3 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues = getelementptr inbounds %struct.igb_adapter* %3, i32 0, i32 12
  %4 = load i32* %num_tx_queues, align 4
  %cmp = icmp uge i32 %2, %4
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %5 = load i32* %r_idx, align 4
  %6 = load %struct.igb_adapter** %adapter.addr, align 8
  %num_tx_queues2 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 12
  %7 = load i32* %num_tx_queues2, align 4
  %rem = urem i32 %5, %7
  store i32 %rem, i32* %r_idx, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %8 = load i32* %r_idx, align 4
  %idxprom = zext i32 %8 to i64
  %9 = load %struct.igb_adapter** %adapter.addr, align 8
  %tx_ring = getelementptr inbounds %struct.igb_adapter* %9, i32 0, i32 13
  %arrayidx = getelementptr [16 x %struct.igb_ring*]* %tx_ring, i32 0, i64 %idxprom
  %10 = load %struct.igb_ring** %arrayidx, align 8
  ret %struct.igb_ring* %10
}

define internal void @skb_reset_tail_pointer(%struct.sk_buff* %skb) nounwind inlinehint noredzone {
entry:
  %skb.addr = alloca %struct.sk_buff*, align 8
  store %struct.sk_buff* %skb, %struct.sk_buff** %skb.addr, align 8
  %0 = load %struct.sk_buff** %skb.addr, align 8
  %data = getelementptr inbounds %struct.sk_buff* %0, i32 0, i32 42
  %1 = load i8** %data, align 8
  %2 = load %struct.sk_buff** %skb.addr, align 8
  %head = getelementptr inbounds %struct.sk_buff* %2, i32 0, i32 41
  %3 = load i8** %head, align 8
  %sub.ptr.lhs.cast = ptrtoint i8* %1 to i64
  %sub.ptr.rhs.cast = ptrtoint i8* %3 to i64
  %sub.ptr.sub = sub i64 %sub.ptr.lhs.cast, %sub.ptr.rhs.cast
  %conv = trunc i64 %sub.ptr.sub to i32
  %4 = load %struct.sk_buff** %skb.addr, align 8
  %tail = getelementptr inbounds %struct.sk_buff* %4, i32 0, i32 39
  store i32 %conv, i32* %tail, align 4
  ret void
}

define internal void @dev_set_drvdata(%struct.device* %dev, i8* %data) nounwind inlinehint noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %data.addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load i8** %data.addr, align 8
  %1 = load %struct.device** %dev.addr, align 8
  %driver_data = getelementptr inbounds %struct.device* %1, i32 0, i32 9
  store i8* %0, i8** %driver_data, align 8
  ret void
}

declare i32 @dma_set_mask(%struct.device*, i64) noredzone

define internal i32 @dma_set_coherent_mask(%struct.device* %dev, i64 %mask) nounwind inlinehint noredzone {
entry:
  %retval = alloca i32, align 4
  %dev.addr = alloca %struct.device*, align 8
  %mask.addr = alloca i64, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i64 %mask, i64* %mask.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %1 = load i64* %mask.addr, align 8
  %call = call i32 @dma_supported(%struct.device* %0, i64 %1) noredzone
  %tobool = icmp ne i32 %call, 0
  br i1 %tobool, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  store i32 -5, i32* %retval
  br label %return

if.end:                                           ; preds = %entry
  %2 = load i64* %mask.addr, align 8
  %3 = load %struct.device** %dev.addr, align 8
  %coherent_dma_mask = getelementptr inbounds %struct.device* %3, i32 0, i32 14
  store i64 %2, i64* %coherent_dma_mask, align 8
  store i32 0, i32* %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %4 = load i32* %retval
  ret i32 %4
}

declare i32 @dma_supported(%struct.device*, i64) noredzone

define internal i8* @dev_name(%struct.device* %dev) nounwind inlinehint noredzone {
entry:
  %retval = alloca i8*, align 8
  %dev.addr = alloca %struct.device*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %init_name = getelementptr inbounds %struct.device* %0, i32 0, i32 3
  %1 = load i8** %init_name, align 8
  %tobool = icmp ne i8* %1, null
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %2 = load %struct.device** %dev.addr, align 8
  %init_name1 = getelementptr inbounds %struct.device* %2, i32 0, i32 3
  %3 = load i8** %init_name1, align 8
  store i8* %3, i8** %retval
  br label %return

if.end:                                           ; preds = %entry
  %4 = load %struct.device** %dev.addr, align 8
  %kobj = getelementptr inbounds %struct.device* %4, i32 0, i32 2
  %call = call i8* @kobject_name(%struct.kobject* %kobj) noredzone
  store i8* %call, i8** %retval
  br label %return

return:                                           ; preds = %if.end, %if.then
  %5 = load i8** %retval
  ret i8* %5
}

define internal i8* @kobject_name(%struct.kobject* %kobj) nounwind inlinehint noredzone {
entry:
  %kobj.addr = alloca %struct.kobject*, align 8
  store %struct.kobject* %kobj, %struct.kobject** %kobj.addr, align 8
  %0 = load %struct.kobject** %kobj.addr, align 8
  %name = getelementptr inbounds %struct.kobject* %0, i32 0, i32 0
  %1 = load i8** %name, align 8
  ret i8* %1
}

define internal i32 @igb_notify_dca(%struct.notifier_block* %nb, i64 %event, i8* %p) nounwind noredzone {
entry:
  %nb.addr = alloca %struct.notifier_block*, align 8
  %event.addr = alloca i64, align 8
  %p.addr = alloca i8*, align 8
  %ret_val = alloca i32, align 4
  store %struct.notifier_block* %nb, %struct.notifier_block** %nb.addr, align 8
  store i64 %event, i64* %event.addr, align 8
  store i8* %p, i8** %p.addr, align 8
  %0 = bitcast i64* %event.addr to i8*
  %call = call i32 @driver_for_each_device(%struct.device_driver* getelementptr inbounds (%struct.pci_driver* @igb_driver, i32 0, i32 12), %struct.device* null, i8* %0, i32 (%struct.device*, i8*)* @__igb_notify_dca) noredzone
  store i32 %call, i32* %ret_val, align 4
  %1 = load i32* %ret_val, align 4
  %tobool = icmp ne i32 %1, 0
  %cond = select i1 %tobool, i32 32770, i32 0
  ret i32 %cond
}

declare i32 @driver_for_each_device(%struct.device_driver*, %struct.device*, i8*, i32 (%struct.device*, i8*)*) noredzone

define internal i32 @__igb_notify_dca(%struct.device* %dev, i8* %data) nounwind noredzone {
entry:
  %dev.addr = alloca %struct.device*, align 8
  %data.addr = alloca i8*, align 8
  %netdev = alloca %struct.net_device*, align 8
  %adapter = alloca %struct.igb_adapter*, align 8
  %pdev = alloca %struct.pci_dev*, align 8
  %hw = alloca %struct.e1000_hw*, align 8
  %event = alloca i64, align 8
  %hw_addr = alloca i8*, align 8
  store %struct.device* %dev, %struct.device** %dev.addr, align 8
  store i8* %data, i8** %data.addr, align 8
  %0 = load %struct.device** %dev.addr, align 8
  %call = call i8* @dev_get_drvdata(%struct.device* %0) noredzone
  %1 = bitcast i8* %call to %struct.net_device*
  store %struct.net_device* %1, %struct.net_device** %netdev, align 8
  %2 = load %struct.net_device** %netdev, align 8
  %call1 = call i8* @netdev_priv(%struct.net_device* %2) noredzone
  %3 = bitcast i8* %call1 to %struct.igb_adapter*
  store %struct.igb_adapter* %3, %struct.igb_adapter** %adapter, align 8
  %4 = load %struct.igb_adapter** %adapter, align 8
  %pdev2 = getelementptr inbounds %struct.igb_adapter* %4, i32 0, i32 32
  %5 = load %struct.pci_dev** %pdev2, align 8
  store %struct.pci_dev* %5, %struct.pci_dev** %pdev, align 8
  %6 = load %struct.igb_adapter** %adapter, align 8
  %hw3 = getelementptr inbounds %struct.igb_adapter* %6, i32 0, i32 35
  store %struct.e1000_hw* %hw3, %struct.e1000_hw** %hw, align 8
  %7 = load i8** %data.addr, align 8
  %8 = bitcast i8* %7 to i64*
  %9 = load i64* %8, align 8
  store i64 %9, i64* %event, align 8
  %10 = load i64* %event, align 8
  switch i64 %10, label %sw.epilog [
    i64 1, label %sw.bb
    i64 2, label %sw.bb10
  ]

sw.bb:                                            ; preds = %entry
  %11 = load %struct.igb_adapter** %adapter, align 8
  %flags = getelementptr inbounds %struct.igb_adapter* %11, i32 0, i32 3
  %12 = load i32* %flags, align 4
  %and = and i32 %12, 2
  %tobool = icmp ne i32 %and, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %sw.bb
  br label %sw.epilog

if.end:                                           ; preds = %sw.bb
  %13 = load %struct.device** %dev.addr, align 8
  %call4 = call i32 @dca_add_requester(%struct.device* %13) noredzone
  %cmp = icmp eq i32 %call4, 0
  br i1 %cmp, label %if.then5, label %if.end9

if.then5:                                         ; preds = %if.end
  %14 = load %struct.igb_adapter** %adapter, align 8
  %flags6 = getelementptr inbounds %struct.igb_adapter* %14, i32 0, i32 3
  %15 = load i32* %flags6, align 4
  %or = or i32 %15, 2
  store i32 %or, i32* %flags6, align 4
  %16 = load %struct.pci_dev** %pdev, align 8
  %dev7 = getelementptr inbounds %struct.pci_dev* %16, i32 0, i32 33
  %call8 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev7, i8* getelementptr inbounds ([13 x i8]* @.str56, i32 0, i32 0)) noredzone
  %17 = load %struct.igb_adapter** %adapter, align 8
  call void @igb_setup_dca(%struct.igb_adapter* %17) noredzone
  br label %sw.epilog

if.end9:                                          ; preds = %if.end
  br label %sw.bb10

sw.bb10:                                          ; preds = %entry, %if.end9
  %18 = load %struct.igb_adapter** %adapter, align 8
  %flags11 = getelementptr inbounds %struct.igb_adapter* %18, i32 0, i32 3
  %19 = load i32* %flags11, align 4
  %and12 = and i32 %19, 2
  %tobool13 = icmp ne i32 %and12, 0
  br i1 %tobool13, label %if.then14, label %if.end27

if.then14:                                        ; preds = %sw.bb10
  %20 = load %struct.device** %dev.addr, align 8
  %call15 = call i32 @dca_remove_requester(%struct.device* %20) noredzone
  %21 = load %struct.pci_dev** %pdev, align 8
  %dev16 = getelementptr inbounds %struct.pci_dev* %21, i32 0, i32 33
  %call17 = call i32 (%struct.device*, i8*, ...)* @_dev_info(%struct.device* %dev16, i8* getelementptr inbounds ([14 x i8]* @.str47, i32 0, i32 0)) noredzone
  %22 = load %struct.igb_adapter** %adapter, align 8
  %flags18 = getelementptr inbounds %struct.igb_adapter* %22, i32 0, i32 3
  %23 = load i32* %flags18, align 4
  %and19 = and i32 %23, -3
  store i32 %and19, i32* %flags18, align 4
  br label %do.body

do.body:                                          ; preds = %if.then14
  %24 = load %struct.e1000_hw** %hw, align 8
  %hw_addr20 = getelementptr inbounds %struct.e1000_hw* %24, i32 0, i32 1
  %25 = load volatile i8** %hw_addr20, align 8
  store i8* %25, i8** %hw_addr, align 8
  %26 = load i8** %hw_addr, align 8
  %tobool21 = icmp ne i8* %26, null
  %lnot = xor i1 %tobool21, true
  %lnot22 = xor i1 %lnot, true
  %lnot23 = xor i1 %lnot22, true
  %lnot.ext = zext i1 %lnot23 to i32
  %conv = sext i32 %lnot.ext to i64
  %expval = call i64 @llvm.expect.i64(i64 %conv, i64 0)
  %tobool24 = icmp ne i64 %expval, 0
  br i1 %tobool24, label %if.end26, label %if.then25

if.then25:                                        ; preds = %do.body
  %27 = load i8** %hw_addr, align 8
  %arrayidx = getelementptr i8* %27, i64 23412
  call void @writel(i32 1, i8* %arrayidx) noredzone
  br label %if.end26

if.end26:                                         ; preds = %if.then25, %do.body
  br label %do.end

do.end:                                           ; preds = %if.end26
  br label %if.end27

if.end27:                                         ; preds = %do.end, %sw.bb10
  br label %sw.epilog

sw.epilog:                                        ; preds = %entry, %if.end27, %if.then5, %if.then
  ret i32 0
}

declare void @dca_register_notify(%struct.notifier_block*) noredzone

declare i32 @__pci_register_driver(%struct.pci_driver*, %struct.module*, i8*) noredzone

!0 = metadata !{i32 -2145711900}                  
!1 = metadata !{i32 -2146806355, i32 -2146806316, i32 -2146806295, i32 -2146806258, i32 -2146806235, i32 -2146806365} 
!2 = metadata !{i32 -2142833274, i32 -2142833249, i32 -2142832979, i32 -2142833182, i32 -2142833151, i32 -2142833121} 
!3 = metadata !{i32 -2142832868}                  
!4 = metadata !{i32 -2141527220, i32 -2141527195, i32 -2141526925, i32 -2141527128, i32 -2141527097, i32 -2141527067} 
!5 = metadata !{i32 -2145710161}                  
!6 = metadata !{i32 -2146807094, i32 -2146807055, i32 -2146807034, i32 -2146806997, i32 -2146806974, i32 -2146807104} 
!7 = metadata !{i32 -2146383265}                  
!8 = metadata !{i32 -2146804586, i32 -2146804547, i32 -2146804526, i32 -2146804489, i32 -2146804466, i32 -2146804457} 
!9 = metadata !{i32 582055, i32 582066}
!10 = metadata !{i32 -2143401443, i32 -2143401418, i32 -2143401148, i32 -2143401351, i32 -2143401320, i32 -2143401290} 
!11 = metadata !{i32 -2143398901, i32 -2143398876, i32 -2143398606, i32 -2143398809, i32 -2143398778, i32 -2143398748} 
!12 = metadata !{i32 -2141465604}                 
!13 = metadata !{i32 -2141465550}                 
!14 = metadata !{i32 -2141422526}                 
!15 = metadata !{i32 -2141454190}                 
!16 = metadata !{i32 -2141449930}                 
!17 = metadata !{i32 -2141444083}                 
!18 = metadata !{i32 -2141430878}                 
!19 = metadata !{i32 -2141423051}                 
!20 = metadata !{i32 -2143373009, i32 -2143372984, i32 -2143372714, i32 -2143372917, i32 -2143372886, i32 -2143372856} 
!21 = metadata !{i32 -2146440150, i32 -2146440143, i32 -2146440127, i32 -2146440523, i32 -2146440100, i32 -2146440052, i32 -2146439986, i32 -2146439924, i32 -2146439872, i32 -2146440443, i32 -2146440418, i32 -2146439664, i32 -2146440345, i32 -2146440320, i32 -2146439410, i32 -2146439480, i32 -2146439393, i32 -2146439436} 
!22 = metadata !{i32 -2143397078, i32 -2143397053, i32 -2143396783, i32 -2143396986, i32 -2143396955, i32 -2143396925} 
!23 = metadata !{i32 -2143396474, i32 -2143396449, i32 -2143396179, i32 -2143396382, i32 -2143396351, i32 -2143396321} 
!24 = metadata !{i32 -2145582364}                 
!25 = metadata !{i32 -2145150931}                 
!26 = metadata !{i32 -2142811605}                 
!27 = metadata !{i32 -2146803593, i32 -2146803554, i32 -2146803533, i32 -2146803496, i32 -2146803473, i32 -2146803464} 
!28 = metadata !{i32 -2143399516, i32 -2143399491, i32 -2143399221, i32 -2143399424, i32 -2143399393, i32 -2143399363} 
!29 = metadata !{i32 -2145951190}                 
!30 = metadata !{i32 -2145951294}                 
!31 = metadata !{i32 -2143402922, i32 -2143402897, i32 -2143402627, i32 -2143402830, i32 -2143402799, i32 -2143402769} 
!32 = metadata !{i32 -2142811849}                 
!33 = metadata !{i32 -2144022425, i32 -2144022400, i32 -2144022130, i32 -2144022333, i32 -2144022302, i32 -2144022272} 
!34 = metadata !{i32 4032487, i32 4032510}        
!35 = metadata !{i32 4034255, i32 4034279, i32 4034302, i32 4034325} 
!36 = metadata !{i32 -2146420313, i32 -2146420274, i32 -2146420253, i32 -2146420216, i32 -2146420193, i32 -2146420323} 
!37 = metadata !{i32 -2141465515}                 
!38 = metadata !{i32 1032275, i32 1032296}        
!39 = metadata !{i32 -2146267861}                 
!40 = metadata !{i32 -2146288626}                 
!41 = metadata !{i32 -2146412687, i32 -2146412648, i32 -2146412627, i32 -2146412590, i32 -2146412567, i32 -2146412558} 
